/* gcc parse_elf.c -o parse*/
/* #include <elf.h> */
/* #include <string.h> */
#include <stdio.h>
#include <stdlib.h>

typedef struct Elf64Hdr{
    unsigned char         e_ident[16];         /* Magic number and other info */
    unsigned short        e_type;              /* Object file type */
    unsigned short        e_machine;           /* Architecture */
    unsigned int          e_version;           /* Object file version */
    unsigned long long    e_entry;             /* Entry point virtual address */
    unsigned long long    e_phoff;             /* Program header table file offset */
    unsigned long long    e_shoff;             /* Section header table file offset */
    unsigned int          e_flags;             /* Processor-specific flags */
    unsigned short        e_ehsize;            /* ELF header size in bytes */
    unsigned short        e_phentsize;         /* Program header table entry size */
    unsigned short        e_phnum;             /* Program header table entry count */
    unsigned short        e_shentsize;         /* Section header table entry size */
    unsigned short        e_shnum;             /* Section header table entry count */
    unsigned short        e_shstrndx;          /* Section header string table index */
} Elf64Hdr;

typedef struct Elf64_Shdr {
    unsigned int          sh_name;      /* Section name (string tbl index) */
    unsigned int          sh_type;      /* Section type */
    long long             sh_flags;     /* Section flags */
    unsigned long long    sh_addr;      /* Section virtual addr at execution */
    unsigned long long    sh_offset;        /* Section file offset */
    long long             sh_size;      /* Section size in bytes */
    unsigned int          sh_link;      /* Link to another section */
    unsigned int          sh_info;      /* Additional section information */
    long long             sh_addralign;     /* Section alignment */
    long long             sh_entsize;       /* Entry size if section holds table */
} Elf64_Shdr;

typedef struct Elf64_Phdr {
    unsigned int          p_type;           /* Segment type */
    unsigned int          p_flags;      /* Segment flags */
    unsigned long long    p_offset;     /* Segment file offset */
    unsigned long long    p_vaddr;      /* Segment virtual address */
    unsigned long long    p_paddr;      /* Segment physical address */
    unsigned long long    p_filesz;     /* Segment size in file */
    unsigned long long    p_memsz;      /* Segment size in memory */
    unsigned long long    p_align;      /* Segment alignment */
} Elf64_Phdr;

void miss_symbols(int n, FILE* file) {
    char buf[n];
    fread(&buf, 1, sizeof(buf), file);
}

void read_programm_header(int n, FILE* file) {
    struct Elf64_Phdr programm_table;

    for( int i = 0; i < n; i++) {
    fread(&programm_table, 1, sizeof(programm_table), file);

    printf("p_type %d \n", programm_table.p_type);
    printf("programm_section_offset %llu \n", programm_table.p_offset);
    printf("p_filesz %llu \n", programm_table.p_filesz);
    printf("p_vaddr %p \n \n",  (void*)programm_table.p_vaddr);

    }
}

void read_elf(const char* elfFile) {
    // Either Elf64_Ehdr or Elf32_Ehdr depending on architecture.
    struct Elf64Hdr header;
    struct Elf64_Phdr programm_table;
    struct Elf64_Shdr sections_table;

    unsigned long long sections_table_offset;
    unsigned long long programm_table_offset;
    unsigned long long align;

    FILE* file = fopen(elfFile, "rb");

    if(file) {
        // read the header
        fread(&header, 1, sizeof(header), file);
        read_programm_header( header.e_phnum, file);

        printf("e_phnum %d \n", header.e_phnum);
    }
    fclose(file);
}

int main () {
    char* name = "example";
    read_elf( name );

    return 1;
}
