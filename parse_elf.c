/* gcc parse_elf.c -o parse*/
#include <stdio.h>
#include <stdlib.h>

typedef struct Elf64Hdr{
    unsigned char         e_ident[16];         /* Magic number and other info */
    unsigned short        e_type;              /* Object file type */
    unsigned short        e_machine;           /* Architecture */
    unsigned int          e_version;           /* Object file version */
    unsigned long long    e_entry;             /* Entry point virtual address */
    unsigned long long    e_phoff;             /* Program header table file offset */
    unsigned long long    e_shoff;             /* Section header table file offset */
    unsigned int          e_flags;             /* Processor-specific flags */
    unsigned short        e_ehsize;            /* ELF header size in bytes */
    unsigned short        e_phentsize;         /* Program header table entry size */
    unsigned short        e_phnum;             /* Program header table entry count */
    unsigned short        e_shentsize;         /* Section header table entry size */
    unsigned short        e_shnum;             /* Section header table entry count */
    unsigned short        e_shstrndx;          /* Section header string table index */
} Elf64Hdr;

typedef struct Elf64_Shdr {
    unsigned int          sh_name;      /* Section name (string tbl index) */
    unsigned int          sh_type;      /* Section type */
    long long             sh_flags;     /* Section flags */
    unsigned long long    sh_addr;      /* Section virtual addr at execution */
    unsigned long long    sh_offset;        /* Section file offset */
    long long             sh_size;      /* Section size in bytes */
    unsigned int          sh_link;      /* Link to another section */
    unsigned int          sh_info;      /* Additional section information */
    long long             sh_addralign;     /* Section alignment */
    long long             sh_entsize;       /* Entry size if section holds table */
} Elf64_Shdr;

typedef struct Elf64_Phdr {
    unsigned int          p_type;           /* Segment type */
    unsigned int          p_flags;      /* Segment flags */
    unsigned long long    p_offset;     /* Segment file offset */
    unsigned long long    p_vaddr;      /* Segment virtual address */
    unsigned long long    p_paddr;      /* Segment physical address */
    unsigned long long    p_filesz;     /* Segment size in file */
    unsigned long long    p_memsz;      /* Segment size in memory */
    unsigned long long    p_align;      /* Segment alignment */
} Elf64_Phdr;

void miss_symbols(int n, FILE* file) {
    char buf[n];
    fread(&buf, 1, sizeof(buf), file);
}

Elf64_Phdr find_last_segment( int n, FILE* file ) {
    struct Elf64_Phdr program_header;
    struct Elf64_Phdr program_header_last_segment = *(Elf64_Phdr* )malloc(sizeof
                                                                          (Elf64_Phdr));
    for( int i = 0; i < n; i++) {
        fread(&program_header, 1, sizeof(program_header), file);

        if (i == 0) {
            program_header_last_segment = program_header;

        } else if ( ( program_header_last_segment.p_offset <= program_header.p_offset ) &&
                    ( program_header_last_segment.p_filesz <= program_header.p_filesz ) ) {

            program_header_last_segment = program_header;
        }

        printf("тип сегмента %d \n", program_header.p_type);
        printf("смещение сегмента от начала файла %llu \n",
               program_header.p_offset);
        printf("размер сегмента в файле %llu \n",
               program_header.p_filesz);
        printf("виртуальный адрес сегмента  %p \n \n",
               (void*)program_header.p_vaddr);
    }
    printf("тип последнего сегмента %d \n", program_header_last_segment.p_type);
    printf("смещение последнего сегмента от начала файла %llu \n",
           program_header_last_segment.p_offset);
    printf("размер последнего сегмента в файле %llu \n",
           program_header_last_segment.p_filesz);
    printf("виртуальный адрес последнего сегмента  %p \n \n",
           (void*)program_header_last_segment.p_vaddr);

    return program_header_last_segment;
}

/* выгружает все заголовки кода в массив */
Elf64_Phdr* get_program_headers (int n, FILE* file) {
    Elf64_Phdr* array_headers = (Elf64_Phdr*)malloc( sizeof( Elf64_Phdr ) * n);
    Elf64_Phdr* array_headers_pointer = array_headers;

    for( int i = 0; i < n; i++) {
        fread(array_headers_pointer, 1, sizeof(Elf64_Phdr), file);
        array_headers_pointer++;
    }
    return array_headers;
}

/* выгружает все заголовки секций в массив */
Elf64_Shdr* get_section_headers (int n, FILE* file) {
    Elf64_Shdr* array_headers = (Elf64_Shdr*)malloc( sizeof( Elf64_Shdr ) * n);
    Elf64_Shdr* array_headers_pointer = array_headers;

    for( int i = 0; i < n; i++) {
        fread(array_headers_pointer, 1, sizeof(Elf64_Shdr), file);
        array_headers_pointer++;
    }
    return array_headers;
}

/* сортирует пузырьком заголовки программы по смещению (от минимального к максимальному) */
Elf64_Phdr* sort_program_headers (int n, Elf64_Phdr* array) {
    struct Elf64_Phdr a;
    struct Elf64_Phdr b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.p_offset > b.p_offset ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Phdr* check_array (int n, Elf64_Phdr* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.p_offset > b.p_offset ) {
                bubble_sort();
                check_array (n, array);
            }
        }
        return array;
    }
    check_array (n, array);
    return array;
}

/* сортирует пузырьком заголовки секций по смещению (от минимального к максимальному) */
Elf64_Shdr* sort_section_headers (int n, Elf64_Shdr* array) {
    struct Elf64_Shdr a;
    struct Elf64_Shdr b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.sh_offset > b.sh_offset ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Shdr* check_array (int n, Elf64_Shdr* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.sh_offset > b.sh_offset ) {
                bubble_sort();
                check_array (n, array);
            }
        }
        return array;
    }
    check_array (n, array);
    return array;
}

/* прибавляет n байт к смещению в каждом заголовке секции */
Elf64_Shdr* add_offset_to_sections (int n, unsigned long long offset, Elf64_Shdr* array) {
    struct Elf64_Shdr header;
    for( int i = 0; i < n; i++) {
        header = array[i];
        header.sh_offset = header.sh_offset + offset;
        array[i] = header;
    }
}

/* прибавляет n байт к смещению в каждом заголовке программы */
Elf64_Shdr* add_offset_to_programs (int n, unsigned long long offset, Elf64_Phdr* array) {
    struct Elf64_Phdr header;
    for( int i = 0; i < n; i++) {
        header = array[i];
        header.p_offset = header.p_offset + offset;
        array[i] = header;
    }
}

void read_programm_header(int n, FILE* file) {
    struct Elf64_Phdr programm_table;

    for( int i = 0; i < n; i++) {
    fread(&programm_table, 1, sizeof(programm_table), file);

    printf("тип сегмента %d \n", programm_table.p_type);
    printf("смещение сегмента от начала файла %llu \n", programm_table.p_offset);
    printf("размер сегмента в файле %llu \n", programm_table.p_filesz);
    printf("размер сегмента в памяти %llu \n", programm_table. p_memsz);

    printf("виртуальный адрес сегмента  %p \n \n",  (void*)programm_table.p_vaddr);

    }
}

void read_array_programm_header(int n, Elf64_Phdr* array) {
    struct Elf64_Phdr programm_table;

    for( int i = 0; i < n; i++) {
        programm_table = array[i];
        printf("тип сегмента %d \n", programm_table.p_type);
        printf("смещение сегмента от начала файла %llu \n", programm_table.p_offset);
        printf("размер сегмента в файле %llu \n", programm_table.p_filesz);
        printf("размер сегмента в памяти %llu \n", programm_table. p_memsz);

        printf("виртуальный адрес сегмента  %p \n \n",  (void*)programm_table.p_vaddr);

    }
}

void read_array_section_header(int n, Elf64_Shdr* array) {
    struct Elf64_Shdr section_table;

    for( int i = 0; i < n; i++) {
        section_table = array[i];

        printf("тип секции %d \n", section_table.sh_type);
        printf("смещение секции от начала файла %llu \n", section_table.sh_offset);
        printf("атрибуты секции %llx \n", section_table.sh_flags);
        printf("размер секции в файле %llu \n", section_table.sh_size);
        printf("виртуальный адрес секции  %p \n \n",  (void*)section_table.sh_addr);

    }
}


void read_section_header(int n, FILE* file) {
    struct Elf64_Shdr section_table;

    for( int i = 0; i < n; i++) {
        fread(&section_table, 1, sizeof(section_table), file);

        printf("тип секции %d \n", section_table.sh_type);
        printf("смещение секции от начала файла %llu \n", section_table.sh_offset);
        printf("атрибуты секции %llx \n", section_table.sh_flags);
        printf("размер секции в файле %llu \n", section_table.sh_size);
        printf("виртуальный адрес секции  %p \n \n",  (void*)section_table.sh_addr);

    }
}

void read_elf(const char* elfFile) {
    // Either Elf64_Ehdr or Elf32_Ehdr depending on architecture.
    struct Elf64Hdr header;
    struct Elf64_Phdr programm_table;
    struct Elf64_Shdr sections_table;

    unsigned long long sections_table_offset;
    unsigned long long programm_table_offset;
    unsigned long long align;

    FILE* file = fopen(elfFile, "rb");

    if(file) {
        // read the header
        fread(&header, 1, sizeof(header), file);
        /* read_programm_header( header.e_phnum, file); */
        Elf64_Phdr* array = get_program_headers (header.e_phnum, file);
        read_array_programm_header(header.e_phnum, array);

        array =  sort_program_headers (header.e_phnum, array);

        printf("\n\n");
        read_array_programm_header(header.e_phnum, array);

        sections_table_offset = header.e_shoff - sizeof(header) -
                                sizeof(Elf64_Phdr) * header.e_phnum;
        miss_symbols(sections_table_offset, file);

        Elf64_Shdr* array2 = get_section_headers (header.e_shnum, file);
        read_array_section_header(header.e_shnum, array2);

        array2 =  sort_section_headers (header.e_shnum, array2);

        printf("\n\n");
        read_array_section_header(header.e_shnum, array2);

        /* read_section_header(header.e_shnum, file); */

        printf("e_phnum %d \n", header.e_phnum);
    }
    fclose(file);
}

int main () {
    char* name = "example";
    read_elf( name );

    return 1;
}
