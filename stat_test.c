/* Compile: gcc stat_test.c -o test */
/* Usage: ./test test */
#include <sys/mman.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <elf.h>

typedef struct Elf64Hdr{
    unsigned char         e_ident[16];         /* Magic number and other info */
    unsigned short        e_type;              /* Object file type */
    unsigned short        e_machine;           /* Architecture */
    unsigned int          e_version;           /* Object file version */
    unsigned long long    e_entry;             /* Entry point virtual address */
    unsigned long long    e_phoff;             /* Program header table file offset */
    unsigned long long    e_shoff;             /* Section header table file offset */
    unsigned int          e_flags;             /* Processor-specific flags */
    unsigned short        e_ehsize;            /* ELF header size in bytes */
    unsigned short        e_phentsize;         /* Program header table entry size */
    unsigned short        e_phnum;             /* Program header table entry count */
    unsigned short        e_shentsize;         /* Section header table entry size */
    unsigned short        e_shnum;             /* Section header table entry count */
    unsigned short        e_shstrndx;          /* Section header string table index */
} Elf64Hdr;

/* глобальные переменные для возвращаемых значений функций */
/* это единственный способ присвоить возвращаемое ассемблерным кодом
   значение сишной переменной - даже если локальные переменные объявлены в куче,
   компилятор сначала кладет адрес переменной в стек,
   и только затем присваивает ему значение. Нам это не подходит, поскольку неизвестно,
   куда именно в стеке будет записан адрес,
   а взаимодествовать со стеком вслепую = получить segfault*/
void* return_mmap_ptr = NULL;
int return_open_fd;
int return_close_val;
int return_read_count;

/* вызывает stat */
void call_stat ( const char* path_name, struct stat *stat_struct ) {
    __asm__( "mov $4, %rax\n\t"
             "syscall\n\t");
}

/* вызывает mmap */
void* call_mmap ( void *address,
                  size_t length,
                  int protect,
                  int flags,
                  int filedes,
                  off_t offset ) {

    __asm__("push %rbx \n\t"
            "push %rcx \n\t"
            "push %rdx \n\t"
            "push %rbp \n\t"
            "push %r10 \n\t"
            "push %r14 \n\t"
            "push %r15 \n\t"

            "mov %r9, %r15 \n\t"
            "mov %rsi, %r13 \n\t"
            "mov %rdi, %r12 \n\t"
            "mov %ecx, %r14d \n\t"

            "movslq %r8d, %rbp \n\t"
            "movslq %edx, %rbx \n\t"
            "movslq %r14d, %r10 \n\t"
            "mov $0x9, %eax \n\t"

            "syscall \n\t"
            "movq %rax, return_mmap_ptr(%rip) \n\t"

            "pop %r15 \n\t"
            "pop %r14 \n\t"
            "pop %r10 \n\t"
            "pop %rbp \n\t"
            "pop %rdx \n\t"
            "pop %rcx \n\t"
            "pop %rbx \n\t"
            );

    return return_mmap_ptr;
}

/* вызывает open */
int call_open (const char *filename, int flags) {

    __asm__( "mov $2, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_open_fd(%rip) \n\t"
             );

    return return_open_fd;
}

/* вызывает close */
int call_close (unsigned int fd) {

    __asm__( "mov $3, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_close_val(%rip) \n\t");

    return return_close_val;
}

/* вызывает read */
int call_read (unsigned int fd, char *buf, size_t count) {

    __asm__( "mov $0, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_read_count(%rip) \n\t"
             );
    return return_read_count;
}

void* call_fopen ( const char *filename, int flags ) {

}

/* тестируем call_read */
/* цель: открыть эльф файл, прочитать его заголовок,
   вывести значение ожного из его полей */
int read_test( const char *filename ) {
    int fd = call_open( filename, O_RDWR );

    /* int fd = open( filename, O_RDWR); */
    if ( fd < 0 ) {
        printf("open: Не удалось открыть файл, ошибка № %d\n", errno);
        return -1;
    }

    Elf64Hdr header;
    int count = call_read( fd, (char*)&header, sizeof(header) );

    /* int count = read(fd, (char*)&header, sizeof(header)); */

    if ( count <= 0 ) {
        printf("read_test: Не удалось прочитать файл, ошибка № %d\n", errno);
        return -1;
    }

    printf("read_test: смещение e_phnum %d \n", header.e_phnum);
    call_close( fd );
    return 0;
}

/* тестируем stat */
int stat_test( const char *filename ) {

    struct stat mystruct;
    call_stat( filename, &mystruct );

    printf("stat_test: file size %ld \n", mystruct.st_dev);
    return 0;
}

void print_elf_header_field(  Elf64Hdr* header_ptr ) {
    Elf64Hdr header = *header_ptr;

    printf("print elf header: \n");

    printf("header.e_type : %d\n", header.e_type);
    printf("header.e_machine : %d\n", header.e_machine);
    printf("header.e_version : %ud\n", header.e_version);
    printf("header.e_entry : %p\n", (void*)header.e_entry);
    printf("header.e_phoff : %llu\n", header.e_phoff);
    printf("header.e_shoff : %llu\n", header.e_shoff);
    printf("header.e_flags : %d\n", header.e_flags);
    printf("header.e_ehsize : %d\n", header.e_ehsize);
    printf("header.e_phentsize : %d\n", header.e_phentsize);
    printf("header.e_phnum : %d\n", header.e_phnum);
    printf("header.e_shentsize : %d\n", header.e_shentsize);
    printf("header.e_shnum : %d\n", header.e_shnum);
    printf("header.e_shstrndx : %d\n", header.e_shstrndx);

    printf("\n");
}


int mmap_test( const char *filename ) {

    /* открываем файл, чтоб получить дескриптор */
    int fd = call_open( filename, O_RDWR );

    if ( fd < 0 ) {
        printf("open: Не удалось открыть файл, ошибка № %d\n", errno);
        return -1;
    }

    /* получаем свойства файла */
    struct stat mystruct;
    call_stat( filename, &mystruct );

    /* маппим файл в память */
    void* ptr = call_mmap( NULL, mystruct.st_size,
                           PROT_READ|PROT_WRITE, MAP_SHARED,
                           fd, 0 );

    if ( ( ptr == MAP_FAILED ) || ( ptr < 0 ) ) {
        printf("pointer: %p\n", ptr);
        printf(" mmap_test: Mapping Failed, err number %d \n",
               errno);
        return -1;
    }

    printf("mmap_test: pointer %p \n", ptr);

    Elf64Hdr header;
    memcpy( &header, ptr, sizeof(header) );
    print_elf_header_field( &header );

    call_close( fd );
    return 0;
}

/* запускает все тесты */
int run_tests ( const char* elf_filename ) {

    if ( stat_test( elf_filename ) != 0 ) {
        printf("stat_test failed for elf %s\n",  elf_filename);
        return -1;
    }

    printf("stat_test passed for elf %s \n\n",  elf_filename);

    if ( read_test( elf_filename ) != 0 ) {
        printf("read_test failed for elf %s\n",  elf_filename);
        return -1;
    }

    printf("read_test passed for elf %s \n\n",  elf_filename);

    if ( mmap_test( elf_filename ) != 0 ) {
        printf("mmap_test failed for elf %s\n",  elf_filename);
        return -1;
    }

    printf("mmap_test passed for elf %s \n\n",  elf_filename);
}

int main ( int argc, const char **argv ) {

    /* printf("%x \n", PROT_READ|PROT_WRITE); */
    /* printf("%x \n", MAP_SHARED); */

    int i;
    for (i = 1; i < argc; i++) {
        run_tests ( argv[i] );
    }
}
