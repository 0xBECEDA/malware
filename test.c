/* Compile: gcc test.c -o test */
/* Usage: ./test test */

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

/* typedef struct timespec { */
/*     long  tv_sec;     /\* seconds *\/ */
/*     long  tv_nsec;    /\* and nanoseconds *\/ */
/* }timespec; */

/* typedef struct stat64 { */
/*     long unsigned int st_dev; */
/*     long unsigned int st_ino; */
/*     long int st_mode; */
/*     long unsigned int st_nlink; */
/*     unsigned int st_uid; */
/*     unsigned int st_gid; */
/*     long unsigned int st_rdev; */
/*     long int st_size; */
/*     struct timespec st_atime; */
/*     struct timespec st_mtime; */
/*     struct timespec st_ctime; */
/*     long int st_blksize; */
/*     long int st_blocks; */
/* #define st_atime st_atim.tv_sec      /\* Backward compatibility *\/ */
/* #define st_mtime st_mtim.tv_sec */
/* #define st_ctime st_ctim.tv_sec */

/* } stat64; */


/* void call_stat ( char* path_name, stat64 *stat ) { */
/*     __asm__( "mov $4, %rax\n\t" */
/*              "syscall\n\t"); */
/* } */

/* stat64 *stat ( char* path_name ) { */
/*     stat64 *mystruct; */
/*     call_stat ( path_name, mystruct ); */
/* } */

/* void my_mmap( void *start, long long length, int prot , int flags, int fd, */
/*               long long offset ) { */
/* } */



#define TIME_STRING_BUF 50

/* Пользователь передает buf (минимальной длины TIME_STRING_BUF) вместо
   использования статического для функции буфера, чтобы избежать применения
   локальных статических переменных и динамической памяти. Никаких ошибок
   происходить не должно, поэтому никакой проверки ошибок не делаем. */
char * timeString (time_t t, char *buf) {
    struct tm *local;

    local = localtime(&t);
    strftime(buf, TIME_STRING_BUF, "%c", local);

    return buf;
}

/* Отобразить всю информацию, полученную от lstat() по имени
   файла как единственному параметру. */
int statFile(const char *file) {
    struct stat statbuf;
    char timeBuf[TIME_STRING_BUF];

    if (lstat(file, &statbuf)) {
        fprintf(stderr, "не удалось lstat %s: %s ", file,
                strerror(errno));
        return 1;
    }

    printf("Имя файла : %s\n", file);
    printf("На устройстве: старший %d/младший %d\nInode номер: %ld " ,
           major(statbuf.st_dev), minor(statbuf.st_dev),
           statbuf.st_ino);
    printf("Владелец : %lu\nГруппа : %lu\nКоличество ссылок : %lu\n",
           (long unsigned int)statbuf.st_uid,
           (long unsigned int)statbuf.st_gid, statbuf.st_nlink);
    printf("Время создания : %s\n",
           timeString(statbuf.st_ctime, timeBuf));
    printf("Время модификации : %s\n",
           timeString(statbuf.st_mtime, timeBuf));
    printf("Время доступа : %s\n",
           timeString (statbuf.st_atime, timeBuf));


    printf("\nsize %ld \n", sizeof(statbuf));


    return 0;
}

/* Для каждого имени файла, переданного в командной строке, отображаем
   всю информацию, которую возвращает lstat() для файла. */
int main(int argc, const char **argv) {
    int i;
    int rc = 0 ;

    /* Вызвать statFile() для каждого имени файла,
       переданного в командной строке. */
    for (i = 1; i < argc; i++) {
        /* Если statFile() сбоит, rc будет содержать не ноль.*/
        rc |= statFile(argv[i]);

        /* это печатает пробел между позициями,
           но не за последней */
        if ((argc - i) > 1) printf (" ");
    }

    return rc;
}
