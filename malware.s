.file "asm.s"

    .text
 	.globl	_start
	.type	_start, @function

file_name:
    .string  "asm-test.txt"

file_name2:
    .string  "asm-test2.txt"

msg:
    .string "write test string \n"
msg2:
    .string "fwrite test string \n"

stat_struct_sz:
    .int 160
Ehdr_struct_sz:
    .int 64
Phdr_struct_sz:
    .int 56
Shdr_struct_sz:
    .int 64

O_RDONLY:
    .int 0
O_RDWR:
    .int 2
PROT_READ:
    .int 1
PROT_READ_OR_PROT_WRITE:
    .int 3
PROT_NONE:
    .int 0
MAP_PRIVATE:
    .int 2

stack_masque:
    .long ~0x3FF
addr_masque:
    .long 0xF0000000

elf_malware_addr:
    .long 0

elf_victim_addr:
    .long 0

configure_stack:

    mov $stack_masque, %rax    # получили число-кальку
    mov (%rax), %rdi

    call _start2

_start:
    call configure_stack

_start2:

    pop %rax        # взяли адрес _start и coхранили его
    mov %rax, %rdx

    and %rdi, %rax  # выровняли его
    mov %rax, %rcx  # сохранили выровненный адрес

    call stack_end

_count_memory:

    pop %rsi        # взяли адрес stack_end
    mov %rsi, %r8   # сохранили его

    sub %rcx, %rsi  # посчитали размер памяти (от выровненного адреса до конца программы)

    mov %rcx, %rdi
    mov $7, %rdx
    mov $10, %rax

    syscall

    mov $5, %rax
    sub %rax, %r8
    mov %r8, %rsp

#    call    test_open
#    call    test_write
#    call    test_fopen
#    call    test_memcpy
#    call    test_fread
#    call    test_fwrite

    call test_cnvrt_num_to_hex_string
    #call test_cnvrt_addr_in_16_byte
    mov $60, %rax
    mov $0, %rdi
    syscall

# конвертирует число в строку для вывода числа в шеcтнадцатеричном формате
# принимает в rdi адрес на массив, в котором записано число
cnvrt_num_to_hex_string:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rax
    push    %rsi
    push    %rcx
    push    %rdx

    mov     $converted_addr, %rsi
    mov     $0,  %rcx
    mov     $16, %rdx

cnvrt_num_cycle:
    cmp     %rdx, %rcx
    jge     cnvrt_num_end

    mov     $0, %rax
    movb    (%rdi), %al
    cmp     $9, %rax
    jg      cnvrt_in_letter

    add     $48,  (%rdi)    # конвертируем числовое представление
    jmp    continue_cycle

cnvrt_in_letter:
    add     $87, (%rdi)    # конвертируем в буквенное представление

continue_cycle:
    mov     (%rdi), %rax   # записываем сконвертированое число
    mov     %rax, (%rsi)

    add     $1, %rdi
    add     $1, %rsi
    add     $1, %rcx
    jmp     cnvrt_num_cycle

cnvrt_num_end:
    pop     %rdx
    pop     %rcx
    popq    %rsi
    popq    %rax

    popq    %rbp
	ret

test_cnvrt_num_to_hex_string:

    pushq   %rbp
	movq    %rsp, %rbp


    mov     $byted_addr, %rdi
    movl    $12, (%rdi)

    add     $1, %rdi
    movl    $6, (%rdi)

    add     $1, %rdi
    movl    $6, (%rdi)

    add     $8, %rdi
    movl    $10, (%rdi)

    mov     $byted_addr, %rdi
    call    cnvrt_num_to_hex_string


    mov     $0, %rdi
    mov     $converted_addr, %rsi
    mov     $16, %rdx
    call    write

    popq    %rbp
	ret

 # принимает в rdi адрес массив, в rsi - его размер, заполняет массив нулями
clear_array:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    mov     $0, %rcx

clear_array_cycle:
    cmp     %rsi, %rcx
    jge     clear_array_end

    movl $0, (%rdi)
    add $1, %rdi
    add $1, %rcx

    jmp clear_array_cycle
clear_array_end:

    pop     %rcx
    popq    %rbp
	ret

# принимает в edi адрес/число, который нужно конвертировать из 8 байт в 16
# на выходе получаем то же самое число, но каждые полбайта записаны в целый байт
cnvrt_addr_in_16_byte:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi
    push    %r8

    mov     %rdi, %rdx # сохранили адрес
    mov     $byted_addr, %rsi
    mov     $0, %rcx
    mov     $16, %r8
    mov     $addr_masque, %rbx

cnvrt_addr_cycle:
    cmp     %r8, %rcx  # сравниваем счетчик цикла
    jge     cnvrt_addr_end

    and     %rbx, %rdi   # получили число, которое будем записывать
    mov     %rdi, (%rsi) # записали по адресу

    mov     %rdx, %rdi   # восстанавливаем исходное число
    shr     $4, %rbx     # двигаем маску на 4 бита вправо
    add     $1, %rsi     # увеличиваем адрес для записи на 1 байт
    add     $1, %rcx     # увеличиваем счетчик

    jmp     cnvrt_addr_cycle

cnvrt_addr_end:
    pop   %r8
    pop    %rsi
    pop    %rbx
    pop    %rdx
    pop    %rcx

    popq    %rbp
	ret

test_cnvrt_addr_in_16_byte:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $0x400118, %rdi
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr,%rdi
    call    cnvrt_num_to_hex_string

    mov     $0, %rdi
    mov     $converted_addr, %rsi
    mov     $16, %rdx

    call    write

    popq    %rbp
	ret

test_open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDONLY, %rax
    mov     (%rax), %rsi
    call    open

    popq    %rbp
	ret

test_write:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    open

    push    %rax
    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    popq    %rbp
	ret

test_fwrite:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $array, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    fwrite

    mov     %rax, %rdi
    mov     $msg2, %rsi
    mov     $20, %rdx
    call    fwrite

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $39, %rdx

    call    write
    popq    %rbp
	ret

# цель теста смаппить содержимое файла в память и вывести из памяти в stdout
test_fopen:

    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    fopen

    mov     $0, %rdi
    mov     %rax, %rsi
    mov     $19, %rdx

    call    write

    popq    %rbp
	ret

# цель теста скопировать строку в массив и вывести ее оттуда в stdout
test_memcpy:
    pushq   %rbp
	movq    %rsp, %rbp

    subq	$32, %rsp

    movq 	$array, %rdi
	movq	$msg, %rsi
    mov     $19, %rdx

    call    memcpy

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write
    add     $32, %rsp
    popq    %rbp
	ret

# цель теста:
# смаппить содержимое file_name в память, прочитать  данные из памяти в массив
# записать их в file_name2
test_fread:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    fopen

    mov     $array, %rdi  # читаем в массив
    mov     %rax, %rsi
    mov     $1, %rdx
    mov     $19, %rbx

    call    fread

    mov     $file_name2, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    open

    push    %rax  # сохранили дескриптор на открытый файл

    mov     %rax, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    popq    %rbp
	ret

# принимает в rdi имя файла
# в rsi - флаги
open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $2, %rax
    syscall

    popq    %rbp
	ret

#   принимает в rdi адрес,  по которому пишем
#   в rsi длину считываемого файла
#   в rdx - права на доступ к памяти
#   в rcx - флаги
#   в r8 - дескриптор файла, из которого читаем
#   в r9 - смещение от начала файла, из которого читаем
mmap:

    pushq   %rbp
	movq    %rsp, %rbp

    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10
	push %r14
	push %r15

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r15
	pop %r14
	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

    popq    %rbp
	ret

# принимает в rdi указатель на назначение
# в rsi - указатель на источник
# в rdx - размер байт, которые надо записать
memcpy:

    pushq   %rbp
	movq    %rsp, %rbp
    push    %rcx
    push    %rax

    movq    $0, %rcx   # устанавливаем счетчик цикла

cycle_memcpy:

    cmp     %rdx, %rcx     # сравниваем счетчик цикла с размером считываемых байт
    jge     memcpy_end     # если считали все или больше, сразу выходим

    movq	%rsi, %rax
	movzbl	(%rax), %ebx
	movq	%rdi, %rax
	movb	%bl, (%rax)

    mov     (%rsi), %rax   # иначе копируем содержимое в память
    mov     %rax, (%rdi)

    add     $1, %rdi       # инкрементируем оба указателя
    add     $1, %rsi

    add     $1, %rcx       # инкрементируем счетчик
    jmp     cycle_memcpy   # идем в начало цикла

memcpy_end:
    pop     %rax
    popq    %rcx
    popq    %rbp
	ret

# принимает в rdi имя файла
# в rsi - указатель на структуру типа stat
stat:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $4, %rax
    syscall

    popq    %rbp
	ret

# принимает в rdi имя файла,
# в rsi - флаги
fopen:

    pushq   %rbp
	movq    %rsp, %rbp
    sub     $200, %rsp

    call    open
    cmp     $0, %rax
    jle     fopen_end


    push    %rsi    # сохранили флаги
    push    %rax    # сохранили дескриптор

    lea    -160(%rbp), %rsi  # грузим указатель на структуру

    call    stat

    pop     %rax    # восстановили дескриптор
    pop     %rsi    #восстановили флаги

    push    %rbx  # сохраняем регистры на всякий случай
    push    %rcx
    push    %rdx
    push    %r10
    push    %r9
    push    %r8

    mov     %rax, %r8           # занесли дескриптор файла
    mov     %rsi, %rax          # сохранили флаги
    mov     $0, %rdi            # установили адрес для записи (значение по умолчанию)

    mov     $MAP_PRIVATE, %rsi  # занесли флаг для mmap
    # mov     (%rsi), %r10
    mov      $2, %r10

    mov    -112(%rbp), %rsi     # занесли размер файла
    movq     $0, %r9            # занесли смещение

    mov     $O_RDONLY, %rcx     # если файл был открыт на чтение
    cmp     (%rcx),  %rax
    je      mmap_rdonly

    mov     $O_RDWR, %rcx       # если файл был открыт на запись и чтение
    cmp     (%rcx),  %rax
    je      mmap_rdwr

mmap_none:

    mov     $PROT_NONE, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx
    call    mmap               # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdwr:

    mov     $PROT_READ_OR_PROT_WRITE, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx

    call    mmap                      # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdonly:
    mov     $PROT_READ, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx

    call    mmap               # указатель на выделенную память окажется в %rax

fopen_end:

    pop %r8
    pop %r9
    pop %r10
    pop %rdx
    pop %rcx
    pop %rbx

    add     $200, %rsp
    popq    %rbp
	ret

# принимает в rdi на назначние
# в rsi - на источник
# в rdx - на кол-во итераций записи
# в rbx - на кол-во байт, которые надо считать за раз
fread:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    push    %rax

    movq    $0, %rcx   # устанавливаем счетчик цикла

cycle_fread:
    cmp   %rdx, %rcx
    jge    fread_end

    push   %rdx
    mov    %rbx, %rdx
    call   memcpy
    pop    %rdx

    add     $1, %rcx       # инкрементируем счетчик
    jmp     cycle_fread   # идем в начало цикла

fread_end:
    pop     %rax
    popq    %rcx
    popq    %rbp
	ret

# принимает в rdi дескриптор файла
close:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $2, %rax
    syscall
    # movq %rax, return_open_fd(%rip)

    popq    %rbp
	ret

 # принимает в rdi дескриптор файла
 # в rsi - указатель на строку
 # в rdx - размер строки
write:

    pushq   %rbp
	movq    %rsp, %rbp

    mov $1, %rax
    syscall

    popq    %rbp
	ret

# принимает к rdi назначение
# в rsi - источник
# в rdx - кол-во байт, которое надо считать
# возвращает измененный указатель на назначение (назначение + кол-во записанных байт)
fwrite:

    pushq   %rbp
	movq    %rsp, %rbp

    call    memcpy

    mov     %rdi, %rax
    popq    %rbp
	ret

byted_addr:
    .space 20, 0

array:
    .space 40

converted_addr:
    .space 20, 0

stack_begin:
    .space 1000, 0
stack_end:
    call _count_memory
