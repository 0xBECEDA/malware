.file "asm.s"

    .text
    .globl main
	.type  main, @function

file_name:
    .string  "asm-test.txt"

file_name2:
    .string  "asm-test2.txt"

msg:
    .string "write test string \n"
msg2:
    .string "fwrite test string \n"


stat_struct_sz:
    .int 160
Ehdr_struct_sz:
    .int 64
Phdr_struct_sz:
    .int 56
Shdr_struct_sz:
    .int 64

O_RDONLY:
    .int 0
O_RDWR:
    .int 2
PROT_READ:
    .int 1
PROT_READ_OR_PROT_WRITE:
    .int 3
PROT_NONE:
    .int 0
MAP_PRIVATE:
    .int 2

main:
    pushq   %rbp
	movq    %rsp, %rbp

#   call    test_open
#   call    test_write
#   call    test_fopen
#   call    test_memcpy
#   call    test_fread
#   call    test_fwrite
    popq    %rbp
	ret

test_open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDONLY, %rax
    mov     (%rax), %rsi
    call    open

    popq    %rbp
	ret

test_write:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    open

    push    %rax
    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    popq    %rbp
	ret

test_fwrite:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $array, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    fwrite

    mov     %rax, %rdi
    mov     $msg2, %rsi
    mov     $20, %rdx
    call    fwrite

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $39, %rdx

    call    write
    popq    %rbp
	ret

# цель теста смаппить содержимое файла в память и вывести из памяти в stdout
test_fopen:

    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    fopen

    mov     $0, %rdi
    mov     %rax, %rsi
    mov     $19, %rdx

    call    write

    popq    %rbp
	ret

# цель теста скопировать строку в массив и вывести ее оттуда в stdout
test_memcpy:
    pushq   %rbp
	movq    %rsp, %rbp

    subq	$32, %rsp

    movq 	$array, %rdi
	movq	$msg, %rsi
    mov     $19, %rdx

    call    memcpy

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write
    add     $32, %rsp
    popq    %rbp
	ret

# цель теста:
# смаппить содержимое file_name в память, прочитать  данные из памяти в массив
# записать их в file_name2
test_fread:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    fopen

    mov     $array, %rdi  # читаем в массив
    mov     %rax, %rsi
    mov     $1, %rdx
    mov     $19, %rbx

    call    fread

    mov     $file_name2, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    open

    push    %rax  # сохранили дескриптор на открытый файл

    mov     %rax, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    popq    %rbp
	ret

# принимает в rdi имя файла
# в rsi - флаги
open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $2, %rax
    syscall

    popq    %rbp
	ret

#   принимает в rdi адрес,  по которому пишем
#   в rsi длину считываемого файла
#   в rdx - права на доступ к памяти
#   в rcx - флаги
#   в r8 - дескриптор файла, из которого читаем
#   в r9 - смещение от начала файла, из которого читаем
mmap:

    pushq   %rbp
	movq    %rsp, %rbp

    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10
	push %r14
	push %r15

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r15
	pop %r14
	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

    popq    %rbp
	ret

# принимает в rdi указатель на назначение
# в rsi - указатель на источник
# в rdx - размер байт, которые надо записать
memcpy:

    pushq   %rbp
	movq    %rsp, %rbp
    push    %rcx
    push    %rax

    movq    $0, %rcx   # устанавливаем счетчик цикла

cycle_memcpy:

    cmp     %rdx, %rcx     # сравниваем счетчик цикла с размером считываемых байт
    jge     memcpy_end     # если считали все или больше, сразу выходим

    movq	%rsi, %rax
	movzbl	(%rax), %ebx
	movq	%rdi, %rax
	movb	%bl, (%rax)

    mov     (%rsi), %rax   # иначе копируем содержимое в память
    mov     %rax, (%rdi)

    add     $1, %rdi       # инкрементируем оба указателя
    add     $1, %rsi

    add     $1, %rcx       # инкрементируем счетчик
    jmp     cycle_memcpy   # идем в начало цикла

memcpy_end:
    pop     %rax
    popq    %rcx
    popq    %rbp
	ret

# принимает в rdi имя файла
# в rsi - указатель на структуру типа stat
stat:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $4, %rax
    syscall

    popq    %rbp
	ret

# принимает в rdi имя файла,
# в rsi - флаги
fopen:

    pushq   %rbp
	movq    %rsp, %rbp
    sub     $200, %rsp

    call    open
    cmp     $0, %rax
    jle     fopen_end


    push    %rsi    # сохранили флаги
    push    %rax    # сохранили дескриптор

    lea    -160(%rbp), %rsi  # грузим указатель на структуру

    call    stat

    pop     %rax    # восстановили дескриптор
    pop     %rsi    #восстановили флаги

    push    %rbx  # сохраняем регистры на всякий случай
    push    %rcx
    push    %rdx
    push    %r10
    push    %r9
    push    %r8

    mov     %rax, %r8           # занесли дескриптор файла
    mov     %rsi, %rax          # сохранили флаги
    mov     $0, %rdi            # установили адрес для записи (значение по умолчанию)

    mov     $MAP_PRIVATE, %rsi  # занесли флаг для mmap
    # mov     (%rsi), %r10
    mov      $2, %r10

    mov    -112(%rbp), %rsi     # занесли размер файла
    movq     $0, %r9            # занесли смещение

    mov     $O_RDONLY, %rcx     # если файл был открыт на чтение
    cmp     (%rcx),  %rax
    je      mmap_rdonly

    mov     $O_RDWR, %rcx       # если файл был открыт на запись и чтение
    cmp     (%rcx),  %rax
    je      mmap_rdwr

mmap_none:

    mov     $PROT_NONE, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx
    call    mmap               # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdwr:

    mov     $PROT_READ_OR_PROT_WRITE, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx

    call    mmap                      # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdonly:
    mov     $PROT_READ, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx

    call    mmap               # указатель на выделенную память окажется в %rax

fopen_end:

    pop %r8
    pop %r9
    pop %r10
    pop %rdx
    pop %rcx
    pop %rbx

    add     $200, %rsp
    popq    %rbp
	ret

# принимает в rdi на назначние
# в rsi - на источник
# в rdx - на кол-во итераций записи
# в rbx - на кол-во байт, которые надо считать за раз
fread:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    push    %rax

    movq    $0, %rcx   # устанавливаем счетчик цикла

cycle_fread:
    cmp   %rdx, %rcx
    jge    fread_end

    push   %rdx
    mov    %rbx, %rdx
    call   memcpy
    pop    %rdx

    add     $1, %rcx       # инкрементируем счетчик
    jmp     cycle_fread   # идем в начало цикла

fread_end:
    pop     %rax
    popq    %rcx
    popq    %rbp
	ret

# принимает в rdi дескриптор файла
close:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $2, %rax
    syscall
    # movq %rax, return_open_fd(%rip)

    popq    %rbp
	ret

 # принимает в rdi дескриптор файла
 # в rsi - указатель на строку
 # в rdx - размер строки
write:

    pushq   %rbp
	movq    %rsp, %rbp

    mov $1, %rax
    syscall

    popq    %rbp
	ret

# принимает к rdi назначение
# в rsi - источник
# в rdx - кол-во байт, которое надо считать
# возвращает измененный указатель на назначение (назначение + кол-во записанных байт)
fwrite:

    pushq   %rbp
	movq    %rsp, %rbp

    call    memcpy

    mov     %rdi, %rax
    popq    %rbp
	ret

    .data
array:
    .space 40
