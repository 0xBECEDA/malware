#+STARTUP: showall indent hidestars


Попытка написать собственный вирус.

~Устройство эльфа~
Сначала идет заголовок самого эльфа. Он фиксированного размера. На моей
архитектуре это 64 байта.
Из заголовка можно узнать:
- тип эльфа
- смещение от начала файла до таблицы заголовков программы (на самом деле
  это массив)
- количество этих заголовков
- смещение от начала файла до таблицы заголовков секций
- entry point программы
- прочая нужная информация, но сейчас без надобности

Затем идет выравнивание - но его может и не быть

Потом идет таблица заголовков программы. Эти заголовки описывают сегменты
исполняемого кода программы.
Заголовки представляют собой массив.
Об заголовках известно:
- все фиксированного размера - на 64-разрядной архитектуре каждый
  занимает 52 байта
- идут подряд друг за другом
- каждый заголовок описывает 1 сегмент кода
- содержит в себе: размер описываемого сегмента, его смещение от начала
  файла, его вирутальный и физический адреса и т.д.
- порядок заголовков не соответствует порядку сегментв кода: второй
  заголовок вполне может описывать последний сегмент кода и наоборот

После таблицы заголовков может быть выравнивание. А может и не быть.

Следом идут сами сегменты исполняемого кода - кода программы.
За ними идут секции раздела .data, т.е. сегменты кода данных.
На них указывает таблица заголовков секций.
Она - последнее что есть в файле и из каждого заголовка можно вытащить ту
де информацию о сегменте кода данных, что мы вытаскивали из заголовков
программы.

~Этапы работы по написанию вируса~:
- найти все исполняемые (ELF) файлы текущей директории
- найти место, в которое можно вписать код вируса
- установить точку исполнения для вируса
- вписать вирус в файл
- запустить

~Куда записать вирус~
Есть несколько вариантов.
1. Вписать в padding между заголовком эльфа и таблицей заголовков
   программы.
- плюсы: легко найти
- минусы: мало места, а может и вообще не быть
2. Вписать прямо в основную секцию кода, прямо начиная с entry point
- плюсы: не надо париться с передачей управления вирусу, возможно под
  него не надо будет писать отдельный заголовок, только подкорректировать
  уже сущетвующий
- минусы: легко попасть между инстуркциями, надо грамонтно вставить код,
  чтоб не поломать файл
3. Вписать в самый конец файла
- плюсы: конец файла относительно легко найти
- минусы: первый же антивирус спалит подозрительный эльф, у которого
  последняя секция кода исполняемая, а не таблица заголовком сегмантов
  данных или сами сегменты данных
4. Вписать между последним сегментом исполняемого кода и первым сегментом
   данных
- плюсы: выглядит менее подозрительно для антивируса
- минусы: нужно найти это место, создать новый сегмент кода, создать под
  него новый заголовок, включить его в таблицу заголовков программы,
  передать управление.
Выглядит как самый геморройный вариант, но тем не менее самый надежный:
эльф придется пересобирать, но зато можно выделить себе столько места,
сколько понадобится и не бояться, что файл от этого сломается

Так что остановимся на нем.

~Передача управления~
Самый простой способ передать управление вирусу - это начать исполнение с
него, а он уже будет передавать упарвление в основную программу.Т.е. в
основной секции кода первой инструкцией поставить ~call~ на код вируса,
так что когда вирус совершит ~ret~, мы автоматически вернемся к
исполнению программы-жертвы

~Как пересобрать эльф~
- выгружаем заголовок эльфа
- правим в нем поле ~e_phnum~ - оно отвечает за количество заголовков
  программ - раз мы добавляем минимум один сегмент кода, нам понадобится
  новый заголовок. Значит, кол-во заголовков увеличится
- создаем новый заголовок для нашего вируса - это будет структура типа
  ~Elf64_Phdr~, заполняем все ее поля. На самом деле нам не нужно
  создавать новый заголовок с нуля, эльф вируса уже содержит в себе все
  заголовки, надо просто вытащить их
  сложность состоит в том, что их надо будет поправить: изменить смещения
  от начала файла, виртуальные адреса и т.д.
- по очереди выгружаем все заголовки секций данных и правим их: если мы
  вставляем между сегментами данных и сегментами кода доп. сегмент,
  значит, сегменты данных отъедут дальше от начала файла. Нужно поправить
  смещения - пишем для нее специальную функцию, которая, зная, сколько
  байт занимает доп. сегмент, увеличит ровно на это значение смещения
  секций.
- выгружаем оставшиеся части кода эльфа
- теперь создаем новый эльф (на время отладки, в "продакшене" будем
  открывать на запись эльф-жертву, который мы и препарировали) и начинаем
  по очереди вписывть код: измененный заголовок, таблицу заголовков
  программы и т.д.

~Как найти, где кончаются сегменты кода и начинаются сегменты данных~
У нас есть вся необходимая информация из заголовков сегментов кода и
заголовка эльфа.

А именно:
- из поля заголовка эльфа ~e_phoff~ вытаскиваем смещение до таблицы
  заголовков сегментов кода (программы)
- читаем таблицу заголовков программы
- сверяем смещение каждого сегмента кода и его размер
- таким образом находим сегмент с самым большим смещением от начала файла
  и самым большим размером - иногда почему-то сегменты накладываются друг
  на друга, если верить инфе из их заголовков
- сегмент с самым большим смещением от начала файла - это и есть и
  последний сегмент кода
- проматываем колво байт, которое равно самое большое смещение сегмента +
  его размер и получаем байт, с которого начнем вписывать вирус

~Посчитать виртуальный адрес, куда вирус будет выгружаться в память~
(посмотреть, как это орагнизовано в других секциях кода, получить
представление о карте памяти)

Программа выделяет определенное количество виртуальной памяти под
программу. Адреса идут подряд, как правило.
Так что чтоб присвоить новые виртуальные адреса вирусу нужно:
- найти последний сегмент кода жертве, получить его виртуальный адрес
- вытащить все заголовки вируса кроме заголовка самого эльфа - заголовки
  программы отдельно, а заголовки секций - отдельно. Записывать будем в
  два массива
- отсортировать элементы массивов - структуры заголовков - по их смещению
  от начала файлов. Так будет проще и смещения изменять, и виртуальные
  адреса присваивать
- посчитать соотношения между адресами сегментов кода вируса - так мы
  получим представление, сколько они занимают места в виртуальной памяти
- пройтись по каждому из массивов и присвоить новые адреса. Отсчет пойдет
  от адреса последней секции кода жертвы

Похожим обраом посчитать физические адреса

~Как не заражать файлы повторно и не заразить исполняемый файл вируса~
Установить маркер заражения. Над установить так, чтоб было относительно
легко достать.

Немаловажно заметить, что эльф вируса - это полноценный эльф, который
имеет свой заголовок, таблицы заголовков и т.д. А нам от него нужны
только секции с исполняемым кодом.

Так что перед тем, как вписать свой код, вирус должен проанализировать
собственный эльф и получить из него секции кода.

~Нужно избавиться от всех библиотечных функций~

Для этого нужно реализовать все необходимые библиотечные функции. Если
подключать либы, вирус становится слишком большим.

Нам нужны вызовы ~fopen~, ~fclose~ и ~fread~.
Для их реализации понадобится вызов ~mmap~, который скопирует файл в
страницу памяти и вернет указатель на нее, так что на этой основе можно
будет реализовать все необходимые функции.

Для mmap требуется знать размер файла. Поэтому мы реализуем вызов ~stat~,
который вернет заполненную структуру, содержащую все свойства файла,
включая его размер.

Так же реализуем собственную версию ~memcpy~, поскольку копирование из
одной области памяти в другую нам однозначно понадобится.
Хорошо бы, конечно, реализовать ~malloc~ и ~free~, но как показал анализ
под gdb, реализовывать эти функции слишком сложно. Вместо этого
используем следующий костыль: если нам нужно передавать
переменную/указатель на что-то из функции в функцию, то мы объявим все
необходимое в ~main~, таким образом пока мэйн не завершится - а с ним и
вся прога - переменные будут существовать на стеке и мы не наткнемся на
UB из-за их внезапного исчезновения.

~Выгрузка кода файла-жертвы и вируса~

Для того, чтоб правильно пересобрать эльф-жертву, нам нужно сначала
раздеить этот эльф на части:
- заголовок самого эльфа
- таблица заголовков программы
- таблица загоовков секций
- остальной код

Если с первыми тремя пунктами все более-менее понятно, то с выгрузкой
остального кода не так все просто. Заголовки программ указывают на весь
код в принципе - например, ожин из заголовков может указывать на довльно
большой сегмент кода, у которого нудевое смеение от начала файла, что
означает, что он включает в себя не только сам код, но и заголовки
программ и эльфа. А нам-то они уже не нужны, нам нужен только код.

Следовательно, нужно создать систему правил, которая будет решать, где
именно следует искать исполняемый код и либо выгружать его тут же, либо
сохранять "координаты", т.е. смещение, по которому можно найти данный
код, чтоб затем его выгрузить.

Чтоб определить, где брать код, нам понадобится следующая информация из
заголовков программы:
- тип заголовка (позволяет определить, какого рода сегмент кода описывает
  заголовок)
- смещение сегмента от начала файла
- размер сегмента

~Свод правил, по которым разбираются заголовки для выгрузки кода~

Проблема в том, что один сегмент кода может включать в себя другие, а еще
они могут даже немного накладываться друг на друга. А нам не надо
выгружать одно и то же по сто раз. Слеовательно, надо пересчитывать
смещение и размер сегмента в зависимости от того, является ли он частью
другого сегмента и т.д.

Для удобства создадим структуру, в которой будет 2 поля: пересчитанное
смещение и пересчитанный размер сегмента кода. По окончании пересчета у
нас будет массив таких структур.

Все для того же удобства вытаскиваем отдельно заголовок, у которого
тип - 6. Это заголовок таблицы заголовоков, он всегда стоит в начале
таблицы если она есть. Заголовок с таким типом может встречаться только 1
раз. Нам этот загоовок понадобится, чтоб узнать размер таблицы заголовков
и ее смещение - это позволит сразу отсекать этот кусок кода, если он
будет включен в другие сегменты.

Затем сортируем заголовки по их размеру.
Дело в том, что заголовки могут накладываться друг на друга как краями,
так и где-то посередине. Если сначала записать смещения более мелких
сегментов, а потом наткнуться на более крупный, который их включает, то
придется "вырезать" более мелкие сегменты, чтоб не копировать их дважды
потом. Это очень трудно. Поэтому проще сначала записать смещения и
размеры более крупных, а  затем уже проверять, являются ли другие
сегменты кода частью более крупных.

Алгоритм достаточно простой
- берем каждый заголовок, смотрим его тип (см. ниже)
- получаем смещение и размер сегмента, который описывает заголовок
- сравниваем его с смещениями и сегментами прочих заголовков, если мы
  понимаем, что этот сегмент является частью другого, то пересчитываем
  размер и/или смещение
- заносим новые данные в структуру
- повторяем алгоритм до тех пор, пока заголовки не кончатся


2. ~если тип заголовка = 0~, то
заголовок не используется, остальные поля не определы, вообще ничего не
трогаем

3. ~если тип заголовка =! 0 and != 6~, то
- выгружаем смещение и размер сегмента
- сравниваем их с размерами и смещениями у прочих сегментов

Сравнение происходит следующим образом:

- берем из каждой сохраненной структуры с данными смещение и размер
  сегмента.
- если их сумма < смещения текущаего сегмента кода, то ничего
  не делаем. Сегменты никак не пересекаются.
- если сумма > смещения текущего сегмента, то смотрим насколько. Сегменты
  могут накладываться друг на друга не по краям, а где-то посередине,
  например.

Так что выясняем, где именно сегменты накладываются друг на друга - на
это укажет смещение из текущей структуры - и... что? Большой сегмент
придется разрезать на много мелких, если придется. Как сохранять их
смещения и размеры?
