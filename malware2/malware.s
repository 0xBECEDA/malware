.macro STACK_MASQUE reg
    mov $~0x3FF, \reg
.endm

.macro ADDR_MASQUE reg
    mov $0xF, \reg
.endm

    .text
 	.globl	_start
	.type	_start, @function

file_name:
    .string  "asm-test.txt"

file_name2:
    .string  "asm-test2.txt"

file_name3:
    .string  "asmt"

msg:
    .string "write test string \n"
msg2:
    .string "fwrite test string \n"

stat_struct_sz:
    .int 160
Ehdr_struct_sz:
    .int 64
Phdr_struct_sz:
    .int 56
Shdr_struct_sz:
    .int 64

O_RDONLY:
    .int 0
O_RDWR:
    .int 2
PROT_READ:
    .int 1
PROT_READ_OR_PROT_WRITE:
    .int 3
PROT_NONE:
    .int 0
MAP_PRIVATE:
    .int 2

elf_malware_addr:
    .long 0

elf_victim_addr:
    .long 0

_start:

    call _start2

_start2:
    pop %rax        # взяли адрес _start2 и coхранили его

    STACK_MASQUE %rdi

    mov %rax, %rdx

    and %rdi, %rax  # выровняли его
    mov %rax, %rcx  # сохранили выровненный адрес

    call stack_end

_count_memory:

    pop %rsi        # взяли адрес stack_end
    mov %rsi, %r8   # сохранили его

    sub %rcx, %rsi  # посчитали размер памяти (от выровненного адреса до конца программы)

    mov %rcx, %rdi
    mov $7, %rdx
    mov $10, %rax

    syscall

    mov $5, %rax
    sub %rax, %r8
    mov %r8, %rsp

#    call    test_open
#    call    test_write
#    call    test_fopen
#    call    test_memcpy
#    call    test_fread
#    call    test_fwrite
#    call test_cnvrt_num_to_hex_string
#    call test_cnvrt_addr_in_16_byte
#    call test_my_printf1
#    call test_my_printf2
#    call test_my_printf3
    call test_read_elf_header

exit:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

    # читает заголовок эльфаиз памяти
    # в rdi принимает указатель на память, в которой лежит эльф
elf_header_victim:
    .space 0x40,0

    .globl  read_elf_header
	.type	read_elf_header, @function

read_elf_header:
    push %rsi
    push %rbx
    push %rdx

    mov  %rdi, %rsi
    mov  $elf_header_victim, %rdi
    mov  $0x1, %rdx
    mov  $0x40, %rbx

    call fread

    pop  %rdx
    pop  %rbx
    pop  %rsi

    ret

test_read_elf_header:

    mov     $file_name3, %rdi
    mov     $O_RDONLY, %rax
    mov     (%rax), %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_elf_header_end
    mov     %rax, %rdi
    call    read_elf_header

test_read_elf_header_end:
    ret

    # конвертирует число в строку для вывода числа в шеcтнадцатеричном формате
    # принимает в rsi адрес на массив, в котором записано число
converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function
    #.param  ptr_array_num, gr # %rsi

cnvrt_num_to_hex_string:
    push    %rax
    push    %rsi
    push    %rdi
    push    %rcx
    push    %rdx

    mov     $converted_addr, %rdi

    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    mov     $converted_addr, %rdi

    mov     $0x10, %rcx

cnvrt_num_cycle:

    xor     %rax, %rax
    movb    (%rsi), %al
    cmp     $0x09, %rax
    jg      cnvrt_in_letter

    add     $0x30,  %al    # конвертируем в числовое представление
    jmp     continue_cycle

cnvrt_in_letter:
    add     $0x57, %al    # конвертируем в буквенное представление

continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rdx
    popq    %rcx
    popq    %rdi
    popq    %rsi
    popq    %rax

	ret

test_cnvrt_num_to_hex_string:

    pushq   %rbp
	movq    %rsp, %rbp

    mov     $byted_addr, %rdi
    mov     $0x10, %rsi

    call    clear_array
    mov     $byted_addr, %rsi

    movb    $0x01, (%rsi)

    call    cnvrt_num_to_hex_string

    mov     $0x0, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx
    call    write

    popq    %rbp
	ret

 # принимает в rdi адрес массив, в rsi - его размер, заполняет массив нулями
clear_array:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:

    pop     %rcx
    popq    %rbp
	ret

    # принимает в rdi строку, которую нужно вывести,
    # в rsi - число для вывода
    # в rdx - основание системы счисления, в которой надо вывести число
    # или 0, если вывода числа нет,
    # в r8 - размер строки, если она есть
my_printf:
    push    %rcx
    push    %rax
    push    %rdx

    mov     %rdi, %rcx
    mov     %rsi, %rax

    cmp     $0, %rdx
    je      print_string

    cmp     $16, %rdx
    je      cnvrt_hex_num

    jmp     print_string

cnvrt_hex_num:
    mov     $byted_addr, %rdi   # очищаем массив (там могло быть другое число)
    mov     $0x10, %rsi

    call    clear_array

    mov     $converted_addr, %rdi
    mov     $0x11, %rsi

    call    clear_array

    mov     %rax, %rdi               # забираем число со стека
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr, %rsi
    call    cnvrt_num_to_hex_string   # преобразовываем в строку

print_string:
    mov     %rcx, %rsi # забрали строку

    cmp     $0, %rsi
    je      print_num

    mov     $0, %rdi

    mov     %r8, %rdx
    call    write

print_num:
    pop     %rdx      # забрали снование системы счисления
    cmp     $0, %rdx
    je      my_printf_end

    xor     %rdi, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx

    call    write

my_printf_end:
    pop     %rax
    pop     %rcx
	ret

test_my_printf1:
    mov     $msg, %rdi
    mov     $0x3041d23e2, %rsi
    mov     $0x10, %rdx
    mov     $0x13, %r8

    call    my_printf
	ret

test_my_printf2:
    mov     $0x0, %rdi
    mov     $0x3041d23e2, %rsi
    mov     $0x10, %rdx
    mov     $0x0, %r8

    call    my_printf

    ret

test_my_printf3:

    mov     $msg, %rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x13, %r8

    call    my_printf
	ret

    # принимает в rdi адрес/число, который нужно конвертировать из 8 байт в 16
    # на выходе получаем то же самое число, но каждые полбайта записаны в целый байт
byted_addr:
    .space  20, 0

cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rax
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    mov     %rdi, %rdx
    mov     $byted_addr, %rsi

    add     $0xF, %rsi
    mov     $0x10, %rcx

    mov     $0x0, %r8

    ADDR_MASQUE %rbx

cnvrt_addr_cycle:

    and     %rbx, %rdx

    mov     %rcx, %r9
    xor     %rcx, %rcx

mov_num_cycle:
    cmp     %r8, %rcx
    jge     mov_num_end

    shr     $0x4, %rdx
    inc     %rcx
    jmp     mov_num_cycle

mov_num_end:
    mov     %r9, %rcx
    movb    %dl, (%rsi)

    mov     %rdi, %rdx
    shl     $0x4, %rbx

    dec     %rsi
    inc     %r8

    loop   cnvrt_addr_cycle

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %rax
    pop     %r9
    pop     %r8

    ret

test_cnvrt_addr_in_16_byte:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $0x40, %rdi
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr, %rsi
    call    cnvrt_num_to_hex_string

    mov     $0, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx

    call    write

    popq    %rbp
	ret

test_open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDONLY, %rax
    mov     (%rax), %rsi
    call    open

    popq    %rbp
	ret

test_write:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    open

    push    %rax
    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    popq    %rbp
	ret

test_fwrite:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $array, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    fwrite

    mov     %rax, %rdi
    mov     $msg2, %rsi
    mov     $20, %rdx
    call    fwrite

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $39, %rdx

    call    write
    popq    %rbp
	ret

# цель теста смаппить содержимое файла в память и вывести из памяти в stdout
test_fopen:

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    fopen

    mov     $0, %rdi
    mov     %rax, %rsi
    mov     $19, %rdx

    call    write

	ret

# цель теста скопировать строку в массив и вывести ее оттуда в stdout
test_memcpy:
    pushq   %rbp
	movq    %rsp, %rbp

    subq	$32, %rsp

    movq 	$array, %rdi
	movq	$msg, %rsi
    mov     $19, %rdx

    call    memcpy

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write
    add     $32, %rsp
    popq    %rbp
	ret

# цель теста:
# смаппить содержимое file_name в память, прочитать  данные из памяти в массив
# записать их в file_name2
test_fread:

    mov     $file_name, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    fopen

    cmp     $0, %rax
    jle     test_fread_end

    mov     $array, %rdi  # читаем в массив
    mov     %rax, %rsi
    mov     $1, %rdx
    mov     $19, %rbx

    call    fread

    mov     $file_name2, %rdi
    mov     $O_RDWR, %rax
    mov     (%rax), %rsi

    call    open

    push    %rax  # сохранили дескриптор на открытый файл

    mov     %rax, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

test_fread_end:
	ret

# принимает в rdi имя файла
# в rsi - флаги
open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $2, %rax
    syscall

    popq    %rbp
	ret

#   принимает в rdi адрес,  по которому пишем
#   в rsi длину считываемого файла
#   в rdx - права на доступ к памяти
#   в rcx - флаги
#   в r8 - дескриптор файла, из которого читаем
#   в r9 - смещение от начала файла, из которого читаем
mmap:

    pushq   %rbp
	movq    %rsp, %rbp

    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10
	push %r14
	push %r15

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r15
	pop %r14
	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

    popq    %rbp
	ret

# принимает в rdi указатель на назначение
# в rsi - указатель на источник
# в rdx - размер байт, которые надо записать
memcpy:

    pushq   %rbp
	movq    %rsp, %rbp
    push    %rcx
    push    %rax

    movq    $0, %rcx   # устанавливаем счетчик цикла

cycle_memcpy:

    cmp     %rdx, %rcx     # сравниваем счетчик цикла с размером считываемых байт
    jge     memcpy_end     # если считали все или больше, сразу выходим

    movq	%rsi, %rax
	movzbl	(%rax), %ebx
	movq	%rdi, %rax
	movb	%bl, (%rax)

    mov     (%rsi), %rax   # иначе копируем содержимое в память
    mov     %rax, (%rdi)

    add     $1, %rdi       # инкрементируем оба указателя
    add     $1, %rsi

    add     $1, %rcx       # инкрементируем счетчик
    jmp     cycle_memcpy   # идем в начало цикла

memcpy_end:
    pop     %rax
    popq    %rcx
    popq    %rbp
	ret

# принимает в rdi имя файла
# в rsi - указатель на структуру типа stat
stat:
    pushq   %rbp
	movq    %rsp, %rbp

    mov $4, %rax
    syscall

    popq    %rbp
	ret

# принимает в rdi имя файла,
# в rsi - флаги
fopen:
    sub     $200, %rsp

    call    open
    cmp     $0, %rax
    jle     fopen_end2

    push    %rsi    # сохранили флаги
    push    %rax    # сохранили дескриптор

    lea    -160(%rbp), %rsi  # грузим указатель на структуру

    call    stat

    pop     %rax    # восстановили дескриптор
    pop     %rsi    #восстановили флаги

    push    %rbx  # сохраняем регистры на всякий случай
    push    %rcx
    push    %rdx
    push    %r10
    push    %r9
    push    %r8

    mov     %rax, %r8           # занесли дескриптор файла
    mov     %rsi, %rax          # сохранили флаги
    mov     $0, %rdi            # установили адрес для записи (значение по умолчанию)

    mov     $MAP_PRIVATE, %rsi  # занесли флаг для mmap
    # mov     (%rsi), %r10
    mov      $2, %r10

    mov    -112(%rbp), %rsi     # занесли размер файла
    movq     $0, %r9            # занесли смещение

    mov     $O_RDONLY, %rcx     # если файл был открыт на чтение
    cmp     (%rcx),  %rax
    je      mmap_rdonly

    mov     $O_RDWR, %rcx       # если файл был открыт на запись и чтение
    cmp     (%rcx),  %rax
    je      mmap_rdwr

mmap_none:

    mov     $PROT_NONE, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx
    call    mmap               # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdwr:

    mov     $PROT_READ_OR_PROT_WRITE, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx

    call    mmap                      # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdonly:
    mov     $PROT_READ, %rcx   # занесли права на доступ к памяти
    mov     (%rcx), %rdx
    mov     $2, %rcx

    call    mmap               # указатель на выделенную память окажется в %rax

fopen_end:

    pop     %r8
    pop     %r9
    pop     %r10
    pop     %rdx
    pop     %rcx
    pop     %rbx

fopen_end2:

    xor     %rax, %rax
    add     $200, %rsp

	ret

# принимает в rdi на назначние
# в rsi - на источник
# в rdx - на кол-во итераций записи
# в rbx - на кол-во байт, которые надо считать за раз
fread:

    push    %rcx
    push    %rax

    movq    $0, %rcx   # устанавливаем счетчик цикла

cycle_fread:
    cmp   %rdx, %rcx
    jge    fread_end

    push   %rdx
    mov    %rbx, %rdx
    call   memcpy
    pop    %rdx

    add     $1, %rcx       # инкрементируем счетчик
    jmp     cycle_fread   # идем в начало цикла

fread_end:
    pop     %rax
    popq    %rcx
	ret

# принимает в rdi дескриптор файла
close:
    mov $2, %rax
    syscall
    # movq %rax, return_open_fd(%rip)

	ret

 # принимает в rdi дескриптор файла
 # в rsi - указатель на строку
 # в rdx - размер строки
write:

    mov $1, %rax
    syscall

	ret

# принимает к rdi назначение
# в rsi - источник
# в rdx - кол-во байт, которое надо считать
# возвращает измененный указатель на назначение (назначение + кол-во записанных байт)
fwrite:

    pushq   %rbp
	movq    %rsp, %rbp

    call    memcpy

    mov     %rdi, %rax
    popq    %rbp
	ret
array:
    .space 40

stack_begin:
    .space 1000, 0
stack_end:
    call _count_memory
