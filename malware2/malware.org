** Устройство эльфа.
~Заголовок эльфа~ - это структура, которая содержит в себе информацию о
точке входа, количестве заголовков программ, их размере, количестве
загоолвков секций,  их размере, где эти заголовки искать в файле и еще некоторые данные.
Следом идет таблица заголовков программ (сегментов).

~Таблица заголовков программ~ - представляет собой несколько заголовков
программ (сегментов), которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента, его размере,
смещении, виртуальном адресе и т.д. Количество заголовоков сегментов
зависит от количества сегментов в программе. Каждый заголовок занимает 56 байт.

Затем идет весь код программы, а после него - таблица заголовков секций

~Таблица заголовков секций~ - представляет собой несколько заголовков
секций, которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую одну секцию кода. Эта
структура содержит в себе информацию о типе секции, ее размере,
смещении, виртуальном адресе и т.д.

После заголовков секций в файле ничего нет.

Все эти разнообразные виды заголовков нужны, чтоб загрузчик сразу мог
определить, какой код где находится. как должен быть использован и т.д.

Программа поделена на сегменты - это относительно большие блоки кода,
каждый из которых имеет свою функцию: некоторые сегменты содержат в себе
код программы - тип LOAD - и будут загружены в память, некоторые содержат
в себе .data, другие же вообще не будут загружены в память и содержат в
себе информацию для линкера.

Сегменты в свою очередь состоят из более мелких сегментов - их называют
секциями. Каждая секция так же имеет свое назначение и свои заголовки.

** Заражение
Чтоб заразить жертву вирусом, нужно найти подходящий для заражения
сегмент кода и подходящую секцию. Поскольку нам надо, чтоб код вируса был
загружен загрузчиком в память - иначе он не исполнится - нам нужно
разместить код вируса в загружаемом сегменте кода - он имеет тип LOAD. А
затем в нем мы находим последнюю секцию кода и вписываем вирус сразу
после нее.
Самое простое - это найти сегмент кода, который содержит в себе e_entry -
точку входа, с которой начинается программа-жертва - и использовать его для
заражения. Данные о сегментах и секциях можно найти в их заголовках. Для
поиска заражаемого сегмента и секции нам понадобятся виртуальные адреса,
с которых начинается код, который они описывают.

Вписывая вирус сразу после подходящего сегмента, мы как бы расширяем его
и его последнюю секцию. Поэтому нужно отредактировать их заголовки,
увеличив поля, в которых содержится информация о размере описываемого
кода - в заголовке сегмента это поля p_memsz и p_filesz, а в заголовке
секции это поле sh_size. Тогда нам не придется создавать отдельный
заголовок для кода вируса и мучиться, вписывая его в таблицу заголовков.

Теперь мы сталкиваемся с необходимостью сместить весь код, который
находится в жертве после точки заражения - конца заражаемого сегмента,
куда будет записан вирус - иначе код будет затерт, а файл "сломается".

Физически переместить код нетрудно - при пересборке эльфа достаточно
просто его вписать после вируса. Но мы помним, что мало просто вписать
код, надо еще оставить информацию загрузчику, где его искать. А значит,
нужно отредактировать заголовки сегментов и секций, которые описывают
код, находящийся после точки заражения. В этих заголовках нужно
отредватировать поля, содержащие в себе информацию об адресе и смещении
кода.

Как найти сегменты и секции, которые лежат после точки заражения? Можно
было бы искать их только по виртуальным адресам. Идея простая: если
виртуальный адрес в заголовке меньше, чем виртуальный адрес заражаемой
точки, то заголовок редактировать не нужно - код, описываемый им,
находится выше точки заражения.
Выглядит очень логично, но на самом деле этот подход вызывает
труднотлаживаемые ошибки.
Дело в том, что у нас есть сегменты и секции, которые в память процесса
не загружаются, они нужны только линкеру и загрузчику для построение
образа процесса в памяти. Поэтому адрес у них нулевой, а вот смещение
есть. В результате эти заголовки никогда не будут отредактированы, а
загрузчик, проходя по старым смещениям, будет видеть совершенно не тот
код, что должен был бы. Можно провести пару увлекательных вечеров,
пытаясь понять, почему в бинарном файле заголовки есть и находятся там,
где мы ожидаем их увидеть,и данные в них совершенно правильные, а
~readelf~ - утилита для парсинга эльф-файла - будет сообщать что не может
найти то одну секцию, то другую.
Поэтому на этапе мы проверяем и смещение, и виртуальный адрес.

Завершив редактирование заголовков, нужно отредактировать поле ~e_shoff~
в заголовке эльфа и указать ему новое смещение, по которому лежат
заголовки секций. В противном случае загрузчик будет искать их по старому
смещению и никогда не найдет.
** Загрузка эльфа в память
Ошибка "elf_machine_runtime_setup (profile=0, lazy=1, l=0x7ffff7ffe168)
at ../sysdeps/x86_64/dl-machine.h:86
../sysdeps/x86_64/dl-machine.h: Нет такого файла или каталога"

Из-за записи вируса в файл, я вынуждена сместить остальной код жертвы на
размер вируса, в противном случае он будет затерт. Из-за этого смещения
возникает данная ошибка.

Если заражать жертву, которая не использует динамическую линковку, то
жертва исполняется после заражения без проблем. Так же если просто
скопировать код жертвы в другой файл - так же переписывая его по кускам,
как при заражении - данная ошибка не возникает. Следовательно, проблема
именно в смещении кода, начинающегося с точки заражения.

~Решение ошибки~
Развернутое объяснение см. ниже.
Сжатое объяснение:

Сегфолт происходит на этапе рантайм-линковки. Это видно по выводу gdb  -
~dl_relocate_object~, внутри которого происходит сегфолт, является частью
либы dl_reloc.c (сорцы
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html ), в частности
_dl_relocate_object (сорцы здесь
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html#_dl_relocate_object)

dl_reloc перемещает разделяемый объект и разрешает ссылки -
т.е. заполняет их адресами - на другие разделяемые объекты.

Сегфолт происходит потому, что линкеру необходима информация о
расположении GOT и некоторые другие данные. Проблема в том, что сведения
о расположении эьих данных линкер берет не из заголовков секций, из
секции .dynamic, ведь заголовки  Если не отредактировать данные в ней, то линковщик будет
искать GOT по старому адресу, что вызывает сегфолт.

Следовательно, надо отредактировать записи в секции .dynamic - если
виртуальный адрес кода, описываемый записью, больше виртуального адреса
точки заражения, значит данный код находится ниже точки заражения и
следовательно виртуальный адрес должен быть увеличен на размер вируса.

Полагаю, что так же надо отредактировать записи в rel_name и symtab. В
symtab хранится информация о символах - функциях и переменных - в
частности, виртуальные адреса, по которым они расположены, а в rel_name
хранится информация о перемещениях - думаю, это связано с работой
линковщика - следовательно, виртуальные адреса в этих записяз надо
исправить тоже.

~Загрузка эльфа~
Процесс загрузки эьфа управляется функцией load_elf_binary() ( файл
binfmt_elf.c, сорцы здесь
https://elixir.bootlin.com/linux/latest/source/fs/binfmt_elf.c ). Это и
есть загрузчик, который должен правильно отобразить программу в память.

~load_elf_binary()~
- начинает чтение эльфа с его заголовка
Из него он берет смещение до таблицы заголовков сегментов, смещение до таблицы
заголовков секций и др. данные
- затем читает заголовки сегментов
Ищет среди него заголовок PT_INTERP и заголовок GNU_STACK. GNU_STACK
содержит информацию о стеке, а PT_INTERP - о рантайм-линкере, который должен быть
использован для этого бинаря.

Теперь можно начать подготовку для непосредственной загрузки программы в
память.
Для этого нужно:
- очистить состояние ядра, которое ссылается на предыдущую выполненную
  программу (что бы это ни значило)
- убить потоки, связанные с предыдущей программой. Новая всегда
  начинается в одном потоке.
- указать новое местоположение  - метоположение текущего исполняемого
  файла
- очистить виртуальную память от предыдущей программы
- закрыть файловые дескрипторы, оставшиеся от сратой программы

После этого настраиваем виртуальную память для новой программы.
Устанавливаем новую вершину стека - обычно смещается вниз на случайное
значение, это усложняет атаки на переполнение стека (если не знаешь, где
будет вершина, труднее переполнить).
Затем проходимся по всем сегментам PT_LOAD и отображаем их в память,
составляя макет памяти новой программы. Затем устанавливает страницы BSS,
заполненные нулями (неинициализированные данные).
На финальном этапе загрузки устанавливается база стека.

Теперь про ~линковку~

Большинство файлов слинкованы динамически - т.е. когда компилятор
проходится по файлу и находит вызов библиотечной функции, он оставляет
пометку, что это пространство в будущем должено быть заполнено вызовом
библиотечной функции, а сам код библиотеки в бинаре не присутствует.

Чтоб код корректно исполнялся, нужен рантайм линкер. Он задается в
заголовк PT_INTERP, в моем случае это  ld-linux-x86-64.so.2. После того,
как процесс загрузки программы завершился, вызывается
~load_elf_interp()~, который загрузит код линкера в память. Затем
срабатывает системный вызов ~execve()~ - он разрешает программе
выполняться. Но выполнение начинается не с самого эльфа, а с его
линкера - поэтому он и рантайм, потому что работает во время
исполнения. Рантайм-линкер должен позаботиться о загрузке библиотек,
разрешении неопределенных символов программы до правильных определений в
этих библиотеках и т.д.

Конечная цель линкера - это заполнение GOT смещениеями до библиотечных
функции. Но фишка в том, что он берет информацию о том, где находится GOT
не из заголовков секций, а из секции .dynamic, которая находится в
разделе DYNAMIC. . Соответственно, если не
отредактировать записи в ней, то линкер будет искать GOT и другие данные
по старым адресам, где на самом деле ничего нет. Что и приводет к
сегфолту скорее всего.

Теперь о том, самом механизме ~PLT/GOT~.
Неизвестно, по какому адресу будет загружена динамиеская
библиотека. Соответственно, нельзя предугадать, где какая функция будет
лежать.
Поэтому и нужен механизм PLT/GOT, цель которого - это перенаправить
вызов библиотечной функции так, чтоб вызвался библиотечный код, а не
какая-то чушь.

Если описать механизм совсем грубо, то получится следующее:
GOT представляет собой таблицу смещений, которая должна быть заполнена
смещениями до кода вызываемой функции. А PLT представляет собой таблицу,
которая содержит в себе код, который и вызовет библиотечную функцию, используя
смещение из таблицы GOT. У каждой библиотечной функции есть запись в GOT,
между ними установлено соответствие.

Теперь к деталям.
В основе заполнения таблицу GOT лежит так называемое "ленивое"
связывание. Ленивое оно потому, что мы заполняем записи GOT не для всех
вызываемых функций сразу, а только тогда, когда они будут вызываны.

Например, в нашем коде дважды вызывается ~printf~.
Когда ~printf~ вызывается в первый раз, то plt записывает
смещение (адрес), по которому находится библиотечный код, в GOT, пушит индекс
перемещения - он нужен линкеру для работы (скорее всего связан с записями
перемещений в соответствующей секции rel_dyn или rel_plt, уточнить), а
затем вызывает линкер, чтоб тот усновил связывание - этим занимается
~_dl_runtime_resolve_xsave~ из файла ~dl-trampoline.h~

Когда ~printf~ вызовется второй раз, то мы просто сделаем ~jmp~ на адрес,
находящийся в записи GOT.

Подробно и с картинками этот  механизм описывается здесь:
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html

** Передача управления с жертвы на вирус и с вируса на жертву

Передача с жертвы на вирус простая - в эльф хедере меняем адрес в поле
e_entry с оригинального на точку инфицирования. Так управление попадет на
вирус

Передать управление обратно сложнее.
Есть фукция _exit_victim - она последней исполняется в вирусе. Она
находилась в середине файла, но я переместила ее сразу перед
_fin_infector.
Мы разрешили самомодификацию кода - технически во время исполнения вируса
можно прямо исравить код внутри _exit_victim, чтоб сразу перейти на
жертву. Но в первый раз наш вирус включается не из жертвы, а из
собственного эльф-файла, и ему нужно обеспечить корректный выход.
Поэтому при редактировании жертвы, мы впишем в нее весь код вируса до
метки _exit_victim, затем вручную впишем условный джамп, потом
_fin_infector.
Таким образом вирус корректно заверится и в первый раз своего
исполнения, и в последующие, когда будет работать из жертвы.

Теперь о том, как совершить сам прыжок на оригинальный e_entry жертвы.
jmp занимает 5 байт, код комманды - e9, остальные 4 байта занимает
смещение до адреса, на который следует совершить прыжок. Новый адрес
рассчитывается как
адрес след. инструкции + смещение = адрес для прыжка
Поскольку оригинальный e_entry будет всегда выше точки заражения,
т.е. e_entry вируса, смещение должно быть отрицательным.

Почитать об этом можно здесь. Описывается call, но jmp отличается от него
только опкодом.
https://stackoverflow.com/questions/10376787/need-help-understanding-e8-asm-call-instruction-x86

Чтоб посчитать смещение корректно, берем адрес следующей инструкции и
вычитаем его из оригинального e_entry. Получаем отрицательное смещение.
