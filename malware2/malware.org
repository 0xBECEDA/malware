** Устройство эльфа.
~Заголовок эльфа~ - это структура, которая содержит в себе информацию о
точке входа, количестве заголовков программ, их размере, количестве
загоолвков секций,  их размере, где эти заголовки искать в файле и еще некоторые данные.
Следом идет таблица заголовков программ (сегментов).

~Таблица заголовков программ~ - представляет собой несколько заголовков
программ (сегментов), которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента, его размере,
смещении, виртуальном адресе и т.д. Количество заголовоков сегментов
зависит от количества сегментов в программе. Каждый заголовок занимает 56 байт.

Затем идет весь код программы, а после него - таблица заголовков секций

~Таблица заголовков секций~ - представляет собой несколько заголовков
секций, которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую одну секцию кода. Эта
структура содержит в себе информацию о типе секции, ее размере,
смещении, виртуальном адресе и т.д.

После заголовков секций в файле ничего нет.

Все эти разнообразные виды заголовков нужны, чтоб загрузчик сразу мог
определить, какой код где находится. как должен быть использован и т.д.

Программа поделена на сегменты - это относительно большие блоки кода,
каждый из которых имеет свою функцию: некоторые сегменты содержат в себе
код программы - тип LOAD - и будут загружены в память, некоторые содержат
в себе .data, другие же вообще не будут загружены в память и содержат в
себе информацию для линкера.

Сегменты в свою очередь состоят из более мелких сегментов - их называют
секциями. Каждая секция так же имеет свое назначение и свои заголовки.

** Заражение
Чтоб заразить жертву вирусом, нужно найти подходящий для заражения
сегмент кода и подходящую секцию. Поскольку нам надо, чтоб код вируса был
загружен загрузчиком в память - иначе он не исполнится - нам нужно
разместить код вируса в загружаемом сегменте кода - он имеет тип LOAD. А
затем в нем мы находим последнюю секцию кода и вписываем вирус сразу
после нее.
Самое простое - это найти сегмент кода, который содержит в себе e_entry -
точку входа, с которой начинается программа-жертва - и использовать его для
заражения. Данные о сегментах и секциях можно найти в их заголовках. Для
поиска заражаемого сегмента и секции нам понадобятся виртуальные адреса,
с которых начинается код, который они описывают.

Вписывая вирус сразу после подходящего сегмента, мы как бы расширяем его
и его последнюю секцию. Поэтому нужно отредактировать их заголовки,
увеличив поля, в которых содержится информация о размере описываемого
кода - в заголовке сегмента это поля p_memsz и p_filesz, а в заголовке
секции это поле sh_size. Тогда нам не придется создавать отдельный
заголовок для кода вируса и мучиться, вписывая его в таблицу заголовков.

Теперь мы сталкиваемся с необходимостью сместить весь код, который
находится в жертве после точки заражения - конца заражаемого сегмента,
куда будет записан вирус - иначе код будет затерт, а файл "сломается".

Физически переместить код нетрудно - при пересборке эльфа достаточно
просто его вписать после вируса. Но мы помним, что мало просто вписать
код, надо еще оставить информацию загрузчику, где его искать. А значит,
нужно отредактировать заголовки сегментов и секций, которые описывают
код, находящийся после точки заражения. В этих заголовках нужно
отредватировать поля, содержащие в себе информацию об адресе и смещении
кода.

Как найти сегменты и секции, которые лежат после точки заражения? Можно
было бы искать их только по виртуальным адресам. Идея простая: если
виртуальный адрес в заголовке меньше, чем виртуальный адрес заражаемой
точки, то заголовок редактировать не нужно - код, описываемый им,
находится выше точки заражения.
Выглядит очень логично, но на самом деле этот подход вызывает
труднотлаживаемые ошибки.
Дело в том, что у нас есть сегменты и секции, которые в память процесса
не загружаются, они нужны только линкеру и загрузчику для построение
образа процесса в памяти. Поэтому адрес у них нулевой, а вот смещение
есть. В результате эти заголовки никогда не будут отредактированы, а
загрузчик, проходя по старым смещениям, будет видеть совершенно не тот
код, что должен был бы. Можно провести пару увлекательных вечеров,
пытаясь понять, почему в бинарном файле заголовки есть и находятся там,
где мы ожидаем их увидеть,и данные в них совершенно правильные, а
~readelf~ - утилита для парсинга эльф-файла - будет сообщать что не может
найти то одну секцию, то другую.
Поэтому на этапе мы проверяем и смещение, и виртуальный адрес.

Завершив редактирование заголовков, нужно отредактировать поле ~e_shoff~
в заголовке эльфа и указать ему новое смещение, по которому лежат
заголовки секций. В противном случае загрузчик будет искать их по старому
смещению и никогда не найдет.
** Загрузка эльфа в память
Ошибка "elf_machine_runtime_setup (profile=0, lazy=1, l=0x7ffff7ffe168)
at ../sysdeps/x86_64/dl-machine.h:86
../sysdeps/x86_64/dl-machine.h: Нет такого файла или каталога"

~Загрузка эльфа~
Процесс загрузки эьфа управляется функцией load_elf_binary() ( файл
binfmt_elf.c, сорцы здесь
https://elixir.bootlin.com/linux/latest/source/fs/binfmt_elf.c ). Это и
есть загрузчик, который должен правильно отобразить программу в память.

~load_elf_binary()~
- начинает чтение эльфа с его заголовка
Из него он берет смещение до таблицы заголовков сегментов, смещение до таблицы
заголовков секций и др. данные
- затем читает заголовки сегментов
Ищет среди него заголовок PT_INTERP и заголовок GNU_STACK. GNU_STACK
содержит информацию о стеке, а PT_INTERP - о рантайм-линкере, который должен быть
использован для этого бинаря.

Теперь можно начать подготовку для непосредственной загрузки программы в
память.
Для этого нужно:
- очистить состояние ядра, которое ссылается на предыдущую выполненную
  программу (что бы это ни значило)
- убить потоки, связанные с предыдущей программой. Новая всегда
  начинается в одном потоке.
- указать новое местоположение  - метоположение текущего исполняемого
  файла
- очистить виртуальную память от предыдущей программы
- закрыть файловые дескрипторы, оставшиеся от сратой программы

После этого настраиваем виртуальную память для новой программы.
Устанавливаем новую вершину стека - обычно смещается вниз на случайное
значение, это усложняет атаки на переполнение стека (если не знаешь, где
будет вершина, труднее переполнить).
Затем проходимся по всем сегментам PT_LOAD и отображаем их в память,
составляя макет памяти новой программы. Затем устанавливает страницы BSS,
заполненные нулями (неинициализированные данные).
На финальном этапе загрузки устанавливается база стека.

Теперь про ~линковку~

Большинство файлов слинкованы динамически - т.е. когда компилятор
проходится по файлу и находит вызов библиотечной функции, он оставляет
пометку, что это пространство в будущем должено быть заполнено вызовом
библиотечной функции, а сам код библиотеки в бинаре не присутствует.

Чтоб код корректно исполнялся, нужен рантайм линкер. Он задается в
заголовк PT_INTERP, в моем случае это  ld-linux-x86-64.so.2. После того,
как процесс загрузки программы завершился, вызывается
~load_elf_interp()~, который загрузит код линкера в память. Затем
срабатывает системный вызов ~execve()~ - он разрешает программе
выполняться. Но выполнение начинается не с самого эльфа, а с его
линкера - поэтому он и рантайм, потому что работает во время
исполнения. Рантайм-линкер должен позаботиться о загрузке библиотек,
разрешении неопределенных символов программы до правильных определений в
этих библиотеках и т.д.

Вот на этом этапе происходит сегфолт, который вызывает код из библиотеки
dl_reloc.c (сорцы
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html ), в частности
_dl_relocate_object (сорцы здесь
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html#_dl_relocate_object)


dl_reloc перемещает разделяемый объект и разрешает ссылки -
т.е. заполняет их адресами - на другие разделяемые объекты. Из-за того,
что я переместила часть кода - иначе вирус бы их просто затер -
dl_relocate_object не может найти то, что ему нужно.

Вопрос, где содержится информация, которую ищет dl_reloc.
- не секция .symtab (записи редактировали, без результата)
- не секции .rel_name (записи редактировались, без результата)
- не внутри plt/got - этот механизм включается на стадии исполнения самой
  программы, а не линкера
