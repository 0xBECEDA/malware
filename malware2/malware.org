** Устройство эльфа.
~Заголовок эльфа~ - это структура, которая содержит в себе информацию о
точке входа, количестве заголовков программ, их размере, количестве
загоолвков секций,  их размере, где эти заголовки искать в файле и еще некоторые данные.
Следом идет таблица заголовков программ (сегментов).

~Таблица заголовков программ~ - представляет собой несколько заголовков
программ (сегментов), которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента, его размере,
смещении, виртуальном адресе и т.д. Количество заголовоков сегментов
зависит от количества сегментов в программе. Каждый заголовок занимает 56 байт.

Затем идет весь код программы, а после него - таблица заголовков секций

~Таблица заголовков секций~ - представляет собой несколько заголовков
секций, которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую одну секцию кода. Эта
структура содержит в себе информацию о типе секции, ее размере,
смещении, виртуальном адресе и т.д.

После заголовков секций в файле ничего нет.

Все эти разнообразные виды заголовков нужны, чтоб загрузчик сразу мог
определить, какой код где находится. как должен быть использован и т.д.

Программа поделена на сегменты - это относительно большие блоки кода,
каждый из которых имеет свою функцию: некоторые сегменты содержат в себе
код программы - тип LOAD - и будут загружены в память, некоторые содержат
в себе .data, другие же вообще не будут загружены в память и содержат в
себе информацию для линкера.

Сегменты в свою очередь состоят из более мелких сегментов - их называют
секциями. Каждая секция так же имеет свое назначение и свои заголовки.

** Заражение
Чтоб заразить жертву вирусом, нужно найти подходящий для заражения
сегмент кода и подходящую секцию. Поскольку нам надо, чтоб код вируса был
загружен загрузчиком в память - иначе он не исполнится - нам нужно
разместить код вируса в загружаемом сегменте кода - он имеет тип LOAD. А
затем в нем мы находим последнюю секцию кода и вписываем вирус сразу
после нее.
Самое простое - это найти сегмент кода, который содержит в себе e_entry -
точку входа, с которой начинается программа-жертва - и использовать его для
заражения. Данные о сегментах и секциях можно найти в их заголовках. Для
поиска заражаемого сегмента и секции нам понадобятся виртуальные адреса,
с которых начинается код, который они описывают.

Вписывая вирус сразу после подходящего сегмента, мы как бы расширяем его
и его последнюю секцию. Поэтому нужно отредактировать их заголовки,
увеличив поля, в которых содержится информация о размере описываемого
кода - в заголовке сегмента это поля p_memsz и p_filesz, а в заголовке
секции это поле sh_size. Тогда нам не придется создавать отдельный
заголовок для кода вируса и мучиться, вписывая его в таблицу заголовков.

Теперь мы сталкиваемся с необходимостью сместить весь код, который
находится в жертве после точки заражения - конца заражаемого сегмента,
куда будет записан вирус - иначе код будет затерт, а файл "сломается".

Физически переместить код нетрудно - при пересборке эльфа достаточно
просто его вписать после вируса. Но мы помним, что мало просто вписать
код, надо еще оставить информацию загрузчику, где его искать. А значит,
нужно отредактировать заголовки сегментов и секций, которые описывают
код, находящийся после точки заражения. В этих заголовках нужно
отредватировать поля, содержащие в себе информацию об адресе и смещении
кода.

Как найти сегменты и секции, которые лежат после точки заражения? Можно
было бы искать их только по виртуальным адресам. Идея простая: если
виртуальный адрес в заголовке меньше, чем виртуальный адрес заражаемой
точки, то заголовок редактировать не нужно - код, описываемый им,
находится выше точки заражения.
Выглядит очень логично, но на самом деле этот подход вызывает
труднотлаживаемые ошибки.
Дело в том, что у нас есть сегменты и секции, которые в память процесса
не загружаются, они нужны только линкеру и загрузчику для построение
образа процесса в памяти. Поэтому адрес у них нулевой, а вот смещение
есть. В результате эти заголовки никогда не будут отредактированы, а
загрузчик, проходя по старым смещениям, будет видеть совершенно не тот
код, что должен был бы. Можно провести пару увлекательных вечеров,
пытаясь понять, почему в бинарном файле заголовки есть и находятся там,
где мы ожидаем их увидеть,и данные в них совершенно правильные, а
~readelf~ - утилита для парсинга эльф-файла - будет сообщать что не может
найти то одну секцию, то другую.
Поэтому на этапе мы проверяем и смещение, и виртуальный адрес.

Завершив редактирование заголовков, нужно отредактировать поле ~e_shoff~
в заголовке эльфа и указать ему новое смещение, по которому лежат
заголовки секций. В противном случае загрузчик будет искать их по старому
смещению и никогда не найдет.
