#+STARTUP: showall indent hidestars

** Устройство эльфа.
~Заголовок эльфа~ - это структура, которая содержит в себе информацию о
точке входа, количестве заголовков программ, их размере, количестве
загоолвков секций,  их размере, где эти заголовки искать в файле и еще некоторые данные.
Следом идет таблица заголовков программ (сегментов).

~Таблица заголовков программ~ - представляет собой несколько заголовков
программ (сегментов), которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента, его размере,
смещении, виртуальном адресе и т.д. Количество заголовоков сегментов
зависит от количества сегментов в программе. Каждый заголовок занимает 56 байт.

Затем идет весь код программы, а после него - таблица заголовков секций

~Таблица заголовков секций~ - представляет собой несколько заголовков
секций, которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую одну секцию кода. Эта
структура содержит в себе информацию о типе секции, ее размере,
смещении, виртуальном адресе и т.д.

После заголовков секций в файле ничего нет.

Все эти разнообразные виды заголовков нужны, чтоб загрузчик сразу мог
определить, какой код где находится. как должен быть использован и т.д.

Программа поделена на сегменты - это относительно большие блоки кода,
каждый из которых имеет свою функцию: некоторые сегменты содержат в себе
код программы - тип LOAD - и будут загружены в память, некоторые содержат
в себе .data, другие же вообще не будут загружены в память и содержат в
себе информацию для линкера.

Сегменты в свою очередь состоят из секций. Каждая секция так же имеет
свое назначение и свои заголовки (TODO: где?).

** Заражение

~Сжатый алгоритм заражения~

- загрузить жертву в память
- выяснить, где начинаются заголовки сегментов, заголовки секций, какое
  их количество
- найти первый сегмент загружаемого кода - он содержит в себе ~e_entry~
- найти последнюю секцию в этом сегменте кода - сразу после нее будет
  вписан вирус
- сохранить виртуальный адрес точки инфицирования
- увеличить размер заражемой секции и заражаемого сегмента на размер
  вируса
- изменить поля ~vaddr~ и ~size~ у заголовков сегментов и секций, которые
  описывают код, находящийся ниже точки инфицирования
- исправить vaddr по тому же принципу в записях symtab - таблицы, которая
  содержит в себе инфу о всех символах программы
- исправить vaddr по тому же принципу в записях секций rela - они
  содержат в себе информацию о перемещениях (TODO: раскрыть формат)
- исправить vaddr по тому же принципу в записях секции dynamic - на нее
  ориентируется рантайм линкер, который связывает библиотечные функции с
  конкретными адресами (TODO: раскрыть как)
-  заменить оригинальный e_entry на точку инфицирования, чтоб при запуске
  жертвы управление было сразу передано на мылварь
- посчитать смещение от конца вируса до оригинального e_entry - оно
  понадобится для джампа, который вернет управление жертве обратно
- создать код, который переведет управление на жертву - в буфер длиной 6
  байт вписывается e9 - опкод jmp - затем смещение до оригинального
  e_entry, и 90 - опкод nop. Этот код будет вписан вместо exit_victim -
  последняя функция, исполняющаяся в вирусе, которая обеспечивает ему
  корректный выход
- записать в зараженный файл  код жертвы от начала до точки инфицрования
- записать в зараженный файл код вируса до exit_victim (если что,
  exit_victim я переместила в конец файла вируса, так его удобнее
  редактировать. теперь он стоит перед fin_infector, который содержит в
  себе nop)
- записать код для передачи управления на жертву
- записать код жертвы от точки инфицирования до конца

~Развернутый алгоритм заражения~
Чтоб заразить жертву вирусом, нужно найти подходящий для заражения
сегмент кода и подходящую секцию. Поскольку нам надо, чтоб код вируса был
загружен загрузчиком в память - иначе он не исполнится - нам нужно
разместить код вируса в загружаемом сегменте кода - он имеет тип LOAD. А
затем в нем мы находим последнюю секцию кода и вписываем вирус сразу
после нее.
Самое простое - это найти сегмент кода, который содержит в себе e_entry -
точку входа, с которой начинается программа-жертва - и использовать его для
заражения. Данные о сегментах и секциях можно найти в их заголовках. Для
поиска заражаемого сегмента и секции нам понадобятся виртуальные адреса,
с которых начинается код, который они описывают.

Вписывая вирус сразу после подходящего сегмента, мы как бы расширяем его
и его последнюю (NB: почему последнюю?) секцию. Поэтому нужно отредактировать их заголовки,
увеличив поля, в которых содержится информация о размере описываемого
кода - в заголовке сегмента это поля p_memsz и p_filesz, а в заголовке
секции это поле sh_size. Тогда нам не придется создавать отдельный
заголовок для кода вируса и мучиться, вписывая его в таблицу заголовков.

Теперь мы сталкиваемся с необходимостью сместить весь код, который
находится в жертве после точки заражения - конца заражаемого сегмента,
куда будет записан вирус - иначе код будет затерт, а файл "сломается".

Физически переместить код нетрудно - при пересборке эльфа достаточно
просто его вписать после вируса. Но мы помним, что мало просто вписать
код, надо еще оставить информацию загрузчику, где его искать. А значит,
нужно отредактировать заголовки сегментов и секций, которые описывают
код, находящийся после точки заражения. В этих заголовках нужно
отредватировать поля, содержащие в себе информацию об адресе и смещении
кода.

Как найти сегменты и секции, которые лежат после точки заражения? Можно
было бы искать их только по виртуальным адресам. Идея простая: если
виртуальный адрес в заголовке меньше, чем виртуальный адрес заражаемой
точки, то заголовок редактировать не нужно - код, описываемый им,
находится выше точки заражения.
Выглядит очень логично, но на самом деле этот подход вызывает
труднотлаживаемые ошибки.
Дело в том, что у нас есть сегменты и секции, которые в память процесса
не загружаются, они нужны только линкеру и загрузчику для построение
образа процесса в памяти. Поэтому адрес у них нулевой, а вот смещение
есть. В результате эти заголовки никогда не будут отредактированы, а
загрузчик, проходя по старым смещениям, будет видеть совершенно не тот
код, что должен был бы. Можно провести пару увлекательных вечеров,
пытаясь понять, почему в бинарном файле заголовки есть и находятся там,
где мы ожидаем их увидеть,и данные в них совершенно правильные, а
~readelf~ - утилита для парсинга эльф-файла - будет сообщать что не может
найти то одну секцию, то другую.
Поэтому на этапе мы проверяем и смещение, и виртуальный адрес.

Завершив редактирование заголовков, нужно отредактировать поле ~e_shoff~
в заголовке эльфа и указать ему новое смещение, по которому лежат
заголовки секций. В противном случае загрузчик будет искать их по старому
смещению и никогда не найдет.

~Алгоритм зараджения2~

Отличие от первого алгоритма состоит в том, что вирус пишется не в первый
сегмент кода жертвы, а конец, сразу перед заголовками секций.
Тогда понадобистя оформлять вирус как отдельный сегмент кода, для
которого нужно создать и вставить свой собственный заголовок сегмента и
заголвок секции.

Что этот способ заражения?
Понадобится вставить заголсоов сегмента - поэтому все части кода жертвы
съедут равномерно. Это значит, что секция got будет находиться от секции
plt на том же удалении, что и до заражения, и не придется редактировать
скомпилированный код plt - внутри него мы совершаем прыжки на записи
внутри got. Если вирус вставить в первую секцию кода, то расстояние между
plt и got становятся больше и смещения для относительных джампов внутри
plt перестают работать корректно.

~Сжатый алгоритм заражения2~

- загрузить жертву в память
- выяснить, где начинаются заголовки сегментов, заголовки секций, какое
  их количество, где начинается код жертвы и сколько места занимает
- найти первый сегмент кода (у него будет нулевое смещение в файле),
  выяснить его виртуальный адрес - так можно понять, с какого
  виртуального адреса начинается эльф
- посчитать и сохранить виртуальный адрес точки инфицирования -
  виртуальный адрес сегмента кода с нулевым смещением + смещение таблицы
  заголвоков секций. Этот адрес понадобится как новый e_entry, а так же
  как виртуальный адрес новой секции кода, который будет вписан в новые
  заголовки.
- содать новый заголовок сегмента (возможно вставить его последним в
  таблицу заголовков сегментов ?)
- создать новый заголовок секции  (аналогичный вопрос)
- отредактировать смещения и адреса во всех остальных заголоков секций и
  сегментов - увеличить их vaddr и смещения на размер вставляемого
  заголовка для вируса (56 байт)
- по этому же принципу исправить все зависи в symtab, rela и dynamic.
- заменить оригинальный e_entry на точку инфицирования, чтоб при запуске
  жертвы управление было сразу передано на мылварь
- посчитать смещение от конца вируса до оригинального e_entry - оно
  понадобится для джампа, который вернет управление жертве обратно
- создать код, который переведет управление на жертву - в буфер длиной 6
  байт вписывается e9 - опкод jmp - затем смещение до оригинального
  e_entry, и 90 - опкод nop. Этот код будет вписан вместо exit_victim -
  последняя функция, исполняющаяся в вирусе, которая обеспечивает ему
  корректный выход
- изменить поле e_shoff в заголове эльфа жертвы - указать новое смещение
  до таблицы секций (старое смещение + размер вируса)
- записать в зараженный файл код жертвы от начала до конца таблицы
  заголовков сегментов
- записать новый заголовок сегмента для вируса
- вписать код жертвы
- вписать код вируса о метки _exit_victim
- вписать код для передачи управления на жертву
- вписать заголовки секций жертвы
- вписать заголовок секции вируса


БОльшая часть функционала для этого заражения есть и нужно только ее
немного доработать.
Кардинальное изменение касается только генерации заголвоков для вируса.
Вирус будет состоять из одного сегмента, внутри которого будет только
одна секция, поскольку мы вписываем только код вируса, не используя
больше ничего.

~Заголовок сегмента вируса~
- 56 байт
- p_type - 4 байт, value 1 - PL_LOAD
- p_flags - 4 байта, value 1 - разрешение на исполнение
- p_offset - 8 байт, оригинальный offset до начала таблицы заголовков секций
  жертвы (можно посмотреть в заголовке хедера жертвы) + 56 байт
  (доп. заголовок сегмента)
- p_vaddr - 8 байт, виртуальный адрес располодения вируса в файле -
  оригинальный виртуальный адрес таблицы секций жертвы
- p_paddr - аналогично p_vaddr
- p_filesz - 8 байт, размер вируса в файле (_start_infector - _exit_victim)
- p_memsz - 8 байт, размер вируса в памяти
- p_allign - 8 байт, - значение 0, выравнивание не требуется

~Заголовок секции вируса~
- 64 байтa
- sh_name - 4 байта, значение - индекс в таблице строк, где строка - это
  имя секции. Поэтому мы воспользуемся тем же индексом, что и у секции
  text жертвы.
- sh_type - 4 байта, тип секции 1 (PROGBITS) - значение секции определяется
  и используется программой единолично
- sh_flags - 8 байт, value 4 - разрешение на исполнение
- sh_addr - 8 байт, виртуальный адрес располодения вируса в файле -
  оригинальный виртуальный адрес таблицы секций жертвы (такой же как p_vaddr)
- sh_offset - 8 байт, оригинальный offset до начала таблицы заголовков секций
  жертвы (можно посмотреть в заголовке хедера жертвы) + 56 байт (такой же
  как p_offset)
  (доп. заголовок сегмента)
- sh_size - 8 байт, размер вируса в файле (_start_infector -
  _exit_victim), такой же как p_filesz
- sh_link - 8 байт, значение - 0 (подсмотрено в выводе ридэльфа вируса)
- sh_info - 8 байт, значение 0
- sh_addralign - 8 байт, - значение 0, выравнивание не требуется
- sh_entsize - 8 байт, - значение 0, код не содержит никаких записей
  фиксированного размера

~Редактирование записей GOT~
Зачем?
Дело в том, что хотя весь код жертвы, включаяя секции PLT и GOT сместятся
на одно и то же расстоние - 56 байт (размер вставляемого заголовка
сегмента вируса) - механизм работы PLT/GOT будет нарушен.
Внутри секции PLT находится позиционно независимый код, который при
первом вызове функции из библиотеки сначала отправится в соответствующую
запись таблицы GOT - косвенный джамп - и поскольку внутри этой записи
находится адрес следующей инструкции за джампом в секции PLT, нас выкинет
обратно в PLT, который затем запустит линкер, который впишет в запись GOT
адрес, по которому лежит искомый библиотечный код.
Так происходит в норме. Но из-за того, что весь код сместился, а внутри
GOT прописаны абсолютные адреса, то при первом вызове библиотечной
функции GOT перенаправляет джамп не обратно в PLT, а туда, где PLT был до
заражения, что, естетсвенно, вызывает сегфолт.
Поэтому все записи внутри GOT, которые представляют собой просто адреса,
идущие друг за другом, нужно отредактировать, увеличив на 56 байт.

Самое трудное - это найти таблицу GOT. Хотя в спецификации написано, что
GOT, как не странно, должна быть в секции .got, на моей машине это не
так, например. У меня GOT  находится в секции got.plt, а секция .got
занимает всего 8 байт и заполнена нулями. Это затрудняет поиск GOT, но
не делает его невозможным. Дело в том, что где бы не лежал GOT, как бы не
называлась его секция, информация о местоположении GOT обязательно будет
прописана в одной из записей секции .dynamic - и этой информации можно
верить на 100%, поскольку рантайм-линкер ищет GOT используя именно
.dynamic. Найти запись dynamic, которая содержит информацию о GOT, можно
по типу этой записи - это тип 3.

Проблема заключается в том, что в секции .dynamic указан виртуальный
адрес GOT, а нам нужно узнать, где GOT находится в файле физически.

Для этого мы берем виртуальный адрес GOT, ищем заголовок секции, который будет
описывать код с таким же виртуальным адресом, и берем смещение оттуда

Еще нам надо еще узнать размер GOT - так мы сможем вычислить
количество записей в ней.

После того, как GOT найден, редактируем все его записи.

~Проблема с инициализацией стека для жертвы~

После того, как вирус отработал, он возвращает управление жертве, в ее
оригинальный _start. Поскольку мы выполняем косвенный джамп, то неважно,
что метка _start сместилась на 56 байт - соотношение между ней и точкой
инфицирования не изменилось.

Внутри _start жертва вызывает __libc_start_main@plt. Эта функция должна
настроить стек для программы (и не только).Почитать о ней (в 32 разрядной
системе) можно здесь:
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

А сорцы вот здесь
https://code.woboq.org/userspace/glibc/csu/libc-start.c.html

Проблема в том, что у меня стек недонастраивается, где-то на полпути libc
переходит по не тому адресу, которому нужно, и я оказываюсь где-то в
функции main. При попытке корректно ее покинуть  - через ret - я
сталкиваюсь с сегфолтом, потому что никакого адреса возврата просто нет
(либо он некорректен).

__libc_start_main@plt принимает параметры:
- RDI - виртуальный адрес main
- RSI - кол-во аргументов main (?)
- RDX - указатель на аргументы (?)
- RCX - виртуальный адрес __libc_csu_init (выяснить, что оно делает)
- R8 - виртуальный адрес __libc_csu_fini (выяснить, зачем оно)

# set $rax = 0x1c
# set $rbx = 0x0
# set $rcx += 0x38
# set $rdx = 0x7fffffffe428
# set $rsi = 0x1
# set $rdi += 0x38
# set $rbp = 0x0

# set $rsp =  0x7fffffffe410
# set $r8  += 0x38
# set $r9  =  0x7ffff7de7af0
# set $r10 =  0x3a
# set $r11 =  0xb
# set $r12 += 0x38
# set $r13 =  0x7fffffffe420
# set $r14 =  0x0
# set $r15 =  0x0

Проблема #1:
Виртуальные адреса названных разделов программы берутся не из заголовков
или из каки-то секций. Внутри _start выполняются инструкции вида
~mov $адрес регистр~, а поскольку все сместилось, то адреса уже
неактуальны. Следовательно, надо редактировать скомпилированный код
жертвы, чтоб адрес стали корректными. С учетом того, что жертва может
вообще не использовать никакие библиотеки (как наш вирус), то придется
сначала проверять, использует ли жертва динамическую линковку - если нет,
то у нее не будет раздела .dynamic, - затем искать в ней по сигнатуре или
иным способом нужные нам команды и редактировать их.

При этом, отладка под гдб, во время которой адреса были вручную заменены
на актуальные, показала, что отредактировать адреса - это еще полбеды,
настройка стека все еще не работает. Теоритически, можно детально
разобраться, как работает все внутри, но нет гарантии, что не
используется еще какой-то вкомпилированный код, который тоже придется
редактировать.

~Возможное решение~
Поэтому есть идея вообще не настраивать стек для жертвы, а предоставить
ей стек вируса, который уже настроен. Стек вируса на данный момент
занимает 6 тыс байт, технически, мы можем увеличить его до 10 тыс и
надеяться, что этого жертве хватит.

Для этого надо решить несколько проблем.

~Если жертва использует линамическую линковку~
В этом случае нам нужно:
- найти main (интересно, как, на него не указывает просто ничего в заголовках)
- передать управление ему, после того, как вирус отработает
- затем после того, как жертва отработает, заставить ее корректно выйти

При динамической линковке выход обеспечивается инструкцией ret, но при
ненастроенном стеке это вызовет сегфолт, поэтому нужно вызвать прерывание
и таким образом выйти.

Вместо того, чтоб искать конец кода жертвы и редактировать его вручную,
мы вызовем main инструкцией call, которая положит адрес возврата на
стек. А сразу за ~call main~ последует код, который обеспечит вызов
соответствующего syscall. Поэтому кода main выполнит последний ~ret~, она
возьмет адрес возврата со стека и перейдет на код, который обеспечит ей
корректный выход.

~Если жертва не использует никакие библиотеки~
В этом случае делаем почти то же, но только main не ищем, а передаем
управление на _start. И делаем это не с помощью call, а с помощью jmp.

Почему заменяется call на jmp?
Потому что если жертва скомпилирована без либ, то она настраивает себе
стек сама (либо он ей вообщей не нужен) и обеспечивает корректный выход
сама. А следовательно, если мы вызовем ее через call, то на стеке
останется адрес возврата, который никогда не будет взят, и следовательно
по выходу из программы стек останется несбалансированным.

Понять, использует жертва динамичекую линковку или нет, может понять по
наличию секции dynamic, которая необходима линкеру.
Если ее нет, то линкер не вызывает, следовательно, динамическая линковка
не используется.

~Возможное решение 2~

К сожалению, мой компилятор генерирует позиционно-зависимый код. Пока что
это оказало влияние только на _start и настройку стека, но неизвестно,
где может выявиться еще. Тем более, что заражать мы планируем любые
файлы, а не только текущий. А урегулирование всех ссылок - это слишком
трудоемкий процесс, чтоб в него ввязываться. Поэтому нам нужно сделать
так, как будто заражения не было вообще и код жертвы никуда не
сдвигался.


** Загрузка эльфа в память

Ошибка "elf_machine_runtime_setup (profile=0, lazy=1, l=0x7ffff7ffe168)
at ../sysdeps/x86_64/dl-machine.h:86
../sysdeps/x86_64/dl-machine.h: Нет такого файла или каталога"

Из-за записи вируса в файл, я вынуждена сместить остальной код жертвы на
размер вируса, в противном случае он будет затерт. Из-за этого смещения
возникает данная ошибка.

Если заражать жертву, которая не использует динамическую линковку, то
жертва исполняется после заражения без проблем. Так же если просто
скопировать код жертвы в другой файл - так же переписывая его по кускам,
как при заражении - данная ошибка не возникает. Следовательно, проблема
именно в смещении кода, начинающегося с точки заражения.

~Решение ошибки~
Развернутое объяснение см. ниже.
Сжатое объяснение:

Сегфолт происходит на этапе рантайм-линковки. Это видно по выводу gdb  -
~dl_relocate_object~, внутри которого происходит сегфолт, является частью
либы dl_reloc.c (сорцы
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html ), в частности
_dl_relocate_object (сорцы здесь
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html#_dl_relocate_object)

dl_reloc перемещает разделяемый объект и разрешает ссылки -
т.е. заполняет их адресами - на другие разделяемые объекты.

Сегфолт происходит потому, что линкеру необходима информация о
расположении GOT и некоторые другие данные. Проблема в том, что сведения
о расположении эьих данных линкер берет не из заголовков секций, из
секции .dynamic, ведь заголовки  Если не отредактировать данные в ней, то линковщик будет
искать GOT по старому адресу, что вызывает сегфолт.

Следовательно, надо отредактировать записи в секции .dynamic - если
виртуальный адрес кода, описываемый записью, больше виртуального адреса
точки заражения, значит данный код находится ниже точки заражения и
следовательно виртуальный адрес должен быть увеличен на размер вируса.

Полагаю, что так же надо отредактировать записи в rel_name и symtab. В
symtab хранится информация о символах - функциях и переменных - в
частности, виртуальные адреса, по которым они расположены, а в rel_name
хранится информация о перемещениях - думаю, это связано с работой
линковщика - следовательно, виртуальные адреса в этих записяз надо
исправить тоже.

~Загрузка эльфа~
Процесс загрузки эьфа управляется функцией load_elf_binary() ( файл
binfmt_elf.c, сорцы здесь
https://elixir.bootlin.com/linux/latest/source/fs/binfmt_elf.c ). Это и
есть загрузчик, который должен правильно отобразить программу в память.

~load_elf_binary()~
- начинает чтение эльфа с его заголовка
Из него он берет смещение до таблицы заголовков сегментов, смещение до таблицы
заголовков секций и др. данные
- затем читает заголовки сегментов
Ищет среди него заголовок PT_INTERP и заголовок GNU_STACK. GNU_STACK
содержит информацию о стеке, а PT_INTERP - о рантайм-линкере, который должен быть
использован для этого бинаря.

Теперь можно начать подготовку для непосредственной загрузки программы в
память.
Для этого нужно:
- очистить состояние ядра, которое ссылается на предыдущую выполненную
  программу (что бы это ни значило) (NB: может это программа после форка?)
- убить потоки, связанные с предыдущей программой. Новая всегда
  начинается в одном потоке.
- указать новое местоположение  - метоположение текущего исполняемого
  файла
- очистить виртуальную память от предыдущей программы
- закрыть файловые дескрипторы, оставшиеся от сратой программы

После этого настраиваем виртуальную память для новой программы.
Устанавливаем новую вершину стека - обычно смещается вниз на случайное
значение, это усложняет атаки на переполнение стека (если не знаешь, где
будет вершина, труднее переполнить).
Затем проходимся по всем сегментам PT_LOAD и отображаем их в память,
составляя макет памяти новой программы. Затем устанавливает страницы BSS,
заполненные нулями (неинициализированные данные).
На финальном этапе загрузки устанавливается база стека.

Теперь про ~линковку~

Большинство файлов слинкованы динамически - т.е. когда компилятор
проходится по файлу и находит вызов библиотечной функции, он оставляет
пометку, что это пространство в будущем должено быть заполнено вызовом
библиотечной функции, а сам код библиотеки в бинаре не присутствует.

Чтоб код корректно исполнялся, нужен рантайм линкер. Он задается в
заголовк PT_INTERP, в моем случае это  ld-linux-x86-64.so.2. После того,
как процесс загрузки программы завершился, вызывается
~load_elf_interp()~, который загрузит код линкера в память. Затем
срабатывает системный вызов ~execve()~ - он разрешает программе
выполняться. Но выполнение начинается не с самого эльфа, а с его
линкера - поэтому он и рантайм, потому что работает во время
исполнения. Рантайм-линкер должен позаботиться о загрузке библиотек,
разрешении неопределенных символов программы до правильных определений в
этих библиотеках и т.д.

Конечная цель линкера - это заполнение GOT смещениеями до библиотечных
функции. Но фишка в том, что он берет информацию о том, где находится GOT
не из заголовков секций, а из секции .dynamic, которая находится в
разделе DYNAMIC. . Соответственно, если не
отредактировать записи в ней, то линкер будет искать GOT и другие данные
по старым адресам, где на самом деле ничего нет. Что и приводет к
сегфолту скорее всего.

Теперь о том, самом механизме ~PLT/GOT~.
Неизвестно, по какому адресу будет загружена динамиеская
библиотека. Соответственно, нельзя предугадать, где какая функция будет
лежать.
Поэтому и нужен механизм PLT/GOT, цель которого - это перенаправить
вызов библиотечной функции так, чтоб вызвался библиотечный код, а не
какая-то чушь.

Если описать механизм совсем грубо, то получится следующее:
GOT представляет собой таблицу смещений, которая должна быть заполнена
смещениями до кода вызываемой функции. А PLT представляет собой таблицу,
которая содержит в себе код, который и вызовет библиотечную функцию, используя
смещение из таблицы GOT. У каждой библиотечной функции есть запись в GOT,
между ними установлено соответствие.

Теперь к деталям.
В основе заполнения таблицу GOT лежит так называемое "ленивое"
связывание. Ленивое оно потому, что мы заполняем записи GOT не для всех
вызываемых функций сразу, а только тогда, когда они будут вызываны.

Например, в нашем коде дважды вызывается ~printf~.
Когда ~printf~ вызывается в первый раз, то plt записывает
смещение (адрес), по которому находится библиотечный код, в GOT, пушит индекс
перемещения - он нужен линкеру для работы (TODO: скорее всего связан с записями
перемещений в соответствующей секции rel_dyn или rel_plt, уточнить), а
затем вызывает линкер, чтоб тот установил связывание - этим занимается
~_dl_runtime_resolve_xsave~ из файла ~dl-trampoline.h~

Когда ~printf~ вызовется второй раз, то мы просто сделаем ~jmp~ на адрес,
находящийся в записи GOT.

Подробно и с картинками этот  механизм описывается здесь:
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html


Опытным путем выяснилось, что мало поправить заголовки, данные внутри
rela, dynamic и symtab.
Скорее всего придется исправлять смещения для команд jmp внутри секции
plt. Внутри каждого из фрагментов кода plt, которые отвечают за
связывание библиотечной функции и GOT, есть относительный jmp на
соответствующую запись в GOT.
Проблема в том, если код смещается - а у нас он смещается - то старые
смещение перестают работать и попытка прыгнуть на адрес по старому
смещению оборачивается сегфолтом.

Поэтому надо либо отредактировать смещения "вручную", увеличив каждое из
них на размер вируса (NB: выглядит просто?), либо найти, какие секции отвечают за эти
смещения. Но скорее всего никакие, потому что это уже скомпилированный
код, ничто его во время линковки или загрузки не модифицирует,
следовательно, никакие секции или заголовки не должны быть связаны с
этими смещениями.

~Символы и релокейты~
Почитать о символах можно здесь
https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/

А о релокейтах - здесь
https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/

В процессе разработки программы мы используем имена для функций и
переменных - т.е. символы. А компилятор должен сгенерировать код, который
превратит символьную ссылку в смещение или адрес, где можно найти
значения для этого символа. Все символы вместе называются символической
информацией.

Символы нужны для:
- удобства разработки (очевидно)
- отладки (у компилятора есть возможность экспортировать символы в ELF
  файл, а у эльфа есть таблицы символов, позволяющая эти символы хранить)
- для линковки (чтоб связать символ с новым значением, надо знать, где
  этот символ находится)

Символы хранятся в таблице символов.
Таблиц символов в эльфе может быть максимум две - это symtab и dynsym.
Dynsym содержит в себе символы, которые ссылаются на объекты, необходимые
для линковки. А symtab содержит в себе вообще все символы, которые
используются в текущем файле.

Каждая запись в таблице символов представлена в виде структуры,
которая описывает 1 символ.
Структура содержит в себе информацию о имени символа, его значении,
размере, типе, типе связывания (аттрибуте), видимости символа и индек
заголовка секций в таблице секций, поскольку каждый символ ассоциирован с
секцией, где он определен.

- Имя - здесь все понятно.
- Тип символа - это то, какого рода код этот символ обозначает: секцию,
переменную, функцию и т.д.
- Размер - сколько места занимает сам символ
- Тип связывания (в англоязычных источниках это называется атрибут,
можно долго ломать голову, что имеется ввиду)
Эта информация очень нужна при линковке. По ней будет определяться
поведение, если ссылка на этот символ обнаружится в другом объекте
(сегменте программы?).
Есть несколько типов связывания, но самые основные - это LOCAL и GLOBAL
Если атрибут LOCAL, то символ не будет видел за пределами эльфа, внтури
которого он определяется. Если GLOBAL, то символ будет виден всем.
- Видимость символа - определяет доступ к символу после того, как он
  был определен. Можно ли его перезаписывать, видим ли он вообще за
  пределами своего файла и т.д.
В чем тогда разница между типом связывания и видимостью?
Видимость символа зависит от того, как объект, на который ссылается
символ был скомпилирован. В то время как тип связывания используется при
линковке и зависит от самого объекта, на который ссылается символ.
- Индекс заголовка секции - здесь все понятно.

Теперь про релокейты и их связь с символами.
Собственно, релокейты - это связь символа с его объектом, на который он должен
ссылаеться.
Компиляция файла происходит в несколько этапов в результате чего мы
получаем исполняемый файл. Но до этого мы получаем промежуточное
представление - объектный файл, он же object file или elocatable object
file  в англоязычных источниках. Фалй такого типа содержит в себе всю
необходимую информацию - машинный код и т.д., но ссылки и адреса в нем
еще не заполнены. Тогда на хаключительном этапе компиляции - линковке -
линкер соединяет ссылками символы и объекты.

Некоторые объекты немозможно соединить ссылками сразу на этапе
компиляции - это касается использования динамических библиотек, поскольку
мы не знаем, по какому адресу они будут загружены в момент исполнения
программы. Эти ссылки остаются незаполненными и тогда на этапе исполнения
включается рантайм-линкер и дозаполняет их (см. PLT/GOT).

Если открыть symtab (readelf -s elf_file_name), то мы увидим, что адреса
у некоторых символов отсутствуют - это и будут символы, чей код определен
в библиотеке, которая еще не загружена, а потому символы с объектами не
связаны.

А если открыть содержимое секций rela (readelf -r elf_file_name), то мы
увидим в каждой записи следующую информацию:
- смещение - адрес (в моем случае), по которому дожно быть записано
  значение символа, т.е. адрес объекта, на который он должен ссылаться
- инфо - см. спецификацию
- тип - см. спецификацию
- значение символа - адрес, по которому должен находиться объект,
  т.е. сама ссылка на этот объект. Заполняется на этапе рантайм линковки
- имя символа - здесь итак понятно.

Таким образом, по записям в rela линковщик узнает, каких ссылок не
хватает, и куда мы будем из писать.

Откуда линковщик узнает, где искать rela? Эта информация прописана в
секции dynamic.

** Передача управления с жертвы на вирус и с вируса на жертву

Передача с жертвы на вирус простая - в эльф хедере меняем адрес в поле
e_entry с оригинального на точку инфицирования. Так управление попадет на
вирус

Передать управление обратно сложнее.
Есть фукция _exit_victim - она последней исполняется в вирусе. Она
находилась в середине файла, но я переместила ее сразу перед
_fin_infector.
Мы разрешили самомодификацию кода - технически во время исполнения вируса
можно прямо исравить код внутри _exit_victim, чтоб сразу перейти на
жертву. Но в первый раз наш вирус включается не из жертвы, а из
собственного эльф-файла, и ему нужно обеспечить корректный выход.
Поэтому при редактировании жертвы, мы впишем в нее весь код вируса до
метки _exit_victim, затем вручную впишем условный джамп, потом
_fin_infector.
Таким образом вирус корректно заверится и в первый раз своего
исполнения, и в последующие, когда будет работать из жертвы.

Теперь о том, как совершить сам прыжок на оригинальный e_entry жертвы.
jmp занимает 5 байт, код комманды - e9, остальные 4 байта занимает
смещение до адреса, на который следует совершить прыжок. Новый адрес
рассчитывается как
адрес след. инструкции + смещение = адрес для прыжка
Поскольку оригинальный e_entry будет всегда выше точки заражения,
т.е. e_entry вируса, смещение должно быть отрицательным.

Почитать об этом можно здесь. Описывается call, но jmp отличается от него
только опкодом.
https://stackoverflow.com/questions/10376787/need-help-understanding-e8-asm-call-instruction-x86

Чтоб посчитать смещение корректно, берем адрес следующей инструкции и
вычитаем его из оригинального e_entry. Получаем отрицательное смещение.

Есть одна сложность: нам надо посчитать адрес следующей инструкции так,
как будто уже находимся в зараженном файле, а не смотрим из
своего. Поэтому считаем мы смещение не от следующей инструкции в самом
вирусе, а так:
- берем точку инфицирования файла - это виртуальный адрес из файла жертвы
- мы знаем, что передача управления на жертву будет происходить в самом
  конце вируса
- поэтому vaddr точки инфицирования + размер вируса + 5 байт (столько
  заимает сам jmp )= виртуальный адрес передачи управления на жертву
  внутри самой жертвы послее еe инфицирования вирусом

NB: а еще можно вычислить нужный адрес и сделать jmp %REG

** Найти исполняемые файлы в текущей папке

Чтоб заразить какой-то файл, его надо сначала найти. Чтоб случайно не
заразить всю систему, искать будет только в текущей папке.

https://www.sanfoundry.com/c-program-list-files-directory/
