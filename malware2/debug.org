** Исследование работы __libc_start_main@plt и работы линкера
   Исследование проводится на незараженном файле жертвы. Цель - понять и
   зафиксировать штатное поведение библиотеки, чтоб затем сравнить с тем,
   как эта же библотека ведет себя внутри зараженной жертвы, когда поведение
   начинает отличаться и почему.

   Принцип простой - пройти под gdb инструкцию за инструкцией. Я специально
   скопировала вывод gdb, чтоб при повторном проходе было проще
   ориентироваться.

   Сначала следуют инструкции, затем описывается результат их работы.

   Например:

   => 0x400000:	mov $0x10, %rax

   Теперь в RAX лежит число 0x10.


   ~Запуск~
   Пропустили start, сразу дошли до инструкции call, которая вызывает либу.

   Вызывается plt, plt переходит в got, got вышвыривает обратно в plt.
   Вызываем линкер.

   0x400428:	pushq  0x200c12(%rip)        # 0x601008
   0x40042e:	jmpq   *0x200c14(%rip)        # 0x601010

   В 0x601008 - запись в got - лежит адрес 0xf7ffe168. На этот адрес мы
   вернемся после того, как отработает линкер
   В 0x601010 - запись в got - адрес линкера 0xf7deee40

   Джамп совершен. Мы внутри ~_dl_runtime_resolve_xsave~ (часть библиотеки dl-trampoline)
   RDI - виртуальный адрес main
   RCX - виртуальный адрес __libc_csu_init
   R8 -  виртуальный адрес  __libc_csu_fini
   R12 - виртуальный адрес _start

   0x7ffff7deee41 <_dl_runtime_resolve_xsave+1>:	mov    %rsp,%rbx
   0x7ffff7deee44 <_dl_runtime_resolve_xsave+4>:	and    $0xffffffffffffffc0,%rsp

   RBX - хранит адрес бывшей вершины стека 0x7fffffffe3f0
   RSP - выровнен, стал 0x7fffffffe3c0

   Далее идет сохранение всех регистров в стек и заполнение некоторых
   адресов на стеке нулями. Подготовка параметров для вызова ~_dl_fixup~

   Мы внутри ~_dl_fixup~. Здесь новый адрес должен быть вписан в
   соответствующую запись GOT.

   RDI - 0x7ffff7ffe168 (адрес, куда надо вернуться после того, как линкер отработает)
   RSI - 0x1 (кол-во аргументов запущенного эльфа. У меня один, потому что
   единственный аргумент - это само имя эльфа)

   0x7ffff7de6a30 <_dl_fixup>:	push   %rbx
   0x7ffff7de6a31 <_dl_fixup+1>:	mov    %rdi,%r10
   0x7ffff7de6a34 <_dl_fixup+4>:	mov    %esi,%esi
   0x7ffff7de6a36 <_dl_fixup+6>:	lea    (%rsi,%rsi,2),%rdx
   0x7ffff7de6a3a <_dl_fixup+10>:	sub    $0x10,%rsp
   0x7ffff7de6a3e <_dl_fixup+14>:	mov    0x68(%rdi),%rax
   0x7ffff7de6a42 <_dl_fixup+18>:	mov    0x8(%rax),%rdi

   После этих команд в RDI оказывается адрес 0x400318. Это адрес .dynstr
   эльфа - место, где хранятся имена динамических либ и символов.
   Идем дальше:

   0x7ffff7de6a4d <_dl_fixup+29>:	mov    0x8(%rax),%rax
   0x7ffff7de6a51 <_dl_fixup+33>:	lea    (%rax,%rdx,8),%r8

   После этого в RAX попадает 0x400398 - адрес секции rela.plt эльфа. Здесь
   зранится инфа, как именно символ и объект должен быть связан.
   Идем дальше:

   lea    (%rax,%rdx,8),%r8

   В R8 теперь лежит 0x4003b0 - это адрес записи в rela.plt, которая
   выглядит вот так:
   адр           info         тип               знач              имя
   000000601020  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0

   Т.е. именно эта запись описывает, как должна быть разрешена ссылка
   на __libc_start_main@GLIBC_2.2.5
   Идем дальше:

   0x7ffff7de6a55 <_dl_fixup+37>:	mov    0x70(%r10),%rax

   В RAX лежит 0x600eb8 - это где-то внутри секции .init_array.

   0x7ffff7de6a59 <_dl_fixup+41>:	mov    0x8(%r8),%rcx
   0x7ffff7de6a5d <_dl_fixup+45>:	mov    0x8(%rax),%rax

   В RCX лежит 0x200000007 - это содержимое поля info из записи rela.plt, описывающей
   связыывание для __libc_start_main@GLIBC_2.2.5.
   В RAX - 0x4002b8. Это адрес секции .dynsym в исполняемом эльфе.

   => 0x7ffff7de6a64 <_dl_fixup+52>:	shr    $0x20,%rdx
   0x7ffff7de6a68 <_dl_fixup+56>:	lea    (%rdx,%rdx,2),%rsi
   0x7ffff7de6a6c <_dl_fixup+60>:	lea    (%rax,%rsi,8),%rsi

   RSI - 0x4002e8 - это адрес записи в dynsym о init_array. Выглядит эта
   запись вот так:

   имя                                    адр
   0x0000000000000019 (INIT_ARRAY)        0x600e10

   Дальше:

   => 0x7ffff7de6a70 <_dl_fixup+64>:	mov    (%r10),%rax
   0x7ffff7de6a73 <_dl_fixup+67>:	mov    %rsi,0x8(%rsp)
   0x7ffff7de6a78 <_dl_fixup+72>:	mov    %rax,%rbx
   0x7ffff7de6a7b <_dl_fixup+75>:	add    (%r8),%rbx

   В RBX - 0x601020 - адрес записи GOT, в которую должен быть записан адрес,
   по которому лежит код  __libc_start_main@GLIBC_2.2.5

   => 0x7ffff7de6a7e <_dl_fixup+78>:	cmp    $0x7,%ecx
   0x7ffff7de6a81 <_dl_fixup+81>:	jne    0x7ffff7de6bd7 <_dl_fixup+423>

   Проверка занчения поля info в записи rela. Значение != 7


   => 0x7ffff7de6a87 <_dl_fixup+87>:	testb  $0x3,0x5(%rsi)
   0x7ffff7de6a8b <_dl_fixup+91>:	jne    0x7ffff7de6b29 <_dl_fixup+249>

   Проверили что-то еще, пока не знаю, что.

   => 0x7ffff7de6a91 <_dl_fixup+97>:	mov    0x1c8(%r10),%rax

   В RAX - 0x600f88 - адрес, по которому должен быть записан адрес либы __gmon_start__

   => 0x7ffff7de6a98 <_dl_fixup+104>:	test   %rax,%rax
   0x7ffff7de6a9b <_dl_fixup+107>:	je     0x7ffff7de6b50 <_dl_fixup+288>
   0x7ffff7de6aa1 <_dl_fixup+113>:	mov    0x8(%rax),%rax

   Адрес для записи __gmon_start__ не нулевой, никуда прыгать не пришлось,
   продолжили исполнение. В RAX - 0x400358  - адрес секции .gnu.version. Она
   хранит в себе инфу о версии символов.

   => 0x7ffff7de6aa5 <_dl_fixup+117>:	movzwl (%rax,%rdx,2),%eax
   0x7ffff7de6aa9 <_dl_fixup+121>:	and    $0x7fff,%eax
   0x7ffff7de6aae <_dl_fixup+126>:	lea    (%rax,%rax,2),%rdx
   0x7ffff7de6ab2 <_dl_fixup+130>:	mov    0x2e0(%r10),%rax

   В RAX - 0x7ffff7fd7520. Есть идея, что по адресу 0x7ffff7fd7000 лежит сам
   загруженный эльф, поскольку ранее при отладке вируса я видела, что mmap
   всегда грузит эльф-жертву по этому адресу. Так что возможно, что
   0x7ffff7fd7520 - это указатель на что-то внутри эльфа, который лежит в
   памяти.

   => 0x7ffff7de6ab9 <_dl_fixup+137>:	lea    (%rax,%rdx,8),%r8
      0x7ffff7de6abd <_dl_fixup+141>:	mov    $0x0,%eax
      0x7ffff7de6ac2 <_dl_fixup+146>:	mov    0x8(%r8),%r9
      0x7ffff7de6ac6 <_dl_fixup+150>:	test   %r9d,%r9d
      0x7ffff7de6ac9 <_dl_fixup+153>:	cmove  %rax,%r8
      0x7ffff7de6acd <_dl_fixup+157>:	mov    %fs:0x18,%eax
      0x7ffff7de6ad5 <_dl_fixup+165>:	test   %eax,%eax
      0x7ffff7de6ad7 <_dl_fixup+167>:	mov    $0x1,%r9d
      0x7ffff7de6add <_dl_fixup+173>:	jne    0x7ffff7de6b70      <_dl_fixup+320>

   Цель этого кода - опять какая-то проверка. К сожалению, пока не поняла,
   чего именно. Но что бы это ни было, прыжка не было, мы пошли дальше.

   => 0x7ffff7de6ae3 <_dl_fixup+179>:	mov    (%rsi),%eax
      0x7ffff7de6ae5 <_dl_fixup+181>:	mov    0x380(%r10),%rcx
      0x7ffff7de6aec <_dl_fixup+188>:	lea    0x8(%rsp),%rdx
      0x7ffff7de6af5 <_dl_fixup+197>:	mov    %r10,%rsi
      0x7ffff7de6af8 <_dl_fixup+200>:	mov    $0x1,%r9d
      0x7ffff7de6afe <_dl_fixup+206>:	add    %rax,%rdi

   Это явно подготовка параметров для вызова ~_dl_lookup_symbol_x~,
   которая будет искать необходимый символ внутри библиотеки.

   RAX - 0x12 - индекс имени символа в таблице строк dynstr.
   RCX - 0x7ffff7ffe4c0
   RDX - 0x7fffffffe028
   RSI - 0x7ffff7ffe168 - адрес, куда нужно вернуться после завершения
   линковки
   RDI - 0x40032a - адрес строки __libc_start_main

   Выполнили call и оказалсиь внутри ~_dl_lookup_symbol_x~
