#+STARTUP: showall indent hidestars

** Исследование работы __libc_start_main@plt и работы линкера
   Исследование проводится на незараженном файле жертвы. Цель - понять и
   зафиксировать штатное поведение библиотеки, чтоб затем сравнить с тем,
   как эта же библотека ведет себя внутри зараженной жертвы, когда поведение
   начинает отличаться и почему.

   Принцип простой - пройти под gdb инструкцию за инструкцией. Я специально
   скопировала вывод gdb, чтоб при повторном проходе было проще
   ориентироваться.

   Сначала следуют инструкции, затем описывается результат их работы.

   Например:

   #+BEGIN_SRC asm

   => 0x400000:	mov $0x10, %rax

   #+END_SRC

   Теперь в RAX лежит число 0x10.


   ~Запуск~
   Пропустили start, сразу дошли до инструкции call, которая вызывает либу.

   Вызывается plt, plt переходит в got, got вышвыривает обратно в plt.
   Вызываем линкер.

   #+BEGIN_SRC asm

   0x400428:	pushq  0x200c12(%rip)        # 0x601008
   0x40042e:	jmpq   *0x200c14(%rip)        # 0x601010

   #+END_SRC

   В ~0x601008~ - запись в got - лежит адрес ~0xf7ffe168~. На этот адрес мы
   вернемся после того, как отработает линкер
   В ~0x601010~ - запись в got - адрес линкера ~0xf7deee40~

   Джамп совершен. Мы внутри ~_dl_runtime_resolve_xsave~ (часть библиотеки dl-trampoline)
   - RDI - виртуальный адрес ~main~
   - RCX - виртуальный адрес ~__libc_csu_init~
   - R8 -  виртуальный адрес  ~__libc_csu_fini~
   - R12 - виртуальный адрес ~_start~

   #+BEGIN_SRC asm

   0x7ffff7deee41 <_dl_runtime_resolve_xsave+1>:	mov    %rsp,%rbx
   0x7ffff7deee44 <_dl_runtime_resolve_xsave+4>:	and    $0xffffffffffffffc0,%rsp

   #+END_SRC

   - RBX - хранит адрес бывшей вершины стека ~0x7fffffffe3f0~
   - RSP - выровнен, стал ~0x7fffffffe3c0~

   Далее идет сохранение всех регистров в стек и заполнение некоторых
   адресов на стеке нулями. Подготовка параметров для вызова ~_dl_fixup~

   Мы внутри ~_dl_fixup~. Здесь новый адрес должен быть вписан в
   соответствующую запись GOT.

   - RDI - ~0x7ffff7ffe168~ (адрес, куда надо вернуться после того, как линкер отработает)
   - RSI - ~0x1~ (кол-во аргументов запущенного эльфа. У меня один, потому что
   единственный аргумент - это само имя эльфа)

   #+BEGIN_SRC asm

   0x7ffff7de6a30 <_dl_fixup>:	push   %rbx
   0x7ffff7de6a31 <_dl_fixup+1>:	mov    %rdi,%r10
   0x7ffff7de6a34 <_dl_fixup+4>:	mov    %esi,%esi
   0x7ffff7de6a36 <_dl_fixup+6>:	lea    (%rsi,%rsi,2),%rdx
   0x7ffff7de6a3a <_dl_fixup+10>:	sub    $0x10,%rsp
   0x7ffff7de6a3e <_dl_fixup+14>:	mov    0x68(%rdi),%rax
   0x7ffff7de6a42 <_dl_fixup+18>:	mov    0x8(%rax),%rdi

   #+END_SRC

   После этих команд в RDI оказывается адрес ~0x400318~. Это адрес ~.dynstr~
   эльфа - место, где хранятся имена динамических либ и символов.
   Идем дальше:


   #+BEGIN_SRC asm

   0x7ffff7de6a4d <_dl_fixup+29>:	mov    0x8(%rax),%rax
   0x7ffff7de6a51 <_dl_fixup+33>:	lea    (%rax,%rdx,8),%r8

   #+END_SRC

   После этого в RAX попадает ~0x400398~ - адрес секции ~rela.plt~ эльфа. Здесь
   зранится инфа, как именно символ и объект должен быть связан.
   Идем дальше:

   #+BEGIN_SRC asm

   lea    (%rax,%rdx,8),%r8

   #+END_SRC

   В R8 теперь лежит ~0x4003b0~ - это адрес записи в ~rela.plt~, которая
   выглядит вот так:

   #+BEGIN_SRC asm

   адр           info         тип               знач              имя
   000000601020  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0

   #+END_SRC

   Т.е. именно эта запись описывает, как должна быть разрешена ссылка
   на ~__libc_start_main@GLIBC_2.2.5~
   Идем дальше:

   #+BEGIN_SRC asm

   0x7ffff7de6a55 <_dl_fixup+37>:	mov    0x70(%r10),%rax

   #+END_SRC

   В RAX лежит 0x600eb8 - это где-то внутри секции .init_array.

   #+BEGIN_SRC asm

   0x7ffff7de6a59 <_dl_fixup+41>:	mov    0x8(%r8),%rcx
   0x7ffff7de6a5d <_dl_fixup+45>:	mov    0x8(%rax),%rax

   #+END_SRC

   - В RCX лежит ~0x200000007~ - это содержимое поля ~info~ из записи
     ~rela.plt~, описывающей связыывание для ~__libc_start_main@GLIBC_2.2.5.~
   - В RAX - ~0x4002b8~. Это адрес секции .dynsym в исполняемом эльфе.

   #+BEGIN_SRC asm

   0x7ffff7de6a64 <_dl_fixup+52>:	shr    $0x20,%rdx
   0x7ffff7de6a68 <_dl_fixup+56>:	lea    (%rdx,%rdx,2),%rsi
   0x7ffff7de6a6c <_dl_fixup+60>:	lea    (%rax,%rsi,8),%rsi

   #+END_SRC

   RSI - ~0x4002e8~ - это адрес записи в dynsym о ~init_array~. Выглядит эта
   запись вот так:

   #+BEGIN_SRC asm

   имя                                    адр
   0x0000000000000019 (INIT_ARRAY)        0x600e10

   #+END_SRC

   Дальше:

   #+BEGIN_SRC asm

   0x7ffff7de6a70 <_dl_fixup+64>:	mov    (%r10),%rax
   0x7ffff7de6a73 <_dl_fixup+67>:	mov    %rsi,0x8(%rsp)
   0x7ffff7de6a78 <_dl_fixup+72>:	mov    %rax,%rbx
   0x7ffff7de6a7b <_dl_fixup+75>:	add    (%r8),%rbx

   #+END_SRC

   В RBX - ~0x601020~ - адрес записи GOT, в которую должен быть записан адрес,
   по которому лежит код  ~__libc_start_main@GLIBC_2.2.5~

   #+BEGIN_SRC asm

   0x7ffff7de6a7e <_dl_fixup+78>:	cmp    $0x7,%ecx
   0x7ffff7de6a81 <_dl_fixup+81>:	jne    0x7ffff7de6bd7 <_dl_fixup+423>

   #+END_SRC

   Проверка занчения поля ~info~ в записи rela. Значение != 7

   #+BEGIN_SRC asm

   0x7ffff7de6a87 <_dl_fixup+87>:	testb  $0x3,0x5(%rsi)
   0x7ffff7de6a8b <_dl_fixup+91>:	jne    0x7ffff7de6b29 <_dl_fixup+249>

   #+END_SRC

   Проверили что-то еще, пока не знаю, что.

   #+BEGIN_SRC asm

   0x7ffff7de6a91 <_dl_fixup+97>:	mov    0x1c8(%r10),%rax

   #+END_SRC

   В RAX - ~0x600f88~ - адрес, по которому должен быть записан адрес либы ~__gmon_start__~

   #+BEGIN_SRC asm

   0x7ffff7de6a98 <_dl_fixup+104>:	test   %rax,%rax
   0x7ffff7de6a9b <_dl_fixup+107>:	je     0x7ffff7de6b50 <_dl_fixup+288>
   0x7ffff7de6aa1 <_dl_fixup+113>:	mov    0x8(%rax),%rax

   #+END_SRC

   Адрес для записи ~__gmon_start__~ не нулевой, никуда прыгать не пришлось,
   продолжили исполнение. В RAX - ~0x400358~  - адрес секции ~.gnu.version.~ Она
   хранит в себе инфу о версии символов.

   #+BEGIN_SRC asm

   0x7ffff7de6aa5 <_dl_fixup+117>:	movzwl (%rax,%rdx,2),%eax
   0x7ffff7de6aa9 <_dl_fixup+121>:	and    $0x7fff,%eax
   0x7ffff7de6aae <_dl_fixup+126>:	lea    (%rax,%rax,2),%rdx
   0x7ffff7de6ab2 <_dl_fixup+130>:	mov    0x2e0(%r10),%rax

   #+END_SRC

   В RAX - ~0x7ffff7fd7520~. Есть идея, что по адресу ~0x7ffff7fd7000~ лежит сам
   загруженный эльф, поскольку ранее при отладке вируса я видела, что mmap
   всегда грузит эльф-жертву по этому адресу. Так что возможно, что
   ~0x7ffff7fd7520~ - это указатель на что-то внутри эльфа, который лежит в
   памяти.

   #+BEGIN_SRC asm

   0x7ffff7de6ab9 <_dl_fixup+137>:	lea    (%rax,%rdx,8),%r8
   0x7ffff7de6abd <_dl_fixup+141>:	mov    $0x0,%eax
   0x7ffff7de6ac2 <_dl_fixup+146>:	mov    0x8(%r8),%r9
   0x7ffff7de6ac6 <_dl_fixup+150>:	test   %r9d,%r9d
   0x7ffff7de6ac9 <_dl_fixup+153>:	cmove  %rax,%r8
   0x7ffff7de6acd <_dl_fixup+157>:	mov    %fs:0x18,%eax
   0x7ffff7de6ad5 <_dl_fixup+165>:	test   %eax,%eax
   0x7ffff7de6ad7 <_dl_fixup+167>:	mov    $0x1,%r9d
   0x7ffff7de6add <_dl_fixup+173>:	jne    0x7ffff7de6b70      <_dl_fixup+320>

   #+END_SRC

   Цель этого кода - опять какая-то проверка. К сожалению, пока не поняла,
   чего именно. Но что бы это ни было, прыжка не было, мы пошли дальше.

   #+BEGIN_SRC asm

   0x7ffff7de6ae3 <_dl_fixup+179>:	mov    (%rsi),%eax
   0x7ffff7de6ae5 <_dl_fixup+181>:	mov    0x380(%r10),%rcx
   0x7ffff7de6aec <_dl_fixup+188>:	lea    0x8(%rsp),%rdx
   0x7ffff7de6af5 <_dl_fixup+197>:	mov    %r10,%rsi
   0x7ffff7de6af8 <_dl_fixup+200>:	mov    $0x1,%r9d
   0x7ffff7de6afe <_dl_fixup+206>:	add    %rax,%rdi

   #+END_SRC

   Это явно подготовка параметров для вызова ~_dl_lookup_symbol_x~,
   которая будет искать необходимый символ внутри библиотеки.

   - RAX - ~0x12~ - индекс имени символа в таблице строк dynstr.
   - RCX - ~0x7ffff7ffe4c0~
   - RDX - ~0x7fffffffe028~
   - RSI - ~0x7ffff7ffe168~ - адрес, куда нужно вернуться после завершения
   линковки
   - RDI - 0x40032a - адрес строки ~__libc_start_main~

   Выполнили call и оказалсиь внутри ~_dl_lookup_symbol_x~
   Пока не будем освещать эту функцию подробно, поскольку сейчас процесс
   поиска имени внутри библиотеки интересует нас слабо.

   Скажем только, что внутри вызываетс ~do_lookup_x~, которая как раз и
   ищет символ.
   Если найдет, то вернет значение > 0, если не найдет - 0, и если
   значение < 0, значит, произошла какая-то ошибка.

   Сразу прыгаем на следующую инструкцию в ~_dl_lookup_symbol_x~ после
   вызова ~do_lookup_x~.

   #+BEGIN_SRC asm
     0x7ffff7de1b53 <_dl_lookup_symbol_x+339>:	cmp    $0x0,%eax
     0x7ffff7de1b56 <_dl_lookup_symbol_x+342>:
     jle    0x7ffff7de1b00 <_dl_lookup_symbol_x+256>
     0x7ffff7de1b58 <_dl_lookup_symbol_x+344>:	cmpq   $0x0,-0x90(%rbp)
     0x7ffff7de1b60 <_dl_lookup_symbol_x+352>:
     je     0x7ffff7de1d06 <_dl_lookup_symbol_x+774>
     0x7ffff7de1b66 <_dl_lookup_symbol_x+358>:	mov    (%r15),%rcx
     0x7ffff7de1b69 <_dl_lookup_symbol_x+361>:	test   %rcx,%rcx
     0x7ffff7de1b6c <_dl_lookup_symbol_x+364>:
     je     0x7ffff7de1b79 <_dl_lookup_symbol_x+377>

   #+END_SRC

   В RAX у нас лежит 0x1 - т.е. символ найден. Поэтому никакие переходы
   мы не совершаем, а просто идем дальше.
   В RCX лежит адрес ~0x7ffff7a13288~ - (интересно, что это, это явно вне
   моего эьф-файла, возможно, адрес, по котормоу находится искомый символ
   в библиотеке).
   Пропускаем остальные инструкции и выполняем ret.
   Вернулись в ~_dl_fixup~.

   Посмотрим на состояние регистров и зафиксируем те, чьи значения нам
   однозначно понятны:
   - RAX - ~0x7ffff7fd7000~ - с очень большой вероятностью это адрес
   загруженного эльфа в памяти (спойлер, нет, это указатель на указатель,
   где лежит либа)
   - RBX - ~0x601020~ - это адрес записи GOT, в которую нужно положить
   настоящий адрес ~__libc_start_main~ (сейчас там лежит адрес записи
   plt, которая вызывает линкер)
   - RCX - ~0x4002e8~ - это адрес записи в dynsym о ~init_array~
   - RSI - ~0x40034b~ - это адрес имени символа ~printf~ внутри таблицы
     строк ~dynstr~
   - R12 - ~0x400430~ - это адрес _start эльф

  #+BEGIN_SRC asm
    0x7ffff7de6b09 <_dl_fixup+217>:	mov    %fs:0x18,%eax
    0x7ffff7de6b11 <_dl_fixup+225>:	test   %eax,%eax
    0x7ffff7de6b13 <_dl_fixup+227>:	pop    %rcx
    0x7ffff7de6b14 <_dl_fixup+228>:	pop    %rsi
    0x7ffff7de6b15 <_dl_fixup+229>:	jne    0x7ffff7de6b90 <_dl_fixup+352>
  #+END_SRC

  Здесь мы проверяли, что вернула ~_dl_lookup_symbol_x~, поскольку в RAX
  был 0, проверка не сработала, так что идем дальше.

  #+BEGIN_SRC asm
    0x7ffff7de6b17 <_dl_fixup+231>:	mov    0x8(%rsp),%rsi
    0x7ffff7de6b1c <_dl_fixup+236>:	test   %rsi,%rsi
    0x7ffff7de6b1f <_dl_fixup+239>:	je     0x7ffff7de6b60 <_dl_fixup+304>
    0x7ffff7de6b21 <_dl_fixup+241>:	test   %r8,%r8
    0x7ffff7de6b24 <_dl_fixup+244>:	je     0x7ffff7de6b68 <_dl_fixup+312>
  #+END_SRC

  Проверяем содержимое RSI и R8.
  В RSI - ~0x7ffff7a1d410~ ?
  В R8 - ~0x7ffff7fd7000~ - выше было неоднократно указано, что это
  скорее всего адрес, по которому лежит сам наш агруженный эльф.
  Но который идет дальше, ставит под сомнение эту гипотезу. Скорее всего
  это указатель на указатель, по которому загружена библиотека, в которой
  мы ищем функцию

  Поскольку в обоих регистрах не 0, то просто идем дальше, не совершая
  никаких переходов

  #+BEGIN_SRC asm
    0x7ffff7de6b26 <_dl_fixup+246>:	mov    (%r8),%rax
    0x7ffff7de6b29 <_dl_fixup+249>:	movzbl 0x4(%rsi),%edx
    0x7ffff7de6b2d <_dl_fixup+253>:	add    0x8(%rsi),%rax
  #+END_SRC

  Что мы видим в этом коде?
  Мы берем содержимое по адресу из R8 - это тоже будет адрес - затем
  прибавляем к нему значение, которое лежит по адресу, который на 8 байт
  больше, чем тот, что в RSI. Значение это равно ~0x20750~

  То есть мы взяли адрес начала библиотеки, прибавили к нему вычисленное
  смещение и получили адрес, по которму лежит код ~__libc_start_main~!

  Пропустим следующие несколько инструкций и... вот оно наше связвание.
  #+BEGIN_SRC asm
    0x7ffff7de6b47 <_dl_fixup+279>:	mov    %rax,(%rbx)
  #+END_SRC

  В RBX лежит адрес записи GOT, куда помещается новый адрес.

  Дошли до конца ~_dl_fixup~
  Инуструкция ret вернет нас обратно в ~dl_runtime_resolve_xsave~, откуда
  мы и перешли в ~_dl_fixup~.
  Дальше, в общем ничего интересного - восстановление значений
  регистров - это можно пропстить.

  А зачем мы все это начали? Ах да, мы же хотели вызвать
  ~__libc_start_main~, точно. Теперь это можно сделать, наконец-то.

  Оказались внутри ~__libc_start_main~.
  В начале ничего интересного - сохранение регистров и резервирование стека.

  Затем прверяем, что там оказалось в RAX
  #+BEGIN_SRC asm
    0x7ffff7a2d762 <__libc_start_main+18>:
        mov    0x3a37df(%rip),%rax        # 0x7ffff7dd0f48
    0x7ffff7a2d777 <__libc_start_main+39>:	test   %rax,%rax
    0x7ffff7a2d77a <__libc_start_main+42>:
    je     0x7ffff7a2d847 <__libc_start_main+247>
  #+END_SRC
  Поскольку там 0, то совершаем переход, который предостережет нас от
  попытки взять содержимое от нулевого адреса и окажемся вот на этом
  участке.

  #+BEGIN_SRC asm
    lea    0x3a38f0(%rip),%rax        # 0x7ffff7dd1080 <__libc_multiple_libcs>
    0x7ffff7a2d790 <__libc_start_main+64>:	test   %r9,%r9
    0x7ffff7a2d793 <__libc_start_main+67>:	mov    %edx,(%rax)
    0x7ffff7a2d795 <__libc_start_main+69>:
    je     0x7ffff7a2d7a3 <__libc_start_main+83>
    0x7ffff7a2d797 <__libc_start_main+71>:	xor    %edx,%edx
    0x7ffff7a2d799 <__libc_start_main+73>:	xor    %esi,%esi
    0x7ffff7a2d79b <__libc_start_main+75>:	mov    %r9,%rdi
    0x7ffff7a2d79e <__libc_start_main+78>:	callq  0x7ffff7a47290 <__GI___cxa_atexit>
  #+END_SRC
  Здесь явно идет подготовка параметров для ~__GI___cxa_atexit~
  Ее задача - подготовить деструктор для линкера. Пока пропустим ее,
  поскольку нам это не очень интересно.

  Затем у нас идет подготовка для вызова ~__libc_csu_init~, которая
  находится в нашем эльфе - это адрес ~0x400550~.

  Эта функция вызывает указатели на функции в секции .preinit.
  Затем должна исполнить код в секции .init программы.

  Сначала ничего интересного - сохраняем регистры.

  #+BEGIN_SRC asm
    0x40055b <__libc_csu_init+11>:	lea    0x2008ae(%rip),%r12        # 0x600e10
    0x400562 <__libc_csu_init+18>:	push   %rbp
    0x400563 <__libc_csu_init+19>:	lea    0x2008ae(%rip),%rbp        # 0x600e18
  #+END_SRC

  По адресу ~0x600e18~ в нашем эльфе лежит
  ~__do_global_dtors_aux_fini_array_entry~, а по адресу ~0x600e10~ лежит
  ~__frame_dummy_init_array_entry~.

  Затем готовим параметры для функции ~init~, определенной в нашем эльфе,
  и вызываем ее.

  Что делает код в .init зависит от компилятора, но при использовании gcc, код в .init
  исполняет функции программы, обозначенные как _attribute__ ((constructor)) (in
  __do_global_dtors_aux). Затем вызывает указатели на функции в
  секции .init_array.

  #+BEGIN_SRC asm
    0x40056a <__libc_csu_init+26>:	push   %rbx
    0x40056b <__libc_csu_init+27>:	mov    %rsi,%r14
    0x40056e <__libc_csu_init+30>:	mov    %rdx,%r13
    0x400571 <__libc_csu_init+33>:	sub    %r12,%rbp
    0x400574 <__libc_csu_init+36>:	sub    $0x8,%rsp
    0x400578 <__libc_csu_init+40>:	sar    $0x3,%rbp
    0x40057c <__libc_csu_init+44>:	callq  0x4003c8 <_init>
  #+END_SRC

  Интересно, что этот код желает с EBP.
  Подробно не будет рассматривать эту функцию, пока она не кажется
  интересной.

  #+BEGIN_SRC asm
    0x400581 <__libc_csu_init+49>:	test   %rbp,%rbp
    0x400584 <__libc_csu_init+52>:	je     0x4005a6 <__libc_csu_init+86>

  #+END_SRC

  При выходе из ~init~, проверяем, что там EBP. У нас там была единица,
  так что переход не осуществляем.

  #+BEGIN_SRC asm
    0x400586 <__libc_csu_init+54>:	xor    %ebx,%ebx
    0x400588 <__libc_csu_init+56>:	nopl   0x0(%rax,%rax,1)
    0x400590 <__libc_csu_init+64>:	mov    %r13,%rdx
    0x400593 <__libc_csu_init+67>:	mov    %r14,%rsi
    0x400596 <__libc_csu_init+70>:	mov    %r15d,%edi
    0x400599 <__libc_csu_init+73>:	callq  *(%r12,%rbx,8)
 #+END_SRC

В этом коде мы видим, как вычисляется адрес ~frame_dummy~ (и как мы на него
переходим), а так же как подготавляиваются для него параметры.
Параметры выглядят вот так (хотя их значение не очень понятно):

- RDI - ~0x1~
- RSI - ~0x7fffffffe428~
- RDX - ~0x7fffffffe438~

Задачей ~frame_dummy~ является установка аргументов и запуск функции
~register_tm_clones~.

Внутри ~frame_dummy~ мы выдим вот такой код.
#+BEGIN_SRC asm
  0x400500 <frame_dummy>:	mov    $0x600e20,%edi
  0x400505 <frame_dummy+5>:	cmpq   $0x0,(%rdi)
  0x400509 <frame_dummy+9>:	jne    0x400510 <frame_dummy+16>
  0x40050b <frame_dummy+11>: jmp    0x4004a0 <register_tm_clones>
#+END_SRC

~0x600e20~ - это адрес ~__JCR_END__~ в нашем эльфе.
Поскольку у нас по этому адресу пусто, то мы отправляемся в
~register_tm_clones~. Там особо нет ничего интересного, так что пропустим
ее, и сразу перейдем в ее конец.

Инструкция ret возращает нас в ~__libc_csu_init~, где мы восстанавливаем
значения регистров и возвращаемся в ~__libc_start_main~. Которая, в свою
очередь, передает управление ~main~

Так управление переходит непосредственно к сишному коду, который написал
программист.
