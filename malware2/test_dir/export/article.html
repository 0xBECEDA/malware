<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="ss">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org33fad2a">Тут должен быть какой-то заголовок</a></li>
</ul>
</div>
</div>

<div id="outline-container-org33fad2a" class="outline-2">
<h2 id="org33fad2a">Тут должен быть какой-то заголовок</h2>
<div class="outline-text-2" id="text-org33fad2a">
<p>
Я тупо пялился в монитор и в упор не мог понять, что происходит.
У меня уже был написан весь вирус целиком - ничего особенного, просто
находит ELF-файлы в текущей папке и заражает их - он заразил файл жертвы,
отработал в нем без сбоев, передал управление на жертву и&#x2026; вызов <code>libc</code>
внутри жертвы заканчивался сегфолтом.
</p>

<p>
С маниакальной дотошностью я проверял содержимое секции <code>dynamic</code> - она
содержит в себе информацию для линкера, а так же корректного старта и
завершения сишной программы - содержимое разделов <code>GOT</code> и <code>PLT</code>, а так же
заголовков секций, сегментов и самого эльфа, и не мог понять, почему
<code>libc</code> не может провести старт моей жертвы.
</p>

<p>
Вернемся на пару недель назад.
Бегло пролистав книгу Криса Касперски "Записки исследователя компьютерных
вирусов", я загорелся идеей написать свой первый в жизни вирус: всего-то
надо вставить код вируса в файл, немножко подредактировать заголоки
сегментов и секций и изменить <code>entry point</code> - точку входа - и дело в
шляпе.
</p>

<p>
Если вдруг для кого-то ELF-файлы и загрузка программ - это немного черная
магия, то достаточно знать, что ELF-файл нужен, чтоб дать представление
загрузчику и линкеру, как следует расположить программу в памяти процесса
и слинковать ее с библиотеками, если у вас динамическая линковка.
Программа делится на сегменты - объемные куски кода, которые включают в
себя секции - это менее объемные куски кода. У каждого сегмента и укаждой
секции есть свой заголовок: в нем содержит информация, что это за
сегмент/секция, где искать в файле, размещать в памяти процесса и не
размещать вообще, сколько места занимает и т.д. Заголовки секций и
заголовки сегментов объединены в таблицы. А заголовок эльфа указывает,
гдеискать эти таблицы в файле, каков размер одного заголовка/секции, точку
входа и т.д.
</p>

<p>
Для более детального понимния рекомендую ццикл статей тут
<a href="https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html">https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html</a>
или ман по формату эльфа.
</p>

<p>
В качестве языка реализации был выбран <code>GAS asm</code>, поскольку это позволяло
собрать вирус без библиотек, что значительно упрощало заражение. В
качестве файла жертвы был динамически слинкованный сишный <code>Hello world</code>.
</p>

<p>
Идея заражения, описанная у Касперски проста: находим первый загружаемый
сегмент кода - мы ж хотим, чтоб код вируса оказался в
памяти процесса - находим в нем последнюю секцию и пишем вирус сразу
после нее. Затем расширяем и секцию, и сегмент на размер вируса, путем
редактирования их заголовков, редактируем заголовки всех сегментов и секций,
которые описыают код, лежащий ниже зараженной секции, увеличивая
виртуальные адреса и смещение в файле на размер вируса и изменяем точку
входа в заголовке эльфа, чтоб программа стартовала с выполнения вируса.
Передача управления на жертву решалась пятью байтами машинного кода,
который я вставлял после вируса: <code>e9</code> - машкод относительного <code>jmp</code>, и
смещением от следующей инструкции до оригинальной точки входа.
</p>

<p>
В качестве результата я получил сегфолт еще до того, как управление
перешло на точку входа - т.е. что-то случилось на этапе загрузки и
линковки.
</p>

<p>
Программа загружается лоадером в память процесса, а затем вызывается
линкер - в моем случае это <code>ld-linux-x86-64.so.2</code>, который должен связать
все подключенные библиотеки друг с другом, положить адрес на себя в одну
из записей таблицы <code>GOT</code> - иначе как мы его вызовем, когда встретим в
программе какой-нибудь <code>printf</code>. Всю информацию линкер берет из секции
<code>dynamic</code>, именно она описывает, где искать <code>GOT</code>, какие именно либы надо
подгрузить и т.д. Когда я вставил вирус, все сместилось,
разумеется. А вот <code>dynamic</code> продолжала описывать незараженную версию
программы.
</p>

<p>
Ладно, исправили, изменив виртуальные адреса в каждой записи секции
<code>dynamic</code>. Заодно мимоходом выяснили, что надо отредактировать
виртуальные адреса в записях секциий <code>rela</code> - они описывают, как именно линкер
должен разрешить каждый релокейт - и виртуальные адреса в таблице
символов <code>symtab</code>, где каждая запись описывает, где объевлен символ
программы.
</p>

<p>
Ура, все заработало&#x2026; нет.
Вирус запустился, даже передал управление на жертву. Жертва доходит до
раздела <code>PLT</code>, прыжок и&#x2026; вместо записи в <code>GOT</code> мы попадаем туда, где
эта запись <code>была</code> до заражения. Проблема заключается в том, что раздел
<code>PLT</code> находится до первого загружаемого сегмента кода жертвы, а вот
раздел <code>GOT</code> - после. Расширив сегмент вирусом, мы нарушили соотношение
между <code>PLT</code> и <code>GOT</code>, так что даже относительные джампы из <code>PLT</code> в <code>GOT</code>
никак не могли исправить положение.
</p>

<p>
Можно, конечно, отредактировать смещения в джампах, но это тяжко: надо
научиться определять, где какой переход, не попасть между инструкций и
т.д. Так что я решил зайти с другого конца, в прямом смысле слова.
</p>

<p>
Сделаем все то же самое, но вирус поместим после всего кода жертвы,
вместо заголовков секций, а их сдвинем.
Минус этого подхода по сравнению с предыдущим состоит в том, что виирус
прихожится оформлять в отдельный сегмент кода, а не присоединять к уже
существующему, что предполагает создание его заголовка сегмента и
заголовка секции. Поскольку заголовок сегмента вставляется в таблицу
сегментов, то весь код жертвы съедет вниз равномерно на 56 байт - размер
заголовка сегмента на моей архитектуре - в результате чего
все заработает, как я полагал.
</p>

<p>
Вот после запуска новой версии вируса мы с вами и встретились в начале
этой статьи.
</p>

<p>
Вооружившись сорцами <code>libc</code>, отладчиком <code>gdb</code> и вот этой статьей
<a href="http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html">http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html</a>,
я полез "под капот".
</p>

<p>
Только на этом этапе стало видно, какую подлянку мне устроила моя версия
компилятора <code>gcc</code>, который компилил мою жертву. Он генерировал
позиционно-зависимый код. В результате этого <code>libc</code> получала неверные
параметры и дальше наступало "крушение всех надежд, пять букв".
Напрашивающийся очеивдный вариант - урегулирование всех ссылок. Но это куда хуже,
чем немного подредактировать <code>PLT</code>, от чего мы отказались пару абзацев назад.
</p>

<p>
Так что немного поломав голову я решил сдвинуть жертву в памяти процесса
до того, как вирус передаст на нее управление, чтоб жертва оказалась на
своих прежних адресах, как будто ничего не было.
</p>

<p>
Вот так выглядит инфицированный файл в памяти процесса до заражения
</p>


<div class="figure">
<p><img src="./img/infected_victim_without_bind_now_before_move.png" alt="infected_victim_without_bind_now_before_move.png">
</p>
</div>

<p>
А вот так будет выглядеть после:
</p>


<div class="figure">
<p><img src="./img/infected_victim_after_move.png" alt="infected_victim_after_move.png">
</p>
</div>

<p>
Вас еще ничего не смутило в этом плане?
"Сдвиг" жертвы предполагает запись прямо в код, что по умолчанию
заканчивается сегфолтом. Но если замечательный системный вызов
<code>mprotect</code>, который позволяет менять атрибуты страницы памяти, задавая
новые. Так что если правильно если правильно реализовать и вызвать <code>mprotect</code>
для кода жертвы, то мы можем разрешить запись.
Так что запись в код - это вообще не главная проблема. "Биг босс" ждет
впереди :)
</p>

<p>
Поскольку мы помним, что линкер использует секцию <code>dynamic</code>, а у нас в
файле используется ленивое связывание, то позаботимся, чтоб до "сдвига"
жертвы мы отредактировали записи в секции <code>dynamic</code> "обратно", вернув им
прежние адреса.
</p>

<p>
Файл запустился, вирус отработал, подвинул жертву,  передал ей управление
и&#x2026; попытка слинковать <code>libc</code> в рантайме и затем вызвать завершается
сегфолтом. Маленький зверек с белой шубкой подкрался незаметно.
</p>

<p>
Мы недооценили, насколько линкер хитрая штуковина. Он знает, что скорее
всего его вызовут еще n раз, а еще знает, что скорее всего будет вызвана
<code>libc</code>, которой нужен доступ к некоторым секциям жертвы, вроже секций
<code>fini</code> или <code>init</code>, информация о которых хранится в любимой нами секции
<code>dynamic</code>. Но вот обращаться напрямую к записям <code>dynamic</code> повторно линкер
не хочет, да и <code>libc</code> это незачем. Так что линкер до того как передать
управление программе создает в памяти буфер и сохраняет адреса необходимых
ему и <code>libc</code> записей <code>dynamic</code> - т.е. где эти записи расположены в памяти
процесса. А затем, когда уже есть необходимость, <code>libc</code> и линкер
обращаются к конкретным записям, выуживая из них нужную информацию.
</p>

<p>
В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адресе записей секции <code>dynamic</code> в буфере становятся
неактуальными и <code>libc</code> получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.
</p>

<p>
Выход есть: отказ от "ленивого" связывания. Линкер умеет связывать все
здесь и сейчас и делает это он в случае, если обнаруживает в секции <code>dynamic</code>
запись <code>BIND_NOW</code>. Так что нам надо всего-то вставить дполнительные 16
байт в секцию <code>dynamic</code>, и это решит наши проблемы.
</p>

<p>
Теперь наш инфицированный файл до сдвига кода жертвы будет выглядеть вот
так.
</p>


<div class="figure">
<p><img src="./img/infected_victim_before_move.png" alt="infected_victim_before_move.png">
</p>
</div>

<p>
Надо только немного модифицировать подвижку жертвы таким образом, что мы
затерли запись <code>BIND_NOW</code>, иначе все, что находилось ниже секции
<code>dynamic</code>, окажется не на своих адресах.
</p>

<p>
Запускаем инфицированный файл и&#x2026; видим строчку <code>HELLO WORLD</code> на экране! Ура, это&#x2026;
</p>

<p>
В смысле сегфолт?!
</p>

<p>
Снова забираемся "под капот" с помощью <code>gdb</code> и видим, как <code>libc</code> пытается
завершить корректно сишную жертву. И даже несмотря на "связывание здесь и
сейчас" <code>libc</code> обращается к буферу, который создал линкер, и берет оттуда
адреса записей <code>fini</code> и других в секции <code>dynamic</code>, которую мы
подвинули. И вот на этот процесс у нас нет позможности повлиять, кроме
как&#x2026; не двигать <code>dynamic</code> вообще.
</p>

<p>
На наше счастье все записи, необходимые <code>libc</code> для корректного завершения
программы, находятся в начале секции <code>dynamic</code>. Это значит, что мы вполне
можем оставить ее на месте, но подвинуть весь код, расположенный за ней,
затерев ее нижние 72 байта - размер заголовка сегмента вируса и записи
<code>BIND_NOW</code>.
</p>

<p>
Таким образом после "сдвига" инфицированный файл будет выглядеть вот так:
</p>

<p>
Итого мы получили вирус, который может заражать файлы как с
позиционно-независимым, так и с позиционно-зависимым кодом.
</p>

<p>
Ссылка на проект на гите
(тут будет ссылка)
</p>
</div>
</div>
</div>
</body>
</html>
