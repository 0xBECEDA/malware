<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>&lrm;</title>
<meta name="generator" content="Org mode">
<meta name="author" content="ss">
<link href="/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgedaae9f">Пишем вирус под Linux с нуля: мой опыт и грабли</a></li>
</ul>
</div>
</div>



<div id="outline-container-orgedaae9f" class="outline-2">
<h2 id="orgedaae9f">Пишем вирус под Linux с нуля: мой опыт и грабли</h2>
<div class="outline-text-2" id="text-orgedaae9f">
<p>
Последнее более-менее подробное и доступное для новичка руководство по
написанию вирусов, которое ищется в гугле - это книга "Записки
вирусописателя" Криса Касперски. Лично у меня был плохо отсканированный
экземпляр, где в некоторых местах не видно половину страницы.
В этой статье я хочу восполнить этот пробел и показать, как написать
свой первый вирус за пару дней, не прокачивая способности медиума.
</p>

<p>
Поскольку мы тут с вами тру хакеры, то писать вирус будем на <code>GAS asm</code> -
это сделает его достаточно маленьким и при этом независимым от
библиотек. Все библиотечные функции, которые могут понадобиться, мы
реализуем сами, используя несколько строчек кода. У вируса будет только
две задачи: найти ближайший ELF-файл и заразить его.
</p>

<p>
Если вдруг для кого-то ELF-файлы и загрузка программ - это немного черная
магия, то достаточно знать, что ELF-файл нужен, чтоб дать представление
загрузчику и линкеру, как следует расположить программу в памяти процесса
и слинковать ее с библиотеками, если у вас динамическая линковка.
</p>

<p>
Программа делится на сегменты - объемные куски кода, которые включают в
себя секции - это менее объемные куски кода. У каждого сегмента и укаждой
секции есть свой заголовок: в нем содержится информация, что это за
сегмент/секция, где искать в файле, где размещать в памяти процесса или не
размещать вообще, сколько места занимает и т.д. Заголовки секций и
заголовки сегментов объединены в таблицы. А заголовок эльфа указывает,
где искать эти таблицы в файле, каков размер одного заголовка/секции, точку
входа и т.д.
</p>

<p>
Вот так очень схематично выглядит ELF-файл.
</p>

<div class="figure">
<p><img src="./img/elf.png" alt="elf.png">
</p>
</div>

<p>
Для более детального понимания рекомендую цикл статей
<a href="https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html">https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html</a>
или ман по формату эльфа.
</p>

<p>
Главный вопрос - это куда вставлять код вируса в ELF-файл, от этого
зависит модель вашего заражения. Вариантов так много, насколько хватит
фантазии. Но мы выделим три наиболее простых:
</p>

<ol class="org-ol">
<li>Вставить вирус в <code>padding</code> между таблицей заголовков сегментов и кодом
программы. Проблема в том, что в padding-е очень мало места. А может
padding-а вообще нет.</li>

<li><p>
Найти первый загружаемый сегмент кода - сегменты такого типа грузятся
в память процесса - и вписать вирус в его конец. Затем расширить этот
сегмент на размер вируса и немного отредактировать остальные заголовки
секций и секций, потому что весь код сместится на рамер вируса.
</p>

<p>
Проблема в том, что в динамически слинкованном файле у нас есть <code>PLT</code> и
<code>GOT</code>, и они лежат в разных загружаемых сегментах. Для общения
между собой эти ребята используют позиционно-независимый код - т.е. им
совершенно все равно, по каким адресам и где именно в файле они будут
расположены, но критически важно какое между ними расстояние. Если,
грубо говоря, <code>PLT</code> рассчитывает, что между ней и <code>GOT</code> 100 байт, то
если там внезапно окажется 300 байт из-за вписанного вируса, <code>PLT</code>
обратится туда, где <code>GOT</code> была раньше.
</p>

<p>
Есть, конечно, очевидный способ это исправить - подредактировать код внутри
<code>PLT</code> - но это муторно: надо определить, где начинается нужная
инструкция, не попасть посередине инструкции и т.д.
</p></li>

<li><p>
Вписать вирус в самый конец кода жертвы. Для этого придется оформить
его в отдельный сегмент кода, а значит создать под него собственный
заголовок - иначе загрузчик его просто не загрузит в память. В
результате весь код равномерно съедет на размер нового заголовка - на
моей архитектуре это 56 байт.
</p>

<p>
Плюсы очевидны: не придется исполнять танцы с бубном над <code>PLT</code> и
<code>GOT</code>. Проблемы менее очевидны на данном этапе, так что остановимся на
этом варианте.
</p>

<p>
После заражения мы рассчитываем, что инфицированный файл будет
выглядеть вот так:
</p></li>
</ol>


<div class="figure">
<p><img src="./img/infected_elf.png" alt="infected_elf.png">
</p>
</div>

<p>
Провернуть такое и не сломать эльф достаточно легко, записывайте
пошаговый рецепт:
</p>
<ol class="org-ol">
<li>Загрузите ваш файл в память. Я это делаю с помощью <code>mmap</code>, но вы
можете использовать любой другой способ.</li>

<li>Распарсите ваш эльф. Выясните где у него какие заголовки</li>

<li>Выделите память под новые заголовки: нам понадобится 56 байт на
заголовок сегмента и 60 байт на загоовок секции.</li>

<li>Запоолните эти буфера данными в соответствии со структурами заголовка
сегмента и заголовка секции. Они подробно описаны в мане.</li>

<li>Увеличьте поля <code>p_paddr</code>, <code>p_vaddr</code> и <code>p_offset</code> на 56 байт во всех
заголовках сегментов, которые описывают код, находящийся после таблицы
заголовков. Таким образом вы укажете, что изменились физические и
виртуальные адреса сегментов, а так же их смещение от начала файла,
т.е. весь код съехал на те самые 56 байт как в файле, так и в памяти
процесса.</li>

<li>Увеличьте поля <code>sh_addr</code> и <code>sh_offset</code> на 56 байт во всех заголовках
секций по тому же принципу и тем же причинам, описанным в пункте
выше.</li>

<li>Увеличьте поля <code>e_phnum</code> и <code>e_shnum</code> в загоовке эльфа на единицу - так
вы укажете, что загоовков сегментов и загоовков секций стало на 1
больше. А так же установите новое смещение от начала файла таблицы
заголовков секций в поле <code>e_shoff</code> - в противном случае заголовки
секций не будут найдены, и формат будет сломан.</li>

<li>Перезапишите ваш эльф по кусочкам, дополняя его кодом вируса и его
заголовками. Мне в этом помог вызов <code>pwite</code>, где можно задать смещение
от начала файла, по которому должна вестись запись.</li>
</ol>

<p>
Но загрузчик слишком умен, он еще проверяет валидность сегментов кода.
Чтоб сегмент сочли валидным, вы должны соблюсти соотношение между
виртуальным адресом вашего сегмента и его смещением от начала файла.
Если вычесть второе из первого, то вы должны получить адрес, кратный 4кб.
</p>

<p>
Посчитать виртуальный адрес для вируса нетрудно:
</p>
<ol class="org-ol">
<li>Находите загоовок последнего загружаемого сегмента кода жертвы</li>

<li>Считываете его <code>p_vaddr</code> и <code>p_allign</code> - т.е. его виртуальный адрес и
выравнивание.</li>

<li>Выравниваете виртуальный адрес последнего сегмента по 4 кб,
прибавляете к нему выравнивание и смещение вашего вируса в файле.
Приходится учитывать выравнивание, поскольку как правило с байтами
выравнивания вы не можете делать буквально ничего и попытка что-то
исполнить там приведет к сегфолту.</li>
</ol>

<p>
Поздравляю, вы являетесь счастливым обладателем валидного сегмента кода.
</p>

<p>
Теперь у нас есть инфицированный эльф, но вирус в нем не заработает,
потому что мы никак не перевели на него управление. Самый простой способ
</p>
<ul class="org-ul">
<li>это вписать виртуальный адрес нашего вируса, который мы высчитали выше,</li>
</ul>
<p>
в поле <code>e_entry</code> заголовка эльфа - таким образом мы изменим точку входа и
управление перейдет на вирус сразу.
</p>

<p>
Вам не кажется, что мы что-то забыли?
Подсказываю, вы же, наверное, хотите, чтоб с появлением вируса в вашем
файле основная программа все равно продолжала исполняться?
</p>

<p>
Да, мы должны передать управление на жертву после того, как вирус отработает.
</p>

<p>
Сделать это можно всего с помощью пяти байт кода. В ассмеблере есть
инструкция <code>jmp</code>, которая является безусловным переходом. Ее параметр
может быть как абсолютным адрсом, т.е. буквально <code>jmp 0x400345</code>, так и
смещением до нужного адреса. Параметр занимает 4 байта, а машкод <code>jmp</code>
<code>e9</code> занимает 1 байт.
</p>

<p>
Смещение высчитывается от адреса <code>следующей</code> за <code>jmp</code> инуструкцией.
Для этого мы высчитываем, на каком виртуальном адресе закончится вирус -
берем его виртуальный адрес и складываем с размером вируса - прибавляем к
полученному адресу 5 байт - размер инструкции <code>jmp</code> - и полученный адрес
 вычитаем адрес оригинальной точки входа. Смещение получится
отрицательным, как нам и нужно, поскольку мы прыгаем "назад" в
программе.
</p>

<p>
Возьмем конкретный пример: адрес вашего вируса <code>0x8012a8</code>, его размер
<code>0x100</code> байт, адрес оригинальной точки входа <code>0x400430</code>.
<code>0x400430 - (0x8012a8 + 0x100 + 0x5) = -400f7d</code>.
</p>

<p>
Просто зарезервируйте 5 байт памяти, впишите в первый код <code>e9</code>, затем
полученное смещение и вставьте полученную инструкцию сразу после кода
вируса в вашем файле.
</p>

<p>
Получится вот такой эльф
</p>


<div class="figure">
<p><img src="./img/infected_elf_with_transfer_control_block.png" alt="infected_elf_with_transfer_control_block.png">
</p>
</div>

<p>
Ура, у вас есть работающий инфицированный эльф. Правда, работающий
недолго: во время исполнения кода жертвы вы получите сегфолт.
</p>

<p>
И вот тут начинается самое интересное. Есть ли у вас минутка поговорить о
боге нашем линкере?
</p>

<p>
У линкера в общем есть две глобальные задачи: он должне связать библиотеки, которые
вы используете, друг с другом - это происходит еще до того, как
управление будет передано на вашу программу, а затем он должен
осуществить "ленивое" связывание, когда ваш код дойдет до вызова какой-то
библиотечной функции в первый раз.
</p>

<p>
Всю информацию ему предоставляет секция <code>dynamic</code>. Ее в ваш код, как и
много другое, вставляет компилятор.  Увидеть ее вы
можете, если возьмете любой динамически склинкованный бинарь и прогоните
его под <code>readelf -d filename</code>.
</p>


<div id="org6c6e7b7" class="figure">
<p><img src="./img/dynamic.png" alt="dynamic.png">
</p>
</div>

<p>
Записи, помеченные как <code>NEEDED</code> - это имена библиотек, от которых зависят
все прочие библиотеки вашей программы, они будут загружены в первую
очередь.
</p>

<p>
Запись <code>PLTGOT</code> - это таблица <code>GOT</code>, которая до осуществления ленивого
связывания в своих записях содержит адрес, по которому лежит код в <code>PLT</code>,
вызывающий линкер.
</p>

<p>
Записи, помеченные как <code>RELA</code> - это адреса секций <code>rela</code>. Их может быть
несколько в файле и они содержат в себе информацию о том, как именно
следует разрешить релокейты и куда должны быть положены связанные адреса
</p>

<p>
Вот так выглядит секция <code>rela</code>
</p>


<div id="org9c46084" class="figure">
<p><img src="./img/rela.png" alt="rela.png">
</p>
</div>

<p>
Если вы слабо себе представляете, что такое релокейты, то рекомендую вот
эту статью
<a href="http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html">http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html</a>
</p>

<p>
<code>SYMTAB</code> - это таблица символов, которая содержит в себе информацию обо
всех символах программы. Каждая запись в ней представлена как
соответствие между символом и виртуальным адресом, по которому он
объявлен.
</p>

<p>
Но весь наш код съехал из-за нового заголовка сегмента,
о чем секции <code>dynamic</code>, <code>rela</code>, <code>got</code> и <code>symtab</code> понятия не имеют.
</p>

<p>
Чтоб это исправить, нужно отредактировать все виртуальные адреса в
записях этих секций, увеличив их на 56 байт. Найти их можно по их
заголовкам: у загоовков секций есть поле <code>sh_type</code>, которое указывает на
тип описываемой секции. Заголовки <code>rela</code> имеют тип 4, загоовок
<code>dynamic</code> - тип 6, а <code>symtab</code> - тип 2. Из заголовка вы можете выудить
смещение секции от начала файла, сложить с базовым адресом загруженного в
память эльфа-жертвы и таким образом добраться до самой секции. А
поскольку в одной секции все записи одного размера, то вам достаточно
передвигаться на фиксированное количество байт и редактировать нужные
адреса.
</p>

<p>
С секцией <code>GOT</code> все чуть сложнее. Ее заголовок не имеет специфического
типа, поэтому лучше искать ее через секцию <code>dynamic</code>. Запись, которая
описывает <code>GOT</code>, имеет тип 3. Вы можете вытащить из нее виртуальный адрес
<code>GOT</code>, по нему найти заголовок секции в таблице секций, а затем проделать
все то же, что мы делали с другими секциями. Так вы обеспечите преход
обратно на <code>PLT</code> в случае, если библиотечная функция вызывается в первый
раз.
</p>

<p>
Если вы счастливый компилятора, который генерирует позиционно-независимый
код для вашей жертвы, то вы только что закончили свой первый вирус.
</p>

<p>
Моя же версия <code>gcc</code> подсунула мне хорошие грабли с увесистым таким
черенком. Она генерирует позиционно-зависимый код, в результате чего,
например, <code>libc</code>, которая должна обеспечить корректный старт и завершение
передаются неверные параметры.
</p>

<p>
Урегулирование всех ссылок - это куда хуже, чем просто подредактировать
<code>PLT</code>, а ведь из-за этого мы отвергли более простую модель
заражения.
</p>

<p>
Но есть совершенно радикальный вариант: после исполнения вируса мы
подвинем код жертвы в памяти процесса таким образом, будто никакого
заражения не было. То есть сместим весь ее код, лежащий после таблицы
сегментов, на 56 байт назад, затерев таким образом вставленный заголовок
вируса. Все, что требуется для этого - это разрешить запись прямо в код.
</p>

<p>
Здесь поможет <code>mprotect</code>, он позволяет менять атрибуты страниц памяти на
те, что нам нужны.
</p>

<p>
Таким образом до "сдвига" инфицированный файл выглядит вот так:
</p>


<div class="figure">
<p><img src="./img/infected_victim_without_bind_now_before_move.png" alt="infected_victim_without_bind_now_before_move.png">
</p>
</div>


<p>
А вот так будет выглядеть после:
</p>


<div class="figure">
<p><img src="./img/infected_victim_after_move.png" alt="infected_victim_after_move.png">
</p>
</div>

<p>
К сожалению, это не решит все наши проблемы.
</p>

<p>
Мы недооценили, насколько линкер хитрая штуковина. Он знает, что скорее
всего его вызовут еще n раз, а еще знает, что скорее всего будет вызвана
<code>libc</code>, которой нужен доступ к некоторым секциям жертвы, вроже секций
<code>fini</code> или <code>init</code>, информация о которых хранится в любимой нами секции
<code>dynamic</code>. Но вот обращаться напрямую к записям <code>dynamic</code> повторно линкер
не хочет, да и <code>libc</code> это незачем. Так что линкер до того как передать
управление программе создает в памяти буфер и сохраняет адреса необходимых
ему и <code>libc</code> записей <code>dynamic</code> - т.е. где эти записи расположены в памяти
процесса. А затем, когда уже есть необходимость, <code>libc</code> и линкер
обращаются к конкретным записям, выуживая из них нужную информацию.
</p>

<p>
В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции <code>dynamic</code> в буфере становятся
неактуальными и <code>libc</code> получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.
</p>

<p>
Выход есть: отказ от "ленивого" связывания. Линкер умеет связывать все
здесь и сейчас и делает это он в случае, если обнаруживает в секции <code>dynamic</code>
запись <code>BIND_NOW</code>. Так что нам надо всего-то вставить дополнительные 16
байт в секцию, в первые из которых положено число <code>0x18</code>.
</p>

<p>
Теперь наш файл будет выглядеть в памяти следующим образом, пока мы его
не подвинем:
</p>


<div class="figure">
<p><img src="./img/victim_before_move.png" alt="victim_before_move.png">
</p>
</div>

<p>
И хотя это позволит вызывать библиотеки, это никак не поможет <code>libc</code>
корректно завершить программу жертвы. <code>libc</code> берет из буфера, который нам
создал линкер, адреса записей <code>fini</code>, <code>fini_array</code> и других, из которых
она должна получить адреса этих секций кода в памяти, а затем вызвать их.
И у нас нет никакой возможности повлиять на этот процесс.
</p>

<p>
На наше счастье все записи, необходимые <code>libc</code> для корректного завершения
программы, находятся в начале секции <code>dynamic</code>. Это значит, что мы вполне
можем оставить ее на месте, но подвинуть весь код, расположенный за ней,
затерев ее нижние 72 байта - размер заголовка сегмента вируса и записи
<code>BIND_NOW</code>.
</p>

<p>
Таким образом после "сдвига" инфицированный файл будет выглядеть вот так:
</p>


<div class="figure">
<p><img src="./img/victim_after_move.png" alt="victim_after_move.png">
</p>
</div>

<p>
Итого мы получили вирус, который может заражать файлы как с
позиционно-независимым, так и с позиционно-зависимым кодом.
</p>

<p>
Надеюсь, мой опыт был кому-то полезным. Идеи и конструктивная критика крайне
приветствуются.
</p>
</div>
</div>
</div>
</body>
</html>
