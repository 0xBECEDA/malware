#+STARTUP: showall indent hidestars
** Устройство эльфа
Зачем вообще нужны ELF файлы?
Нам нужно сообщать загрузчику, что мы хотим загрузить: как и с каких
адресов располагать сегменты кода, сколько места они занимают, какие
библиотеки нужны и нужны ли вообще и т.д. Всю эту информацию о программе
загрузчик черпает из эльфа.

Подробно о ELF-формате можно прочитать вот здесь:
https://refspecs.linuxfoundation.org/elf/elf.pdf

А чтоб посмотреть, как в эльфе все устроено, можно использовать утилиту
~readelf~ с разнообразными ключами.

*** Общее устройство эльф-файла
Эльф файл состоиз из:
- заголовка эльфа
- таблицы заголовков сегментов - заголовки сегментов просто идут один за
  другим, пока не кончатся. Их колчичество зависит от того, на сколько
  сегментов компилятор поделил код программы
- сам код программы - его-то мы и пишем + его дополняет компилятор
  (например, разделом кода PLT/GOT, который необходим при использовании
  динамических либ)
- таблица заголовков секций - заголовки так же идут один за другим.

Секции - это тоже разннобразный код. Отличие секций от сегментов в том,
что секции меньше, они объединяются в сегменты кода. У каждой секции есть
свое назначение (как и укаждого сегмента).
В англоязычных источниках заголовки сегментов часто упоминаются как
~program header~, т.е. заголовки программ.

*** Заголовок эльфа
Это структура, которая содержит в себе информацию о
точке входа - метка ~start~ программы, -  количестве заголовков сегментов,
их размере, их смещении от начала файла, количестве загоолвков секций, их
размере, где их искать в файле и т.д.

Чтоб посмотреть заголовок эльфа, можно использовать ~readelf -h elf_filename~
*** Таблица заголовков программ
Представляет собой несколько заголовков программ (сегментов), которые
идут один за другим.
Первый заголовок этой таблицы описывает всю таблицу - сколько места
занимает, какое смещение и т.д. Заголовок такого типа может быть в файле
в единственном числе, потому что в файле может быть только одна таблица
сегментов.

Каждый заголовок представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента (загружаемый -
т.е. загрузчик загрузит его в память процесса, только для чтения и т.д.) его размере,
смещении, виртуальном адресе и т.д.

Количество заголовоков сегментов зависит от количества сегментов в
программе.
Каждый заголовок на моей архитектура занимает 56 байт.
Опираясь на эти заголовки программ, загрузчик понимает, что ему грузить,
куда и откуда, а так же какого типа этот код - он же должен выставить
атрибуты (права) страницам памяти, в которые он грузит код. Чтоб,
например, код, предназначенный только для чтения, не был воспринят как
исполняемый.

Затем идет весь код программы, который написал программист и дополнил
компилятор.

Заголовки сегментов можно посмотреть с помощью  ~readelf -l elf_filename~
*** Таблица заголовков секций
Эта таблица заголовков замыкает собой эльф-файл. Ее устройство похоже на
устройство талицы заголовков сегментов.

Каждый заголовок описывает одну секцию кода, сообщая, где она лежит в
файле, ее виртуальный адрес, тип и т.д. Как и в случае с заголовками
сегментов, есть типы заголовков, которые могут встречаться лишь однажды в
файле - поскольку код, который они описывают, может быть в файле только в
единственном экземпляре.

Например, не может быть в одном файле двух секций ~dynamic~ или двух
таблиц ~GOT~.

Заголовки сегментов можно посмотреть с помощью  ~readelf -S elf_filename~

** Какие секции и сегменты критично важны для корректной работы эльф-файла

Вообще, если секция или сегмент есть в файле, значит они нужны, компилятор абы что в
файл пихать не будет - очевидная мысль, я знаю.

Но некоторые секции и сегменты кода критически важны для правильной загрузки и
исполнения эльф-файла. Если мы во время заражения как-то неправильно
отредактируем их, то файл либо не загрузится, либо не слинкуется, либо
завершит исполнение сегфолтом.

Критически важна информация, содержащаяся во всех заголовках: в
заголовках секций, сегментов и самого эльфа. Как было уже сказано выше,
именно из них черпается информация, каким образом следует разместить эльф
в памяти.

Если наш эльф файл собран с без каких-либо библиотек, например, он
написан на ассмеблере, и ему не требуется ~libc~, которая обеспечивает
корректный старт любой сишной программы, то корректного редактирования
заголовков будет достаточно, чтоб правильно оформить вставку кода
вируса.

Но если файл собран с либами, то все становится значительно веселее,
потому что в игру вступает линкер, механизм PLT/GOT и "ленивое" (или нет,
если выставить соответствующий флаг при компиляции программы)
связывание.

Для корректной работы линкера необходимы секции
- ~rela~ - их может быть несколько в файле
- ~dynamic~ - она бывает только одна
- ~got~ - она так же бывает только в единственном числе
- ~symtab~ - опять же в единственная и неповторимая

Секции типа ~rela~ содержат в себе информацию о ~релокейтах~. Именно
оттуда линкер берет информацию, какие символы необходимо связать, кким
образом это сделать и где будет находиться этот символ в программе -
т.е. его виртуальный адрес.
Посмотреть, как выглядит секция ~rela~ можно, использовав ~readelf -r elf_name~

Секция ~got~ - содержит в себе таблицу ~GOT~, которая содержит в себе
адреса, на которые мы переходим в случае, когда вызывается библиотечная
функция. О механизме ~PLT/GOT~ можно прочитать вот тут
http://rigidus.ru/doc/got-plt.html

Секция ~symtab~ представляет собой таблицу символов, где каждая запись -
это имя символа (название функции, переменной и т.д.) и адрес, по
которому этот символ объявлен.

Подробно о символах написано здесь
https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/
Посмотреть, как выглядит секция ~symtab~ можно, использовав ~readelf -s elf_name~

Ну и самая важная в этом списке секция ~dynamic~.
Именно из нее линкер во время загрузки (да, линкер вызывается и во время
загрузки, чтоб связать библиотеки друг с другом, например, и во время
рантайма, если у нас используется "ленивое" связывание) берет информацию,
где искать секции ~rela~, ~got~ и др. Соответственно, если информация в
секции ~dynamic~ не соответствует тому, где на самом деле расположен код,
программа завершится сегфолтом до того, как на нее фактически будет
передано управление.

Посмотреть, что находится в секции ~dynamic~ в эльфе можно, используя
~readelf -d elf_name~.

Поэтому если ваш алгоритм заражения предполагает, что код жертвы
сдвинется в файле в ту или иную сторону, то вам нужно держать в уме
называнные секции. Иначе вас ждут увлекательные часы отладки (как это
было со мной).


*** TODO описать работу линкера и релокетойв подробно, дать ссылки на используемые источники.
