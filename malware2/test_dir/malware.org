#+STARTUP: showall indent hidestars

** Устройство эльфа.
~Заголовок эльфа~ - это структура, которая содержит в себе информацию о
точке входа, количестве заголовков программ, их размере, количестве
загоолвков секций,  их размере, где эти заголовки искать в файле и еще некоторые данные.
Следом идет таблица заголовков программ (сегментов).

~Таблица заголовков программ~ - представляет собой несколько заголовков
программ (сегментов), которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую один сегмент кода. Эта
структура содержит в себе информацию о типе сегмента, его размере,
смещении, виртуальном адресе и т.д. Количество заголовоков сегментов
зависит от количества сегментов в программе. Каждый заголовок занимает 56 байт.

Затем идет весь код программы, а после него - таблица заголовков секций

~Таблица заголовков секций~ - представляет собой несколько заголовков
секций, которые идут один за другим. Каждый заголовок
представляет собой структуру, описывающую одну секцию кода. Эта
структура содержит в себе информацию о типе секции, ее размере,
смещении, виртуальном адресе и т.д.

После заголовков секций в файле ничего нет.

Все эти разнообразные виды заголовков нужны, чтоб загрузчик сразу мог
определить, какой код где находится. как должен быть использован и т.д.

Программа поделена на сегменты - это относительно большие блоки кода,
каждый из которых имеет свою функцию: некоторые сегменты содержат в себе
код программы - тип LOAD - и будут загружены в память, некоторые содержат
в себе .data, другие же вообще не будут загружены в память и содержат в
себе информацию для линкера.

Сегменты в свою очередь состоят из секций. Каждая секция так же имеет
свое назначение и свои заголовки (TODO: где?).

** Заражение

~Сжатый алгоритм заражения~

- загрузить жертву в память
- выяснить, где начинаются заголовки сегментов, заголовки секций, какое
  их количество
- найти первый сегмент загружаемого кода - он содержит в себе ~e_entry~
- найти последнюю секцию в этом сегменте кода - сразу после нее будет
  вписан вирус
- сохранить виртуальный адрес точки инфицирования
- увеличить размер заражемой секции и заражаемого сегмента на размер
  вируса
- изменить поля ~vaddr~ и ~size~ у заголовков сегментов и секций, которые
  описывают код, находящийся ниже точки инфицирования
- исправить vaddr по тому же принципу в записях symtab - таблицы, которая
  содержит в себе инфу о всех символах программы
- исправить vaddr по тому же принципу в записях секций rela - они
  содержат в себе информацию о перемещениях (TODO: раскрыть формат)
- исправить vaddr по тому же принципу в записях секции dynamic - на нее
  ориентируется рантайм линкер, который связывает библиотечные функции с
  конкретными адресами (TODO: раскрыть как)
-  заменить оригинальный e_entry на точку инфицирования, чтоб при запуске
  жертвы управление было сразу передано на мылварь
- посчитать смещение от конца вируса до оригинального e_entry - оно
  понадобится для джампа, который вернет управление жертве обратно
- создать код, который переведет управление на жертву - в буфер длиной 6
  байт вписывается e9 - опкод jmp - затем смещение до оригинального
  e_entry, и 90 - опкод nop. Этот код будет вписан вместо exit_victim -
  последняя функция, исполняющаяся в вирусе, которая обеспечивает ему
  корректный выход
- записать в зараженный файл  код жертвы от начала до точки инфицрования
- записать в зараженный файл код вируса до exit_victim (если что,
  exit_victim я переместила в конец файла вируса, так его удобнее
  редактировать. теперь он стоит перед fin_infector, который содержит в
  себе nop)
- записать код для передачи управления на жертву
- записать код жертвы от точки инфицирования до конца

~Развернутый алгоритм заражения~
Чтоб заразить жертву вирусом, нужно найти подходящий для заражения
сегмент кода и подходящую секцию. Поскольку нам надо, чтоб код вируса был
загружен загрузчиком в память - иначе он не исполнится - нам нужно
разместить код вируса в загружаемом сегменте кода - он имеет тип LOAD. А
затем в нем мы находим последнюю секцию кода и вписываем вирус сразу
после нее.
Самое простое - это найти сегмент кода, который содержит в себе e_entry -
точку входа, с которой начинается программа-жертва - и использовать его для
заражения. Данные о сегментах и секциях можно найти в их заголовках. Для
поиска заражаемого сегмента и секции нам понадобятся виртуальные адреса,
с которых начинается код, который они описывают.

Вписывая вирус сразу после подходящего сегмента, мы как бы расширяем его
и его последнюю (NB: почему последнюю?) секцию. Поэтому нужно отредактировать их заголовки,
увеличив поля, в которых содержится информация о размере описываемого
кода - в заголовке сегмента это поля p_memsz и p_filesz, а в заголовке
секции это поле sh_size. Тогда нам не придется создавать отдельный
заголовок для кода вируса и мучиться, вписывая его в таблицу заголовков.

Теперь мы сталкиваемся с необходимостью сместить весь код, который
находится в жертве после точки заражения - конца заражаемого сегмента,
куда будет записан вирус - иначе код будет затерт, а файл "сломается".

Физически переместить код нетрудно - при пересборке эльфа достаточно
просто его вписать после вируса. Но мы помним, что мало просто вписать
код, надо еще оставить информацию загрузчику, где его искать. А значит,
нужно отредактировать заголовки сегментов и секций, которые описывают
код, находящийся после точки заражения. В этих заголовках нужно
отредватировать поля, содержащие в себе информацию об адресе и смещении
кода.

Как найти сегменты и секции, которые лежат после точки заражения? Можно
было бы искать их только по виртуальным адресам. Идея простая: если
виртуальный адрес в заголовке меньше, чем виртуальный адрес заражаемой
точки, то заголовок редактировать не нужно - код, описываемый им,
находится выше точки заражения.
Выглядит очень логично, но на самом деле этот подход вызывает
труднотлаживаемые ошибки.
Дело в том, что у нас есть сегменты и секции, которые в память процесса
не загружаются, они нужны только линкеру и загрузчику для построение
образа процесса в памяти. Поэтому адрес у них нулевой, а вот смещение
есть. В результате эти заголовки никогда не будут отредактированы, а
загрузчик, проходя по старым смещениям, будет видеть совершенно не тот
код, что должен был бы. Можно провести пару увлекательных вечеров,
пытаясь понять, почему в бинарном файле заголовки есть и находятся там,
где мы ожидаем их увидеть,и данные в них совершенно правильные, а
~readelf~ - утилита для парсинга эльф-файла - будет сообщать что не может
найти то одну секцию, то другую.
Поэтому на этапе мы проверяем и смещение, и виртуальный адрес.

Завершив редактирование заголовков, нужно отредактировать поле ~e_shoff~
в заголовке эльфа и указать ему новое смещение, по которому лежат
заголовки секций. В противном случае загрузчик будет искать их по старому
смещению и никогда не найдет.

~Алгоритм зараджения2~

Отличие от первого алгоритма состоит в том, что вирус пишется не в первый
сегмент кода жертвы, а конец, сразу перед заголовками секций.
Тогда понадобистя оформлять вирус как отдельный сегмент кода, для
которого нужно создать и вставить свой собственный заголовок сегмента и
заголвок секции.

Что этот способ заражения?
Понадобится вставить заголсоов сегмента - поэтому все части кода жертвы
съедут равномерно. Это значит, что секция got будет находиться от секции
plt на том же удалении, что и до заражения, и не придется редактировать
скомпилированный код plt - внутри него мы совершаем прыжки на записи
внутри got. Если вирус вставить в первую секцию кода, то расстояние между
plt и got становятся больше и смещения для относительных джампов внутри
plt перестают работать корректно.

~Сжатый алгоритм заражения2~

- загрузить жертву в память
- выяснить, где начинаются заголовки сегментов, заголовки секций, какое
  их количество, где начинается код жертвы и сколько места занимает
- найти первый сегмент кода (у него будет нулевое смещение в файле),
  выяснить его виртуальный адрес - так можно понять, с какого
  виртуального адреса начинается эльф
- посчитать и сохранить виртуальный адрес точки инфицирования -
  виртуальный адрес сегмента кода с нулевым смещением + смещение таблицы
  заголвоков секций. Этот адрес понадобится как новый e_entry, а так же
  как виртуальный адрес новой секции кода, который будет вписан в новые
  заголовки.
- содать новый заголовок сегмента (возможно вставить его последним в
  таблицу заголовков сегментов ?)
- создать новый заголовок секции  (аналогичный вопрос)
- отредактировать смещения и адреса во всех остальных заголоков секций и
  сегментов - увеличить их vaddr и смещения на размер вставляемого
  заголовка для вируса (56 байт)
- по этому же принципу исправить все зависи в symtab, rela и dynamic.
- заменить оригинальный e_entry на точку инфицирования, чтоб при запуске
  жертвы управление было сразу передано на мылварь
- посчитать смещение от конца вируса до оригинального e_entry - оно
  понадобится для джампа, который вернет управление жертве обратно
- создать код, который переведет управление на жертву - в буфер длиной 6
  байт вписывается e9 - опкод jmp - затем смещение до оригинального
  e_entry, и 90 - опкод nop. Этот код будет вписан вместо exit_victim -
  последняя функция, исполняющаяся в вирусе, которая обеспечивает ему
  корректный выход
- изменить поле e_shoff в заголове эльфа жертвы - указать новое смещение
  до таблицы секций (старое смещение + размер вируса)
- записать в зараженный файл код жертвы от начала до конца таблицы
  заголовков сегментов
- записать новый заголовок сегмента для вируса
- вписать код жертвы
- вписать код вируса о метки _exit_victim
- вписать код для передачи управления на жертву
- вписать заголовки секций жертвы
- вписать заголовок секции вируса


БОльшая часть функционала для этого заражения есть и нужно только ее
немного доработать.
Кардинальное изменение касается только генерации заголвоков для вируса.
Вирус будет состоять из одного сегмента, внутри которого будет только
одна секция, поскольку мы вписываем только код вируса, не используя
больше ничего.

~Заголовок сегмента вируса~
- 56 байт
- p_type - 4 байт, value 1 - PL_LOAD
- p_flags - 4 байта, value 1 - разрешение на исполнение
- p_offset - 8 байт, оригинальный offset до начала таблицы заголовков секций
  жертвы (можно посмотреть в заголовке хедера жертвы) + 56 байт
  (доп. заголовок сегмента)
- p_vaddr - 8 байт, виртуальный адрес располодения вируса в файле -
  оригинальный виртуальный адрес таблицы секций жертвы
- p_paddr - аналогично p_vaddr
- p_filesz - 8 байт, размер вируса в файле (_start_infector - _exit_victim)
- p_memsz - 8 байт, размер вируса в памяти
- p_allign - 8 байт, - значение 0, выравнивание не требуется

~Заголовок секции вируса~
- 64 байтa
- sh_name - 4 байта, значение - индекс в таблице строк, где строка - это
  имя секции. Поэтому мы воспользуемся тем же индексом, что и у секции
  text жертвы.
- sh_type - 4 байта, тип секции 1 (PROGBITS) - значение секции определяется
  и используется программой единолично
- sh_flags - 8 байт, value 4 - разрешение на исполнение
- sh_addr - 8 байт, виртуальный адрес располодения вируса в файле -
  оригинальный виртуальный адрес таблицы секций жертвы (такой же как p_vaddr)
- sh_offset - 8 байт, оригинальный offset до начала таблицы заголовков секций
  жертвы (можно посмотреть в заголовке хедера жертвы) + 56 байт (такой же
  как p_offset)
  (доп. заголовок сегмента)
- sh_size - 8 байт, размер вируса в файле (_start_infector -
  _exit_victim), такой же как p_filesz
- sh_link - 8 байт, значение - 0 (подсмотрено в выводе ридэльфа вируса)
- sh_info - 8 байт, значение 0
- sh_addralign - 8 байт, - значение 0, выравнивание не требуется
- sh_entsize - 8 байт, - значение 0, код не содержит никаких записей
  фиксированного размера

~Редактирование записей GOT~
Зачем?
Дело в том, что хотя весь код жертвы, включаяя секции PLT и GOT сместятся
на одно и то же расстоние - 56 байт (размер вставляемого заголовка
сегмента вируса) - механизм работы PLT/GOT будет нарушен.
Внутри секции PLT находится позиционно независимый код, который при
первом вызове функции из библиотеки сначала отправится в соответствующую
запись таблицы GOT - косвенный джамп - и поскольку внутри этой записи
находится адрес следующей инструкции за джампом в секции PLT, нас выкинет
обратно в PLT, который затем запустит линкер, который впишет в запись GOT
адрес, по которому лежит искомый библиотечный код.
Так происходит в норме. Но из-за того, что весь код сместился, а внутри
GOT прописаны абсолютные адреса, то при первом вызове библиотечной
функции GOT перенаправляет джамп не обратно в PLT, а туда, где PLT был до
заражения, что, естетсвенно, вызывает сегфолт.
Поэтому все записи внутри GOT, которые представляют собой просто адреса,
идущие друг за другом, нужно отредактировать, увеличив на 56 байт.

Самое трудное - это найти таблицу GOT. Хотя в спецификации написано, что
GOT, как не странно, должна быть в секции .got, на моей машине это не
так, например. У меня GOT  находится в секции got.plt, а секция .got
занимает всего 8 байт и заполнена нулями. Это затрудняет поиск GOT, но
не делает его невозможным. Дело в том, что где бы не лежал GOT, как бы не
называлась его секция, информация о местоположении GOT обязательно будет
прописана в одной из записей секции .dynamic - и этой информации можно
верить на 100%, поскольку рантайм-линкер ищет GOT используя именно
.dynamic. Найти запись dynamic, которая содержит информацию о GOT, можно
по типу этой записи - это тип 3.

Проблема заключается в том, что в секции .dynamic указан виртуальный
адрес GOT, а нам нужно узнать, где GOT находится в файле физически.

Для этого мы берем виртуальный адрес GOT, ищем заголовок секции, который будет
описывать код с таким же виртуальным адресом, и берем смещение оттуда

Еще нам надо еще узнать размер GOT - так мы сможем вычислить
количество записей в ней.

После того, как GOT найден, редактируем все его записи.

** Проблема с инициализацией стека для жертвы

После того, как вирус отработал, он возвращает управление жертве, в ее
оригинальный _start. Поскольку мы выполняем косвенный джамп, то неважно,
что метка _start сместилась на 56 байт - соотношение между ней и точкой
инфицирования не изменилось.

Внутри _start жертва вызывает __libc_start_main@plt. Эта функция должна
настроить стек для программы (и не только).Почитать о ней (в 32 разрядной
системе) можно здесь:
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

А сорцы вот здесь
https://code.woboq.org/userspace/glibc/csu/libc-start.c.html

Проблема в том, что у меня стек недонастраивается, где-то на полпути libc
переходит по не тому адресу, которому нужно, и я оказываюсь где-то в
функции main. При попытке корректно ее покинуть  - через ret - я
сталкиваюсь с сегфолтом, потому что никакого адреса возврата просто нет
(либо он некорректен).

Скорее всего релокейты внутри библиотеки или внутри эльфа настраиваются
линкером неверно.

При этом интересно, что при выходе из линковки, перед передачей
управления программе, линкер вписывает свой адрес в запись GOT, чтоб было
что вызвать, когда программа решит вызвать сишные либы. Так вот в
зараженном файле этот адрес оказывается ровно в той же записи, что и в
незараженном. Иными словами, линкер верно распознает, где лежит GOT и
правильно считает адрес записи, в которую надо положить свой адрес, хотя
GOT смещена на 56 байт из-за добавленного заголовка сегмента вируса.

[NB] Следует написать на это тест (например в .gdbinit), а потом
разобраться как именно он это делает и сломать этот тест (например
изменением соответствующей релокации).

Вторая интересная деталь: если заразить жертву вирусом, но управление ему
не передавать, а потом открыть жертву под гдб, поставить бряк перед
вызовом __libc_start_main@plt и вручную исправить адреса в rdi, rcx и r8,
увеличив их на 56 байт, то сегфолт наступает внутри __libc_csu_init -
этот код вызывается ближе к концу __libc_start_main@plt. А в случае,
когда вирус запускается первым, а только потом передает управление на
жертву, __libc_start_main@plt выкидывет меня в main жертвы раньше, чем
управление доходит до __libc_csu_init.

[NB] Как я могу это воспроизвести?

Есть идея, что если б проблема была исключительно в релокейтах, то
сегфолт наступал в одном и том же месте, т.е. до __libc_csu_init.

[NB] Почему это предположение - верное?

__libc_start_main@plt принимает параметры:
- RDI - виртуальный адрес main
- RSI - кол-во аргументов main (?)
- RDX - указатель на аргументы (?)
- RCX - виртуальный адрес __libc_csu_init (выяснить, что оно делает)
- R8 - виртуальный адрес __libc_csu_fini (выяснить, зачем оно)

Проблема #1:
Виртуальные адреса названных разделов программы берутся не из заголовков
или из каки-то секций. Внутри _start выполняются инструкции вида
~mov $адрес регистр~, а поскольку все сместилось, то адреса уже
неактуальны. Следовательно, надо редактировать скомпилированный код
жертвы, чтоб адрес стали корректными. С учетом того, что жертва может
вообще не использовать никакие библиотеки (как наш вирус), то придется
сначала проверять, использует ли жертва динамическую линковку - если нет,
то у нее не будет раздела .dynamic, - затем искать в ней по сигнатуре или
иным способом нужные нам команды и редактировать их.

При этом, отладка под гдб, во время которой адреса были вручную заменены
на актуальные, показала, что отредактировать адреса - это еще полбеды,
настройка стека все еще не работает. Теоритически, можно детально
разобраться, как работает все внутри, но нет гарантии, что не
используется еще какой-то вкомпилированный код, который тоже придется
редактировать.

~Возможное решение~
Поэтому есть идея вообще не настраивать стек для жертвы, а предоставить
ей стек вируса, который уже настроен. Стек вируса на данный момент
занимает 6 тыс байт, технически, мы можем увеличить его до 10 тыс и
надеяться, что этого жертве хватит.

Для этого надо решить несколько проблем.

~Если жертва использует линамическую линковку~
В этом случае нам нужно:
- найти main (интересно, как, на него не указывает просто ничего в заголовках)
- передать управление ему, после того, как вирус отработает
- затем после того, как жертва отработает, заставить ее корректно выйти

При динамической линковке выход обеспечивается инструкцией ret, но при
ненастроенном стеке это вызовет сегфолт, поэтому нужно вызвать прерывание
и таким образом выйти.

Вместо того, чтоб искать конец кода жертвы и редактировать его вручную,
мы вызовем main инструкцией call, которая положит адрес возврата на
стек. А сразу за ~call main~ последует код, который обеспечит вызов
соответствующего syscall. Поэтому кода main выполнит последний ~ret~, она
возьмет адрес возврата со стека и перейдет на код, который обеспечит ей
корректный выход.

~Если жертва не использует никакие библиотеки~
В этом случае делаем почти то же, но только main не ищем, а передаем
управление на _start. И делаем это не с помощью call, а с помощью jmp.

Почему заменяется call на jmp?
Потому что если жертва скомпилирована без либ, то она настраивает себе
стек сама (либо он ей вообщей не нужен) и обеспечивает корректный выход
сама. А следовательно, если мы вызовем ее через call, то на стеке
останется адрес возврата, который никогда не будет взят, и следовательно
по выходу из программы стек останется несбалансированным.

Понять, использует жертва динамичекую линковку или нет, может понять по
наличию секции dynamic, которая необходима линкеру.
Если ее нет, то линкер не вызывает, следовательно, динамическая линковка
не используется.

** Решение
К сожалению, мой компилятор генерирует позиционно-зависимый код. Пока что
это оказало влияние только на _start и настройку стека, но неизвестно,
где может выявиться еще. Тем более, что заражать мы планируем любые
файлы, а не только текущий. А урегулирование всех ссылок - это слишком
трудоемкий процесс, чтоб в него ввязываться. Поэтому нам нужно сделать
так, как будто заражения не было вообще и код жертвы никуда не
сдвигался.

UPD:
Это единственное возможное решение. Исследование работы линкера и
libc_start_main показало, что вся проблема заключается в
позиционно-зависимом коде, который генеирует моя версия компилятора.

Перед тем, как передать управление на жертву, нужно сдвинуть ее в памяти
на 56 байт.

Надо помнить один важный нюанс: вирус в будущем будет исполняться в одном
зараженном файле, а пытаться заразить - другой файл.
Т.е. "данные жертвы", которыми он будет располагать в момент своего
исполнения - адрес в памяти, кол-во заголоков, размер кода и т.д. - это
данные не той жертвы, где он исполняется, а той, которую пытается
заразить. Только на этапе тестирования это по факту один и тот же файл,
но в "дикой природе" это не так.

По факту, когда вирус исполняется в зараженной жертве, он снова о ней
ничего не знает.
А нам нужно узнать:
- виртуальный адрес dynamic
- сколько в ней записей
- виртуальный адрес symtab
- сколько в ней записей
- где начианется код жертвы (ее оригианльй e_entry + 56 байт)
- размер кода жертвы

Зачем нам dynamic и symtab?
Дело в том, что если не откорректировать записи внутри dynamic, то линкер
просто не запустится корректно - вернее, не найдет секции, которые ему
нужны, а если не отредактировать symtab, то код жертвы начинает
интерпретироваться некорректно. При том, что и с редактррованием symtab и
без, указатель на код жертвы и размер этого кода не меняется - проверено
под gdb - в зараженном файле видно, что если symtab не отредактирован, то
код жертвы съезжает, в результате чего e_entry жертвы оказывается не в
том месте, где мы ожидаем его увидеть - и мы ловим сегфолт.

Все данные известны нам на этапе зараения жертвы, но не этапе исполнения
вируса внутри нее. Поэтому есть такой вариант:
- вручную с помощью опкодов, используя имеющиеся данные о жертве на
  этапе ее заражения, создать блок кода, который выполнит пересчет
  записей внутри секции dynamic и symtab "обратно" и подвинет жертву в памяти на
  прежние адреса
 Фактически это значит создать блок позиционно-зависимого кода, который
 будет свой для каждой зараженной жертвы.

Чтоб все это перезаписать, понадобится memcpy и разрешить жертве себя
модифицировать - т.е. вызвать mprotect.

Разрешить самомодификацию сразу всей жертве не удастся - сегменты лежат
на разных страницах памяти, а между ними страницы, для которых не
разрешены вообще никакие атрибуты (и не могут быть разрешены)
Поэтому нужно разрешать самомодификацию для каждого загружаемого сегмента
отдельно.
Для этого:
- находим заголовки сегментов в памяти
- проходимя циклом по заголовкам сегментов, находим каждый загружаемый
  сегмент кода
- считаем адрес, по которому лежит сегмент кода, считаем где сегмент
  заканчивается, выравниваем адрес начала сегмента
- вызоваем mprotect
Повторяем до тех пор, пока все заголовки загружаемых сегментов кода не
закончатся.

Как найти адрес заголовков сегментов в памяти?
На этапе заражения считаем смещение оригинального e_entry от начала
эльфа. Запоминаем его. Во время исполнения вируса внутри зараженной
жертвы загружаем адрес метки _start (загрузится адрес актуального _start
жертвы), вычитаем из этого адреса смещение до первого сегмента и получаем
таким образом адрес начала эльфа.

В начале эльфа лежит его заголовок. Узначем оттуда смещение до
заголовоков сегментов и их количество.
Складываем адрес со смещением - и вот у нас адрес, по которому лежит
таблица заголовков сегментов.

Дальше можно запускать цикл mprotect.

Как посчитать адрес, по которому лежит конкретный сегмент?
Адреса могут быть изменены загрузчиком. Поэтому мы:
- берем виртуальный адрес первого загружаемого сегмента - он же
  виртуальный адрес начала эльфа (мы его сохранили на этап заражения)
- берем любой заголовок загружемого сегмента кода
- читаем его виртуальный адрес
- вычитаем виртуальный адрес начала эльфа из виртуального адреса сегмента
  кода
- вуаля, мы получили смещение В ПАМЯТИ от начала эльфа до сегмента кода
- складываем это смещение с адресом начала эльфа В ПАМЯТИ

И вот так получаем адрес, по которому лежит интересующий нас сегмент в
памяти.
Да, в заголовке сегмента указано смещени. Но это смещение в файле, в
памяти оно будет другим. Так что придется таким хитрым способом считать
адрес.

Итого код, который сдвинет жертву на прежние адреса, должен делать
следующее:
- пересчитать записи внутри секции dynamic
- пересчитать записи внутри секции symtab
- взять оригинальный e_entry и начиная с него с помощью memcpy переписать
  весь код жертвы, начиная с его e_entry в зараженном файле

Затем передать управление на саму жертву

- вписать вирус от начала до exit
- вписать в передачу управления call move_victim
- в move_victim вписать "сдвиг" жертвы

~Дополнение~.
Мало только сдвинуть жертву, есть новая проблема.
Когда мы вставляем новый заголовок для вируса, весь код жертвы смещается
на 56 байт. Это вынуждает нас редактировать записи в секции динамик -
если этого не сделать, то при загрузке программы линкер не найдет данные,
которые ему нужны,и загрузка не произойдет.

На этапе загрузки линкер читает секцию динамик, устанавливает связи между
библиотеками, а на финальном этапе кладет в запись GOT свой адрес, чтоб
можно было его вызвать, когда он понадобится для вызова сишных
библиотечных функций. Но как оказалось, линкер редактирует под себя не
одну запись в GOT, а две: во вторую он кладет адрес буфера, в которые он
сложил адреса интересующих его записей из секции динамик, чтоб не читать
ее всю второй раз.

Казалось бы, в чем проблема?
Дело в том, что после того, как вирус отработает, мы редактируем записи в
секции динамик и сдвигаем жертву обратно на ее старые адреса.
И раз весь код сдвинулся, то записи в буфере линкера стали
неактуальными.
В результате, опираясь на старые данные,
линкер не может вызвать ни одну сишную функцию и выдает сегфолт.

Как с этим бороться?
- Не редактировать записи внутри динамик на эатпе заражения нельзя -
  иначе не пройдет загрузка программы
- Отредактировать буфер внутри линкера тоже не получится - записи из
  динамик перемежаются с другими данными и распределены неравномерно,
  т.е. нельзя сдвигать указатель на какое-то фиксированное значение и
  редактировать запись за записью.

Поэтому есть идеия избавиться от "ленивого" связывания как такового - мы
можем сообщить линкеру, что хотим связать все сразу, выставив флаг
DT_BIND_NOW, если он еще не выставлен. Тогда линкер свяжет все
библиотечные вызовы с их реальными адресами при загрузке программы, и
жертву можно будет сдвинуть безболезненно.

Есть одна возможная проблема - если этот флаг не был включен при
компиляции, то скорее всего специальная запись для него в секции DYNAMIC
отсутствует. Поэтому ее придется добавить - а это означает, что придется
расширить секцию dynamic, что, в свою очередь, нарушит соотношение между
сегментами кода жертвы - а значит даже позиционно-независимый код
сломается.

Поэтому придется не просто сдвигать весь коджертвы равномерно на 56 байт
вверх, а дополнительно сдвигать участок кода после динамик таким образом,
чтоб "лишняя" запись была затерта.

Кто видел вывод секции динамик с помощью readelf заметил, что в секции
есть запись NULL - она заполнена нулями и стоит последней в списке
записей. Так почему бы не использовать ее вместо того, чтоб городить
новую запись и иметь такой геморрой?

Запись NULL - обязательная для каждой секции dynamic. Если ее не будет,
то файл не загрузится корректно - я думаю, что она служит для линкера
указанием, что секция кончилась, больше ничего читать не надо.

Чтоб вставить дополнительную запись в dynamic, нужно:
- убедиться, что такая секция есть
- убедиться, что в этой секциии уже нет записи BIND_NOW
- запомнить смещение относительно начала секции dynamic, по которому
  будет лежать дополнительная запись
- вычислить размер кода жертвы от начала и до вставляемой записи BIND_NOW
  и размер кода жертвы от вставляемой записи до BIND_NOW, сохранить
  указатели на два эти куска кода (это понадобится, чтоб записать код
  жертвы в зараженный эльф, вставив между двумя частями новую запись)
- добавить при пересчете всех заголовков, записей в секции got, dynamic,
  rela, symtab условие, что если код будет находиться ниже секции
  dynamic, то он будет смещен на дополнительные 16 байт (ведь секция
  dynamic расширится на размер записи)
- расширить секцию dynamic - для этого отредактировать ее заголовок и
  заголовок ее сегмента
- сгенерировать новую запись
- записать все в заражаемый эльф


При этом не забывать обрабатывать кейсы, когда:
- запись BIND_NOW уже есть (тогда ничего вставлять не надо)
- жертва собрана без либ, поэтому секции dynamic в ней нет в принципе -
  следовательно, вставлять опять нечего

Можно испугаться от количества ветвлений, которых приется реализовать в
коде. Например, прибавлять размер добавляемой записи к константе, на
которую сдвигаются все адреса и смещения жертвы, или нет.
Но есть один способ:
Мы вводим переменную, которая называется
~new_bind_now_flag_record_size~ - как не странно, она хранит в себе
размер добавляемой записи. По умолчанию в этой переменной нули - и только
в случае если запись действительно будет добавлена (а мы понимаем это,
исследуя секцию dynamic) в эту переменную будет положен размер записи.
Что нам это дает?
А то, что нам во всех функциях, которые пересчитывают смещения и адреса в
разных кусках кода жертвы, не надо проверять, вставляем мы запись
дополнительно или нет - мы по умолчанию прибавляем ко всем и смещениям и
адресам, находящимся ниже секции dynamic, содержимое
~new_bind_now_flag_record_size~. Просто если запись BIND_NOW по какой-то
причине добавляться не будет, то эта переменная так и будет содержать
ноль. Таким образом можно не плождить энное количество ветвлений.

При сдвиге жертвы нам нужно учитывать тот факт, что
- жертва может быть собрана без либ (тогда ничего не двигаем)
- в зараженной жертве может быть запись BIND_NOW, которой изначально
не было.

Поэтому в блок данных жертвы мы помещаем смещение новой записи от секции
~dynamic~ - это будет содержимое переменной
~new_bind_now_flag_record_size~.
По той же схеме усовершенствуем функции, которые сдвигают нашу жертву -
просто будем сдвигать на содержимое ~new_bind_now_flag_record_size~
все,что ниже секции ~dynamic~ - если в ~new_bind_now_flag_record_size~
будет 0, то нам это картину никак не испортит.

** Загрузка эльфа в память

Ошибка "elf_machine_runtime_setup (profile=0, lazy=1, l=0x7ffff7ffe168)
at ../sysdeps/x86_64/dl-machine.h:86
../sysdeps/x86_64/dl-machine.h: Нет такого файла или каталога"

Из-за записи вируса в файл, я вынуждена сместить остальной код жертвы на
размер вируса, в противном случае он будет затерт. Из-за этого смещения
возникает данная ошибка.

Если заражать жертву, которая не использует динамическую линковку, то
жертва исполняется после заражения без проблем. Так же если просто
скопировать код жертвы в другой файл - так же переписывая его по кускам,
как при заражении - данная ошибка не возникает. Следовательно, проблема
именно в смещении кода, начинающегося с точки заражения.

~Решение ошибки~
Развернутое объяснение см. ниже.
Сжатое объяснение:

Сегфолт происходит на этапе рантайм-линковки. Это видно по выводу gdb  -
~dl_relocate_object~, внутри которого происходит сегфолт, является частью
либы dl_reloc.c (сорцы
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html ), в частности
_dl_relocate_object (сорцы здесь
https://code.woboq.org/userspace/glibc/elf/dl-reloc.c.html#_dl_relocate_object)

dl_reloc перемещает разделяемый объект и разрешает ссылки -
т.е. заполняет их адресами - на другие разделяемые объекты.

Сегфолт происходит потому, что линкеру необходима информация о
расположении GOT и некоторые другие данные. Проблема в том, что сведения
о расположении эьих данных линкер берет не из заголовков секций, из
секции .dynamic, ведь заголовки  Если не отредактировать данные в ней, то линковщик будет
искать GOT по старому адресу, что вызывает сегфолт.

Следовательно, надо отредактировать записи в секции .dynamic - если
виртуальный адрес кода, описываемый записью, больше виртуального адреса
точки заражения, значит данный код находится ниже точки заражения и
следовательно виртуальный адрес должен быть увеличен на размер вируса.

Полагаю, что так же надо отредактировать записи в rel_name и symtab. В
symtab хранится информация о символах - функциях и переменных - в
частности, виртуальные адреса, по которым они расположены, а в rel_name
хранится информация о перемещениях - думаю, это связано с работой
линковщика - следовательно, виртуальные адреса в этих записяз надо
исправить тоже.

~Загрузка эльфа~
Процесс загрузки эьфа управляется функцией load_elf_binary() ( файл
binfmt_elf.c, сорцы здесь
https://elixir.bootlin.com/linux/latest/source/fs/binfmt_elf.c ). Это и
есть загрузчик, который должен правильно отобразить программу в память.

~load_elf_binary()~
- начинает чтение эльфа с его заголовка
Из него он берет смещение до таблицы заголовков сегментов, смещение до таблицы
заголовков секций и др. данные
- затем читает заголовки сегментов
Ищет среди него заголовок PT_INTERP и заголовок GNU_STACK. GNU_STACK
содержит информацию о стеке, а PT_INTERP - о рантайм-линкере, который должен быть
использован для этого бинаря.

Теперь можно начать подготовку для непосредственной загрузки программы в
память.
Для этого нужно:
- очистить состояние ядра, которое ссылается на предыдущую выполненную
  программу (что бы это ни значило) (NB: может это программа после форка?)
- убить потоки, связанные с предыдущей программой. Новая всегда
  начинается в одном потоке.
- указать новое местоположение  - метоположение текущего исполняемого
  файла
- очистить виртуальную память от предыдущей программы
- закрыть файловые дескрипторы, оставшиеся от сратой программы

После этого настраиваем виртуальную память для новой программы.
Устанавливаем новую вершину стека - обычно смещается вниз на случайное
значение, это усложняет атаки на переполнение стека (если не знаешь, где
будет вершина, труднее переполнить).
Затем проходимся по всем сегментам PT_LOAD и отображаем их в память,
составляя макет памяти новой программы. Затем устанавливает страницы BSS,
заполненные нулями (неинициализированные данные).
На финальном этапе загрузки устанавливается база стека.

Теперь про ~линковку~

Большинство файлов слинкованы динамически - т.е. когда компилятор
проходится по файлу и находит вызов библиотечной функции, он оставляет
пометку, что это пространство в будущем должено быть заполнено вызовом
библиотечной функции, а сам код библиотеки в бинаре не присутствует.

Чтоб код корректно исполнялся, нужен рантайм линкер. Он задается в
заголовк PT_INTERP, в моем случае это  ld-linux-x86-64.so.2. После того,
как процесс загрузки программы завершился, вызывается
~load_elf_interp()~, который загрузит код линкера в память. Затем
срабатывает системный вызов ~execve()~ - он разрешает программе
выполняться. Но выполнение начинается не с самого эльфа, а с его
линкера - поэтому он и рантайм, потому что работает во время
исполнения. Рантайм-линкер должен позаботиться о загрузке библиотек,
разрешении неопределенных символов программы до правильных определений в
этих библиотеках и т.д.

Конечная цель линкера - это заполнение GOT смещениеями до библиотечных
функции. Но фишка в том, что он берет информацию о том, где находится GOT
не из заголовков секций, а из секции .dynamic, которая находится в
разделе DYNAMIC. . Соответственно, если не
отредактировать записи в ней, то линкер будет искать GOT и другие данные
по старым адресам, где на самом деле ничего нет. Что и приводет к
сегфолту скорее всего.

Теперь о том, самом механизме ~PLT/GOT~.
Неизвестно, по какому адресу будет загружена динамиеская
библиотека. Соответственно, нельзя предугадать, где какая функция будет
лежать.
Поэтому и нужен механизм PLT/GOT, цель которого - это перенаправить
вызов библиотечной функции так, чтоб вызвался библиотечный код, а не
какая-то чушь.

Если описать механизм совсем грубо, то получится следующее:
GOT представляет собой таблицу смещений, которая должна быть заполнена
смещениями до кода вызываемой функции. А PLT представляет собой таблицу,
которая содержит в себе код, который и вызовет библиотечную функцию, используя
смещение из таблицы GOT. У каждой библиотечной функции есть запись в GOT,
между ними установлено соответствие.

Теперь к деталям.
В основе заполнения таблицу GOT лежит так называемое "ленивое"
связывание. Ленивое оно потому, что мы заполняем записи GOT не для всех
вызываемых функций сразу, а только тогда, когда они будут вызываны.

Например, в нашем коде дважды вызывается ~printf~.
Когда ~printf~ вызывается в первый раз, то plt записывает
смещение (адрес), по которому находится библиотечный код, в GOT, пушит индекс
перемещения - он нужен линкеру для работы (TODO: скорее всего связан с записями
перемещений в соответствующей секции rel_dyn или rel_plt, уточнить), а
затем вызывает линкер, чтоб тот установил связывание - этим занимается
~_dl_runtime_resolve_xsave~ из файла ~dl-trampoline.h~

Когда ~printf~ вызовется второй раз, то мы просто сделаем ~jmp~ на адрес,
находящийся в записи GOT.

Подробно и с картинками этот  механизм описывается здесь:
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html


Опытным путем выяснилось, что мало поправить заголовки, данные внутри
rela, dynamic и symtab.
Скорее всего придется исправлять смещения для команд jmp внутри секции
plt. Внутри каждого из фрагментов кода plt, которые отвечают за
связывание библиотечной функции и GOT, есть относительный jmp на
соответствующую запись в GOT.
Проблема в том, если код смещается - а у нас он смещается - то старые
смещение перестают работать и попытка прыгнуть на адрес по старому
смещению оборачивается сегфолтом.

Поэтому надо либо отредактировать смещения "вручную", увеличив каждое из
них на размер вируса (NB: выглядит просто?), либо найти, какие секции отвечают за эти
смещения. Но скорее всего никакие, потому что это уже скомпилированный
код, ничто его во время линковки или загрузки не модифицирует,
следовательно, никакие секции или заголовки не должны быть связаны с
этими смещениями.

** Символы и релокейты
Почитать о символах можно здесь
https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/

А о релокейтах - здесь
https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/

В процессе разработки программы мы используем имена для функций и
переменных - т.е. символы. А компилятор должен сгенерировать код, который
превратит символьную ссылку в смещение или адрес, где можно найти
значения для этого символа. Все символы вместе называются символической
информацией.

Символы нужны для:
- удобства разработки (очевидно)
- отладки (у компилятора есть возможность экспортировать символы в ELF
  файл, а у эльфа есть таблицы символов, позволяющая эти символы хранить)
- для линковки (чтоб связать символ с новым значением, надо знать, где
  этот символ находится)

Символы хранятся в таблице символов.
Таблиц символов в эльфе может быть максимум две - это symtab и dynsym.
Dynsym содержит в себе символы, которые ссылаются на объекты, необходимые
для линковки. А symtab содержит в себе вообще все символы, которые
используются в текущем файле.

Каждая запись в таблице символов представлена в виде структуры,
которая описывает 1 символ.
Структура содержит в себе информацию о имени символа, его значении,
размере, типе, типе связывания (аттрибуте), видимости символа и индек
заголовка секций в таблице секций, поскольку каждый символ ассоциирован с
секцией, где он определен.

- Имя - здесь все понятно.
- Тип символа - это то, какого рода код этот символ обозначает: секцию,
переменную, функцию и т.д.
- Размер - сколько места занимает сам символ
- Тип связывания (в англоязычных источниках это называется атрибут,
можно долго ломать голову, что имеется ввиду)
Эта информация очень нужна при линковке. По ней будет определяться
поведение, если ссылка на этот символ обнаружится в другом объекте
(сегменте программы?).
Есть несколько типов связывания, но самые основные - это LOCAL и GLOBAL
Если атрибут LOCAL, то символ не будет видел за пределами эльфа, внтури
которого он определяется. Если GLOBAL, то символ будет виден всем.
- Видимость символа - определяет доступ к символу после того, как он
  был определен. Можно ли его перезаписывать, видим ли он вообще за
  пределами своего файла и т.д.
В чем тогда разница между типом связывания и видимостью?
Видимость символа зависит от того, как объект, на который ссылается
символ был скомпилирован. В то время как тип связывания используется при
линковке и зависит от самого объекта, на который ссылается символ.
- Индекс заголовка секции - здесь все понятно.

Теперь про релокейты и их связь с символами.
Собственно, релокейты - это связь символа с его объектом, на который он должен
ссылаеться.
Компиляция файла происходит в несколько этапов в результате чего мы
получаем исполняемый файл. Но до этого мы получаем промежуточное
представление - объектный файл, он же object file или elocatable object
file  в англоязычных источниках. Фалй такого типа содержит в себе всю
необходимую информацию - машинный код и т.д., но ссылки и адреса в нем
еще не заполнены. Тогда на хаключительном этапе компиляции - линковке -
линкер соединяет ссылками символы и объекты.

Некоторые объекты немозможно соединить ссылками сразу на этапе
компиляции - это касается использования динамических библиотек, поскольку
мы не знаем, по какому адресу они будут загружены в момент исполнения
программы. Эти ссылки остаются незаполненными и тогда на этапе исполнения
включается рантайм-линкер и дозаполняет их (см. PLT/GOT).

Если открыть symtab (readelf -s elf_file_name), то мы увидим, что адреса
у некоторых символов отсутствуют - это и будут символы, чей код определен
в библиотеке, которая еще не загружена, а потому символы с объектами не
связаны.

А если открыть содержимое секций rela (readelf -r elf_file_name), то мы
увидим в каждой записи следующую информацию:
- смещение - адрес (в моем случае), по которому дожно быть записано
  значение символа, т.е. адрес объекта, на который он должен ссылаться
- инфо - см. спецификацию
- тип - см. спецификацию
- значение символа - адрес, по которому должен находиться объект,
  т.е. сама ссылка на этот объект. Заполняется на этапе рантайм линковки
- имя символа - здесь итак понятно.

Таким образом, по записям в rela линковщик узнает, каких ссылок не
хватает, и куда мы будем из писать.

Откуда линковщик узнает, где искать rela? Эта информация прописана в
секции dynamic.

~Процесс релойшена от начала до конца~
При компиляции файла мы проходим несколько стадий. Из них нас интересет
только кодогенерация и линковка.
На этапе генерируется весь код и проверяется наличие определения
(объекта) для всех используемых символов. Определения могут находиться и
за пределами текущего файла - тогда компилятор будет искать их в
указанных в файле библиотеках. Если не найдет и там - нас ждет ошибка
компиляции.
На выходе из этого этапа мы получаем объектный файл, его можно
сгенерировать как ~gcc program.c -o program.o~.
Открыв такой файл с помощью objdump-a мы видим, что в файл есть только
секция .text, .rodata, .comment и .eh_frame.
Но самое интересное в том, что вместо адресов, по которым располагаются
разделы и команды внутри них, мы увидим смещения от начала
файла. Cмещения в относительных джампах или вызовах функций будут просто
заполнены нулями, как и абсолютные адреса, которые мы кладем в некоторые
регистры с помощью ~mov~.

Затем мы превращаем объектный файл в исполняемый. Линкер заполняет все
ссылки, которые может. Но что он делает с теми, которые заполнить не
может? Они остаются до этапа рантайм-линкинга. Но дальше есть 2
варианта.

Сейчас мы используем механизм PLT/GOT, поэтому можно загрузить библиотеку
один раз и благодаря магии виртуальной памяти, при том, что она будет
загружена один раз, для разных процессов она будет лежать как будто по
разным адресам.
Если бы PLT/GOT не было, то:
- либу приходилось бы подкгружать для каждого процесса
- линкер во время компиляции предполагал бы, что либы будут размещены
  сразу за стеком, вписывал бы смещения от текущей инструкции до
  интересующего нас кода в либе
- затем рантайм-линкер получал бы базовый адрес, по которому лежит либа в
  памяти, складывал бы этот адрес с посчитанным ранее смещением и таким
  образом мы бы вызывали нужный нам код.
Но именно из-за этого механизма релокейты называются релокйтами,
т.е. перемещениями. Сначала указатель на интересующий нас код в либе
указывал куда-то за стек, а потом стал указывать туда, где лежит код на
самом деле.

Это все страшно неэффективно, поэтому есть PLT/GOT.

Загрузчик должен найти где-то внутри эльф-файла сведения о том, какие
либы ему подгрузить.
Фишка в том, что загрузчик загружает единственную библиотеку - сам
линкер, чье имя он читает из сегмента INTERPRET. А вот остальные
библиотеки подгрузит сам линкер. У меня линкер ld-linux-x86-64.so.2

[NB] Есть ли у тебя его сорцы и можешь ли ты их отлаживать?

Линкер в своей работе опирается только на секцию dynamic, которая
содержит в себе информацию о таблице символов, секции got, rela и т.д.
Сначала линкер проверяет, есть ли среди записей dynamic записи NEEDED.
Эти записи означают, что есть библиотеки, от которых зависят прочие
библиотеки, используемые в этом файле.

Сначала вызывается ~_dl_start~, которая вызывает ~_dl_main~.
~_dl_main~ вызывает ~process_envvars~, которая обработает переменные
окружения (они имеют префикс LD_, например LD_PATH).
Затем внутри ~_dl_main~ проверяются поля NEEDED в секции dynamic нашей
программы.

Поле NEEDED - это смещение (индекс) в таблице строк DT_STRTAB,
которая так же хранится в секции dynamic. По этому смещению можно
получить строку-имя библиотеки, от которой зависят прочие либы
программы.

Затем вызывается ~_dl_init_paths~, которая инициализирует поиск библиотек
по их путям, прочитанным из DT_STRTAB.
После того, как библиотеки найдены, вызывается ~dl_map_object_from_fd~
задача которой - загрузить библиотеки в память и выставить
соответствующие разрешения для них (PROT_READ, PROT_READ | PROT_WRITE и
т.д.) и обнулить их bss-секции.

После этого вызывается ~_dl_relocate_object~, которая должна выполнить
релокейты между библиотеками, заполнить ссылки в них друг на друга.

Затем каждому разделяемому объекту предоставляется возможность
инициализировать свой код. Этим занимается ~_dl_init_internal~
Естетсвенно, что мы начинаем инициализацию с разделяемых файлов, которые
сами ни от каких других файлов не зависят.
Чтоб обеспечить эту очередность, то мы рекурсивно проходим по полям NEEDED
внутри секции dynamic каждого разделяемого файла до тех пор, пока не
наткнемся на файл, у которого это поле отсутствует - это значит, что он
ни от кого не зависит. А затем рекурсия "откатывается назад" и мы
инициализируем весь прочий код в порядке его зависимости друг от друга.
Код инициализации и завершения прописан обычно в секциях init и fini
файла.

Затем линкер кладет свой же адрес в запись секции GOT, чтоб мы могли его
вызвать, когда понадобятся функции из сишных библиотек.

После этого передается управление на точку _start загруженного и
слинкованного эльфа. А дальше если внутри эльфа вызывается сишная либа,
то срабатывает механизм PLT/GOT, описанный выше.

То, как именно должны быть разрешены ссылки на библиотеки внутри самой
программы, описано записями в секциях rela.

** Старт сишной программы
После того, как линкер отработал, он передает управление на точку _start
программы.
Единственная причина, по которой исполнение сишной программы начинается
не прямо с функции main - это подготовка аргументов  и вызов
~__libc_start_main~.
__libc_start_main:
- устанавливает аргументы командной строки и окружение
- вызывает ~__libc_setup_tls~, который должен инициализировать Thread Control
  Block и Dynamic Thread Vector (что это?) [NB] Ира Бакстер отвечает:
  https://stackoverflow.com/questions/19160991/thread-control-blocks-tls-variant-2
  Также см.
  - https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-tbl-1/index.html
  - https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-10/index.html
  Все это относится к тому как рантайм си работает с потоками и их
  локальными переменными.
  По идее ты должна была найти это, т.к. первая ссылка в гугле ведет туда
- устанавливает стек
- регистрирует деструктор (это еще что?) линкера, вызывая ~__cxa_atexit~
  [NB] Деструктор — это функция С++ класса, которая выполняется при
  удалении объекта класса. В то время как конструкторы предназначены для
  инициализации объекта, деструкторы предназначены для очистки памяти
  после него. Если объект класса содержит любые ресурсы (например,
  динамически выделенную память или открытый файловый дескриптор),
  деструктор является идеальным решением, поскольку он производит
  последние действия с объектом перед его окончательным уничтожением.
  [NB] https://habr.com/ru/post/339698/ Обрати внимание на эту статью, в
  ней возможно есть ответ (про стек) на вопрос, почему у тебя зараженный
  файл падает. Статья содержит море ценной инфы, читай внимательно!
- инициализирует glibc, вызывая ~__libc_init_first~
- устанавливает ~__libc_csu_fin~, вызывая ~__cxa_atexit~
- вызывает ~__libc_csu_init~
Эта функция вызывает указатели на функции в секции .preinit (у меня,
например, ее нет) Затем должна исполнить код в секции .init программы.
Что делает код в .init зависит от компилятора, но при использовании gcc, код в .init
исполняет функции программы, обозначенные как _attribute__ ((constructor)) (in
__do_global_dtors_aux) (что это?). Затем вызывает указатели на функции в
секции .init_array
- настройка структур, необходимых для потоков
- вызывает main программы
- после того, как main отработал и код программы был исполнен полностью,
  обеспечивает корректый выход программы, вызывая __libc_csu_fini

__libc_start_main@plt принимает параметры:
- RDI - виртуальный адрес main
- RSI - кол-во аргументов main (?)
- RDX - указатель на аргументы (?)
- RCX - виртуальный адрес __libc_csu_init
- R8 - виртуальный адрес __libc_csu_fini


** Передача управления с жертвы на вирус и с вируса на жертву

Передача с жертвы на вирус простая - в эльф хедере меняем адрес в поле
e_entry с оригинального на точку инфицирования. Так управление попадет на
вирус

Передать управление обратно сложнее.
Есть фукция _exit_victim - она последней исполняется в вирусе. Она
находилась в середине файла, но я переместила ее сразу перед
_fin_infector.
Мы разрешили самомодификацию кода - технически во время исполнения вируса
можно прямо исравить код внутри _exit_victim, чтоб сразу перейти на
жертву. Но в первый раз наш вирус включается не из жертвы, а из
собственного эльф-файла, и ему нужно обеспечить корректный выход.
Поэтому при редактировании жертвы, мы впишем в нее весь код вируса до
метки _exit_victim, затем вручную впишем условный джамп, потом
_fin_infector.
Таким образом вирус корректно заверится и в первый раз своего
исполнения, и в последующие, когда будет работать из жертвы.

Теперь о том, как совершить сам прыжок на оригинальный e_entry жертвы.
jmp занимает 5 байт, код комманды - e9, остальные 4 байта занимает
смещение до адреса, на который следует совершить прыжок. Новый адрес
рассчитывается как
адрес след. инструкции + смещение = адрес для прыжка
Поскольку оригинальный e_entry будет всегда выше точки заражения,
т.е. e_entry вируса, смещение должно быть отрицательным.

Почитать об этом можно здесь. Описывается call, но jmp отличается от него
только опкодом.
https://stackoverflow.com/questions/10376787/need-help-understanding-e8-asm-call-instruction-x86

Чтоб посчитать смещение корректно, берем адрес следующей инструкции и
вычитаем его из оригинального e_entry. Получаем отрицательное смещение.

Есть одна сложность: нам надо посчитать адрес следующей инструкции так,
как будто уже находимся в зараженном файле, а не смотрим из
своего. Поэтому считаем мы смещение не от следующей инструкции в самом
вирусе, а так:
- берем точку инфицирования файла - это виртуальный адрес из файла жертвы
- мы знаем, что передача управления на жертву будет происходить в самом
  конце вируса
- поэтому vaddr точки инфицирования + размер вируса + 5 байт (столько
  заимает сам jmp )= виртуальный адрес передачи управления на жертву
  внутри самой жертвы послее еe инфицирования вирусом

NB: а еще можно вычислить нужный адрес и сделать jmp %REG

** Найти исполняемые файлы в текущей папке

Чтоб заразить какой-то файл, его надо сначала найти. Чтоб случайно не
заразить всю систему, искать будет только в текущей папке.

https://www.sanfoundry.com/c-program-list-files-directory/

** Текущий алгоритм заражения

Идея заражения предельно простая.
Вирус вписывается после кода жертвы, и в файле, и в памяти он будет
располагаться перед заголовками секций жертвы.

Почему пишем в конец?
Потому что если вирус вписать в секцию ~text~ жертвы, то соотношение
между ее секциями PLT и GOT будет нарушено, в результате чего PLT не
сможет обратиться к GOT.

Вирус оформляется в отдельную секцию кода. Отдельной секции кода
необходим заголовок сегмента и заголовок секции - в противном случае
вирус не будет загружен загрузчиком в память процесса.

Поскольку мы вставляем заголовок сегмента вируса, то весь код жертвы
будет смещен на его размер - в моем случае это 56 байт.
Таким образом соотношение между секциями жертвы не нарушается.

У этого способа есть крупный недостаток: если жертва имеет
позиционно-зависимый код (как в моем случае), то надо либо урегулировать
все ссылки в ее коде (что проблемно), либо после того, как вирус
отработает в ней, сдвинуть весь код жертвы в памяти процесса так, как
будто никакой новый заголовок сегмента вируса мы не вставляли -
т.е. сдвинуть ее на прошлые адреса.

У этого решения проблемы, в свою очередь, тоже есть недостаток, о котором
будет рассказано позднее.

~Подготовка к заражению~
1. Расрешить вирусу самомодификацию и сохранить все регистры
2. Загрузить жертву в память с помощью mmap в память

~Распарсить эльф жертвы~
1. Выяснить:
- адрес таблицы заголовков сегментов в памяти, сколько их, сколько места занимают
  суммарно, занести эту инфу в переменные
- адрес таблицы заголовков секций в памяти, сколько их, сколько места занимают
- есть ли секция ~dynamic~, если есть, то где находится, сколько места
  занимает, сохранить эту инфу в переменные
- есть ли в секции dynamic запись ~BIND_NOW~.  Если нет, то высчитать
  смещение от начала секции dynamic, куда будет вставлена эта запись (по
  умолчанию перед последней записью, она всегда будет ~NULL~),
  сохранить эту инфу и записать в переменную
  ~new_bind_now_flag_record_size~ размер вставляемоq записи. По умолчанию
  содержимое переменной 0.
  Благодаря этой переменной можно будет при пересчете заголовков и
  проч. не проверять, вставляем мы запись или нет: если редактирумый
  адрес/смещение находится ниже секции ~dynamic~, то значение
  редактируется на 56 байт + содержимое переменной
  ~new_bind_now_flag_record_size~. Если запись вставлена не будет, то
  содержимое переменной так и останется 0, в противном случае в ней будет
  размер записи. Таким образом, при любом раскладе смещения и адреса
  будут отредактрованы верно.
- есть будет вставлена запись ~BIND_NOW~, то высчитать адрес, по которому
  лежит код жертвы (код - это все, что не заголовки, начинается сразу
  после таблицы заголовков сегментов и заканчивается перед таблицей
  заголовков секций). Высчитать размер этого кода от его начала до места,
  куда вставляем ~BIND_NOW~. Высчитать указатель той точки, куда вставляем
  ~BIND_NOW~, высчитать размер кода от этой точки и до таблицы заголовков сегментов.
  Если запись не вставляется, то просто высчитываем размер всего кода
  жертвы и указатель на этот код.

  Вся эта информация нужна, чтоб жертву можно было редактировать и
  перекомбинировать ее эльф, как нам это нужно.

2. Найти первую секцию ~text~ жертвы - нам нужно узнать индекс строки
   "text" в таблице строк. Мы сошлемся на эту же строку, когда будем
   создавать свой заголовок секции для вируса. Иначе придется генерировать
   доп. запись в таблице строк, а это лишние проблемы.

3. Найти первый загружаемый сегмент кода жертвы - это нужно, чтоб в будущем высчитать
   смещения от оригинального entry point жертвы до ее начала и в
   некоторых других случаях.

   Нарипмер, когда инфицированная жертва будет загружена загрузчиком в память,
   то ее адреса могут измениться, а нам нужно ее "двигать" на старые
   адреса, получать доступ к заголовкам ее сегментов и т.д.
   Чтоб узнать адрес, по которому она лежит в памяти, мы можем
   использовать смещение от нового entry point до оригинального, а от
   оригинального до начала файла. Таким образом можно будет узнать, где
   жертва лежит в памяти.

4. Найти последний загружаемый сегмент жертвы. Нам нужно знать его
   виртуальный адрес и выравнивание, чтоб относительно них высчитать
   новый виртуальный адрес вируса в инфицированной жертве.

~Получить инфу о вирусе~
 Получить размер кода вируса и указатель на него.
 Это нужно, чтоб вирус можно было запись в инфицируемый эльф


~Отредактировать жертву и пересчитать все, что нужно~
1. Найти секцию ~symtab~ - эта секция хранит в себе записи, каждая из
   которых устанавливает соответствие между символом и адресом, по
   которому он объявлен - редактируем адреса внутри этих записей,
   увеличивая их на 56 байт, если адреса младше виртуального дреса секции
   ~dynamic~, иначе
   противном случае программа может работать некорректно (гипотеза нуждается в
   проверке)

2. Редактируем заголовки секций, увеличивая их смещение и адреса
   описываемых ими секций на 56 байт, если они находятся выше секции
   ~dynamic~ и на 56 байт + содержимое переменной
   ~new_bind_now_flag_record_size~, если ниже.

   На этом же этапе расширить секцию ~dynamic~, увеличив ее на содержимое
   переменной ~new_bind_now_flag_record_size~.

   Если не отредактировать заголовки секций, то формат файла будет не
   распознан: код секций окажется не там, где загрузчик и линкер
   рассчитывают его найти.

   На этом же этапе вызывается редактирование записей секций ~rela~. Этих секций
   может быть множество, они хранят в себе инфу о релокейтах - если не
   отредактировать эти записи, то линкер отработает неверно или вообще
   может выдать сегфолт.

   Поскольку секций такого типа может быть множество, то проще не искать
   их отдельно, а во время редактирования заголовков всех секций, как
   только мы встречаем заголовок типа ~rela~ - мы вызываем редактирование
   записей конкретно этой секции - а затем возвращаемся к редактированию
   заголовков всех секций.

3. Редактируем заголовки всех сегментов.

   Принцип тот же: если описываемый код лежит ниже секции ~dynamic~, то
   редактируем смещение и адрес на 56 байт + содержимое
   ~new_bind_now_flag_record_size~, иначе только увеличивем на 56 байт.

   Правило действует для всех заголовокв сегментов кроме заголовка самой
   таблица заголовков сегментов, заголовка первого загружаемого
   сегмента и заголовка сегмента ~DYNAMIC~

   Первый загружаемый сегмент описывает эльф от его заголовка, т.е. с
   самого начала. Доп. заголовок для вируса вставляется в этот сегмент, а
   не перед ним. Поэтому его смещение и адрес не изменятся, только
   размер нужно увеличить на 56 байт.

   Заголовок таблицы заголовоков сегментов так же описывает код - таблицу
   заголовков сегментов - , который лежит до вставляемого заголовка
   вируса. Поэтому мы увеличиваем только его размер.

   Сегмент ~DYNAMIC~ (не путать с одноименной секций) должен быть
   увеличен на содержимое ~new_bind_now_flag_record_size~ - этот сегмент
   содержит в себе секцию ~dynamic~, которая может расширяться.

4. Редактируем записи внутри секции ~dynamic~ по тому же принципу, что
   редактировали все до этого.

   Эта секция содержит в себе всю информацию для линкера. Если ее не
   отредактировать, линкер выдает сегфолт.

5. Редактируем записи секции GOT по тому же принципу. В данном алгоритме
   заражения возможно обойтись без этого, но эта гипотеза нужнается в
   проверке.

6. Считаем новый виртуальный адрес для кода вируса: он считается как
    выровненный по 4кб адрес предыдущего загружаемого сегмента + его
    выравнивание + смещение вируса в файле.

    В противном случае загружаемый сегмент вируса выглядит для загрузчика
    как невалижный.

7. Генерируем заголовок секции и заголовок сегмента вируса - заполняем
    буфера на 64 и 56 байт соответственно данныйми о вируса

8. Геренируем запись ~BIND_NOW~, если в этом есть необходимость

9. Редактируем заголовок эльфа жертвы. Меняем ее entry point на новый
    виртуальный адрес вируса. Редактируем смещение до заголовоков
    секций. Увеличиваем кол-во заголовков секций и сегментов.

10. Считаем смещения:
- от конца вируса до оригинального entry point - это смещение будет
  испольховаться при косвенном джампе, чтоб после выполнения вирус
  передавал управление на жертву
- от предпоследней инструкции в вирусе (последняя - это передача
  управления на жертву) до функции ~move_victim~, которая будет двигать
  жертву на ее прежние адреса после того, как вирус отработает. Смещение
  до нее нужно для передачи на нее управления косвенным ~call~
- от начала файла до кода жертвы (который идет сразу после таблицы
  заголовков сегментов).

Все эти смещения нужны, чтоб передать инфицированной жертве управление
после выполнения вируса и подвинуть ее на прежние адреса

~Создание блоков кода для передачи управления жертве и сохранения ее данных~

1. Заполняем выделенный буфер машинными командами и смещениеями -
   получаем блок кода, который вызывает ~move_victim~ (она подвинет
   жертву на старые адреса) и сделает джамп на ее оригинальный ~entry
   point~
2. Сохраняем данные жертвы, которые необходимы, чтоб ее подвинуть, в
   выделенный буфер.

~Перекомпоновка эльфа~
- вписать заголовок эльфа жертвы и ее таблицу заголовков сегментов
- вписать новый загоовок сегмента вируса
- вписать код жертвы: если вставка ~BIND_NOW~ не нужна, то записываем код
  жертвы одним вызовом. В противном случае записываем ее код от таблицы
  заголовков до точки, куда вписывается запись ~BIMD_NOW~, затем саму
  новую запись ~BIND_NOW~, затем оставшийся код жертвы до ее таблицы
  заголовков секций
- вписать код вируса
- вписать блок передачи управления на жертву
- вписать блок данных жертвы
- вписать заголовки секций жертвы
- вписать заголовок секции вируса
- закрыть файл.

** Исполнение инфицированной жертвы

1. загрузчик загружает жертву в память согласно тому, что указано в
  заголовках ее загружаемых сегментов. Затем вызывается линкер

2. линкер считывает секцию ~dynamic~ и черпает оттуда информацию, где
  лежит секция ~GOT~, секции ~rela~, какие либы грузить в первую очередь
  (они помечены как NEEDED).

Псольку у нас в секции dynamic ест флаг ~BIND_NOW~, то линкер не только
свяжет библиотеки между собой, но и свяжет вызовы их функций из нашего
кода с их кодом в библиотеки - т.е. положит в записи GOT, к которым
обратится PLT при вызове библиотечных функций, не свой адрес, а адреса
кода, который мы собственно и хотим вызвать.

3. Затем линкер передает управление на пользоательскую программу - т.е. на
   наш вирус.

4. Вирус отрабатывает - пробует заразить новую жертву.

5. Затем он сдвигает жертву на ее прежние адреса: сначала разрешает всей
   жертве самомодификацию, а затем двигает каждый загружаемый сегмет
   побайтово, используя данные жертвы из блока данных, который мы
   сгенерили на стадии заражения.

   Если код находится ниже секции ~dynamic~, то жертвы будет сдвинута на
   56 байт вверх + содержимое ~new_bind_now_flag_record_size~

6. После того, как жертва сдвинута, вирус передает на нее управление.

7. Жертва отрабатывает.

8. Выход из кода жертвы, выход из программы.

На данный момент выход происходит некорректно - мы получаем сегфолт
внутри библиотеки ~libc~

Почему?
На этапе №2, когда линкер связывал либы друг с другом и скодом жертвы -
он, создал буфер, в который считал адреса записей секции ~dynamic~, где
они лежат в памяти, и положил адрес этого буфера в одну из записей ~GOT~
Содержимое этих записи нужны библиотеке ~libc~, чтоб
корректно завершить программу жертвы, которая собрана с либами.

Если бы мы не корячились с вставкой ~BIND_NOW~, то в этот буфер попали бы
адреса и тех записей, которые нужны были бы для ленивого связывания
библиотечных функций с кодом жертвы.

Проблема в том, что когда мы подвинули жертву, секция ~dynamic~
сместилась, и сохраненные адреса стали указывать не на те записи. В
резльтате чего ~libc~ фейлится.

~Гипотетическое решение этой проблемы~
Я заметила, что в буфер попадают адреса записей FINI_ARRAY и
FINI_ARRAYSZ. Эти записи лежат в самом начале секции ~dynamic~, а в самом
ее конце лежат записи NULL, записи о флагах и записи о версиях символов.

Технически, можно было бы не двигать секцию ~dynamic~ вообще, но сдвинуть
все, что будет после нее - например, секция ~GOT~. Таким образом,
последние записи в секции ~dynamic~ будут затерты, а первые - которые
нужны ~libc~, чтоб завершить прогу, останутся на своем месте. И тогда
выход из программы должен сработать корректно.

** Получить все именя файлов из текущей директории.

Для этого нужно реализовать ~opendir~ и ~readdir~

~opendir~ открывает стрим для заданного каталога и возвращет указатель на
структуру стрима ~DIR~ или ~NULL~ в случае провала.

Внутри ~opendir~ вызывается:
- ~open~  - открыает поток к каталогу
- ~fstat~ - видимо, получает инфу о каталоге (не понятно, как
  используется эта инфа потом)
- ~malloc~ - выделяет память под структуру ~DIR~ - если выделить память
  на стеке и вернуть на нее указатель, то как только ~opendir~ закончит
  исполнение, стек затрется.
Подозреваю, что так же ~malloc~ выделяет память под буфер, в который будут
читываться записи из каталога.

Судя по исследованиям в ~gdb~, ~DIR~ занимает 48 байт.
- первые 4 байта - дескриптор открытого каталога
- следующие 4 байта - 0
- следующие 8 байт - кладется число ~0x8000~ - это размер буфера, в
  который будут складываться записи о структурах файлов в
  каталоге.
Остальные байты заполнены нулями

~readdir~

Читает запись файла/папки из потока каталога.

Принимает структуру типа ~DIR~ в качестве параметра. Возвращает структуру
типа ~dirent~.
Внутри ~readdir~ вызывается ~getdents~ (сискол номер 78)

~getdents~ читает все записи файлов (их структуры типа ~dirent~) в заданный буфер,
поэтому под него отведено 8тыс байт.

Каждая запись (структура) типа ~dirent~ содержит в себе несколько
полей. Нас интересуют два из них: имя файла (смещение 0x12) и размер самой
структуры (смещение 0х10). Размер структуры зависит от длины имени файла.

~getdents~ принимает 3 параметра:
- дескриптор открытого каталога
- указатель на буфер, в который записываются все структуры ~dirent~
- размер этого буфера

После того, как все структуры считаны, библиотечный ~readdir~ выдает нам
указатели на структуры по одной, эмулируя таким образом считывание
записей из потока по одной, хотя на самом деле записи считаны все сразу.

Мы сделаем проще:
- заведем буфер под структуры на 8 тыс байт
- заведем указатель, который будет указывать на текущую структуру в
  буфере

Таким образом можно будет двигать указатель и брать записи о файлах один
за другим, пока не найдем какой-то эльф-файл.

** Маркер заражения

 Не нужно, чтоб вирус допускал повторное заражение файла - это приведет
 только к увелиению их размера.
 Поэтому нужен маркер заражения

 Маркером заражения будет сам код вируса. Алгоритм простой:
- если размер кода жертвы <= размеру кода вируса - жертва не
  заражена. Иначе код жертвы был бы больше кода вируса.
- берем метку _start вируса и entry point жертвы и сравниваем содержимое
  этих адресов, например, первые 32 байта.
Если вирус находится в жертве, то он будет начинаться с entry point, если
его не будет по адресу entry_point, то его не будет нигде.

Если вирус уже находится в жертве, то мы ее не трогаем, прсто берем
следующий файл.
