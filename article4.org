#+STARTUP: showall indent hidestars

* Пишем вирус под Linux с нуля: опыт и грабли

[TODO:картинка с совой или что-то подобное]

Единственное руководство "для новичка" по написанию вирусов, что
мне удалось найти - это "Записки исследователя компьютерных вирусов"
Криса Касперски. Очень увлекательное чтение! Что если попробовать
реализовать пару идей оттуда? Сколько это займет времени для человека,
который ничего подобного раньше не делал? Какие подводные камни?

Так начался проект по написанию моего первого файлового вируса.

-=[cut]=-

Цель будет достигнута, если вирус сможет заразить файлы-мишени - т.е. это
такой маленький учебный проект на пару уикендов, войти и выйти. Ничего
сложного!

* План простой:

- пишем мишени
- пишем вирус
- ищем файлы
- инфицируем их (если еще не)
- проверяем что зараженные мишени работают
- пишем отчет

Что может пойти не так?

* Простейшая мишень и Section Header Table

Нарисуем мишень:

#+BEGIN_SRC c :tangle hello.c
  /* gcc hello.c -o hello */
  #include <stdio.h>
  #include <time.h>

  time_t rawtime;
  struct tm * timeinfo;

  int main()
  {
      printf( "Hello world!\n" );
      time ( &rawtime );
      timeinfo = localtime ( &rawtime );
      printf ( "Current local time and date: %s", asctime (timeinfo) );
      return 0;
  }
#+END_SRC

После компиляции мы получаем ELF-файл. Он очень просто устроен: таблица
сегментов хранит записи с указателями на сегменты, таблица секций -
записи с указателями на секции в этих сегментах, а заголовок эльфа
содержит информацию, где найти обе эти таблицы в файле, сколько в них
записей, точку входа и т.д.:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf.png
           +-------------------------------+
           | Заголовок ELF-файла           |
           | (ELF-header)                  |
           |                               |
           |   Phdr Table Offset >---------+----+
  +--------+-< Shdr Table Offset           |    |
  |        |        ...                    |    |
  |        +-------------------------------+    |
  |                                             |
  |        +-------------------------------+<---+
  |        | Таблица сегментов             |
  |        | (Program Header Table)        |
  |        |     1                         |
  |   +----+---< 2                         |
  |   |    |     ...                       |
  |   |    +-------------------------------+
  |   |
  |   |    +-------------------------------+
  |   |    | Segment 1 | Section A         |
  |   |    |           +-------------------|
  |   |    |           | Section B         |
  |   |    |           +-------------------|
  |   |    |           |      ...          |
  |   |    +-------------------------------+
  |   +--> +-------------------------------+
  |        | Segment 2 | Section C         |
  |        |           +-------------------|<---+
  |        |           | Section D         |    |
  |        |           +-------------------|    |
  |        |           |      ...          |    |
  |        +-------------------------------+    |
  |                                             |
  +------->+-------------------------------+    |
           | Таблица заголовков секций     |    |
           | (Section Header Table)        |    |
           |                         A     |    |
           |                         B     |    |
           |                         C     |    |
           |                         D >---+----+
           |                         ...   |
           +-------------------------------+
#+END_SRC

#+results: elf
[[file:./img/elf2.png]]

Интересно, что каждый сегмент, содержит внутри себя одну или несколько
секций. В документации указано, что таблица заголовков секций
необязательна, и чтобы проверить это, мы можем ее удалить. Для этого
лучше использовать утилиту ~sstrip~ из ELF Kickers, которую можно взять
тут: http://www.muppetlabs.com/%7Ebreadbox/software/elfkickers.html

Воспользовавшись ей получаем:

#+BEGIN_SRC sh
  $ sstrip hello
  $ readelf -S test_sect_tbl

  There are no sections in this file.

  $ ./hello
  Hello world
#+END_SRC

Действительно, Section Header Table не нужна, чтобы наш hello world мог
загрузиться и выполниться! Но сами секции внутри сегментов никуда не
делись, мы просто потеряли информацию о них. Настало время поговорить о
сегментах.

* Сегменты

Можно ожидать, что наша простая мишень будет иметь два сегмента - один
для кода, а второй для данных. Но ELF-ы умеют превосходить ожидания:

#+BEGIN_SRC sh
  $ readelf -l hello

  Elf file type is DYN (Shared object file)
  Entry point 0x10e0
  There are 13 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000002d8 0x00000000000002d8  R      0x8
    INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000006e0 0x00000000000006e0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x00000000000002b5 0x00000000000002b5  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x0000000000000188 0x0000000000000188  R      0x1000
    LOAD           0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000278 0x0000000000000290  RW     0x1000
    DYNAMIC        0x0000000000002da8 0x0000000000003da8 0x0000000000003da8
                   0x00000000000001f0 0x00000000000001f0  RW     0x8
    NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    GNU_EH_FRAME   0x0000000000002038 0x0000000000002038 0x0000000000002038
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000268 0x0000000000000268  R      0x1

   Section to Segment mapping:
    Segment Sections...
     00
     01     .interp
     02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
     03     .init .plt .plt.got .plt.sec .text .fini
     04     .rodata .eh_frame_hdr .eh_frame
     05     .init_array .fini_array .dynamic .got .data .bss
     06     .dynamic
     07     .note.gnu.property
     08     .note.gnu.build-id .note.ABI-tag
     09     .note.gnu.property
     10     .eh_frame_hdr
     11
     12     .init_array .fini_array .dynamic .got
#+END_SRC

Что это? Вместо ожидаемых двух сегментов, мы получили это! Давайте
разбираться:

~PHDR-сегмент~ описывает саму Program Header Table. Мы видим, что он
начинается по смещению 0x40 байт от начала файла, сразу после
ELF-заголовка.

~INTERP-сегмент~ описывает "Program Interpreter" - это указатель на
строку, содержающую путь к динамическому компоновщику, который еще
побросит нам сюрпризов, но пока мы это пропустим. Этот сегмент содержит
одну секцию .interp

~LOAD-сегмент-R~ - это первый LOAD-сегмент в файле. Он содержит несколько
секций, и первая из них - это .interp - мы ее только что видели в
предыдущем сегменте. Все LOAD-сегменты загружаются в память, когда
программа запускается. Первый LOAD-сегмент начинается с нулевого адреса,
значит он загружает в память все содержимое файла от его начала до
следующего LOAD-сегмента, который обычно содержит кода. Это содержимое
будет доступно программе НА ЧТЕНИЕ.

~LOAD-сегмент-RE~ содержит код в секции .text, а в остальных своих
секциях все что к нему относится, например, .init и .fini, а также
секции, которые связаны с GOT и PLT (.plt, .plt.got,
.plt.sec). Содержимое эттого сегмента будет загружено с правами НА ЧТЕНИЕ
И ИСПОЛНЕНИЕ.

~LOAD-сегмент-R~ обычно содержит в себе данные, которые будут доступны НА
ЧТЕНИЕ, например в секции .rodata и также может содержать в себе секции
вида .eh_frame относящиеся к обработке ислючений.

~LOAD-сегмент-RW~ содержит данные, доступные НА ЧТЕНИЕ И ЗАПИСЬ (в
секциях .data, .bss, .init_array, .fini_array и. т. п.), секции,
связанные с GOT (.got)

~DYNAMIC-сегмент~ содержит одну секцию .dynamic - в ней лежит информация,
имеющая отношение к релокациям. Эта секция тоже доступна НА ЧТЕНИЕ И
ЗАПИСЬ.

~NOTE-сегменты~ имеет тип NOTE, мы можем просмотреть его с помощью
"readelf -n" и обычно там нет ничего интересного.

~GNU_ сегменты~ содержат таблицы для обработки исключений, стек и таблицы
связанные с релокациями

Все это вместе выглядит как-то так:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf2.png
  +----------------------------+
  | Заголовок ELF-файла        |
  | (ELF-header)               |
  +----------------------------+

  +----------------------------+
  |Таблица заголовков сегментов|
  | (Program Header Table)     |
  +----------------------------+

  +----------------------------+
  | Segment (PHDR)             |
  +----------------------------+
  | Segment (INTERP)           |
  |    .interp                 |
  +----------------------------+
  | Segment (LOAD) R           |
  |    .interp                 |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RE          |
  |    .text                   |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) R           |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RW          |
  |      ...                   |
  +----------------------------+
  | Segment (DYNAMIC) RW       |
  |   .dynamic                 |
  +----------------------------+
  | Segment (NOTE)             |
  |     ...                    |
  +----------------------------+
  | Segment (GNU_...)          |
  |     ...                    |
  +----------------------------+

  +----------------------------+
  | Таблица заголовков секций  |
  | (Section Header Table)     |
  +----------------------------+
#+END_SRC

В этом прослеживается некоторая логика - все данные распределены по
секциям, а секции скомпонованы в сегменты в соответствии с правами
доступа к этим данным. Некоторые секции могут относиться к нескольким
сегментам одновременно - стоит это учитывать.

* Релокейты

Большинство серьезных программы используют разделяемые библиотеки,
который связываются динамически. Рассмотрим подробнее этот
механизм. Когда программе нужно вызвать функцию разделяемой библиотеки,
она делает вызов в специальную таблицу связи процедур (PLT - Procedure
Linkage Table).

Каждая запись этой таблицы содержит небольшой кусочек кода, который
выполняет коссвенный вызов нужной функции разделямой библиотеки. Этот
вызов коссвенный, потому что программа не знает адрес, где будет
находиться библиотека при каждом следующем запуске, ведь загрузчик
программ загружает библиотеки в адресное пространство процесса по
случайным адресам.

Чтобы узнать реальный адрес кусочек кода из PLT должен обратиться к GOT -
Global Offset Table, Глобальной Таблице Смещений. Динамический линкер
заботится о том, чтобы там были были правильные значения.

Таким образом, мы видим, что PLT должна иметь права на исполнение, а
GOT - на запись, потому что связывание динамическим линкером выполняется
лениво, т.е. прямо во время работы программы, при первой попытке доступа
к соответствующей функции.

При первом вызове разделяемой функции GOT содержит указатель обратно на
PLT, где вызывается динамический компоновщик для определения фактического
местоположения рассматриваемой функции. Найденное местоположение затем
записывается в GOT. При втором вызове функции GOT содержит известное
местоположение функции. Это называется «ленивое связывание».

Из вышесказанного можно сделать несколько выводов. Во-первых, PLT должен
располагаться с фиксированным смещением от раздела .text, чтобы код знал
как его найти. Во-вторых, поскольку GOT содержит данные, напрямую
используемые различными частями программы, его необходимо разместить по
известному статическому адресу в памяти.

Поскольку GOT существует в заранее определенном месте в памяти,
программа, содержащая уязвимость, позволяющая злоумышленнику записать 4
байта в контролируемое место в памяти, может быть использована для
выполнения произвольного кода.

Чтобы предотвратить эту уязвимость, нужно убедиться, что компоновщик
разрешает все динамически связанные функции в начале выполнения, а затем
делает GOT доступным только для чтения. Этот метод называется RELRO и
гарантирует, что GOT не может быть перезаписан во время выполнения

В частичном RELRO секция .got доступна только для чтения, но .got.plt все
еще доступен для записи. В то время как в полном RELRO и .got и .got.plt
помечен как доступен только для чтения.

И частичное, и полное RELRO изменяют порядок внутренних разделов данных
ELF, чтобы защитить их от перезаписи в случае переполнения буфера.

* Проблема инфицирования

Куда же в этой запутанной структуре мы можем вставить свой вирус?
Нам нужно несколько  факторов:
- сегмент вируса должен загрузиться в память, следовательно, он должен
  быть частью какого-то LOAD-сегмента мишени или же иметь свой
  собственный LOAD-сегмент.

- сегмент вируса должен иметь права на исполнение.

- код в секциях обычно ссылается на данные, которые находятся в сегменте
данных. Это значит, что если мы попытаемся вставить вирус между кодом и
данными, то относительное расстояние между ними изменится и ссылки станут
неверными. В результате мишень станет неработоспособной.

Есть три варианта, которые часто предлагаются как наиболее простые для
начинающего вирусописателя.

1. Вставить вирус в padding между таблицей заголовков сегментов и кодом
   программы.

   Если вирус вмещается в padding, то нам вообще не придется
   редактировать какие-либо структуры ELF-a, кроме его заголовка, чтоб
   изменить адрес точки входа. Но ключевая проблема как раз в том, что
   padding может быть совсем незначительным или его может не быть вовсе.

2. Найти первый загружаемый сегмент кода - сегменты такого типа грузятся
   в память процесса - и вписать вирус в его конец. Затем расширить этот
   сегмент на размер вируса и немного отредактировать остальные заголовки
   секций и сегментов, потому что весь код сместится на рамер вируса.

   Этот способ очень неплох по нескольким параметрам. Во-первых, не
   придется оформлять вирус в отдельный сегмент. Во-вторых, наличие
   вируса становится чуть менее очевидным для вирусного аналитика.

   Но у этого способа есть значительный недостаток. Как уже упоминалось
   выше, программы, слинкованные динамически, имеют секции PLT и
   GOT. PLT обычно располагается перед секцией .text в первом
   LOAD-сегменте, а вот GOT располагается уже во втором LOAD-сегменте. Если мы
   вставляем вирус в конец первого сегмента, то получается, что мы
   вставляем его между PLT и GOT. Из-за этого PLT больше не может
   обратиться к GOT, а обращается к адресу, где GOT была до заражения.

   Исправить это можно, если отредактировать код PLT, найдя инструкции
   относительных ~jmp~ и изменив в них смещения. Но это довольно
   трудоемкий процесс, так что откажемся от этого варианта.

3. Вписать вирус перед таблицей заголовков секций мишени и оформить его в
   самостоятельный LOAD-сегмент.

   Если мы оформляем вирус в отдельный сегмент, то этому сегменту
   понадобится свой собственный заголовок сегмента и заголовок
   секции. Вставка дополнительного заголовка сегмента приведет к тому,
   что весь код жертвы сместится равномерно и нам не придется
   редактировать код PLT.

   Поэтому мы остановимся на этом варианте заражения как на оптимальном.

* Инфицирование пошагово

Первая задача, которая перед нами стоит, заключается в том, чтобы вписать
код вируса в файл мишени, при этом не сломав его формат. То есть мы
пересобрать файл таким образом, чтобы его можно было запустить. Если
сегфолт возник уже после того, как загрузчик передал управление
программе, или же не возник вообще, мы можем быть уверены, что сам формат
файла не поломан.

На выходе из этой стадии ELF должен выглядеть вот так:

#+NAME: infected_elf
#+BEGIN_SRC ditaa :file ./img/infected_elf.png
  +---------------------------------------+
  | Заголовок ELF-файла                   |
  |  (ELF-header)                         |
  +---------------------------------------+

  +---------------------------------------+
  |  Таблица заголовков сегментов         |
  |  (Program Header Table)               |
  |                                       |
  +---------------------------------------+
  |   PHDR Header                         |
  +---------------------------------------+
  |   Interp Header                       |
  +---------------------------------------+
  |   Load Header                         |
  |   (victim load header)                |
  +---------------------------------------+
  |   ...                                 |
  +---------------------------------------+
  |   Load Header                         |
  |   (malware load header)               |
  +---------------------------------------+


  +---------------------------------------+
  |   Load Segment 1                      |
  +---------------------------------------+
  |   Load Segment 2                      |
  +---------------------------------------+
  |   ....                                |
  +---------------------------------------+
  |   Load Segment                        |
  |   (malware load segment)              |
  +---------------------------------------+

  +---------------------------------------+
  |  Таблица заголовков секций            |
  |  (Section Header Table)               |
  +---------------------------------------+
  |  Null Section Header                  |
  +---------------------------------------+
  |  Interp Section Header                |
  +---------------------------------------+
  |  ...                                  |
  +---------------------------------------+
  |  Text Section Header                  |
  |  (victim text section header)         |
  +---------------------------------------+
  |  ...                                  |
  +---------------------------------------+
  |  Text Section Header                  |
  |  (malware text section header)        |
  +---------------------------------------+
#+END_SRC

Чтоб получить такой результат, нужно выполнить несколько действий.

1. Загрузите ваш файл в память.

   Загрузка файла в память нужна, чтоб можно было читать, редактировать,
   а затем сливать нужный нам код. Я это делаю с помощью вызова ~mmap~.

2. Распарсите ваш ELF.

   На этом этапе вы должны выяснить, где что у вас в файле находится. На
   данный момент нас интересуют только таблицы заголовков секций и
   сегментов, а так же точка входа.

   Выяснить их расположение таблиц просто: заголовок ELF-файла содержит в себе поля
   e_phoff - оно содержит в себе смещение от начала файла до таблицы
   заголовков сегментов - и  e_shoff, которое содержит в себе смещение от
   начала файла до таблицы заголовков секций. Имея базовый адрес
   ELF-файла в памяти, который вернул mmap, можно поочередно сложить его
   с полученными смещениями и таким образом выяснить, где находятся
   таблицы заголовков в памяти на данный момент.
   А поля e_phnum и e_shnum в заговке ELF-а позволят узнать количество
   этих заголовков в этих таблицах.

   Поле e_entry сообщит виртуальный адрес точки входа.

3. Выделите память под новые заголовки.

   В 64-разрядной системе заголовок сегмента всегда будет занимать 56
   байт, а заголовок секции - 60 байт.

4. Посчитайте виртуальный адрес вируса.

   Загрузчик слишком умен, нам нужно сделать так, чтоб сегмент кода
   вируса выглядел для него влаидным. Чтоб сегмент сочли валидным, вы
   должны соблюсти  соотношение между виртуальным адресом вашего сегмента
   и его смещением от начала файла.
   Если вычесть второе из первого, то вы должны получить адрес, кратный 4кб.

   Посчитать виртуальный адрес для вируса нетрудно:
   - Находите заголовок последнего LOAD-сегмента мишени (у него будет
     самый большой виртуальный адрес)

   - Считываете его ~p_vaddr~ и ~p_allign~ - т.е. его виртуальный адрес и
     выравнивание.

   - Выравниваете виртуальный адрес последнего сегмента по 4 кб,
     прибавляете к нему выравнивание и смещение вашего вируса в файле.

   Приходится учитывать выравнивание, поскольку как правило с байтами
   выравнивания вы не можете делать буквально ничего и попытка что-то
   исполнить там приведет к сегфолту.

5. Заполните выделенную память под заголовки данными в соответствии
   со структурами заголовка сегмента и заголовка секции.

   Заголовок сегмента для вируса будет выглядеть следующим образом:
   - p_type   - 4 байта, знач. 1 - PL_LOAD
   - p_flags  - 4 байта, знач. 1 - разрешение на исполнение
   - p_offset - 8 байт, смещение вируса в файле
   - p_vaddr  - 8 байт, виртуальный адрес вируса
   - p_paddr  - аналогично ~p_vaddr~
   - p_filesz - 8 байт, размер вируса в файле
   - p_memsz  - 8 байт, размер вируса в памяти (аналогичен p_filesz в
     нашем случае)
   - p_allign - 8 байт, - значение 0, выравнивание не требуется

  А вот таким будет загоовок секции вируса.
   - sh_name      - 4 байта, значение - индекс в таблице строк, где строка - это
                              имя секции.
   - sh_type      - 4 байта, тип секции 1 (PROGBITS) - значение секции определяется
                             и используется программой единолично
   - sh_flags     - 8 байт, значение 4 - разрешение на исполнение
   - sh_addr      - 8 байт, виртуальный адрес вируса, аналогичен p_vaddr из
                            заголовка сегмента
   - sh_offset    - 8 байт, смещение вируса в файле
   - sh_size      - 8 байт, размер вируса в файле
   - sh_link      - 8 байт, значение - 0
   - sh_info      - 8 байт, значение 0
   - sh_addralign - 8 байт, значение 0, выравнивание не требуется
   - sh_entsize   - 8 байт, значение 0, код не содержит никаких записей
                  фиксированного размера


6. Увеличьте поля p_paddr, p_vaddr и p_offset на 56 байт во всех
   заголовках сегментов, которые описывают код, находящийся после таблицы
   заголовков.

   Таким образом вы укажете, что изменились физические и
   виртуальные адреса сегментов, а так же их смещение от начала файла,
   т.е. весь код съехал на те самые 56 байт как в файле, так и в памяти
   процесса.

7. Увеличьте поля sh_addr и sh_offset на 56 байт во всех заголовках
   секций по тому же принципу и тем же причинам, описанным в пункте
   выше.

8. Увеличьте поля e_phnum и e_shnum в заголовке эльфа на единицу.

   Так вы укажете, что загоовков сегментов и загоовков секций стало на 1
   больше. А так же установите новое смещение от начала файла таблицы
   заголовков секций в поле e_shoff - в противном случае заголовки
   секций не будут найдены, и формат будет сломан.

9. Перезапишите ваш ELF.

   Впишите данные в файл в следующей последовательности:
   - код от начала файла до конца таблицы заголовков сегментов
   - заголовок сегмента вируса
   - весь код жертвы до начала таблицы секций
   - весь код вируса
   - таблицу секций
   - заголовок секции вируса

   Мне в этом помог вызов ~pwite~, где можно задать смещение
   от начала файла, по которому должна вестись запись.

Теперь у вас есть инфицированный файл, но пока что он совершенно
бесполезен: во-первых, мы не передали управление на вирус, следовательно,
его код не исполнится, а во-вторых, с большой вероятностью запуск этого
файла завершится сегфолтом, о причинах которого я расскажу ниже.

Для начала разберемся с более простой задачей, заставим вирус
исполниться.

В общем случае у нас есть два варианта, как будет работать инфицированный
файл: либо вирус исполняется сначала, а затем передает управление на код
мишени, либо наоборот.

Первый вариант воплотить проще, поскольку не придется искать окончание
функции main мишени и переписывать его конец, чтоб обеспечить передачу
управления вирусу.

Чтоб перевести управление на вирус сразу, нужно отредактировать поле
e_entry в заголовке инфицированного ELF-a, вставив в него виртуальный
адрес вируса. А чтоб передать управление на код мишени, нам понадобится
всего 5 байт машинного кода, который мы напишем вручную и вставим его
вместо выхода из вируса.

* Пишем машинный код вручную

В ассмеблере есть инструкция jmp, которая является безусловным переходом. Ее параметр
может быть как абсолютным адрсом, т.е. буквально ~jmp 0x400345~, так и
смещением от следующей за jmp инструкцией до нужного адреса.
Параметр занимает 4 байта, а e9 - машкод jmp -  занимает 1 байт.

Чтобы правильно написать переход на код мишени, нам понадобится:
- посчитать, на каком адресе инструкции будет находиться вирус, когда
  будет передавать управление на оригинальную точку входа мишени

  Берем виртуальный адрес вируса, который мы высчитывали выше, берем
  размер кода вируса и складываем их. А затем прибавляем к полученному
  адресу еще 5 байт - смещение высчитывается от следующей за переходом
  инструкции.

- оригинальная точка входа мишени
  Ее мы берем из поля e_entry до того, как успели отредактровать это
  поле.

 Теперь вычитаем из оригинальной e_entry полученный адрес инструкции и
 получаем таким образом смещение до оригинальной точки входа.

 Возьмем конкретный пример: адрес вашего вируса 0x8012a8, его размер
 0x100 байт, адрес оригинальной точки входа 0x400430.
 0x400430 - (0x8012a8 + 0x100 + 0x5) = -400f7d.
 Смещение получается отрицательным, поскольку мы совершаем прыжок не
 "вперед", а "назад".

Теперь наш инфицированный ELF выглядит следующим образом:

#+NAME: infected_elf2
#+BEGIN_SRC ditaa :file ./img/infected_elf2.png
         +---------------------------------------+
         | Заголовок ELF-файла                   |
         |  (ELF-header)                         |
         |   ...                                 |
         |   e_entry                             |------+
         +---------------------------------------+      |
                                                        |
         +---------------------------------------+      |
         |  Таблица заголовков сегментов         |      |
         |  (Program Header Table)               |      |
         |                                       |      |
         +---------------------------------------+      |
         |   PHDR Header                         |      |
         +---------------------------------------+      |
         |   Interp Header                       |      |
         +---------------------------------------+      |
         |   Load Header                         |      |
         |   (victim load header)                |      |
         +---------------------------------------+      |
         |   ...                                 |      |
         +---------------------------------------+      |
         |   Load Header                         |      |
         |   (malware load header)               |      |
         +---------------------------------------+      |
                                                        |
                                                        |
         +---------------------------------------+      |
         |   Load Segment 1                      |      |
         |   ...                                 |      |
  +----->|   original e_entry                    |      |
  |      +---------------------------------------+      |
  |      |   Load Segment 2                      |      |
  |      +---------------------------------------+      |
  |      |   ....                                |      |
  |      +---------------------------------------+      |
  |      |   Load Segment                        |<-----+
  |      |   (malware load segment)              |
  |      +---------------------------------------+
  +------|   Transfer Control to                 |
         |   original e_entry                    |
         +---------------------------------------+


         +---------------------------------------+
         |  Таблица заголовков секций            |
         |  (Section Header Table)               |
         +---------------------------------------+
         |  Null Section Header                  |
         +---------------------------------------+
         |  Interp Section Header                |
         +---------------------------------------+
         |  ...                                  |
         +---------------------------------------+
         |  Text Section Header                  |
         |  (victim text section header)         |
         +---------------------------------------+
         |  ...                                  |
         +---------------------------------------+
         |  Text Section Header                  |
         |  (malware text section header)        |
         +---------------------------------------+
#+END_SRC

#+results: infected_elf2
[[file:./img/infected_elf2.png]]


* Немного о линковке

Теперь у нас есть запускающийся инфицированный ELF-файл, который
неизменно выдает сегфолт. Чтоб понять причины этого, нужно детально разобраться в том,
как происходит процесс линковки от начала и до конца.

В начале этой статьи мы разобрались с сегментами программы, выяснили, для
чего каждый из них нужен, и немного коснулись релокейтов и секций plt и
got. Теперь мы поговорим о некоторых секциях, которые критично важны для
правильной работы динамически слинкованного файла и линковки.

Помимо секций когда и секций данных в каждом ELF-файле есть таблица
символов, которая содержит в себе информацию о символах
программы. В динамически слинкованном ELF-е таблиц символов может быть
максимум две - symtab и dynsym. Dynsym содержит в себе информацию о
динамических символах программы - т.е. о символах, заимствованных из
библиотек, а symtab хранит в себе информацию обо всех символах вообще:
имя символа, его виртуальный адрес, тип связязывания, видимость в файле и
т.д. После компиляции в этой таблице можно увидеть связь символа и адрес,
на который он ссылается. Именно такую таблицу проверяет рантайм-линкер, когда
ищет, например, код printf в библиотеке, чтоб вернуть нам адрес на него.

Для корректной работы помимо symtab линкеру необходимы секции rela и
dynamic.

Секция dynamic хранит в себе всю информацию, которая может понадобиться
линкеру или libc, которая осуществляет корректный старт и завершение
сишной программы.

Здесь вы можете видеть уже знакомые нам pltgot и symtab, а так же
упомянутую секцию rela. Если какая-то информация в этой секции не будет
соответствовать действительности, то ваша программа либо не запустится,
потому что libc не сможет настроить старт для нее, либо сломается процесс
рантайм линковки, либо программа не сможет корректно завершиться.

#+BEGIN_SRC sh
  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Секция rela содержит в себе информацию о релокейтах: их имена,
адреса, как именно должна выполниться релокация и т.д.
#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0

#+END_SRC

Но что такое релокация? Многих сбивает буквальный перевод -
"перемещение". Что там такое перемещается, если все остается на месте?

Вот тут мы вполную подошли к процессу линковки.

Вернемся назад, к моменту, когда мы только написали код нашей мишени и
запустили ее компиляцию.

Из всех этапов компиляции нас интересует только два: кодогенерация и
линковка. На этапе кодогенерации генерируется весь код и проверяется наличие определения
(объекта) для всех используемых символов. Определения могут находиться и
за пределами текущего файла, и тогда мы будем их искать в указанных
библиотеках с помощью таблицы символов в них.
Если же не найдем и там, то компиляция не завершится.

На выходе из этого этапа мы получаем объектный файл. Распечатав такой файл с
помощью objdump-a мы видим, что в нем не хватает секции plt и got,
dynamic и многих других. Это происходит, потому что заключительного этапа
компиляции - линковки - еще не было.

Давайте взглянем на таблицу символов
#+BEGIN_SRC sh
    $ readelf -s hello.o

  Таблица символов «.symtab» содержит 17 элементов:
     Чис:    Знач           Разм Тип     Связ   Vis      Индекс имени
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
       3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
       4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
       5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
       6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
       7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
       8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
       9: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM rawtime
      10: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM timeinfo
      11: 0000000000000000    81 FUNC    GLOBAL DEFAULT    1 main
      12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
      13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND time
      14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND localtime
      15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND asctime
      16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf

#+END_SRC
Во-первых, она очень короткая, потому что многие символы еще не
подклчены. А во вторых, в поле "значение", в котором должен находиться
адрес символа или его смещение в файле, пусто. Линковки еще не было,
поэтому ссылки на символы все еще не заполнены.

А теперь  посмотрим на секции rela.
#+BEGIN_SRC sh
  $ readelf -r hello.o

  Раздел перемещения '.rela.text' со смещением 0x310 содержит 11 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000005  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
  00000000000a  000c00000002 R_X86_64_PC32     0000000000000000 puts - 4
  00000000000f  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  000000000014  000d00000002 R_X86_64_PC32     0000000000000000 time - 4
  000000000019  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  00000000001e  000e00000002 R_X86_64_PC32     0000000000000000 localtime - 4
  000000000025  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  00000000002c  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  000000000034  000f00000002 R_X86_64_PC32     0000000000000000 asctime - 4
  00000000003c  00050000000a R_X86_64_32       0000000000000000 .rodata + 10
  000000000046  001000000002 R_X86_64_PC32     0000000000000000 printf - 4

  Раздел перемещения '.rela.eh_frame' со смещением 0x418 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
#+END_SRC

Поле "смещение" действительно указывает на смещение в файле, а не на
виртуальный адрес, куда мы положим новый адрес релокейта.

Что ж, завершим нашу компиляцию, превратив объектный файл в
исполняемый. На этом этапе включается линкер, который должен заполнить
все ссылки, какие сможет. Но есть ссылки, которые он заполнить не
сможет. Это происходит, потому что на этом этапе линкер не имеет никакого
представления о том, куда будут загружены библиотеки, и потому оставляет
эти ссылки нетронутыми до исполнения программы, где уже включится
известным нам механизм ленивого связывания, которое осуществляется с
помощью PLT и GOT.

Благодаря им и магии виртуальной памяти мы можем загрузить библиотеку
один раз и разделить ее между несколькими программами, и для каждой она
будет как будто лежать по разным адресам.

Но так было далеко не всегда. Когда PLT и GOT не было, процесс выглядел
по-другому. Помимо того, что для каждого процесса приходилось отдельно
подгружать библиотеку, отличался процесс линковки.
На этапе компиляции линкер предполагал, что библиотеки будут размещены
примерно сразу за стеком и вписывал смещение от текущей инструкции до
предполагаемого адреса кода библиотеки, который был нужен. А затем
рантайм линкер во время исполнения программы получал базовый адрес
загруженной библиотеки и складывал этот адрес с посчитанным ранее
смещением и таким образом вызывался необходимый код.

Именно из-за этого процесса релокейты так называются. Фактически у нас
есть символ и есть ссылка на его объект - определение. До исполнения программы
ссылка указывает в одно место, а во время исполнения начинает указывать в
другое место. Т.е. мы перемещаем саму ссылку на объект.

Теперь же мы используем PLT и GOT. Посмотрите на виртуальные адреса
релокейтов в секциях rela.

#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0

#+END_SRC

И взгляните, на какие именно записи в GOT прыгает PLT.

#+BEGIN_SRC sh
  0000000000400508 <localtime@plt-0x10>:
    400508:	ff 35 32 0b 20 00    	pushq  0x200b32(%rip)        # 601040 <_DYNAMIC+0x1e0>
    40050e:	ff 25 34 0b 20 00    	jmpq   *0x200b34(%rip)        # 601048 <_GLOBAL_OFFSET_TABLE_>
    400514:	0f 1f 40 00          	nopl   0x0(%rax)

  0000000000400518 <localtime@plt>:
    400518:	ff 25 32 0b 20 00    	jmpq   *0x200b32(%rip)        # 601050 <_GLOBAL_OFFSET_TABLE_+0x8>
    40051e:	68 00 00 00 00       	pushq  $0x0
    400523:	e9 e0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400528 <puts@plt>:
    400528:	ff 25 2a 0b 20 00    	jmpq   *0x200b2a(%rip)        # 601058 <_GLOBAL_OFFSET_TABLE_+0x10>
    40052e:	68 01 00 00 00       	pushq  $0x1
    400533:	e9 d0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400538 <asctime@plt>:
    400538:	ff 25 22 0b 20 00    	jmpq   *0x200b22(%rip)        # 601060 <_GLOBAL_OFFSET_TABLE_+0x18>
    40053e:	68 02 00 00 00       	pushq  $0x2
    400543:	e9 c0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400548 <printf@plt>:
    400548:	ff 25 1a 0b 20 00    	jmpq   *0x200b1a(%rip)        # 601068 <_GLOBAL_OFFSET_TABLE_+0x20>
    40054e:	68 03 00 00 00       	pushq  $0x3
    400553:	e9 b0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400558 <__libc_start_main@plt>:
    400558:	ff 25 12 0b 20 00    	jmpq   *0x200b12(%rip)        # 601070 <_GLOBAL_OFFSET_TABLE_+0x28>
    40055e:	68 04 00 00 00       	pushq  $0x4
    400563:	e9 a0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400568 <time@plt>:
    400568:	ff 25 0a 0b 20 00    	jmpq   *0x200b0a(%rip)        # 601078 <_GLOBAL_OFFSET_TABLE_+0x30>
    40056e:	68 05 00 00 00       	pushq  $0x5
    400573:	e9 90 ff ff ff       	jmpq   400508 <_init+0x28>

#+END_SRC

Эти адреса совпадают с виртуальными адресами релокейтов из секций
rela. Суть механизма осталась прежней, просто PLT и GOT позволяют
оптимизировать подкгрузку библиотек.

Сначала ссылки на релокейты  содержат в себе адрес кода в PLT, который
вызовет линкер, а после рантайм линковки будут содержать в себе адрес,
по которому лежит библиотечный код.

Но как в деталях происходит этот процесс?

Теперь, когда мы скомпилировали файл, мы можем его запустить и проследить
весь путь работы линкера.

Загружая файл, загрузчик должен какм-то образом понять, какие библиотеки
ему загружать. Но вся фишка в том, что все, что он загружает - это сам
файл и линкер, чье имя оказано в сегмента INTERP. Затем управление
переходит на линкер, и вот он уже осуществляет всю работу по подгрузке
библиотек.

Первым делом линкер отправляется в секцию dynamic и ищет в ней записи,
помеченные как NEEDED. Эти записи содержат в себе имена библиотек, от
которых зависят все прочие библиотеки. Они будут загружены в первую
очередь.

После этого линкер отправляется в strtab - таблицу строк - и считывает
оттуда пути, по которым ищет остальные библиотеки. Найдя их, линкер
загружает их в память.

Следующий этап - это связывание библиотек друг с другом. Происходит это
рекурсивно: линкер заходит в секцию dynamic каждой библиотеки и ищет в
ней запись NEEDED. Если такая запись есть, то линкер отправляется в
библиотеку, указанную в этой записи, читает ее секцию dynamic и т.д. Это
продолжается до тех пор, пока не будет найдены библиотеки, не зависящие
от прочих. Линкер разрешит все ссылки сначала в них, а затем, откатываясь
назад по дереву рекурсии, будет разрешать ссылки в прочих библиотеках.

Линкер знает, что скорее всего его вызовут еще n раз, а еще знает, что скорее
всего будет вызвана libc, которой нужен доступ к некоторым секциям
жертвы, вроже секций fini или init, информация о которых хранится в
любимой нами секции dynamic. Но вот обращаться напрямую к записям
dynamic повторно линкер не хочет, да и libc это незачем.

Поэтому после того, как линкер свяжет все библиотеки друг с другом, он
создает в памяти буфер и сохраняет адреса необходимых ему и libc
записей dynamic - т.е. где эти записи расположены в памяти
процесса. Это позволит ему и libc обращаться к конкретным записям
dynamic, а не прочесывать ее всю каждый раз. Адрес этого буфера будет
положен в одну и записей GOT, а в другую запись линкер положит свой
собственный адрес, чтоб мы могли вызвать его из PLT. После чего
управление переходит на саму программу.

Внутри программы, когда мы натыкаемся на первый вызов какой-то
библиотечной функции, PLT вызывает линкер снова. Линкер читает имя
символа, который должен быть связан, а затем читает записьиз секции rela,
в которой описано, как именно должен быть связан этот символ. Затем
отправляется в библиотеку, где лежит этот символ, и просматривает ее
таблицу символов. Если символ найден, то линкер считывает смещение, по
которому лежит определение этого символа в библиотеке, складвает его с
базовым адресом и полученный адрес вписывает в запись GOT, которая
ассоциирована с этим символом. Именно так выполняется процесс релокации,
описанный выше. После этого линкер возвращает управление нашей программе.

Теперь, когда мы понимаем этот сложный процесс в деталях, нам становится
очевидно, почему инфицированный ELF работает некорректно.
Добавив новый заголовок, мы сместили весь код мишени на 56 байт. Но
проблема в том, что секции symtab, rela и dynamic ничего об этом не
знают. Адрес и и смещения, записанные в их записях, больше
неактуальны. Поэтому линкер получается совершенно не ту информацию, на
которую рассчитывает.

Чтобы это исправить, нужно отредактировать каждую запись в этих трех
секциях, увеличив смещение и/или адрес, записанные в них, на размер
заголовока сегмента вируса.

[TODO: объяснить, как найти эти секции в памяти и отредактировать записи]


План:
- объясняем релокации
- объясняем способ заражения
- заражаем
- натыкаемся на грабли
- решаем грабли
- подчищаем, чтобы "по красоте"
- бинго!
- радуемся

------------------------------------



Чтоб это исправить, нужно отредактировать все виртуальные адреса в
записях этих секций, увеличив их на 56 байт. Найти их можно по их
заголовкам: у загоовков секций есть поле ~sh_type~, которое указывает на
тип описываемой секции. Заголовки ~rela~ имеют тип 4, загоовок
~dynamic~ - тип 6, а ~symtab~ - тип 2. Из заголовка вы можете выудить
смещение секции от начала файла, сложить с базовым адресом загруженного в
память эльфа-жертвы и таким образом добраться до самой секции. А
поскольку в одной секции все записи одного размера, то вам достаточно
передвигаться на фиксированное количество байт и редактировать нужные
адреса.

С секцией ~GOT~ все чуть сложнее. Ее заголовок не имеет специфического
типа, поэтому лучше искать ее через секцию ~dynamic~. Запись, которая
описывает ~GOT~, имеет тип 3. Вы можете вытащить из нее виртуальный адрес
~GOT~, по нему найти заголовок секции в таблице секций, а затем проделать
все то же, что мы делали с другими секциями. Так вы обеспечите преход
обратно на ~PLT~ в случае, если библиотечная функция вызывается в первый
раз.

Если вы счастливый компилятора, который генерирует позиционно-независимый
код для вашей жертвы, то вы только что закончили свой первый вирус.

Моя же версия ~gcc~ подсунула мне хорошие грабли с увесистым таким
черенком. Она генерирует позиционно-зависимый код, в результате чего,
например, ~libc~, которая должна обеспечить корректный старт и завершение
передаются неверные параметры.

Урегулирование всех ссылок - это куда хуже, чем просто подредактировать
~PLT~, а ведь из-за этого мы отвергли более простую модель
заражения.

Но есть совершенно радикальный вариант: после исполнения вируса мы
подвинем код жертвы в памяти процесса таким образом, будто никакого
заражения не было. То есть сместим весь ее код, лежащий после таблицы
сегментов, на 56 байт назад, затерев таким образом вставленный заголовок
вируса. Все, что требуется для этого - это разрешить запись прямо в код.

Здесь поможет ~mprotect~, он позволяет менять атрибуты страниц памяти на
те, что нам нужны.

Таким образом до "сдвига" инфицированный файл выглядит вот так:

#+NAME: infected_victim_without_bind_now_before_move
#+BEGIN_SRC ditaa :file ./img/infected_victim_without_bind_now_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+
  | 0x400190         |                  cRED                               |
  |                  |  LOAD - ЗАГРУЖАЕМЫЙ ЗАГОЛОВОК СЕГМЕНТА ВИРУСА       |
  +------------------+-----------------------------------------------------+ <--- НАЧАЛО КОДА ЖЕРТВЫ
  | 0x4001c8         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- CЮДА ВИРУС ПЕРЕДАСТ УПРАВЛЕНИЕ
  | 0x400468         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОТСЮДА НАЧНЕТСЯ ИСПОЛНЕНИЕ ПРОГРАММЫ
  |                  |                  cRED                               |
  | 0x80128a         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                   cYEL                              |
  | 0x80158a         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: infected_victim_without_bind_now_before_move
[[file:./img/infected_victim_without_bind_now_before_move.png]]


А вот так будет выглядеть после:

#+NAME: infected_victim_without_bind_now_after_move
#+BEGIN_SRC ditaa :file ./img/infected_victim_after_move.png
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ELF-ФАЙЛА ОСТАЕТСЯ НА МЕСТЕ
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ ОСТАЕТСЯ НА МЕСТЕ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ВИРУСА ОКАЗАЛСЯ ЗАТЕРТ
  |                  |                   cBLU                              |
  | 0x400190         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОРИГИНАЛЬНАЯ ТОЧКА ВХОДА СМЕСТИЛАСЬ
  |                  |                    cBLU                             |       НА 56 БАЙТ
  | 0x400430         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕГМЕНТ ВИРУСА СМЕСТИЛСЯ НА 56 БАЙТ
  |                  |                  cBLU                               |
  | 0x801242         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                   cBLU                              |
  | 0x801542         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: infected_victim_without_bind_now_after_move
[[file:./img/infected_victim_after_move.png]]

К сожалению, это не решит все наши проблемы.

Мы недооценили, насколько линкер хитрая штуковина. Он знает, что скорее
всего его вызовут еще n раз, а еще знает, что скорее всего будет вызвана
~libc~, которой нужен доступ к некоторым секциям жертвы, вроже секций
~fini~ или ~init~, информация о которых хранится в любимой нами секции
~dynamic~. Но вот обращаться напрямую к записям ~dynamic~ повторно линкер
не хочет, да и ~libc~ это незачем. Так что линкер до того как передать
управление программе создает в памяти буфер и сохраняет адреса необходимых
ему и ~libc~ записей ~dynamic~ - т.е. где эти записи расположены в памяти
процесса. А затем, когда уже есть необходимость, ~libc~ и линкер
обращаются к конкретным записям, выуживая из них нужную информацию.

В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции ~dynamic~ в буфере становятся
неактуальными и ~libc~ получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.

Выход есть: отказ от "ленивого" связывания. Линкер умеет связывать все
здесь и сейчас и делает это он в случае, если обнаруживает в секции ~dynamic~
запись ~BIND_NOW~. Так что нам надо всего-то вставить дополнительные 16
байт в секцию, в первые из которых положено число ~0x18~.

Теперь наш файл будет выглядеть в памяти следующим образом, пока мы его
не подвинем:

#+NAME: victim_before_move_pic
#+BEGIN_SRC ditaa :file ./img/victim_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+
  | 0x400190         |                  cRED                               |
  |                  |  LOAD - ЗАГРУЖАЕМЫЙ ЗАГОЛОВОК СЕГМЕНТА ВИРУСА       |
  +------------------+-----------------------------------------------------+ <--- НАЧАЛО КОДА ЖЕРТВЫ
  | 0x4001c8         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- CЮДА ВИРУС ПЕРЕДАСТ УПРАВЛЕНИЕ
  | 0x400468         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕКЦИЯ DYNAMIC
  | 0x600e48         |    NEEDED - ПЕРВАЯ ЗАПИСЬ СЕКЦИИ DYNAMIC            |
  +------------------+-----------------------------------------------------+
  | 0x600e58         |                 ЗАПИСЬ INIT                         |
  +------------------+-----------------------------------------------------+
  | 0x600e68         |                 ЗАПИСЬ FINI                         |
  |                  |                  ........                           |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+
  |                  |                  cRED                               |
  | 0x600ee8         |       BIND_NOW - ВСТАВЛЕННАЯ НАМИ ЗАПИСЬ            |
  +------------------+-----------------------------------------------------+
  | 0x600ef8         |      NULL - ПОСЛЕДНЯЯ ЗАПИСЬ СЕКЦИИ DYNAMIC         |
  +------------------+-----------------------------------------------------+ <---- ОСТАВШИЙСЯ КОД ЖЕРТВЫ
  | 0x600f08         |               ПРОЧИЙ КОД ЖЕРТВЫ                     |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+ <---- ОТСЮДА НАЧНЕТСЯ ИСПОЛНЕНИЕ ПРОГРАММЫ
  |                  |                  cRED                               |
  | 0x80128a         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                  cYEL                               |
  | 0x80158a         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: victim_before_move_pic
[[file:./img/victim_before_move.png]]

И хотя это позволит вызывать библиотеки, это никак не поможет ~libc~
корректно завершить программу жертвы. ~libc~ берет из буфера, который нам
создал линкер, адреса записей ~fini~, ~fini_array~ и других, из которых
она должна получить адреса этих секций кода в памяти, а затем вызвать их.
И у нас нет никакой возможности повлиять на этот процесс.

На наше счастье все записи, необходимые ~libc~ для корректного завершения
программы, находятся в начале секции ~dynamic~. Это значит, что мы вполне
можем оставить ее на месте, но подвинуть весь код, расположенный за ней,
затерев ее нижние 72 байта - размер заголовка сегмента вируса и записи
~BIND_NOW~.

Таким образом после "сдвига" инфицированный файл будет выглядеть вот так:

#+NAME: victim_after_move_pic
#+BEGIN_SRC ditaa :file ./img/victim_after_move.png
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ELF-ФАЙЛА ОСТАЕТСЯ НА МЕСТЕ
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ ОСТАЕТСЯ НА МЕСТЕ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ВИРУСА ОКАЗАЛСЯ ЗАТЕРТ
  |                  |                   cBLU                              |
  | 0x400190         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОРИГИНАЛЬНАЯ ТОЧКА ВХОДА СМЕСТИЛАСЬ
  |                  |                    cBLU                             |       НА 56 БАЙТ
  | 0x400430         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕКЦИЯ DYNAMIC ОСТАЛАСЬ НА МЕСТЕ
  | 0x600e48         |    NEEDED - ПЕРВАЯ ЗАПИСЬ СЕКЦИИ DYNAMIC            |
  +------------------+-----------------------------------------------------+
  | 0x600e58         |                 ЗАПИСЬ INIT                         |
  +------------------+-----------------------------------------------------+
  | 0x600e68         |                 ЗАПИСЬ FINI                         |
  |                  |                  ........                           |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ЗАТЕРЛИ 72 БАЙТА СЕКЦИИ DYNAMIC,
  |                  |                    cBLU                             |       ВКЛЮЧАЯ ЗАПИСЬ BIND_NOW
  | 0x600ec0         |               ПРОЧИЙ КОД ЖЕРТВЫ                     |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+ <---- СЕГМЕНТ ВИРУСА СМЕСТИЛСЯ НА 72 БАЙТА
  |                  |                  cBLU                               |
  | 0x801242         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                  cBLU                               |
  | 0x801542         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: victim_after_move_pic
[[file:./img/victim_after_move.png]]

Итого мы получили вирус, который может заражать файлы как с
позиционно-независимым, так и с позиционно-зависимым кодом.

Надеюсь, мой опыт был кому-то полезным. Идеи и конструктивная критика крайне
приветствуются.
