#+STARTUP: showall indent hidestars

* Пишем вирус под Linux с нуля: опыт и грабли

[TODO:картинка с совой или что-то подобное]

Единственное руководство "для новичка" по написанию вирусов, что
мне удалось найти - это "Записки исследователя компьютерных вирусов"
Криса Касперски. Очень увлекательное чтение! Что если попробовать
реализовать пару идей оттуда? Сколько это займет времени для человека,
который ничего подобного раньше не делал? Какие подводные камни?

Так начался проект по написанию моего первого файлового вируса.

-=[cut]=-

Цель будет достигнута, если вирус сможет заразить файлы-мишени - т.е. это
такой маленький учебный проект на пару уикендов, войти и выйти. Ничего
сложного!

* План простой:

- пишем мишени
- пишем вирус
- ищем файлы
- инфицируем их (если еще не)
- проверяем что зараженные мишени работают
- пишем отчет

Что может пойти не так?

* Простейшая мишень и Section Header Table

Нарисуем мишень:

#+BEGIN_SRC c :tangle hello.c
  /* gcc hello.c -o hello */
  #include <stdio.h>
  #include <time.h>

  time_t rawtime;
  struct tm * timeinfo;

  int main()
  {
      printf( "Hello world!\n" );
      time ( &rawtime );
      timeinfo = localtime ( &rawtime );
      printf ( "Current local time and date: %s", asctime (timeinfo) );
      return 0;
  }
#+END_SRC

После компиляции мы получаем ELF-файл. Он очень просто устроен: таблица
сегментов хранит записи с указателями на сегменты, таблица секций -
записи с указателями на секции в этих сегментах, а заголовок эльфа
содержит информацию, где найти обе эти таблицы в файле, сколько в них
записей, точку входа и т.д.:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf.png
           +-------------------------------+
           | Заголовок ELF-файла           |
           | (ELF-header)                  |
           |                               |
           |   Phdr Table Offset >---------+----+
  +--------+-< Shdr Table Offset           |    |
  |        |        ...                    |    |
  |        +-------------------------------+    |
  |                                             |
  |        +-------------------------------+<---+
  |        | Таблица сегментов             |
  |        | (Program Header Table)        |
  |        |     1                         |
  |   +----+---< 2                         |
  |   |    |     ...                       |
  |   |    +-------------------------------+
  |   |
  |   |    +-------------------------------+
  |   |    | Segment 1 | Section A         |
  |   |    |           +-------------------|
  |   |    |           | Section B         |
  |   |    |           +-------------------|
  |   |    |           |      ...          |
  |   |    +-------------------------------+
  |   +--> +-------------------------------+
  |        | Segment 2 | Section C         |
  |        |           +-------------------|<---+
  |        |           | Section D         |    |
  |        |           +-------------------|    |
  |        |           |      ...          |    |
  |        +-------------------------------+    |
  |                                             |
  +------->+-------------------------------+    |
           | Таблица заголовков секций     |    |
           | (Section Header Table)        |    |
           |                         A     |    |
           |                         B     |    |
           |                         C     |    |
           |                         D >---+----+
           |                         ...   |
           +-------------------------------+
#+END_SRC

#+results: elf
[[file:./img/elf2.png]]

Интересно, что каждый сегмент, содержит внутри себя одну или несколько
секций. В документации указано, что таблица заголовков секций
необязательна, и чтобы проверить это, мы можем ее удалить. Для этого
лучше использовать утилиту ~sstrip~ из ELF Kickers, которую можно взять
тут: http://www.muppetlabs.com/%7Ebreadbox/software/elfkickers.html

Воспользовавшись ей получаем:

#+BEGIN_SRC sh
  $ sstrip hello
  $ readelf -S test_sect_tbl

  There are no sections in this file.

  $ ./hello
  Hello world
#+END_SRC

Действительно, Section Header Table не нужна, чтобы наш hello world мог
загрузиться и выполниться! Но сами секции внутри сегментов никуда не
делись, мы просто потеряли информацию о них. Настало время поговорить о
сегментах.

* Сегменты

Можно ожидать, что наша простая мишень будет иметь два сегмента - один
для кода, а второй для данных. Но ELF-ы умеют превосходить ожидания:

#+BEGIN_SRC sh
  $ readelf -l hello

  Elf file type is DYN (Shared object file)
  Entry point 0x10e0
  There are 13 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000002d8 0x00000000000002d8  R      0x8
    INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000006e0 0x00000000000006e0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x00000000000002b5 0x00000000000002b5  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x0000000000000188 0x0000000000000188  R      0x1000
    LOAD           0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000278 0x0000000000000290  RW     0x1000
    DYNAMIC        0x0000000000002da8 0x0000000000003da8 0x0000000000003da8
                   0x00000000000001f0 0x00000000000001f0  RW     0x8
    NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    GNU_EH_FRAME   0x0000000000002038 0x0000000000002038 0x0000000000002038
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000268 0x0000000000000268  R      0x1

   Section to Segment mapping:
    Segment Sections...
     00
     01     .interp
     02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
     03     .init .plt .plt.got .plt.sec .text .fini
     04     .rodata .eh_frame_hdr .eh_frame
     05     .init_array .fini_array .dynamic .got .data .bss
     06     .dynamic
     07     .note.gnu.property
     08     .note.gnu.build-id .note.ABI-tag
     09     .note.gnu.property
     10     .eh_frame_hdr
     11
     12     .init_array .fini_array .dynamic .got
#+END_SRC

Что это? Вместо ожидаемых двух сегментов, мы получили это! Давайте
разбираться:

~PHDR-сегмент~ описывает саму Program Header Table. Мы видим, что он
начинается по смещению 0x40 байт от начала файла, сразу после
ELF-заголовка.

~INTERP-сегмент~ описывает "Program Interpreter" - это указатель на
строку, содержающую путь к динамическому компоновщику, который еще
побросит нам сюрпризов, но пока мы это пропустим. Этот сегмент содержит
одну секцию .interp

~LOAD-сегмент-R~ - это первый LOAD-сегмент в файле. Он содержит несколько
секций, и первая из них - это .interp - мы ее только что видели в
предыдущем сегменте. Все LOAD-сегменты загружаются в память, когда
программа запускается. Первый LOAD-сегмент начинается с нулевого адреса,
значит он загружает в память все содержимое файла от его начала до
следующего LOAD-сегмента, который обычно содержит кода. Это содержимое
будет доступно программе НА ЧТЕНИЕ.

~LOAD-сегмент-RE~ содержит код в секции .text, а в остальных своих
секциях все что к нему относится, например, .init и .fini, а также
секции, которые связаны с GOT и PLT (.plt, .plt.got,
.plt.sec). Содержимое эттого сегмента будет загружено с правами НА ЧТЕНИЕ
И ИСПОЛНЕНИЕ.

~LOAD-сегмент-R~ обычно содержит в себе данные, которые будут доступны НА
ЧТЕНИЕ, например в секции .rodata и также может содержать в себе секции
вида .eh_frame относящиеся к обработке ислючений.

~LOAD-сегмент-RW~ содержит данные, доступные НА ЧТЕНИЕ И ЗАПИСЬ (в
секциях .data, .bss, .init_array, .fini_array и. т. п.), секции,
связанные с GOT (.got)

~DYNAMIC-сегмент~ содержит одну секцию .dynamic - в ней лежит информация,
имеющая отношение к релокациям. Эта секция тоже доступна НА ЧТЕНИЕ И
ЗАПИСЬ.

~NOTE-сегменты~ имеет тип NOTE, мы можем просмотреть его с помощью
"readelf -n" и обычно там нет ничего интересного.

~GNU_ сегменты~ содержат таблицы для обработки исключений, стек и таблицы
связанные с релокациями

Все это вместе выглядит как-то так:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf2.png
  +----------------------------+
  | Заголовок ELF-файла        |
  | (ELF-header)               |
  +----------------------------+

  +----------------------------+
  |Таблица заголовков сегментов|
  | (Program Header Table)     |
  +----------------------------+

  +----------------------------+
  | Segment (PHDR)             |
  +----------------------------+
  | Segment (INTERP)           |
  |    .interp                 |
  +----------------------------+
  | Segment (LOAD) R           |
  |    .interp                 |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RE          |
  |    .text                   |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) R           |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RW          |
  |      ...                   |
  +----------------------------+
  | Segment (DYNAMIC) RW       |
  |   .dynamic                 |
  +----------------------------+
  | Segment (NOTE)             |
  |     ...                    |
  +----------------------------+
  | Segment (GNU_...)          |
  |     ...                    |
  +----------------------------+

  +----------------------------+
  | Таблица заголовков секций  |
  | (Section Header Table)     |
  +----------------------------+
#+END_SRC

В этом прослеживается некоторая логика - все данные распределены по
секциям, а секции скомпонованы в сегменты в соответствии с правами
доступа к этим данным. Некоторые секции могут относиться к нескольким
сегментам одновременно - стоит это учитывать.

* Релокейты

Большинство серьезных программы используют разделяемые библиотеки,
который связываются динамически. Рассмотрим подробнее этот
механизм. Когда программе нужно вызвать функцию разделяемой библиотеки,
она делает вызов в специальную таблицу связи процедур (PLT - Procedure
Linkage Table).

Каждая запись этой таблицы содержит небольшой кусочек кода, который
выполняет коссвенный вызов нужной функции разделямой библиотеки. Этот
вызов коссвенный, потому что программа не знает адрес, где будет
находиться библиотека при каждом следующем запуске, ведь загрузчик
программ загружает библиотеки в адресное пространство процесса по
случайным адресам.

Чтобы узнать реальный адрес кусочек кода из PLT должен обратиться к GOT -
Global Offset Table, Глобальной Таблице Смещений. Динамический линкер
заботится о том, чтобы там были были правильные значения.

Таким образом, мы видим, что PLT должна иметь права на исполнение, а
GOT - на запись, потому что связывание динамическим линкером выполняется
лениво, т.е. прямо во время работы программы, при первой попытке доступа
к соответствующей функции.

При первом вызове разделяемой функции GOT содержит указатель обратно на
PLT, где вызывается динамический компоновщик для определения фактического
местоположения рассматриваемой функции. Найденное местоположение затем
записывается в GOT. При втором вызове функции GOT содержит известное
местоположение функции. Это называется «ленивое связывание».

Из вышесказанного можно сделать несколько выводов. Во-первых, PLT должен
располагаться с фиксированным смещением от раздела .text, чтобы код знал
как его найти. Во-вторых, поскольку GOT содержит данные, напрямую
используемые различными частями программы, его необходимо разместить по
известному статическому адресу в памяти.

Поскольку GOT существует в заранее определенном месте в памяти,
программа, содержащая уязвимость, позволяющая злоумышленнику записать 4
байта в контролируемое место в памяти, может быть использована для
выполнения произвольного кода.

Чтобы предотвратить эту уязвимость, нужно убедиться, что компоновщик
разрешает все динамически связанные функции в начале выполнения, а затем
делает GOT доступным только для чтения. Этот метод называется RELRO и
гарантирует, что GOT не может быть перезаписан во время выполнения

В частичном RELRO секция .got доступна только для чтения, но .got.plt все
еще доступен для записи. В то время как в полном RELRO и .got и .got.plt
помечен как доступен только для чтения.

И частичное, и полное RELRO изменяют порядок внутренних разделов данных
ELF, чтобы защитить их от перезаписи в случае переполнения буфера.

* Проблема инфицирования

Куда же в этой запутанной структуре мы можем вставить свой вирус?
Нам нужно несколько  факторов:
- сегмент вируса должен загрузиться в память, следовательно, он должен
  быть частью какого-то LOAD-сегмента мишени или же иметь свой
  собственный LOAD-сегмент.

- сегмент вируса должен иметь права на исполнение.

- код в секциях обычно ссылается на данные, которые находятся в сегменте
данных. Это значит, что если мы попытаемся вставить вирус между кодом и
данными, то относительное расстояние между ними изменится и ссылки станут
неверными. В результате мишень станет неработоспособной.

Есть три варианта, которые предлагаются Касперски и некоторыми другими
исследователями как наиболее простые для начинающего вирусописателя.

1. Вставить вирус в padding между таблицей заголовков сегментов и кодом
   программы.

   Если вирус вмещается в padding, то нам вообще не придется
   редактировать какие-либо структуры ELF-a, кроме его заголовка, чтоб
   изменить адрес точки входа. Но ключевая проблема как раз в том, что
   padding может быть совсем незначительным или его может не быть вовсе.

2. Найти первый загружаемый сегмент кода - сегменты такого типа грузятся
   в память процесса - и вписать вирус в его конец. Затем расширить этот
   сегмент на размер вируса и немного отредактировать остальные заголовки
   секций и сегментов, потому что весь код сместится на рамер вируса.

   Этот способ очень неплох по нескольким параметрам. Во-первых, не
   придется оформлять вирус в отдельный сегмент. Во-вторых, наличие
   вируса становится чуть менее очевидным для вирусного аналитика.

   Но у этого способа есть значительный недостаток. Как уже упоминалось
   выше, программы, слинкованные динамически, имеют секции PLT и
   GOT. PLT обычно располагается перед секцией .text в первом
   LOAD-сегменте, а вот GOT располагается уже во втором LOAD-сегменте. Если мы
   вставляем вирус в конец первого сегмента, то получается, что мы
   вставляем его между PLT и GOT. Из-за этого PLT больше не может
   обратиться к GOT, а обращается к адресу, где GOT была до заражения.

   Исправить это можно, если отредактировать код PLT, найдя инструкции
   относительных ~jmp~ и изменив в них смещения. Но это довольно
   трудоемкий процесс, так что откажемся от этого варианта.

3. Вписать вирус перед таблицей заголовков секций мишени и оформить его в
   самостоятельный LOAD-сегмент.

   Если мы оформляем вирус в отдельный сегмент, то этому сегменту
   понадобится свой собственный заголовок сегмента и заголовок
   секции. Вставка дополнительного заголовка сегмента приведет к тому,
   что весь код жертвы сместится равномерно и нам не придется
   редактировать код PLT.

   Поэтому мы остановимся на этом варианте заражения как на оптимальном.

* Инфицирование пошагово

Первая задача, которая перед нами стоит, заключается в том, чтобы вписать
код вируса в файл мишени, при этом не сломав его формат. То есть мы
пересобрать файл таким образом, чтобы его можно было запустить. Если
сегфолт возник уже после того, как загрузчик передал управление
программе, или же не возник вообще, мы можем быть уверены, что сам формат
файла не поломан.

На выходе из этой стадии ELF должен выглядеть вот так:

#+NAME: infected_elf
#+BEGIN_SRC ditaa :file ./img/infected_elf.png
  +---------------------------------------+
  | Заголовок ELF-файла                   |
  |  (ELF-header)                         |
  +---------------------------------------+

  +---------------------------------------+
  |  Таблица заголовков сегментов         |
  |  (Program Header Table)               |
  |                                       |
  +---------------------------------------+
  |   PHDR Header                         |
  +---------------------------------------+
  |   Interp Header                       |
  +---------------------------------------+
  |   Load Header                         |
  |   (victim load header)                |
  +---------------------------------------+
  |   ...                                 |
  +---------------------------------------+
  |   Load Header                         |
  |   (malware load header)               |
  +---------------------------------------+


  +---------------------------------------+
  |   Load Segment 1                      |
  +---------------------------------------+
  |   Load Segment 2                      |
  +---------------------------------------+
  |   ....                                |
  +---------------------------------------+
  |   Load Segment                        |
  |   (malware load segment)              |
  +---------------------------------------+

  +---------------------------------------+
  |  Таблица заголовков секций            |
  |  (Section Header Table)               |
  +---------------------------------------+
  |  Null Section Header                  |
  +---------------------------------------+
  |  Interp Section Header                |
  +---------------------------------------+
  |  ...                                  |
  +---------------------------------------+
  |  Text Section Header                  |
  |  (victim text section header)         |
  +---------------------------------------+
  |  ...                                  |
  +---------------------------------------+
  |  Text Section Header                  |
  |  (malware text section header)        |
  +---------------------------------------+
#+END_SRC

Чтоб получить такой результат, нужно выполнить несколько действий.

1. Загрузите ваш файл в память.

   Загрузка файла в память нужна, чтоб можно было читать, редактировать,
   а затем сливать нужный нам код. Я это делаю с помощью вызова ~mmap~.

2. Распарсите ваш ELF.

   На этом этапе вы должны выяснить, где что у вас в файле находится. На
   данный момент нас интересуют только таблицы заголовков секций и
   сегментов, а так же точка входа.

   Выяснить их расположение таблиц просто: заголовок ELF-файла содержит в себе поля
   e_phoff - оно содержит в себе смещение от начала файла до таблицы
   заголовков сегментов - и  e_shoff, которое содержит в себе смещение от
   начала файла до таблицы заголовков секций. Имея базовый адрес
   ELF-файла в памяти, который вернул mmap, можно поочередно сложить его
   с полученными смещениями и таким образом выяснить, где находятся
   таблицы заголовков в памяти на данный момент.
   А поля e_phnum и e_shnum в заговке ELF-а позволят узнать количество
   этих заголовков в этих таблицах.

   Поле e_entry сообщит виртуальный адрес точки входа.

3. Выделите память под новые заголовки.

   В 64-разрядной системе заголовок сегмента всегда будет занимать 56
   байт, а заголовок секции - 60 байт.

4. Посчитайте виртуальный адрес вируса.

   Загрузчик слишком умен, нам нужно сделать так, чтоб сегмент кода
   вируса выглядел для него влаидным. Чтоб сегмент сочли валидным, вы
   должны соблюсти  соотношение между виртуальным адресом вашего сегмента
   и его смещением от начала файла.
   Если вычесть второе из первого, то вы должны получить адрес, кратный 4кб.

   Посчитать виртуальный адрес для вируса нетрудно:
   - Находите заголовок последнего LOAD-сегмента мишени (у него будет
     самый большой виртуальный адрес)

   - Считываете его ~p_vaddr~ и ~p_allign~ - т.е. его виртуальный адрес и
     выравнивание.

   - Выравниваете виртуальный адрес последнего сегмента по 4 кб,
     прибавляете к нему выравнивание и смещение вашего вируса в файле.

   Приходится учитывать выравнивание, поскольку как правило с байтами
   выравнивания вы не можете делать буквально ничего и попытка что-то
   исполнить там приведет к сегфолту.

5. Заполните выделенную память под заголовки данными в соответствии
   со структурами заголовка сегмента и заголовка секции.

   Заголовок сегмента для вируса будет выглядеть следующим образом:
   - p_type   - 4 байта, знач. 1 - PL_LOAD
   - p_flags  - 4 байта, знач. 1 - разрешение на исполнение
   - p_offset - 8 байт, смещение вируса в файле
   - p_vaddr  - 8 байт, виртуальный адрес вируса
   - p_paddr  - аналогично ~p_vaddr~
   - p_filesz - 8 байт, размер вируса в файле
   - p_memsz  - 8 байт, размер вируса в памяти (аналогичен p_filesz в
     нашем случае)
   - p_allign - 8 байт, - значение 0, выравнивание не требуется

  А вот таким будет загоовок секции вируса.
   - sh_name      - 4 байта, значение - индекс в таблице строк, где строка - это
                              имя секции.
   - sh_type      - 4 байта, тип секции 1 (PROGBITS) - значение секции определяется
                             и используется программой единолично
   - sh_flags     - 8 байт, значение 4 - разрешение на исполнение
   - sh_addr      - 8 байт, виртуальный адрес вируса, аналогичен p_vaddr из
                            заголовка сегмента
   - sh_offset    - 8 байт, смещение вируса в файле
   - sh_size      - 8 байт, размер вируса в файле
   - sh_link      - 8 байт, значение - 0
   - sh_info      - 8 байт, значение 0
   - sh_addralign - 8 байт, значение 0, выравнивание не требуется
   - sh_entsize   - 8 байт, значение 0, код не содержит никаких записей
                  фиксированного размера


6. Увеличьте поля p_paddr, p_vaddr и p_offset на 56 байт во всех
   заголовках сегментов, которые описывают код, находящийся после таблицы
   заголовков.

   Таким образом вы укажете, что изменились физические и
   виртуальные адреса сегментов, а так же их смещение от начала файла,
   т.е. весь код съехал на те самые 56 байт как в файле, так и в памяти
   процесса.

7. Увеличьте поля sh_addr и sh_offset на 56 байт во всех заголовках
   секций по тому же принципу и тем же причинам, описанным в пункте
   выше.

8. Увеличьте поля e_phnum и e_shnum в заголовке эльфа на единицу.

   Так вы укажете, что загоовков сегментов и загоовков секций стало на 1
   больше. А так же установите новое смещение от начала файла таблицы
   заголовков секций в поле e_shoff - в противном случае заголовки
   секций не будут найдены, и формат будет сломан.

9. Перезапишите ваш ELF.

   Впишите данные в файл в следующей последовательности:
   - код от начала файла до конца таблицы заголовков сегментов
   - заголовок сегмента вируса
   - весь код жертвы до начала таблицы секций
   - весь код вируса
   - таблицу секций
   - заголовок секции вируса

   Мне в этом помог вызов ~pwite~, где можно задать смещение
   от начала файла, по которому должна вестись запись.

Теперь у вас есть инфицированный файл, но пока что он совершенно
бесполезен: во-первых, мы не передали управление на вирус, следовательно,
его код не исполнится, а во-вторых, с большой вероятностью запуск этого
файла завершится сегфолтом, о причинах которого я расскажу ниже.

Для начала разберемся с более простой задачей, заставим вирус
исполниться.

В общем случае у нас есть два варианта, как будет работать инфицированный
файл: либо вирус исполняется сначала, а затем передает управление на код
мишени, либо наоборот.

Первый вариант воплотить проще, поскольку не придется искать окончание
функции main мишени и переписывать его конец, чтоб обеспечить передачу
управления вирусу.

Чтоб перевести управление на вирус сразу, нужно отредактировать поле
e_entry в заголовке инфицированного ELF-a, вставив в него виртуальный
адрес вируса. А чтоб передать управление на код мишени, нам понадобится
всего 5 байт машинного кода, который мы напишем вручную и вставим его
вместо выхода из вируса.

* Пишем машинный код вручную

В ассмеблере есть инструкция jmp, которая является безусловным переходом. Ее параметр
может быть как абсолютным адрсом, т.е. буквально ~jmp 0x400345~, так и
смещением от следующей за jmp инструкцией до нужного адреса.
Параметр занимает 4 байта, а e9 - машкод jmp -  занимает 1 байт.

Чтобы правильно написать переход на код мишени, нам понадобится:
- посчитать, на каком адресе инструкции будет находиться вирус, когда
  будет передавать управление на оригинальную точку входа мишени

  Берем виртуальный адрес вируса, который мы высчитывали выше, берем
  размер кода вируса и складываем их. А затем прибавляем к полученному
  адресу еще 5 байт - смещение высчитывается от следующей за переходом
  инструкции.

- оригинальная точка входа мишени
  Ее мы берем из поля e_entry до того, как успели отредактровать это
  поле.

 Теперь вычитаем из оригинальной e_entry полученный адрес инструкции и
 получаем таким образом смещение до оригинальной точки входа.

 Возьмем конкретный пример: адрес вашего вируса 0x8012a8, его размер
 0x100 байт, адрес оригинальной точки входа 0x400430.
 0x400430 - (0x8012a8 + 0x100 + 0x5) = -400f7d.
 Смещение получается отрицательным, поскольку мы совершаем прыжок не
 "вперед", а "назад".

Теперь наш инфицированный ELF выглядит следующим образом:

#+NAME: infected_elf2
#+BEGIN_SRC ditaa :file ./img/infected_elf2.png
         +---------------------------------------+
         | Заголовок ELF-файла                   |
         |  (ELF-header)                         |
         |   ...                                 |
         |   e_entry                             |------+
         +---------------------------------------+      |
                                                        |
         +---------------------------------------+      |
         |  Таблица заголовков сегментов         |      |
         |  (Program Header Table)               |      |
         |                                       |      |
         +---------------------------------------+      |
         |   PHDR Header                         |      |
         +---------------------------------------+      |
         |   Interp Header                       |      |
         +---------------------------------------+      |
         |   Load Header                         |      |
         |   (victim load header)                |      |
         +---------------------------------------+      |
         |   ...                                 |      |
         +---------------------------------------+      |
         |   Load Header                         |      |
         |   (malware load header)               |      |
         +---------------------------------------+      |
                                                        |
                                                        |
         +---------------------------------------+      |
         |   Load Segment 1                      |      |
         |   ...                                 |      |
  +----->|   original e_entry                    |      |
  |      +---------------------------------------+      |
  |      |   Load Segment 2                      |      |
  |      +---------------------------------------+      |
  |      |   ....                                |      |
  |      +---------------------------------------+      |
  |      |   Load Segment                        |<-----+
  |      |   (malware load segment)              |
  |      +---------------------------------------+
  +------|   Transfer Control to                 |
         |   original e_entry                    |
         +---------------------------------------+


         +---------------------------------------+
         |  Таблица заголовков секций            |
         |  (Section Header Table)               |
         +---------------------------------------+
         |  Null Section Header                  |
         +---------------------------------------+
         |  Interp Section Header                |
         +---------------------------------------+
         |  ...                                  |
         +---------------------------------------+
         |  Text Section Header                  |
         |  (victim text section header)         |
         +---------------------------------------+
         |  ...                                  |
         +---------------------------------------+
         |  Text Section Header                  |
         |  (malware text section header)        |
         +---------------------------------------+
#+END_SRC

#+results: infected_elf2
[[file:./img/infected_elf2.png]]


* Немного о линковке

Теперь у нас есть запускающийся инфицированный ELF-файл, который
неизменно выдает сегфолт. Чтоб понять причины этого, нужно детально разобраться в том,
как происходит процесс линковки от начала и до конца.

В начале этой статьи мы разобрались с сегментами программы, выяснили, для
чего каждый из них нужен, и немного коснулись релокейтов и секций plt и
got. Теперь мы поговорим о некоторых секциях, которые критично важны для
правильной работы динамически слинкованного файла и линковки.

Помимо секций когда и секций данных в каждом ELF-файле есть таблица
символов, которая содержит в себе информацию о символах
программы. В динамически слинкованном ELF-е таблиц символов может быть
максимум две - symtab и dynsym. Dynsym содержит в себе информацию о
динамических символах программы - т.е. о символах, заимствованных из
библиотек, а symtab хранит в себе информацию обо всех символах вообще:
имя символа, его виртуальный адрес, тип связязывания, видимость в файле и
т.д. После компиляции в этой таблице можно увидеть связь символа и адрес,
на который он ссылается. Именно такую таблицу проверяет рантайм-линкер, когда
ищет, например, код printf в библиотеке, чтоб вернуть нам адрес на него.

Для корректной работы помимо symtab линкеру необходимы секции rela и
dynamic.

Секция dynamic хранит в себе всю информацию, которая может понадобиться
линкеру или libc, которая осуществляет корректный старт и завершение
сишной программы.

Здесь вы можете видеть уже знакомые нам pltgot и symtab, а так же
упомянутую секцию rela. Если какая-то информация в этой секции не будет
соответствовать действительности, то ваша программа либо не запустится,
потому что libc не сможет настроить старт для нее, либо сломается процесс
рантайм линковки, либо программа не сможет корректно завершиться.

#+BEGIN_SRC sh
  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Секция rela содержит в себе информацию о релокейтах: их имена,
адреса, как именно должна выполниться релокация и т.д.
#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0

#+END_SRC

Но что такое релокация? Многих сбивает буквальный перевод -
"перемещение". Что там такое перемещается, если все остается на месте?

Вот тут мы вполную подошли к процессу линковки.

Вернемся назад, к моменту, когда мы только написали код нашей мишени и
запустили ее компиляцию.

Из всех этапов компиляции нас интересует только два: кодогенерация и
линковка. На этапе кодогенерации генерируется весь код и проверяется наличие определения
(объекта) для всех используемых символов. Определения могут находиться и
за пределами текущего файла, и тогда мы будем их искать в указанных
библиотеках с помощью таблицы символов в них.
Если же не найдем и там, то компиляция не завершится.

На выходе из этого этапа мы получаем объектный файл. Распечатав такой файл с
помощью objdump-a мы видим, что в нем не хватает секции plt и got,
dynamic и многих других. Это происходит, потому что заключительного этапа
компиляции - линковки - еще не было.

Давайте взглянем на таблицу символов
#+BEGIN_SRC sh
    $ readelf -s hello.o

  Таблица символов «.symtab» содержит 17 элементов:
     Чис:    Знач           Разм Тип     Связ   Vis      Индекс имени
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
       3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
       4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
       5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
       6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
       7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
       8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
       9: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM rawtime
      10: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM timeinfo
      11: 0000000000000000    81 FUNC    GLOBAL DEFAULT    1 main
      12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
      13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND time
      14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND localtime
      15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND asctime
      16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf

#+END_SRC
Во-первых, она очень короткая, потому что многие символы еще не
подклчены. А во вторых, в поле "значение", в котором должен находиться
адрес символа или его смещение в файле, пусто. Линковки еще не было,
поэтому ссылки на символы все еще не заполнены.

А теперь  посмотрим на секции rela.
#+BEGIN_SRC sh
  $ readelf -r hello.o

  Раздел перемещения '.rela.text' со смещением 0x310 содержит 11 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000005  00050000000a R_X86_64_32       0000000000000000 .rodata + 0
  00000000000a  000c00000002 R_X86_64_PC32     0000000000000000 puts - 4
  00000000000f  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  000000000014  000d00000002 R_X86_64_PC32     0000000000000000 time - 4
  000000000019  00090000000a R_X86_64_32       0000000000000008 rawtime + 0
  00000000001e  000e00000002 R_X86_64_PC32     0000000000000000 localtime - 4
  000000000025  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  00000000002c  000a00000002 R_X86_64_PC32     0000000000000008 timeinfo - 4
  000000000034  000f00000002 R_X86_64_PC32     0000000000000000 asctime - 4
  00000000003c  00050000000a R_X86_64_32       0000000000000000 .rodata + 10
  000000000046  001000000002 R_X86_64_PC32     0000000000000000 printf - 4

  Раздел перемещения '.rela.eh_frame' со смещением 0x418 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
#+END_SRC

Поле "смещение" действительно указывает на смещение в файле, а не на
виртуальный адрес, куда мы положим новый адрес релокейта.

Что ж, завершим нашу компиляцию, превратив объектный файл в
исполняемый. На этом этапе включается линкер, который должен заполнить
все ссылки, какие сможет. Но есть ссылки, которые он заполнить не
сможет. Это происходит, потому что на этом этапе линкер не имеет никакого
представления о том, куда будут загружены библиотеки, и потому оставляет
эти ссылки нетронутыми до исполнения программы, где уже включится
известным нам механизм ленивого связывания, которое осуществляется с
помощью PLT и GOT.

Благодаря им и магии виртуальной памяти мы можем загрузить библиотеку
один раз и разделить ее между несколькими программами, и для каждой она
будет как будто лежать по разным адресам.

Но так было далеко не всегда. Когда PLT и GOT не было, процесс выглядел
по-другому. Помимо того, что для каждого процесса приходилось отдельно
подгружать библиотеку, отличался процесс линковки.
На этапе компиляции линкер предполагал, что библиотеки будут размещены
примерно сразу за стеком и вписывал смещение от текущей инструкции до
предполагаемого адреса кода библиотеки, который был нужен. А затем
рантайм линкер во время исполнения программы получал базовый адрес
загруженной библиотеки и складывал этот адрес с посчитанным ранее
смещением и таким образом вызывался необходимый код.

Именно из-за этого процесса релокейты так называются. Фактически у нас
есть символ и есть ссылка на его объект - определение. До исполнения программы
ссылка указывает в одно место, а во время исполнения начинает указывать в
другое место. Т.е. мы перемещаем саму ссылку на объект.

Теперь же мы используем PLT и GOT. Посмотрите на виртуальные адреса
релокейтов в секциях rela.

#+BEGIN_SRC sh
  $ readelf -r hello

  Раздел перемещения '.rela.dyn' со смещением 0x438 содержит 1 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601040  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

  Раздел перемещения '.rela.plt' со смещением 0x450 содержит 6 пунктов:
    Смещение        Инфо           Тип            Знач.симв.    Имя симв. + Addend
  000000601060  000100000007 R_X86_64_JUMP_SLO 0000000000000000 localtime@GLIBC_2.2.5 + 0
  000000601068  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
  000000601070  000300000007 R_X86_64_JUMP_SLO 0000000000000000 asctime@GLIBC_2.2.5 + 0
  000000601078  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
  000000601080  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
  000000601088  000700000007 R_X86_64_JUMP_SLO 0000000000000000 time@GLIBC_2.2.5 + 0

#+END_SRC

И взгляните, на какие именно записи в GOT прыгает PLT.

#+BEGIN_SRC sh
  0000000000400508 <localtime@plt-0x10>:
    400508:	ff 35 32 0b 20 00    	pushq  0x200b32(%rip)        # 601040 <_DYNAMIC+0x1e0>
    40050e:	ff 25 34 0b 20 00    	jmpq   *0x200b34(%rip)        # 601048 <_GLOBAL_OFFSET_TABLE_>
    400514:	0f 1f 40 00          	nopl   0x0(%rax)

  0000000000400518 <localtime@plt>:
    400518:	ff 25 32 0b 20 00    	jmpq   *0x200b32(%rip)        # 601050 <_GLOBAL_OFFSET_TABLE_+0x8>
    40051e:	68 00 00 00 00       	pushq  $0x0
    400523:	e9 e0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400528 <puts@plt>:
    400528:	ff 25 2a 0b 20 00    	jmpq   *0x200b2a(%rip)        # 601058 <_GLOBAL_OFFSET_TABLE_+0x10>
    40052e:	68 01 00 00 00       	pushq  $0x1
    400533:	e9 d0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400538 <asctime@plt>:
    400538:	ff 25 22 0b 20 00    	jmpq   *0x200b22(%rip)        # 601060 <_GLOBAL_OFFSET_TABLE_+0x18>
    40053e:	68 02 00 00 00       	pushq  $0x2
    400543:	e9 c0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400548 <printf@plt>:
    400548:	ff 25 1a 0b 20 00    	jmpq   *0x200b1a(%rip)        # 601068 <_GLOBAL_OFFSET_TABLE_+0x20>
    40054e:	68 03 00 00 00       	pushq  $0x3
    400553:	e9 b0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400558 <__libc_start_main@plt>:
    400558:	ff 25 12 0b 20 00    	jmpq   *0x200b12(%rip)        # 601070 <_GLOBAL_OFFSET_TABLE_+0x28>
    40055e:	68 04 00 00 00       	pushq  $0x4
    400563:	e9 a0 ff ff ff       	jmpq   400508 <_init+0x28>

  0000000000400568 <time@plt>:
    400568:	ff 25 0a 0b 20 00    	jmpq   *0x200b0a(%rip)        # 601078 <_GLOBAL_OFFSET_TABLE_+0x30>
    40056e:	68 05 00 00 00       	pushq  $0x5
    400573:	e9 90 ff ff ff       	jmpq   400508 <_init+0x28>

#+END_SRC

Эти адреса совпадают с виртуальными адресами релокейтов из секций
rela. Суть механизма осталась прежней, просто PLT и GOT позволяют
оптимизировать подкгрузку библиотек.

Сначала ссылки на релокейты  содержат в себе адрес кода в PLT, который
вызовет линкер, а после рантайм линковки будут содержать в себе адрес,
по которому лежит библиотечный код.

Но как в деталях происходит этот процесс?

Теперь, когда мы скомпилировали файл, мы можем его запустить и проследить
весь путь работы линкера.

Загружая файл, загрузчик должен какм-то образом понять, какие библиотеки
ему загружать. Но вся фишка в том, что все, что он загружает - это сам
файл и линкер, чье имя оказано в сегмента INTERP. Затем управление
переходит на линкер, и вот он уже осуществляет всю работу по подгрузке
библиотек.

Первым делом линкер отправляется в секцию dynamic и ищет в ней записи,
помеченные как NEEDED. Эти записи содержат в себе имена библиотек, от
которых зависят все прочие библиотеки. Они будут загружены в первую
очередь.

После этого линкер отправляется в strtab - таблицу строк - и считывает
оттуда пути, по которым ищет остальные библиотеки. Найдя их, линкер
загружает их в память.

Следующий этап - это связывание библиотек друг с другом. Происходит это
рекурсивно: линкер заходит в секцию dynamic каждой библиотеки и ищет в
ней запись NEEDED. Если такая запись есть, то линкер отправляется в
библиотеку, указанную в этой записи, читает ее секцию dynamic и т.д. Это
продолжается до тех пор, пока не будет найдены библиотеки, не зависящие
от прочих. Линкер разрешит все ссылки сначала в них, а затем, откатываясь
назад по дереву рекурсии, будет разрешать ссылки в прочих библиотеках.

Линкер знает, что скорее всего его вызовут еще n раз, а еще знает, что скорее
всего будет вызвана libc, которой нужен доступ к некоторым секциям
жертвы, вроже секций fini или init, информация о которых хранится в
любимой нами секции dynamic. Но вот обращаться напрямую к записям
dynamic повторно линкер не хочет, да и libc это незачем.

Поэтому после того, как линкер свяжет все библиотеки друг с другом, он
создает в памяти буфер и сохраняет адреса необходимых ему и libc
записей dynamic - т.е. где эти записи расположены в памяти
процесса. Это позволит ему и libc обращаться к конкретным записям
dynamic, а не прочесывать ее всю каждый раз. Адрес этого буфера будет
положен в одну и записей GOT, а в другую запись линкер положит свой
собственный адрес, чтоб мы могли вызвать его из PLT. После чего
управление переходит на саму программу.

Внутри программы, когда мы натыкаемся на первый вызов какой-то
библиотечной функции, PLT вызывает линкер снова. Линкер читает имя
символа, который должен быть связан, а затем читает записьиз секции rela,
в которой описано, как именно должен быть связан этот символ. Затем
отправляется в библиотеку, где лежит этот символ, и просматривает ее
таблицу символов. Если символ найден, то линкер считывает смещение, по
которому лежит определение этого символа в библиотеке, складвает его с
базовым адресом и полученный адрес вписывает в запись GOT, которая
ассоциирована с этим символом. Именно так выполняется процесс релокации,
описанный выше. После этого линкер возвращает управление нашей программе.

Теперь, когда мы понимаем этот сложный процесс в деталях, нам становится
очевидно, почему инфицированный ELF работает некорректно.
Добавив новый заголовок, мы сместили весь код мишени на 56 байт. Но
проблема в том, что секции symtab, rela, dynamic и got, чьеи записи
содержат адрес кода в PLT, вызывающего линкер, ничего об этом не
знают. Адреса и смещения, записанные в их записях, больше
неактуальны. Поэтому линкер получается совершенно не ту информацию, на
которую рассчитывает.

Чтобы это исправить, нужно отредактировать каждую запись в этих трех
секциях, увеличив смещение и/или адрес, записанные в них, на размер
заголовока сегмента вируса.

* Редактируем got, symtab, rela и dynamic

Секции symtab, rela и dynamic достаточно просто найти.
У нас есть таблица заголовков секций. В каждом заголовке секции есть поле
sh_type, которое обозначает, секцию какого типа описывает этот заголовок. Не у каждой
секции есть свой специфический тип, но у rela, symtab и dynamic этот типа
есть. Секции rela имеют тип 4, секция symtab - тип 2, секция dynamic -
тип 4. Найдя заголовок интересущей вас секции, считайте ее смещение от
начала файла, а затем сложите это смещение с базовым адресом вашей
загруженной в память мишени. Так вы найдете, где секции располагаются в
памяти.

Поскольку записи в этих секциях фиксированного размера, то вы можете
просто сдвигать указатель на определенное количество байт и таким образом
редактировать нужные вам поля.

С секцией got чуть сложнее. Она имеет тип 1, а с этим типом есть
множество секций. Но есть секция, которая которая ссылкается на секцию
got - это секция dynamic, как мы знаем. Запись о секции got имеет тип 3 в
секции dynamic и этот тип уникален. Поскольку мы теперь знаем, где
находится dynamic в памяти, мы можем пройтись по ней и найти запись о
секции got. Затем мы считаем оттуда виртуальный адрес этой секции и уже
по нему найдем ее заголовок в таблице заголовков секций. Далее считаем
смещение, сложим его с базовым адресом эльфа и получим адрес секции got в
памяти. А дальше можем отредактировать записи в ней как в прочих
секциях.

Если так вышло, что у вас нет заголовков секций вообще, то вы можете
сначала найти секцию dynamic по заголовку ее сегмента. Вы вычислите адрес
секции dynamic уже указанным способом и считаете оттуда записи секции
rela, symtab и got и получаете адреса этих сегментов. Затем вы берете
виртуальный адрес первого сегмента и вычитаете его из каждого полученного
виртуального адреса. Так вы получите смещение в файле для rela и symtab,
затем сложите их с базовым адресом ELF-a и получите адреса секций в
памяти.

Но вычислить таким образом адрес got не удастся. Дело в том, что при
загрузке ELF-а в память, mmap не учитывает выравнивание между сегментами,
он просто загружает файл в память, как есть.
А вот виртуальные адреса распределены с учетом этого выравнивания.
В результате если адрес первого сегмента кода у вас 0x400000, а адрес got
0x600e10, то 0x600e10 - 0x400000 = 200e10, что не является верным
смещением, потому что на самом деле оно просто e10. В результате попытка
сложить такое огромное смещение с базовым адресом ELF-а, а потом
прочитать по нему что-то приведет к сегфолту, потому что эта память не
выделена программе.

[TODO: придумать, как решить эту проблему]

Если вы счастливый обладатель компилятора, который сгенерировал для вашей
мишени позиционно-независимый код, то закончив редактирование названных
секций, вы получили работающий вирус. А для мене удачливых приключение
продолжается.

* Чем плох позиционно зависимый код.

Давайте сначала разбираться, что такое позиционно-зависимый код и в чем
его отличие от позиционно-независимого кода.

У нас есть абсолютная или относительная адресация. Абсолютная адресация
предполагает, что вы указываете вашей программе перейти на какой-то
концретный адрес. Например, вызвать адрес 0x400430 или поместить его в
какой-то регистр как параметр. Это значит, что если, например, ваша
программа будет работать корректно только в случае, если каждый раз будет
загружена по одним и тем же адресам. И такой код назвывается
позиционно-зависимым, поскольку зависит от того, с каких адресов
загружается программа.

Но мы можем использовать относительную адресацию. То есть, например,
высчитывать адрес, который мы вызываем или который используем как
параметр, как смещение от какой-то точки программы. Например, именно так
мы передаем управление мишени после того, как вирус отработал - прыгаем
на не конкретный адрес, а на адрес, который находится на определенном
смещении от следующей за прыжком инструкции. Такой код называется
позиционно-независимым, поскольку ему абсолютно неважно, с каких именно
адресов он будет загружен, а важно лишь соотношение между разными блоками
кода. Именно благодаря позиционно-независимому коду динамически
разделяемые библиотеки загружаются каждый раз с нового адреса, но при
этом продолжают работать.

Моя версия компилятора gcc генерирует позиционно-зависимый код. Как мы
помним, во время заражения мы вставили заголовок сегмента вируса, из-за
чего весь код мишени съехал на 56 байт. Из-за этого даже при идеально
отредактированных загоовоках, секциях и т.д. мишень будет выдавать
сегфолт.

Очевидное решение - урегулировать все ссылки - слишком трудоемкое. Мы
отказались вписывать вирус в первый сегмент кода мишени, потому что это
предполагало урегулирование ссылок в PLT. А здесь придется редактировать
ссылки во всей программе. Но решение есть, хотя оно немного радикальное.

* Урегулирование ссылок

Вместо того, чтоб искать каждую ссылку и редактировать ее отдельно, до
того как передать управление на код мишени, мы сдвинем ее код, начинающийся после
таблицы заголовков сегментов, как будто никакого заражения не было. Для этого просто
потребуется затереть заголовок вируса, перенеся весь код на 56 байт
назад. Тогда программа вернется на свои изначальные адреса, и
позиционно-зависимый код будет работать корректно.

Вот так будет выглядеть инфицированный файл до и после того, как мы подвинем код:

#+NAME: infected_elf3
#+BEGIN_SRC ditaa :file ./img/infected_elf3.png
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400000 | Заголовок ELF-файла         |  |0x400000 | Заголовок ELF-файла         |
  |         |  (ELF-header)               |  |         | (ELF-header)                |
  +---------+-----------------------------+  +---------+-----------------------------+

  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400040 |Таблица заголовков сегментов |  |0x400040 |Таблица заголовков сегментов |
  |         |(Program Header Table)       |  |         |(Program Header Table)       |
  |         |                             |  |         |                             |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400040 | PHDR Header                 |  |0x400040 | PHDR Header                 |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400078 | Interp Header               |  |0x400078 | Interp Header               |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x4000b0 | Load Header                 |  |0x4000b0 | Load Header                 |
  |         | (victim load header)        |  |         | (victim load header)        |
  +---------+-----------------------------+  +---------+-----------------------------+
  |...      | ...                         |  |...      | ...                         |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400190 | Load Header                 |
  |         | (malware load header)       |
  +---------+-----------------------------+


  +---------+-----------------------------+  +---------+-----------------------------+
  |0x400000 | Load Segment 1              |  |0x400000 | Load Segment 1              |
  |         | ...                         |  |         | ...                         |
  |0x400468 | original e_entry            |  |0x400430 | original e_entry            |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x600e48 | Load Segment 2              |  |0x600e10 | Load Segment 2              |
  +---------+-----------------------------+  +---------+-----------------------------+
  | ...     | ...                         |  | ...     | ...                         |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x80128a | Load Segment                |  |0x801252 | Load Segment                |
  |         | (malware load segment)      |  |         | (malware load segment)      |
  +---------+-----------------------------+  +---------+-----------------------------+
  |0x80158a | Transfer Control to         |  |0x801552 | Transfer Control to         |
  |         | original e_entry            |  |         | original e_entry            |
  +---------+-----------------------------+  +---------+-----------------------------+
#+END_SRC

#+results: infected_elf3
[[file:./img/infected_elf3.png]]

Таким образом мы затираем заголовок вируса и смещяем весь код на 56 байт
назад.

Обратите внимание, что при загрузке файла в память процесса, таблица
секций не загружается, поскольку она не является частью какого-то
загружаемого сегмента. А вот таблица заголовков сегментов продолжает
загружаться, поскольку явялется частью первого LOAD-сегмента.

Чтобы сдвинуть код, нужно решить несколько проблем.

1. Мы не можем писать в код по умолчанию.

   Сдвиг кода жертвы предполагает его буквальную перезапись.
   Но если вы попытаетесь что-то записать в секциях кода, программа сразу
   выдаст сегфолт.

   Решить эту проблему поможет системный вызов mprotect, который позволяет
   менять атрибуты у страниц памяти. Если заменить атрибуты на
   чтение/запись/исполнение, то мы сможем писать в код.

2. Мы не можем вызвать mprotect для всего ELF-файла сразу.

   Загруженный файл лежит на разных страницах памяти, между которыми у нас
   выравнивание. На рисунках выше видно, что между началом эльфа и его
   концом и у нас более 0x400000 байт. Mprotect просто не позволит умеет
   менять атрибуты у тысяч страниц памяти сразу.

   Поэтому нужно вычислить адрес каждого загружаемого сегмента и вызвать
   mprotect отдельно для каждого.

3. Вычисление адреса сегментов в памяти

   Нам заранее неизвестно, какой файл буде инфицровать вирус и с какого
   адреса он будет загружен. Поэтому нужно узнать базовый адрес эльфа,
   затем пройтись по заголовкам сегментов, вытащить смещение каждого
   сегмента и сложить его с базовым адресом. Таким образом мы получим
   адрес сегмента в памяти.

   Но как получить базовый адрес? Достаточно знать смещение от первого
   сегмента кода до оригинальной точки входа и от оригинальной точки
   входа до новой токи входа. Это легко вычислить на этапе заражения.
   Зная это смещение, можно взять адрес метки _start - она будет будет
   содержать в себе адрес нового e_entry - а затем вычесть из него
   заранее посчитанные смещения.


После вызова mprotect для каждого сегмента, можно спокойно их сдвигать,
просто побайтового переписывая с одного адреса, на другой.

* Самая большая проблема

К сожалению, даже описанные выше ухищрения не позволяют ELF-у корректно
отработать.

Если помните, в разделе о линкове упоминался буфер, в который не в меру
умный линкер записывает адреса, по которым лежат интересующие его и libc
записи из секции dynamic. Но раз мы подвинули весь код, то секция dynamic
тоже сдвинулась на 56 байт.

В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции ~dynamic~ в буфере становятся
неактуальными и ~libc~ получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.

Есть небольшой хак, который позволит нам отказаться от ленивого
связывания, а следоватлеьно отказаться от большей части адресов, которые
сохранены в секции dynamic. Линкер умеет связывать все и сразу до того,
как передаст управление программе, надо просто это указать. Делается это
с помощью записи, которая  находится в секции dynamic и называется
BIND_NOW. Она представляет собой 16 байт кода. Где в первые 8 байт вы пишете число
0x18. Вставить эту запись, в теории, можно в любое место секции dynamic,
но я вставляю ее перед записью NULL - это последняя запись в секции, она
обязательна и полностью заполнена нулями, так что ее легко найти.

Вот так выглядит секция dynamic до вставки записи:

#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0xe28 contains 24 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004a8
   0x000000000000000d (FINI)               0x400714
   0x0000000000000019 (INIT_ARRAY)         0x600e10
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e18
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x400298
   0x0000000000000005 (STRTAB)             0x400378
   0x0000000000000006 (SYMTAB)             0x4002b8
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601000
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400418
   0x0000000000000007 (RELA)               0x400400
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x4003e0
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x4003ce
   0x0000000000000000 (NULL)               0x0
#+END_SRC

А вот так после:
#+BEGIN_SRC sh
  $ readelf -d hello

  Dynamic section at offset 0xe60 contains 25 entries:
    Тег        Тип                          Имя/Знач
   0x0000000000000001 (NEEDED)             Совм. исп. библиотека: [libc.so.6]
   0x000000000000000c (INIT)               0x4004e0
   0x000000000000000d (FINI)               0x40074c
   0x0000000000000019 (INIT_ARRAY)         0x600e48
   0x000000000000001b (INIT_ARRAYSZ)       8 (байт)
   0x000000000000001a (FINI_ARRAY)         0x600e50
   0x000000000000001c (FINI_ARRAYSZ)       8 (байт)
   0x000000006ffffef5 (GNU_HASH)           0x4002d0
   0x0000000000000005 (STRTAB)             0x4003b0
   0x0000000000000006 (SYMTAB)             0x4002f0
   0x000000000000000a (STRSZ)              86 (байт)
   0x000000000000000b (SYMENT)             24 (байт)
   0x0000000000000015 (DEBUG)              0x0
   0x0000000000000003 (PLTGOT)             0x601048
   0x0000000000000002 (PLTRELSZ)           144 (байт)
   0x0000000000000014 (PLTREL)             RELA
   0x0000000000000017 (JMPREL)             0x400450
   0x0000000000000007 (RELA)               0x400438
   0x0000000000000008 (RELASZ)             24 (байт)
   0x0000000000000009 (RELAENT)            24 (байт)
   0x000000006ffffffe (VERNEED)            0x400418
   0x000000006fffffff (VERNEEDNUM)         1
   0x000000006ffffff0 (VERSYM)             0x400406
   0x0000000000000018 (BIND_NOW)
   0x0000000000000000 (NULL)               0x0
#+END_SRC

Обратите внимание, что все адреса изменились на 56 байт, поскольку
вариант dynamic "после" взят из зараженного файла.

К сожалению, BIND_NOW решает проблему с ленивым связываением, но не
решает проблему с работой libc.

libc должна обеспечить корректный старт и завершение сишной
программе. Она настраивает стек, регистры и т.д. Для этого она использует
код, который компилятор вписал в код вашей программы. Для инициализации
программы используется код из секций init и init_array, а для завершения
программы используется код из fini и fini_array. Доступ к этому коду libc
получает с помощью записей dynamic, которые видны на выводе dynamic
выше. А адреса этих записей libc берет из уже известного нам буфера, куда
их кладет линкер на этапе линковки. И у нас нет возможности повлиять на
этот процесс, кроме самого радикального.

Нам сильно повезло и все эти записи находятся в начале секции dynamic. К
секции напрямую никакой другой код не обращается, а линкер больше
включаться не будет, потому что мы все связали сразу. Следовательно, мы
можем не двигать секцию dynamic - единственную из всего кода мишени - но
при этом сдвинуть весь код, ниже нее, на 72 байта - размер заголловка
вируса + размер записи BIND_NOW - просто затерев несколько записей dynamic.
Таким образом нужные libc записи окажутся на тех адресах, которые лнкер
сохранил в буфер, и libc сможет без проблем получить все, что ей нужно.

Посмотри, как будет выглядеть файл до и после того, как мы подвинули код
мишени:

#+NAME: infected_elf5
#+BEGIN_SRC ditaa :file ./img/infected_elf5.png
  +----------+---------------------------------+   +----------+---------------------------------+
  |0x400000  | Заголовок ELF-файла             |   |0x400000  | Заголовок ELF-файла             |
  |          |  (ELF-header)                   |   |          |  (ELF-header)                   |
  +----------+---------------------------------+   +----------+---------------------------------+

  +----------+---------------------------------+   +----------+---------------------------------+
  |0x400040  |  Таблица заголовков сегментов   |   |0x400040  |  Таблица заголовков сегментов   |
  |          |  (Program Header Table)         |   |          |  (Program Header Table)         |
  |          |                                 |   |          |                                 |
  +----------+---------------------------------+   +----------+---------------------------------+
  |0x400040  |   PHDR Header                   |   |0x400040  |   PHDR Header                   |
  +----------+---------------------------------+   +----------+---------------------------------+
  |0x400078  |   Interp Header                 |   |0x400078  |   Interp Header                 |
  +----------+---------------------------------+   +----------+---------------------------------+
  |0x4000b0  |   Load Header                   |   |0x4000b0  |   Load Header                   |
  |          |   (victim load header)          |   |          |   (victim load header)          |
  +----------+---------------------------------+   +----------+---------------------------------+
  |...       |   ...                           |   |...       |   ...                           |
  +----------+---------------------------------+   +----------+---------------------------------+
  |0x400190  |   Load Header                   |
  |          |   (malware load header)         |
  +----------+---------------------------------+


  +----------+---------------------------------+   +----------+--------------------------------+
  |0x400000  |   Load Segment 1                |   |0x400000  |   Load Segment 1               |
  |          |   ...                           |   |          |   ...                          |
  |0x400468  |   original e_entry              |   |0x400430  |   original e_entry             |
  +----------+---------------------------------+   +----------+--------------------------------+
  |0x600e48  |   Load Segment 2                |   |0x600e10  |   Load Segment 2               |
  +----------+---------------------------------+   +----------+--------------------------------+
  | ...      |   ...                           |   | ...      |   ...                          |
  +----------+---------------------------------+   +----------+--------------------------------+

  +----------+---------------------------------+   +----------+--------------------------------+
  |0x600e60  |   Dynamic Section               |   |0x600e28  |   Dynamic Section              |
  |          |                                 |   |          |                                |
  +----------+---------------------------------+   +----------+--------------------------------+
  |0x600e70  |   INIT                          |   |0x600e38  |   INIT                         |
  +----------+---------------------------------+   +----------+--------------------------------+
  |0x600e60  |   FINI                          |   |0x600e48  |   FINI                         |
  +----------+---------------------------------+   +----------+--------------------------------+
  |...       |   ...                           |   |...       |   ...                          |
  +----------+---------------------------------+
  |0x600fd0  |   BIND_NOW                      |
  +----------+---------------------------------+
  |0x600fd0  |   NULL                          |
  +----------+---------------------------------+


  +----------+---------------------------------+   +----------+--------------------------------+
  |0x80128a  |   Load Segment                  |   |0x801242  |   Load Segment                 |
  |          |   (malware load segment)        |   |          |   (malware load segment)       |
  +----------+---------------------------------+   +----------+--------------------------------+
  |0x80158a  |   Transfer Control to           |   |0x801542  |   Transfer Control to          |
  |          |   original e_entry              |   |          |   original e_entry             |
  +----------+---------------------------------+   +----------+--------------------------------+
#+END_SRC


Обратите внимание, что весь код после секции dynamic перемещается не на
56 байт, а на 72 байта.

#+results: infected_elf5
[[file:./img/infected_elf5.png]]

* Заключение

Я надеюсь, что мой опыт был кому-то полезен и теперь вы сможете не просто
реализовать такой же вирус как у меня, но и создать свой собственный,
поскольку ELF-файлы, загрузка программ и линковка перестали быть для вас
каким-то колдунством. К тому же, эти знания достатоно универсальны, чтоб
вы могли использовать их в других своих проектах, не относящихся к
вирусописанию.
