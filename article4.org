#+STARTUP: showall indent hidestars

* Пишем вирус под Linux с нуля: опыт и грабли

[TODO:картинка с совой или что-то подобное]

Единственное руководство "для новичка" по написанию вирусов, что
мне удалось найти - это "Записки исследователя компьютерных вирусов"
Криса Касперски. Очень увлекательное чтение! Что если попробовать
реализовать пару идей оттуда? Сколько это займет времени для человека,
который ничего подобного раньше не делал? Какие подводные камни?

Так начался проект по написанию моего первого файлового вируса.

-=[cut]=-

Цель будет достигнута, если вирус сможет заразить файлы-мишени - т.е. это
такой маленький учебный проект на пару уикендов, войти и выйти. Ничего
сложного!

* План простой:

- пишем мишени
- пишем вирус
- ищем файлы
- инфицируем их (если еще не)
- проверяем что зараженные мишени работают
- пишем отчет

Что может пойти не так?

* Простейшая мишень и Section Header Table

Нарисуем мишень:

#+BEGIN_SRC c :tangle hello.c
  /* gcc hello.c -o hello */
  #include <stdio.h>
  #include <time.h>

  time_t rawtime;
  struct tm * timeinfo;

  int main()
  {
      printf( "Hello world!\n" );
      time ( &rawtime );
      timeinfo = localtime ( &rawtime );
      printf ( "Current local time and date: %s", asctime (timeinfo) );
      return 0;
  }
#+END_SRC

После компиляции мы получаем ELF-файл. Он очень просто устроен: таблица
сегментов хранит записи с указателями на сегменты, а таблица секций -
записи с указателями на секции в этих сегментах:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf.png
       +-------------------------------+
       | Заголовок ELF-файла           |
       | (ELF-header)                  |
       +-------------------------------+

       +-------------------------------+
       | Таблица сегментов             |
       | (Program Header Table)        |
       |     1                         |
  +----+---< 2                         |
  |    |     ...                       |
  |    +-------------------------------+
  |
  |    +-------------------------------+
  |    | Segment 1 | Section A         |
  |    |           +-------------------|
  |    |           | Section B         |
  |    |           +-------------------|
  |    |           |      ...          |
  |    +-------------------------------+
  +--->+-------------------------------+
       | Segment 2 | Section C         |
       |           +-------------------|<---+
       |           | Section D         |    |
       |           +-------------------|    |
       |           |      ...          |    |
       +-------------------------------+    |
                                            |
       +-------------------------------+    |
       | Таблица заголовков секций     |    |
       | (Section Header Table)        |    |
       |                         A     |    |
       |                         B     |    |
       |                         C     |    |
       |                         D >---+----+
       |                         ...   |
       +-------------------------------+
#+END_SRC

Интересно, что каждый сегмент, содержит внутри себя одну или несколько
секций. В документации указано, что таблица заголовков секций
необязательна, и чтобы проверить это, мы можем ее удалить. Для этого
лучше использовать утилиту ~sstrip~ из ELF Kickers, которую можно взять
тут: http://www.muppetlabs.com/%7Ebreadbox/software/elfkickers.html

Воспользовавшись ей получаем:

#+BEGIN_SRC sh
  $ sstrip hello
  $ readelf -S test_sect_tbl

  There are no sections in this file.

  $ ./hello
  Hello world
#+END_SRC

Действительно, Section Header Table не нужна, чтобы наш hello world мог
загрузиться и выполниться! Но сами секции внутри сегментов никуда не
делись, мы просто потеряли информацию о них. Настало время поговорить о
сегментах.

* Сегменты

Можно ожидать, что наша простая мишень будет иметь два сегмента - один
для кода, а второй для данных. Но ELF-ы умеют превосходить ожидания:

#+BEGIN_SRC sh
  $ readelf -l hello

  Elf file type is DYN (Shared object file)
  Entry point 0x10e0
  There are 13 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000002d8 0x00000000000002d8  R      0x8
    INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000006e0 0x00000000000006e0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x00000000000002b5 0x00000000000002b5  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x0000000000000188 0x0000000000000188  R      0x1000
    LOAD           0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000278 0x0000000000000290  RW     0x1000
    DYNAMIC        0x0000000000002da8 0x0000000000003da8 0x0000000000003da8
                   0x00000000000001f0 0x00000000000001f0  RW     0x8
    NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                   0x0000000000000020 0x0000000000000020  R      0x8
    GNU_EH_FRAME   0x0000000000002038 0x0000000000002038 0x0000000000002038
                   0x0000000000000044 0x0000000000000044  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000002d98 0x0000000000003d98 0x0000000000003d98
                   0x0000000000000268 0x0000000000000268  R      0x1

   Section to Segment mapping:
    Segment Sections...
     00
     01     .interp
     02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt
     03     .init .plt .plt.got .plt.sec .text .fini
     04     .rodata .eh_frame_hdr .eh_frame
     05     .init_array .fini_array .dynamic .got .data .bss
     06     .dynamic
     07     .note.gnu.property
     08     .note.gnu.build-id .note.ABI-tag
     09     .note.gnu.property
     10     .eh_frame_hdr
     11
     12     .init_array .fini_array .dynamic .got
#+END_SRC

Что это? Вместо ожидаемых двух сегментов, мы получили это! Давайте
разбираться:

~PHDR-сегмент~ описывает саму Program Header Table. Мы видим, что он
начинается по смещению 0x40 байт от начала файла, сразу после
ELF-заголовка.

~INTERP-сегмент~ описывает "Program Interpreter" - это указатель на
строку, содержающую путь к динамическому компоновщику, который еще
побросит нам сюрпризов, но пока мы это пропустим. Этот сегмент содержит
одну секцию .interp

~LOAD-сегмент-R~ - это первый LOAD-сегмент в файле. Он содержит несколько
секций, и первая из них - это .interp - мы ее только что видели в
предыдущем сегменте. Все LOAD-сегменты загружаются в память, когда
программа запускается. Первый LOAD-сегмент начинается с нулевого адреса,
значит он загружает в память все содержимое файла от его начала до
следующего LOAD-сегмента, который обычно содержит кода. Это содержимое
будет доступно программе НА ЧТЕНИЕ.

~LOAD-сегмент-RE~ содержит код в секции .text, а в остальных своих
секциях все что к нему относится, например, .init и .fini, а также
секции, которые связаны с GOT и PLT (.plt, .plt.got,
.plt.sec). Содержимое эттого сегмента будет загружено с правами НА ЧТЕНИЕ
И ИСПОЛНЕНИЕ.

~LOAD-сегмент-R~ обычно содержит в себе данные, которые будут доступны НА
ЧТЕНИЕ, например в секции .rodata и также может содержать в себе секции
вида .eh_frame относящиеся к обработке ислючений.

~LOAD-сегмент-RW~ содержит данные, доступные НА ЧТЕНИЕ И ЗАПИСЬ (в
секциях .data, .bss, .init_array, .fini_array и. т. п.), секции,
связанные с GOT (.got)

~DYNAMIC-сегмент~ содержит одну секцию .dynamic - в ней лежит информация,
имеющая отношение к релокациям. Эта секция тоже доступна НА ЧТЕНИЕ И
ЗАПИСЬ.

~NOTE-сегменты~ имеет тип NOTE, мы можем просмотреть его с помощью
"readelf -n" и обычно там нет ничего интересного.

~GNU_ сегменты~ содержат таблицы для обработки исключений, стек и таблицы
связанные с релокациями

Все это вместе выглядит как-то так:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf2.png
  +----------------------------+
  | Заголовок ELF-файла        |
  | (ELF-header)               |
  +----------------------------+

  +----------------------------+
  | Таблица сегментов          |
  | (Program Header Table)     |
  +----------------------------+

  +----------------------------+
  | Segment (PHDR)             |
  +----------------------------+
  | Segment (INTERP)           |
  |    .interp                 |
  +----------------------------+
  | Segment (LOAD) R           |
  |    .interp                 |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RE          |
  |    .text                   |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) R           |
  |      ...                   |
  +----------------------------+
  | Segment (LOAD) RW          |
  |      ...                   |
  +----------------------------+
  | Segment (DYNAMIC) RW       |
  |   .dynamic                 |
  +----------------------------+
  | Segment (NOTE)             |
  |     ...                    |
  +----------------------------+
  | Segment (GNU_...)          |
  |     ...                    |
  +----------------------------+

  +----------------------------+
  | Таблица заголовков секций  |
  | (Section Header Table)     |
  +----------------------------+
#+END_SRC

В этом прослеживается некоторая логика - все данные распределены по
секциям, а секции скомпонованы в сегменты в соответствии с правами
доступа к этим данным. Некоторые секции могут относиться к нескольким
сегментам одновременно - стоит это учитывать.

* Проблема инфицирования

Куда же в этой запутанной структуре мы можем вставить свой вирус? Проще
было бы сказать куда НЕ можем:
- Мы не можем вставить код в какой-то из не-LOAD сегментов, потому что
  только они будут загружены в память.
- ...


Код в секциях обычно
ссылается на данные, которые находятся в сегменте данных. Это значит, что
если мы попытаемся вставить вирус между кодом и данными, то относительное
расстояние между ними изменится и ссылки станут неверными. В результате
мишень станет неработоспособной.
------------------------------------

Далее план:
- заражаем минимальную мишень - сначала объясняем способ (с картинками!)
- заражаем мишень с подключенными либами
- наталкиваемся на релокации
- объясняем релокации
- объясняем способ заражения
- заражаем
- натыкаемся на грабли
- решаем грабли
- подчищаем, чтобы "по красоте"
- бинго!
- охуеваем от собственной крутизны

------------------------------------


Для более детального понимания рекомендую цикл статей
https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html
или ман по формату эльфа.

Главный вопрос - это куда вставлять код вируса в ELF-файл, от этого
зависит модель вашего заражения. Вариантов так много, насколько хватит
фантазии. Но мы выделим три наиболее простых:

1. Вставить вирус в ~padding~ между таблицей заголовков сегментов и кодом
   программы. Проблема в том, что в padding-е очень мало места. А может
   padding-а вообще нет.

2. Найти первый загружаемый сегмент кода - сегменты такого типа грузятся
   в память процесса - и вписать вирус в его конец. Затем расширить этот
   сегмент на размер вируса и немного отредактировать остальные заголовки
   секций и секций, потому что весь код сместится на рамер вируса.

   Проблема в том, что в динамически слинкованном файле у нас есть ~PLT~ и
   ~GOT~, и они лежат в разных загружаемых сегментах. Для общения
   между собой эти ребята используют позиционно-независимый код - т.е. им
   совершенно все равно, по каким адресам и где именно в файле они будут
   расположены, но критически важно какое между ними расстояние. Если,
   грубо говоря, ~PLT~ рассчитывает, что между ней и ~GOT~ 100 байт, то
   если там внезапно окажется 300 байт из-за вписанного вируса, ~PLT~
   обратится туда, где ~GOT~ была раньше.

   Есть, конечно, очевидный способ это исправить - подредактировать код внутри
   ~PLT~ - но это муторно: надо определить, где начинается нужная
   инструкция, не попасть посередине инструкции и т.д.

3. Вписать вирус в самый конец кода жертвы. Для этого придется оформить
   его в отдельный сегмент кода, а значит создать под него собственный
   заголовок - иначе загрузчик его просто не загрузит в память. В
   результате весь код равномерно съедет на размер нового заголовка - на
   моей архитектуре это 56 байт.

   Плюсы очевидны: не придется исполнять танцы с бубном над ~PLT~ и
   ~GOT~. Проблемы менее очевидны на данном этапе, так что остановимся на
   этом варианте.

   После заражения мы рассчитываем, что инфицированный файл будет
   выглядеть вот так:

#+NAME: infected_elf
#+BEGIN_SRC ditaa :file ./img/infected_elf.png
  +-----------------------------------------------+
  |              ЗАГОЛОВОК ELF ФАЙЛА              |
  +-----------------------------------------------+
  |          ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ         |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕГМЕНТА ВИРУСА          |
  +-----------------------------------------------+
  |                КОД ПРОГРАММЫ                  |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |                  КОД ВИРУСА                   |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |           ТАБЛИЦА ЗАГОЛОВКОВ СЕКЦИЙ           |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕКЦИИ ВИРУСА            |
  +-----------------------------------------------+
#+END_SRC

#+results: infected_elf
[[file:./img/infected_elf.png]]

Провернуть такое и не сломать эльф достаточно легко, записывайте
пошаговый рецепт:
1. Загрузите ваш файл в память. Я это делаю с помощью ~mmap~, но вы
   можете использовать любой другой способ.

2. Распарсите ваш эльф. Выясните где у него какие заголовки

3. Выделите память под новые заголовки: нам понадобится 56 байт на
   заголовок сегмента и 60 байт на загоовок секции.

4. Запоолните эти буфера данными в соответствии со структурами заголовка
   сегмента и заголовка секции. Они подробно описаны в мане.

5. Увеличьте поля ~p_paddr~, ~p_vaddr~ и ~p_offset~ на 56 байт во всех
   заголовках сегментов, которые описывают код, находящийся после таблицы
   заголовков. Таким образом вы укажете, что изменились физические и
   виртуальные адреса сегментов, а так же их смещение от начала файла,
   т.е. весь код съехал на те самые 56 байт как в файле, так и в памяти
   процесса.

6. Увеличьте поля ~sh_addr~ и ~sh_offset~ на 56 байт во всех заголовках
   секций по тому же принципу и тем же причинам, описанным в пункте
   выше.

7. Увеличьте поля ~e_phnum~ и ~e_shnum~ в загоовке эльфа на единицу - так
   вы укажете, что загоовков сегментов и загоовков секций стало на 1
   больше. А так же установите новое смещение от начала файла таблицы
   заголовков секций в поле ~e_shoff~ - в противном случае заголовки
   секций не будут найдены, и формат будет сломан.

8. Перезапишите ваш эльф по кусочкам, дополняя его кодом вируса и его
   заголовками. Мне в этом помог вызов ~pwite~, где можно задать смещение
   от начала файла, по которому должна вестись запись.

Но загрузчик слишком умен, он еще проверяет валидность сегментов кода.
Чтоб сегмент сочли валидным, вы должны соблюсти соотношение между
виртуальным адресом вашего сегмента и его смещением от начала файла.
Если вычесть второе из первого, то вы должны получить адрес, кратный 4кб.

Посчитать виртуальный адрес для вируса нетрудно:
1. Находите загоовок последнего загружаемого сегмента кода жертвы

2. Считываете его ~p_vaddr~ и ~p_allign~ - т.е. его виртуальный адрес и
   выравнивание.

3. Выравниваете виртуальный адрес последнего сегмента по 4 кб,
   прибавляете к нему выравнивание и смещение вашего вируса в файле.
   Приходится учитывать выравнивание, поскольку как правило с байтами
   выравнивания вы не можете делать буквально ничего и попытка что-то
   исполнить там приведет к сегфолту.

Поздравляю, вы являетесь счастливым обладателем валидного сегмента кода.

Теперь у нас есть инфицированный эльф, но вирус в нем не заработает,
потому что мы никак не перевели на него управление. Самый простой способ
- это вписать виртуальный адрес нашего вируса, который мы высчитали выше,
в поле ~e_entry~ заголовка эльфа - таким образом мы изменим точку входа и
управление перейдет на вирус сразу.

Вам не кажется, что мы что-то забыли?
Подсказываю, вы же, наверное, хотите, чтоб с появлением вируса в вашем
файле основная программа все равно продолжала исполняться?

Да, мы должны передать управление на жертву после того, как вирус отработает.

Сделать это можно всего с помощью пяти байт кода. В ассмеблере есть
инструкция ~jmp~, которая является безусловным переходом. Ее параметр
может быть как абсолютным адрсом, т.е. буквально ~jmp 0x400345~, так и
смещением до нужного адреса. Параметр занимает 4 байта, а машкод ~jmp~
~e9~ занимает 1 байт.

Смещение высчитывается от адреса ~следующей~ за ~jmp~ инуструкцией.
Для этого мы высчитываем, на каком виртуальном адресе закончится вирус -
берем его виртуальный адрес и складываем с размером вируса - прибавляем к
полученному адресу 5 байт - размер инструкции ~jmp~ - и полученный адрес
 вычитаем адрес оригинальной точки входа. Смещение получится
отрицательным, как нам и нужно, поскольку мы прыгаем "назад" в
программе.

Возьмем конкретный пример: адрес вашего вируса ~0x8012a8~, его размер
~0x100~ байт, адрес оригинальной точки входа ~0x400430~.
~0x400430 - (0x8012a8 + 0x100 + 0x5) = -400f7d~.

Просто зарезервируйте 5 байт памяти, впишите в первый код ~e9~, затем
полученное смещение и вставьте полученную инструкцию сразу после кода
вируса в вашем файле.

Получится вот такой эльф

#+NAME: infected_elf_with_transfer_control_block
#+BEGIN_SRC ditaa :file ./img/infected_elf_with_transfer_control_block.png
  +-----------------------------------------------+
  |              ЗАГОЛОВОК ELF ФАЙЛА              |
  +-----------------------------------------------+
  |          ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ         |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕГМЕНТА ВИРУСА          |
  +-----------------------------------------------+
  |                КОД ПРОГРАММЫ                  |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |                  КОД ВИРУСА                   |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |                    cYEL                       |
  |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ     |
  +-----------------------------------------------+
  |           ТАБЛИЦА ЗАГОЛОВКОВ СЕКЦИЙ           |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕКЦИИ ВИРУСА            |
  +-----------------------------------------------+
#+END_SRC

#+results: infected_elf_with_transfer_control_block
[[file:./img/infected_elf_with_transfer_control_block.png]]

Ура, у вас есть работающий инфицированный эльф. Правда, работающий
недолго: во время исполнения кода жертвы вы получите сегфолт.

И вот тут начинается самое интересное. Есть ли у вас минутка поговорить о
боге нашем линкере?

У линкера в общем есть две глобальные задачи: он должне связать библиотеки, которые
вы используете, друг с другом - это происходит еще до того, как
управление будет передано на вашу программу, а затем он должен
осуществить "ленивое" связывание, когда ваш код дойдет до вызова какой-то
библиотечной функции в первый раз.

Всю информацию ему предоставляет секция ~dynamic~. Ее в ваш код, как и
много другое, вставляет компилятор.  Увидеть ее вы
можете, если возьмете любой динамически склинкованный бинарь и прогоните
его под ~readelf -d filename~.

#+CAPTION:
#+NAME:  dynamic.png
[[./img/dynamic.png]]

Записи, помеченные как ~NEEDED~ - это имена библиотек, от которых зависят
все прочие библиотеки вашей программы, они будут загружены в первую
очередь.

Запись ~PLTGOT~ - это таблица ~GOT~, которая до осуществления ленивого
связывания в своих записях содержит адрес, по которому лежит код в ~PLT~,
вызывающий линкер.

Записи, помеченные как ~RELA~ - это адреса секций ~rela~. Их может быть
несколько в файле и они содержат в себе информацию о том, как именно
следует разрешить релокейты и куда должны быть положены связанные адреса

Вот так выглядит секция ~rela~

#+CAPTION:
#+NAME:  rela.png
[[./img/rela.png]]

Если вы слабо себе представляете, что такое релокейты, то рекомендую вот
эту статью
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html

~SYMTAB~ - это таблица символов, которая содержит в себе информацию обо
всех символах программы. Каждая запись в ней представлена как
соответствие между символом и виртуальным адресом, по которому он
объявлен.

Но весь наш код съехал из-за нового заголовка сегмента,
о чем секции ~dynamic~, ~rela~, ~got~ и ~symtab~ понятия не имеют.

Чтоб это исправить, нужно отредактировать все виртуальные адреса в
записях этих секций, увеличив их на 56 байт. Найти их можно по их
заголовкам: у загоовков секций есть поле ~sh_type~, которое указывает на
тип описываемой секции. Заголовки ~rela~ имеют тип 4, загоовок
~dynamic~ - тип 6, а ~symtab~ - тип 2. Из заголовка вы можете выудить
смещение секции от начала файла, сложить с базовым адресом загруженного в
память эльфа-жертвы и таким образом добраться до самой секции. А
поскольку в одной секции все записи одного размера, то вам достаточно
передвигаться на фиксированное количество байт и редактировать нужные
адреса.

С секцией ~GOT~ все чуть сложнее. Ее заголовок не имеет специфического
типа, поэтому лучше искать ее через секцию ~dynamic~. Запись, которая
описывает ~GOT~, имеет тип 3. Вы можете вытащить из нее виртуальный адрес
~GOT~, по нему найти заголовок секции в таблице секций, а затем проделать
все то же, что мы делали с другими секциями. Так вы обеспечите преход
обратно на ~PLT~ в случае, если библиотечная функция вызывается в первый
раз.

Если вы счастливый компилятора, который генерирует позиционно-независимый
код для вашей жертвы, то вы только что закончили свой первый вирус.

Моя же версия ~gcc~ подсунула мне хорошие грабли с увесистым таким
черенком. Она генерирует позиционно-зависимый код, в результате чего,
например, ~libc~, которая должна обеспечить корректный старт и завершение
передаются неверные параметры.

Урегулирование всех ссылок - это куда хуже, чем просто подредактировать
~PLT~, а ведь из-за этого мы отвергли более простую модель
заражения.

Но есть совершенно радикальный вариант: после исполнения вируса мы
подвинем код жертвы в памяти процесса таким образом, будто никакого
заражения не было. То есть сместим весь ее код, лежащий после таблицы
сегментов, на 56 байт назад, затерев таким образом вставленный заголовок
вируса. Все, что требуется для этого - это разрешить запись прямо в код.

Здесь поможет ~mprotect~, он позволяет менять атрибуты страниц памяти на
те, что нам нужны.

Таким образом до "сдвига" инфицированный файл выглядит вот так:

#+NAME: infected_victim_without_bind_now_before_move
#+BEGIN_SRC ditaa :file ./img/infected_victim_without_bind_now_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+
  | 0x400190         |                  cRED                               |
  |                  |  LOAD - ЗАГРУЖАЕМЫЙ ЗАГОЛОВОК СЕГМЕНТА ВИРУСА       |
  +------------------+-----------------------------------------------------+ <--- НАЧАЛО КОДА ЖЕРТВЫ
  | 0x4001c8         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- CЮДА ВИРУС ПЕРЕДАСТ УПРАВЛЕНИЕ
  | 0x400468         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОТСЮДА НАЧНЕТСЯ ИСПОЛНЕНИЕ ПРОГРАММЫ
  |                  |                  cRED                               |
  | 0x80128a         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                   cYEL                              |
  | 0x80158a         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: infected_victim_without_bind_now_before_move
[[file:./img/infected_victim_without_bind_now_before_move.png]]


А вот так будет выглядеть после:

#+NAME: infected_victim_without_bind_now_after_move
#+BEGIN_SRC ditaa :file ./img/infected_victim_after_move.png
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ELF-ФАЙЛА ОСТАЕТСЯ НА МЕСТЕ
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ ОСТАЕТСЯ НА МЕСТЕ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ВИРУСА ОКАЗАЛСЯ ЗАТЕРТ
  |                  |                   cBLU                              |
  | 0x400190         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОРИГИНАЛЬНАЯ ТОЧКА ВХОДА СМЕСТИЛАСЬ
  |                  |                    cBLU                             |       НА 56 БАЙТ
  | 0x400430         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕГМЕНТ ВИРУСА СМЕСТИЛСЯ НА 56 БАЙТ
  |                  |                  cBLU                               |
  | 0x801242         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                   cBLU                              |
  | 0x801542         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: infected_victim_without_bind_now_after_move
[[file:./img/infected_victim_after_move.png]]

К сожалению, это не решит все наши проблемы.

Мы недооценили, насколько линкер хитрая штуковина. Он знает, что скорее
всего его вызовут еще n раз, а еще знает, что скорее всего будет вызвана
~libc~, которой нужен доступ к некоторым секциям жертвы, вроже секций
~fini~ или ~init~, информация о которых хранится в любимой нами секции
~dynamic~. Но вот обращаться напрямую к записям ~dynamic~ повторно линкер
не хочет, да и ~libc~ это незачем. Так что линкер до того как передать
управление программе создает в памяти буфер и сохраняет адреса необходимых
ему и ~libc~ записей ~dynamic~ - т.е. где эти записи расположены в памяти
процесса. А затем, когда уже есть необходимость, ~libc~ и линкер
обращаются к конкретным записям, выуживая из них нужную информацию.

В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции ~dynamic~ в буфере становятся
неактуальными и ~libc~ получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.

Выход есть: отказ от "ленивого" связывания. Линкер умеет связывать все
здесь и сейчас и делает это он в случае, если обнаруживает в секции ~dynamic~
запись ~BIND_NOW~. Так что нам надо всего-то вставить дополнительные 16
байт в секцию, в первые из которых положено число ~0x18~.

Теперь наш файл будет выглядеть в памяти следующим образом, пока мы его
не подвинем:

#+NAME: victim_before_move_pic
#+BEGIN_SRC ditaa :file ./img/victim_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+
  | 0x400190         |                  cRED                               |
  |                  |  LOAD - ЗАГРУЖАЕМЫЙ ЗАГОЛОВОК СЕГМЕНТА ВИРУСА       |
  +------------------+-----------------------------------------------------+ <--- НАЧАЛО КОДА ЖЕРТВЫ
  | 0x4001c8         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- CЮДА ВИРУС ПЕРЕДАСТ УПРАВЛЕНИЕ
  | 0x400468         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕКЦИЯ DYNAMIC
  | 0x600e48         |    NEEDED - ПЕРВАЯ ЗАПИСЬ СЕКЦИИ DYNAMIC            |
  +------------------+-----------------------------------------------------+
  | 0x600e58         |                 ЗАПИСЬ INIT                         |
  +------------------+-----------------------------------------------------+
  | 0x600e68         |                 ЗАПИСЬ FINI                         |
  |                  |                  ........                           |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+
  |                  |                  cRED                               |
  | 0x600ee8         |       BIND_NOW - ВСТАВЛЕННАЯ НАМИ ЗАПИСЬ            |
  +------------------+-----------------------------------------------------+
  | 0x600ef8         |      NULL - ПОСЛЕДНЯЯ ЗАПИСЬ СЕКЦИИ DYNAMIC         |
  +------------------+-----------------------------------------------------+ <---- ОСТАВШИЙСЯ КОД ЖЕРТВЫ
  | 0x600f08         |               ПРОЧИЙ КОД ЖЕРТВЫ                     |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+ <---- ОТСЮДА НАЧНЕТСЯ ИСПОЛНЕНИЕ ПРОГРАММЫ
  |                  |                  cRED                               |
  | 0x80128a         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                  cYEL                               |
  | 0x80158a         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: victim_before_move_pic
[[file:./img/victim_before_move.png]]

И хотя это позволит вызывать библиотеки, это никак не поможет ~libc~
корректно завершить программу жертвы. ~libc~ берет из буфера, который нам
создал линкер, адреса записей ~fini~, ~fini_array~ и других, из которых
она должна получить адреса этих секций кода в памяти, а затем вызвать их.
И у нас нет никакой возможности повлиять на этот процесс.

На наше счастье все записи, необходимые ~libc~ для корректного завершения
программы, находятся в начале секции ~dynamic~. Это значит, что мы вполне
можем оставить ее на месте, но подвинуть весь код, расположенный за ней,
затерев ее нижние 72 байта - размер заголовка сегмента вируса и записи
~BIND_NOW~.

Таким образом после "сдвига" инфицированный файл будет выглядеть вот так:

#+NAME: victim_after_move_pic
#+BEGIN_SRC ditaa :file ./img/victim_after_move.png
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ELF-ФАЙЛА ОСТАЕТСЯ НА МЕСТЕ
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ ОСТАЕТСЯ НА МЕСТЕ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ВИРУСА ОКАЗАЛСЯ ЗАТЕРТ
  |                  |                   cBLU                              |
  | 0x400190         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОРИГИНАЛЬНАЯ ТОЧКА ВХОДА СМЕСТИЛАСЬ
  |                  |                    cBLU                             |       НА 56 БАЙТ
  | 0x400430         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕКЦИЯ DYNAMIC ОСТАЛАСЬ НА МЕСТЕ
  | 0x600e48         |    NEEDED - ПЕРВАЯ ЗАПИСЬ СЕКЦИИ DYNAMIC            |
  +------------------+-----------------------------------------------------+
  | 0x600e58         |                 ЗАПИСЬ INIT                         |
  +------------------+-----------------------------------------------------+
  | 0x600e68         |                 ЗАПИСЬ FINI                         |
  |                  |                  ........                           |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ЗАТЕРЛИ 72 БАЙТА СЕКЦИИ DYNAMIC,
  |                  |                    cBLU                             |       ВКЛЮЧАЯ ЗАПИСЬ BIND_NOW
  | 0x600ec0         |               ПРОЧИЙ КОД ЖЕРТВЫ                     |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+ <---- СЕГМЕНТ ВИРУСА СМЕСТИЛСЯ НА 72 БАЙТА
  |                  |                  cBLU                               |
  | 0x801242         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                  cBLU                               |
  | 0x801542         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: victim_after_move_pic
[[file:./img/victim_after_move.png]]

Итого мы получили вирус, который может заражать файлы как с
позиционно-независимым, так и с позиционно-зависимым кодом.

Надеюсь, мой опыт был кому-то полезным. Идеи и конструктивная критика крайне
приветствуются.
