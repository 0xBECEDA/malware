#+STARTUP: showall indent hidestars

* Пишем вирус под Linux с нуля: опыт и грабли

[TODO:картинка с совой или что-то подобное]

Единственное руководство "для новичка" по написанию вирусов, что
мне удалось найти - это "Записки исследователя компьютерных вирусов"
Криса Касперски. Очень увлекательное чтение! Что если попробовать
реализовать пару идей оттуда? Сколько это займет времени для человека,
который ничего подобного раньше не делал? Какие подводные камни?

Так начался проект по написанию моего первого файлового вируса.

-=[cut]=-

Считаем, что цель достигнута, если вирус сможет заразить файлы-мишени в
своей папке (и не заражать дважды) - т.е. это такой маленький учебный
проект на пару уикендов, войти и выйти. Ничего сложного!

План простой:
- пишем мишени
- пишем вирус
- ищем файлы
- инфицируем их (если еще не)
- проверяем что зараженные мишени работают
- пишем отчет

Что может пойти не так?

* Простейшая мишень и Section Header Table

Я слышал, что каждая формула уменьшает кол-во читающих вдвое, но нам
этого недостаточно - желательно по меньшей мере перекрыть число Пи, чтобы
не оставить шанса для слабаков.

Поэтому, я представляю программу-мишень, написанную в самом наркоманском
синтаксисе ассемблера, который когда-либо существовал - AT&T. Писать на
нем очень весело (осторожно, вызывает привыкание), а читать несколько
проще, надо только помнить что аргументы переставлены местами.

Конечно, я мог бы сказать, что выбрал GNU Assembler потому что он часть
GCC и доступен на любой Linux-системе. Это было бы ближе к правде, но
менее весело.

Для нас важно, что у мишени есть сегмент кода и сегмент данных, это
потребуется в дальнейшем:

#+BEGIN_SRC asm :tangle ./test_sect_tbl.S
      .text   # CODE SEGMENT ------------------------

      .global	_start
      .type	_start, @function

  _start:
      lea     _msg(%rip), %rsi    # pointer to msg
      mov     $len_msg, %rdx      # length of msg
      mov     $0x1, %rax          # write syscall
      mov     %rax, %rdi          # to stdout
      syscall

  _exit:
      mov $0x3c, %rax             # exit syscall
      mov $0x0,  %rdi             # return code
      syscall

      .data   # DATA SEGMENT ------------------------

  _msg:
      .ascii "Hello world\n"
      .set len_msg, . - _msg
#+END_SRC

Скомпилируем нашу мишень обычным компилятором GCC:

#+BEGIN_SRC sh
  gcc -nostdlib test_sect_tbl.S -o test_sect_tbl
#+END_SRC

После компиляции мы получаем ELF-файл. Он очень просто устроен:

#+NAME: elf
#+BEGIN_SRC ditaa :file ./img/elf.png
       +---------------------------------------------------+
       | Заголовок ELF-файла (ELF-header)                  |
       +---------------------------------------------------+

       +---------------------------------------------------+
       | Таблица сегментов (Program Header Table)          |
       |     1                                             |
  +----+---< 2                                             |
  |    |     ...                                           |
  |    +---------------------------------------------------+
  |
  |    +---------------------------------------------------+
  |    | Segment 1    | Section A                          |
  |    |              +------------------------------------|
  |    |              | Section B                          |
  |    |              +------------------------------------|
  |    |              |      ...                           |
  |    +---------------------------------------------------+
  +--->+---------------------------------------------------+
       | Segment 2    | Section C                          |
       |              +------------------------------------|<---+
       |              | Section D                          |    |
       |              +------------------------------------|    |
       |              |      ...                           |    |
       +---------------------------------------------------+    |
                                                                |
       +---------------------------------------------------+    |
       | Таблица заголовков секций (Section Header Table)  |    |
       |                                        A          |    |
       |                                        B          |    |
       |                                        C          |    |
       |                                        D >--------+----+
       |                                        ...        |
       +---------------------------------------------------+
#+END_SRC

Интересно, что каждый сегмент, содержит внутри себя одну или несколько
секций. В документации указано, что таблица заголовков секций
необязательна, и чтобы проверить это, можно её утилитой ~sstrip~ из ELF
Kickers, который можно взять тут:
http://www.muppetlabs.com/%7Ebreadbox/software/elfkickers.html

Воспользовавшись ей получаем:

#+BEGIN_SRC sh
  $ sstrip test_sect_tbl
  $ readelf -S test_sect_tbl

  There are no sections in this file.

  $ ./test_sect_tbl
  Hello world
#+END_SRC

Действительно, Section Header Table не нужна, чтобы наш hello world мог
загрузиться и выполниться! Но сами секции внутри сегментов никуда не
делись, мы просто потеряли информацию о них. Настало время поговорить о
сегментах.

* Сегменты

Загрузчик использует сегменты, чтобы перенести содержимое ELF-а в память,
т.е. каждый сегмент - это непрерывная область памяти. Например, можно
думать, что для строка "Hello world" лежит в сегменте данных, а код,
который ее выводит - в сегменте кода. На практике все устроено несколько
более интересно - и у этого есть серьезные причины.

Информация о сегментах лежит в Program Header Table и выглядит так:

#+BEGIN_SRC sh
  $ readelf -l test_sect_tbl

  Elf file type is DYN (Shared object file)
  Entry point 0x1000
  There are 9 program headers, starting at offset 64

  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                   0x00000000000001f8 0x00000000000001f8  R      0x8
    INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238
                   0x000000000000001c 0x000000000000001c  R      0x1
        [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x00000000000002b1 0x00000000000002b1  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x000000000000002a 0x000000000000002a  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x0000000000000000 0x0000000000000000  R      0x1000
    LOAD           0x0000000000002f20 0x0000000000002f20 0x0000000000002f20
                   0x00000000000000ec 0x00000000000000ec  RW     0x1000
    DYNAMIC        0x0000000000002f20 0x0000000000002f20 0x0000000000002f20
                   0x00000000000000e0 0x00000000000000e0  RW     0x8
    NOTE           0x0000000000000254 0x0000000000000254 0x0000000000000254
                   0x0000000000000024 0x0000000000000024  R      0x4
    GNU_RELRO      0x0000000000002f20 0x0000000000002f20 0x0000000000002f20
                   0x00000000000000e0 0x00000000000000e0  R      0x1

   Section to Segment mapping:
    Segment Sections...
     00
     01     .interp
     02     .interp .note.gnu.build-id .gnu.hash .dynsym .dynstr
     03     .text
     04     .eh_frame
     05     .dynamic .data
     06     .dynamic
     07     .note.gnu.build-id
     08     .dynamic
#+END_SRC

Что это? Вместо ожидаемых двух сегментов, для кода и данных, мы получили
девять! Давайте разбираться:

~Нулевой сегмент~ с типом PHDR описывает саму Program Header Table. Мы
видим, что он начинается по смещению 0x40 байт от начала файла, сразу
после ELF-заголовка. Мы также видим, что он не содержит ни одной секции

~Первый сегмент~ описывает "Program Interpreter" - это указатель на строку,
содержающую путь к динамическому компоновщику, который еще побросит нам
сюрпризов, но пока мы это пропустим. Этот сегмент содержит одну секцию
.interp

~Второй сегмент~ имеет тип LOAD и содержит несколько секций, и первая из
них - это .interp - мы ее только что видели в предыдущем сегменте. Все
дело в том, что LOAD сегменты загружаются в память, когда программа
запускается. И этот сегмент начинается с нулевого адреса, т.е. от начала
файла и занимает 0x2b1 байт, чего вполне достаточно чтобы уместить весь
контент от начала файла до следующего сегмента, который наконец содержит
наш код, который мы ищем.

~Третий сегмент~ содержит наш код. Мы видимо что он начинается с круглого
файлового смещения 0x1000, и открыв его в шестнадцатиричном редакторе мы
увидим следующее:

#+BEGIN_SRC sh
  00001000: 488d 35f9 1f00 0048 c7c2 0c00 0000 48c7  H.5....H......H.
  00001010: c001 0000 0048 89c7 0f05 48c7 c03c 0000  .....H....H..<..
  00001020: 0048 c7c7 0000 0000 0f05 0000 0000 0000  .H..............
#+END_SRC

Гхм, не очень очевидно. Но можно сравнить эти числа с тем что нам покажет
дизассемблер:

#+BEGIN_SRC asm
  $ objdump -d test_sect_tbl

  test_sect_tbl:     file format elf64-x86-64

  Disassembly of section .text:

  0000000000001000 <_start>:
      1000:	48 8d 35 f9 1f 00 00 	lea    0x1ff9(%rip),%rsi        # 3000 <_msg>
      1007:	48 c7 c2 0c 00 00 00 	mov    $0xc,%rdx
      100e:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
      1015:	48 89 c7             	mov    %rax,%rdi
      1018:	0f 05                	syscall

  000000000000101a <_exit>:
      101a:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
      1021:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
      1028:	0f 05                	syscall
#+END_SRC

Все совпадает, мы нашли код! Но все-таки рассмотрим остальные сегменты.

~Четвертый сегмент~ содержит в себе что-то связанное с обработкой
исключений и нам не интересен.

~Пятый сегмент~ содержит в себе секцию .data и там действительно лежат
наши данные - строка "Hello world". Это был последний
LOAD-сегмент. Интересным в нем являются флаги, которые запрещают
исполнение, но разрешеют чтение и запись.

~Шестой сегмент~ имеет тип DYNAMIC и содержит одну секцию .dynamic - она
может серьезно сконфузить неопытного вирусмейкера, потому что в ней лежит
информация, имеющая отношение к релокациям. Постараемся пока не думать об
этом.

~Седьмой сегмент~ имеет тип NOTE, мы можем просмотреть его с помощью
"readelf -n" и обычно там нет ничего интересного.



------------------------------------

Далее план:
- заражаем минимальную мишень - сначала объясняем способ (с картинками!)
- заражаем мишень с подключенными либами
- наталкиваемся на релокации
- объясняем релокации
- объясняем способ заражения
- заражаем
- натыкаемся на грабли
- решаем грабли
- подчищаем, чтобы "по красоте"
- бинго!
- охуеваем от собственной крутизны

------------------------------------


Для более детального понимания рекомендую цикл статей
https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html
или ман по формату эльфа.

Главный вопрос - это куда вставлять код вируса в ELF-файл, от этого
зависит модель вашего заражения. Вариантов так много, насколько хватит
фантазии. Но мы выделим три наиболее простых:

1. Вставить вирус в ~padding~ между таблицей заголовков сегментов и кодом
   программы. Проблема в том, что в padding-е очень мало места. А может
   padding-а вообще нет.

2. Найти первый загружаемый сегмент кода - сегменты такого типа грузятся
   в память процесса - и вписать вирус в его конец. Затем расширить этот
   сегмент на размер вируса и немного отредактировать остальные заголовки
   секций и секций, потому что весь код сместится на рамер вируса.

   Проблема в том, что в динамически слинкованном файле у нас есть ~PLT~ и
   ~GOT~, и они лежат в разных загружаемых сегментах. Для общения
   между собой эти ребята используют позиционно-независимый код - т.е. им
   совершенно все равно, по каким адресам и где именно в файле они будут
   расположены, но критически важно какое между ними расстояние. Если,
   грубо говоря, ~PLT~ рассчитывает, что между ней и ~GOT~ 100 байт, то
   если там внезапно окажется 300 байт из-за вписанного вируса, ~PLT~
   обратится туда, где ~GOT~ была раньше.

   Есть, конечно, очевидный способ это исправить - подредактировать код внутри
   ~PLT~ - но это муторно: надо определить, где начинается нужная
   инструкция, не попасть посередине инструкции и т.д.

3. Вписать вирус в самый конец кода жертвы. Для этого придется оформить
   его в отдельный сегмент кода, а значит создать под него собственный
   заголовок - иначе загрузчик его просто не загрузит в память. В
   результате весь код равномерно съедет на размер нового заголовка - на
   моей архитектуре это 56 байт.

   Плюсы очевидны: не придется исполнять танцы с бубном над ~PLT~ и
   ~GOT~. Проблемы менее очевидны на данном этапе, так что остановимся на
   этом варианте.

   После заражения мы рассчитываем, что инфицированный файл будет
   выглядеть вот так:

#+NAME: infected_elf
#+BEGIN_SRC ditaa :file ./img/infected_elf.png
  +-----------------------------------------------+
  |              ЗАГОЛОВОК ELF ФАЙЛА              |
  +-----------------------------------------------+
  |          ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ         |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕГМЕНТА ВИРУСА          |
  +-----------------------------------------------+
  |                КОД ПРОГРАММЫ                  |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |                  КОД ВИРУСА                   |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |           ТАБЛИЦА ЗАГОЛОВКОВ СЕКЦИЙ           |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕКЦИИ ВИРУСА            |
  +-----------------------------------------------+
#+END_SRC

#+results: infected_elf
[[file:./img/infected_elf.png]]

Провернуть такое и не сломать эльф достаточно легко, записывайте
пошаговый рецепт:
1. Загрузите ваш файл в память. Я это делаю с помощью ~mmap~, но вы
   можете использовать любой другой способ.

2. Распарсите ваш эльф. Выясните где у него какие заголовки

3. Выделите память под новые заголовки: нам понадобится 56 байт на
   заголовок сегмента и 60 байт на загоовок секции.

4. Запоолните эти буфера данными в соответствии со структурами заголовка
   сегмента и заголовка секции. Они подробно описаны в мане.

5. Увеличьте поля ~p_paddr~, ~p_vaddr~ и ~p_offset~ на 56 байт во всех
   заголовках сегментов, которые описывают код, находящийся после таблицы
   заголовков. Таким образом вы укажете, что изменились физические и
   виртуальные адреса сегментов, а так же их смещение от начала файла,
   т.е. весь код съехал на те самые 56 байт как в файле, так и в памяти
   процесса.

6. Увеличьте поля ~sh_addr~ и ~sh_offset~ на 56 байт во всех заголовках
   секций по тому же принципу и тем же причинам, описанным в пункте
   выше.

7. Увеличьте поля ~e_phnum~ и ~e_shnum~ в загоовке эльфа на единицу - так
   вы укажете, что загоовков сегментов и загоовков секций стало на 1
   больше. А так же установите новое смещение от начала файла таблицы
   заголовков секций в поле ~e_shoff~ - в противном случае заголовки
   секций не будут найдены, и формат будет сломан.

8. Перезапишите ваш эльф по кусочкам, дополняя его кодом вируса и его
   заголовками. Мне в этом помог вызов ~pwite~, где можно задать смещение
   от начала файла, по которому должна вестись запись.

Но загрузчик слишком умен, он еще проверяет валидность сегментов кода.
Чтоб сегмент сочли валидным, вы должны соблюсти соотношение между
виртуальным адресом вашего сегмента и его смещением от начала файла.
Если вычесть второе из первого, то вы должны получить адрес, кратный 4кб.

Посчитать виртуальный адрес для вируса нетрудно:
1. Находите загоовок последнего загружаемого сегмента кода жертвы

2. Считываете его ~p_vaddr~ и ~p_allign~ - т.е. его виртуальный адрес и
   выравнивание.

3. Выравниваете виртуальный адрес последнего сегмента по 4 кб,
   прибавляете к нему выравнивание и смещение вашего вируса в файле.
   Приходится учитывать выравнивание, поскольку как правило с байтами
   выравнивания вы не можете делать буквально ничего и попытка что-то
   исполнить там приведет к сегфолту.

Поздравляю, вы являетесь счастливым обладателем валидного сегмента кода.

Теперь у нас есть инфицированный эльф, но вирус в нем не заработает,
потому что мы никак не перевели на него управление. Самый простой способ
- это вписать виртуальный адрес нашего вируса, который мы высчитали выше,
в поле ~e_entry~ заголовка эльфа - таким образом мы изменим точку входа и
управление перейдет на вирус сразу.

Вам не кажется, что мы что-то забыли?
Подсказываю, вы же, наверное, хотите, чтоб с появлением вируса в вашем
файле основная программа все равно продолжала исполняться?

Да, мы должны передать управление на жертву после того, как вирус отработает.

Сделать это можно всего с помощью пяти байт кода. В ассмеблере есть
инструкция ~jmp~, которая является безусловным переходом. Ее параметр
может быть как абсолютным адрсом, т.е. буквально ~jmp 0x400345~, так и
смещением до нужного адреса. Параметр занимает 4 байта, а машкод ~jmp~
~e9~ занимает 1 байт.

Смещение высчитывается от адреса ~следующей~ за ~jmp~ инуструкцией.
Для этого мы высчитываем, на каком виртуальном адресе закончится вирус -
берем его виртуальный адрес и складываем с размером вируса - прибавляем к
полученному адресу 5 байт - размер инструкции ~jmp~ - и полученный адрес
 вычитаем адрес оригинальной точки входа. Смещение получится
отрицательным, как нам и нужно, поскольку мы прыгаем "назад" в
программе.

Возьмем конкретный пример: адрес вашего вируса ~0x8012a8~, его размер
~0x100~ байт, адрес оригинальной точки входа ~0x400430~.
~0x400430 - (0x8012a8 + 0x100 + 0x5) = -400f7d~.

Просто зарезервируйте 5 байт памяти, впишите в первый код ~e9~, затем
полученное смещение и вставьте полученную инструкцию сразу после кода
вируса в вашем файле.

Получится вот такой эльф

#+NAME: infected_elf_with_transfer_control_block
#+BEGIN_SRC ditaa :file ./img/infected_elf_with_transfer_control_block.png
  +-----------------------------------------------+
  |              ЗАГОЛОВОК ELF ФАЙЛА              |
  +-----------------------------------------------+
  |          ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ         |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕГМЕНТА ВИРУСА          |
  +-----------------------------------------------+
  |                КОД ПРОГРАММЫ                  |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |                  КОД ВИРУСА                   |
  |                     ...                       |
  |                     ...                       |
  +-----------------------------------------------+
  |                    cYEL                       |
  |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ     |
  +-----------------------------------------------+
  |           ТАБЛИЦА ЗАГОЛОВКОВ СЕКЦИЙ           |
  |                     ...                       |
  +-----------------------------------------------+
  |                     cRED                      |
  |            ЗАГОЛОВОК СЕКЦИИ ВИРУСА            |
  +-----------------------------------------------+
#+END_SRC

#+results: infected_elf_with_transfer_control_block
[[file:./img/infected_elf_with_transfer_control_block.png]]

Ура, у вас есть работающий инфицированный эльф. Правда, работающий
недолго: во время исполнения кода жертвы вы получите сегфолт.

И вот тут начинается самое интересное. Есть ли у вас минутка поговорить о
боге нашем линкере?

У линкера в общем есть две глобальные задачи: он должне связать библиотеки, которые
вы используете, друг с другом - это происходит еще до того, как
управление будет передано на вашу программу, а затем он должен
осуществить "ленивое" связывание, когда ваш код дойдет до вызова какой-то
библиотечной функции в первый раз.

Всю информацию ему предоставляет секция ~dynamic~. Ее в ваш код, как и
много другое, вставляет компилятор.  Увидеть ее вы
можете, если возьмете любой динамически склинкованный бинарь и прогоните
его под ~readelf -d filename~.

#+CAPTION:
#+NAME:  dynamic.png
[[./img/dynamic.png]]

Записи, помеченные как ~NEEDED~ - это имена библиотек, от которых зависят
все прочие библиотеки вашей программы, они будут загружены в первую
очередь.

Запись ~PLTGOT~ - это таблица ~GOT~, которая до осуществления ленивого
связывания в своих записях содержит адрес, по которому лежит код в ~PLT~,
вызывающий линкер.

Записи, помеченные как ~RELA~ - это адреса секций ~rela~. Их может быть
несколько в файле и они содержат в себе информацию о том, как именно
следует разрешить релокейты и куда должны быть положены связанные адреса

Вот так выглядит секция ~rela~

#+CAPTION:
#+NAME:  rela.png
[[./img/rela.png]]

Если вы слабо себе представляете, что такое релокейты, то рекомендую вот
эту статью
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html

~SYMTAB~ - это таблица символов, которая содержит в себе информацию обо
всех символах программы. Каждая запись в ней представлена как
соответствие между символом и виртуальным адресом, по которому он
объявлен.

Но весь наш код съехал из-за нового заголовка сегмента,
о чем секции ~dynamic~, ~rela~, ~got~ и ~symtab~ понятия не имеют.

Чтоб это исправить, нужно отредактировать все виртуальные адреса в
записях этих секций, увеличив их на 56 байт. Найти их можно по их
заголовкам: у загоовков секций есть поле ~sh_type~, которое указывает на
тип описываемой секции. Заголовки ~rela~ имеют тип 4, загоовок
~dynamic~ - тип 6, а ~symtab~ - тип 2. Из заголовка вы можете выудить
смещение секции от начала файла, сложить с базовым адресом загруженного в
память эльфа-жертвы и таким образом добраться до самой секции. А
поскольку в одной секции все записи одного размера, то вам достаточно
передвигаться на фиксированное количество байт и редактировать нужные
адреса.

С секцией ~GOT~ все чуть сложнее. Ее заголовок не имеет специфического
типа, поэтому лучше искать ее через секцию ~dynamic~. Запись, которая
описывает ~GOT~, имеет тип 3. Вы можете вытащить из нее виртуальный адрес
~GOT~, по нему найти заголовок секции в таблице секций, а затем проделать
все то же, что мы делали с другими секциями. Так вы обеспечите преход
обратно на ~PLT~ в случае, если библиотечная функция вызывается в первый
раз.

Если вы счастливый компилятора, который генерирует позиционно-независимый
код для вашей жертвы, то вы только что закончили свой первый вирус.

Моя же версия ~gcc~ подсунула мне хорошие грабли с увесистым таким
черенком. Она генерирует позиционно-зависимый код, в результате чего,
например, ~libc~, которая должна обеспечить корректный старт и завершение
передаются неверные параметры.

Урегулирование всех ссылок - это куда хуже, чем просто подредактировать
~PLT~, а ведь из-за этого мы отвергли более простую модель
заражения.

Но есть совершенно радикальный вариант: после исполнения вируса мы
подвинем код жертвы в памяти процесса таким образом, будто никакого
заражения не было. То есть сместим весь ее код, лежащий после таблицы
сегментов, на 56 байт назад, затерев таким образом вставленный заголовок
вируса. Все, что требуется для этого - это разрешить запись прямо в код.

Здесь поможет ~mprotect~, он позволяет менять атрибуты страниц памяти на
те, что нам нужны.

Таким образом до "сдвига" инфицированный файл выглядит вот так:

#+NAME: infected_victim_without_bind_now_before_move
#+BEGIN_SRC ditaa :file ./img/infected_victim_without_bind_now_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+
  | 0x400190         |                  cRED                               |
  |                  |  LOAD - ЗАГРУЖАЕМЫЙ ЗАГОЛОВОК СЕГМЕНТА ВИРУСА       |
  +------------------+-----------------------------------------------------+ <--- НАЧАЛО КОДА ЖЕРТВЫ
  | 0x4001c8         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- CЮДА ВИРУС ПЕРЕДАСТ УПРАВЛЕНИЕ
  | 0x400468         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОТСЮДА НАЧНЕТСЯ ИСПОЛНЕНИЕ ПРОГРАММЫ
  |                  |                  cRED                               |
  | 0x80128a         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                   cYEL                              |
  | 0x80158a         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: infected_victim_without_bind_now_before_move
[[file:./img/infected_victim_without_bind_now_before_move.png]]


А вот так будет выглядеть после:

#+NAME: infected_victim_without_bind_now_after_move
#+BEGIN_SRC ditaa :file ./img/infected_victim_after_move.png
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ELF-ФАЙЛА ОСТАЕТСЯ НА МЕСТЕ
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ ОСТАЕТСЯ НА МЕСТЕ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ВИРУСА ОКАЗАЛСЯ ЗАТЕРТ
  |                  |                   cBLU                              |
  | 0x400190         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОРИГИНАЛЬНАЯ ТОЧКА ВХОДА СМЕСТИЛАСЬ
  |                  |                    cBLU                             |       НА 56 БАЙТ
  | 0x400430         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕГМЕНТ ВИРУСА СМЕСТИЛСЯ НА 56 БАЙТ
  |                  |                  cBLU                               |
  | 0x801242         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                   cBLU                              |
  | 0x801542         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: infected_victim_without_bind_now_after_move
[[file:./img/infected_victim_after_move.png]]

К сожалению, это не решит все наши проблемы.

Мы недооценили, насколько линкер хитрая штуковина. Он знает, что скорее
всего его вызовут еще n раз, а еще знает, что скорее всего будет вызвана
~libc~, которой нужен доступ к некоторым секциям жертвы, вроже секций
~fini~ или ~init~, информация о которых хранится в любимой нами секции
~dynamic~. Но вот обращаться напрямую к записям ~dynamic~ повторно линкер
не хочет, да и ~libc~ это незачем. Так что линкер до того как передать
управление программе создает в памяти буфер и сохраняет адреса необходимых
ему и ~libc~ записей ~dynamic~ - т.е. где эти записи расположены в памяти
процесса. А затем, когда уже есть необходимость, ~libc~ и линкер
обращаются к конкретным записям, выуживая из них нужную информацию.

В резльутате мы получаем потрясающую ситуацию: не сдвигать код жертвы мы
не можем, потому что у нас позиционно-зависимый код, а сдвиг приводит к
тому, что адреса записей секции ~dynamic~ в буфере становятся
неактуальными и ~libc~ получает доступ к совсем не той информации, на
которую рассчитывает. И отредактировать эти адреса нет никакой возможности: они
не расположены в буфере один за другим, мы не знаем, сколько их и т.д.

Выход есть: отказ от "ленивого" связывания. Линкер умеет связывать все
здесь и сейчас и делает это он в случае, если обнаруживает в секции ~dynamic~
запись ~BIND_NOW~. Так что нам надо всего-то вставить дополнительные 16
байт в секцию, в первые из которых положено число ~0x18~.

Теперь наш файл будет выглядеть в памяти следующим образом, пока мы его
не подвинем:

#+NAME: victim_before_move_pic
#+BEGIN_SRC ditaa :file ./img/victim_before_move.png
  +------------------+-----------------------------------------------------+
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ СЕГМЕНТОВ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+
  | 0x400190         |                  cRED                               |
  |                  |  LOAD - ЗАГРУЖАЕМЫЙ ЗАГОЛОВОК СЕГМЕНТА ВИРУСА       |
  +------------------+-----------------------------------------------------+ <--- НАЧАЛО КОДА ЖЕРТВЫ
  | 0x4001c8         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- CЮДА ВИРУС ПЕРЕДАСТ УПРАВЛЕНИЕ
  | 0x400468         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕКЦИЯ DYNAMIC
  | 0x600e48         |    NEEDED - ПЕРВАЯ ЗАПИСЬ СЕКЦИИ DYNAMIC            |
  +------------------+-----------------------------------------------------+
  | 0x600e58         |                 ЗАПИСЬ INIT                         |
  +------------------+-----------------------------------------------------+
  | 0x600e68         |                 ЗАПИСЬ FINI                         |
  |                  |                  ........                           |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+
  |                  |                  cRED                               |
  | 0x600ee8         |       BIND_NOW - ВСТАВЛЕННАЯ НАМИ ЗАПИСЬ            |
  +------------------+-----------------------------------------------------+
  | 0x600ef8         |      NULL - ПОСЛЕДНЯЯ ЗАПИСЬ СЕКЦИИ DYNAMIC         |
  +------------------+-----------------------------------------------------+ <---- ОСТАВШИЙСЯ КОД ЖЕРТВЫ
  | 0x600f08         |               ПРОЧИЙ КОД ЖЕРТВЫ                     |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+ <---- ОТСЮДА НАЧНЕТСЯ ИСПОЛНЕНИЕ ПРОГРАММЫ
  |                  |                  cRED                               |
  | 0x80128a         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                  cYEL                               |
  | 0x80158a         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: victim_before_move_pic
[[file:./img/victim_before_move.png]]

И хотя это позволит вызывать библиотеки, это никак не поможет ~libc~
корректно завершить программу жертвы. ~libc~ берет из буфера, который нам
создал линкер, адреса записей ~fini~, ~fini_array~ и других, из которых
она должна получить адреса этих секций кода в памяти, а затем вызвать их.
И у нас нет никакой возможности повлиять на этот процесс.

На наше счастье все записи, необходимые ~libc~ для корректного завершения
программы, находятся в начале секции ~dynamic~. Это значит, что мы вполне
можем оставить ее на месте, но подвинуть весь код, расположенный за ней,
затерев ее нижние 72 байта - размер заголовка сегмента вируса и записи
~BIND_NOW~.

Таким образом после "сдвига" инфицированный файл будет выглядеть вот так:

#+NAME: victim_after_move_pic
#+BEGIN_SRC ditaa :file ./img/victim_after_move.png
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ELF-ФАЙЛА ОСТАЕТСЯ НА МЕСТЕ
  | 0x400000         |             ЗAГОЛОВОК ELF-ФАЙЛА                     |
  |                  |                ...............                      |
  +------------------+-----------------------------------------------------+ <--- ТАБЛИЦА ЗАГОЛОВКОВ ОСТАЕТСЯ НА МЕСТЕ
  | 0x400040         |     PHRD - ЗАГОЛОВОК ТАБЛИЦЫ СЕГМЕНТОВ              |
  +------------------+-----------------------------------------------------+
  | 0x400078         |             INTERP - ЗАГОЛОВОК                      |
  +------------------+-----------------------------------------------------+
  | 0x4000b0         |  LOAD - ЗАГОЛОВОК ЗАГРУЖАЕМОГО СЕГМЕНТА ЖЕРТВЫ      |
  +------------------+-----------------------------------------------------+
  | 0x4000e8         |      DYNAMIC - ЗАГОЛОВОК СЕГМЕНТА DYNAMIC           |
  |                  |                  .......                            |
  |                  |                  .......                            |
  +------------------+-----------------------------------------------------+ <--- ЗАГОЛОВОК ВИРУСА ОКАЗАЛСЯ ЗАТЕРТ
  |                  |                   cBLU                              |
  | 0x400190         |                 КОД ЖЕРТВЫ                          |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ОРИГИНАЛЬНАЯ ТОЧКА ВХОДА СМЕСТИЛАСЬ
  |                  |                    cBLU                             |       НА 56 БАЙТ
  | 0x400430         |           ОРИГИНАЛЬНЫЙ _START ЖЕРТВЫ                |
  |                  |                  .......                            |
  |                  |                  .......                            |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- СЕКЦИЯ DYNAMIC ОСТАЛАСЬ НА МЕСТЕ
  | 0x600e48         |    NEEDED - ПЕРВАЯ ЗАПИСЬ СЕКЦИИ DYNAMIC            |
  +------------------+-----------------------------------------------------+
  | 0x600e58         |                 ЗАПИСЬ INIT                         |
  +------------------+-----------------------------------------------------+
  | 0x600e68         |                 ЗАПИСЬ FINI                         |
  |                  |                  ........                           |
  |                  |                                                     |
  +------------------+-----------------------------------------------------+ <---- ЗАТЕРЛИ 72 БАЙТА СЕКЦИИ DYNAMIC,
  |                  |                    cBLU                             |       ВКЛЮЧАЯ ЗАПИСЬ BIND_NOW
  | 0x600ec0         |               ПРОЧИЙ КОД ЖЕРТВЫ                     |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+ <---- СЕГМЕНТ ВИРУСА СМЕСТИЛСЯ НА 72 БАЙТА
  |                  |                  cBLU                               |
  | 0x801242         |               _START ВИРУСА                         |
  |                  |                  ......                             |
  |                  |                  ......                             |
  +------------------+-----------------------------------------------------+
  |                  |                  cBLU                               |
  | 0x801542         |        БЛОК ПЕРЕДАЧИ УПРАВЛЕНИЯ НА ЖЕРТВУ           |
  +------------------+-----------------------------------------------------+  <---- КОНЕЦ ФАЙЛА В ПАМЯТИ
#+END_SRC

#+results: victim_after_move_pic
[[file:./img/victim_after_move.png]]

Итого мы получили вирус, который может заражать файлы как с
позиционно-независимым, так и с позиционно-зависимым кодом.

Надеюсь, мой опыт был кому-то полезным. Идеи и конструктивная критика крайне
приветствуются.
